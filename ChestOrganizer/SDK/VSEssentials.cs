// Warning: Some assembly references could not be resolved automatically. This might lead to incorrect decompilation of some parts,
// for ex. property getter/setter access. To get optimal decompilation results, please manually add the missing references to the list of loaded assemblies.

// C:\Users\Bille\AppData\Roaming\Vintagestory\Mods\VSEssentials.dll
// VSEssentials, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// Global type: <Module>
// Architecture: AnyCPU (64-bit preferred)
// Runtime: v4.0.30319
// This assembly was compiled using the /deterministic option.
// Hash algorithm: SHA1
// Debug info: Loaded from portable PDB: C:\Users\Bille\AppData\Roaming\Vintagestory\Mods\VSEssentials.pdb

using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AnimatedGif;
using Cairo;
using JsonPatch.Operations;
using JsonPatch.Operations.Abstractions;
using Microsoft.Data.Sqlite;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using OpenTK.Graphics.OpenGL;
using OpenTK.Mathematics;
using ProtoBuf;
using SkiaSharp;
using Tavis;
using Vintagestory.API;
using Vintagestory.API.Client;
using Vintagestory.API.Common;
using Vintagestory.API.Common.CommandAbbr;
using Vintagestory.API.Common.Entities;
using Vintagestory.API.Config;
using Vintagestory.API.Datastructures;
using Vintagestory.API.MathTools;
using Vintagestory.API.Server;
using Vintagestory.API.Util;
using Vintagestory.Client.NoObf;
using Vintagestory.Essentials;
using Vintagestory.GameContent;
using VSEssentialsMod.Entity.AI.Task;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyTitle("Vintage Story Default Server Mods")]
[assembly: AssemblyDescription("www.vintagestory.at")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Tyron Madlener (Anego Studios)")]
[assembly: AssemblyProduct("Vintage Story")]
[assembly: AssemblyCopyright("Copyright Â© 2016-2024 Anego Studios")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("3730ff53-02ab-4ccd-80ab-6199df67383b")]
[assembly: AssemblyFileVersion("1.21.5")]
[assembly: InternalsVisibleTo("VSSurvivalModTests")]
[assembly: ModInfo("Essentials", "game", Version = "1.21.5", NetworkVersion = "1.21.9", CoreMod = true, IconPath = "game/textures/gui/modicon.png", Description = "Game Essentials (Assets loader, world map, weather, AI, handbook, physics,...)", Authors = new string[] { "Tyron" })]
[assembly: TargetFramework(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("1.0.0.0")]
[module: UnverifiableCode]
[module: RefSafetyRules(11)]
public struct PositionSnapshot
{
	public double x;

	public double y;

	public double z;

	public float interval;

	public bool isTeleport;

	public PositionSnapshot(Vec3d pos, float interval, bool isTeleport)
	{
		x = pos.X;
		y = pos.Y;
		z = pos.Z;
		this.interval = interval;
		this.isTeleport = isTeleport;
	}

	public PositionSnapshot(EntityPos pos, float interval, bool isTeleport)
	{
		x = pos.X;
		y = pos.Y;
		z = pos.Z;
		this.interval = interval;
		this.isTeleport = isTeleport;
	}
}
public class EntityBehaviorInterpolatePosition : EntityBehavior, IRenderer, IDisposable
{
	public ICoreClientAPI capi;

	public EntityAgent agent;

	public IMountable mountableSupplier;

	public float dtAccum;

	public PositionSnapshot pL;

	public PositionSnapshot pN;

	public Queue<PositionSnapshot> positionQueue = new Queue<PositionSnapshot>();

	public float currentYaw;

	public float targetYaw;

	public float currentPitch;

	public float targetPitch;

	public float currentRoll;

	public float targetRoll;

	public float currentHeadYaw;

	public float targetHeadYaw;

	public float currentHeadPitch;

	public float targetHeadPitch;

	public float currentBodyYaw;

	public float targetBodyYaw;

	public float interval = 1f / 15f;

	public int queueCount;

	public IRemotePhysics physics;

	public int wait;

	public float targetSpeed = 0.6f;

	public double RenderOrder => 0.0;

	public int RenderRange => 9999;

	public EntityBehaviorInterpolatePosition(Entity entity)
		: base(entity)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Invalid comparison between Unknown and I4
		if ((int)entity.World.Side == 1)
		{
			throw new Exception("Remove server interpolation behavior from " + ((RegistryObject)entity).Code.Path + ".");
		}
		ref ICoreClientAPI reference = ref capi;
		ICoreAPI api = entity.Api;
		reference = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
		capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)0, "interpolateposition");
		agent = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
	}

	public override void AfterInitialized(bool onFirstSpawn)
	{
		mountableSupplier = base.entity.GetInterface<IMountable>();
	}

	public void PushQueue(PositionSnapshot snapshot)
	{
		positionQueue.Enqueue(snapshot);
		queueCount++;
	}

	public void PopQueue(bool clear)
	{
		dtAccum -= pN.interval;
		if (dtAccum < 0f)
		{
			dtAccum = 0f;
		}
		if (dtAccum > 1f)
		{
			dtAccum = 0f;
		}
		pL = pN;
		pN = positionQueue.Dequeue();
		queueCount--;
		if (clear && queueCount > 1)
		{
			PopQueue(clear: true);
		}
		IMountable obj = mountableSupplier;
		if (obj == null || !MountableUtil.IsBeingControlled(obj))
		{
			base.entity.ServerPos.SetPos(pN.x, pN.y, pN.z);
			IRemotePhysics obj2 = physics;
			if (obj2 != null)
			{
				obj2.HandleRemotePhysics(Math.Max(pN.interval, interval), pN.isTeleport);
			}
		}
	}

	public override void Initialize(EntityProperties properties, JsonObject attributes)
	{
		currentYaw = base.entity.ServerPos.Yaw;
		targetYaw = base.entity.ServerPos.Yaw;
		PushQueue(new PositionSnapshot(base.entity.ServerPos, 0f, isTeleport: false));
		targetYaw = base.entity.ServerPos.Yaw;
		targetPitch = base.entity.ServerPos.Pitch;
		targetRoll = base.entity.ServerPos.Roll;
		currentYaw = base.entity.ServerPos.Yaw;
		currentPitch = base.entity.ServerPos.Pitch;
		currentRoll = base.entity.ServerPos.Roll;
		if (agent != null)
		{
			targetHeadYaw = base.entity.ServerPos.HeadYaw;
			targetHeadPitch = base.entity.ServerPos.HeadPitch;
			targetBodyYaw = agent.BodyYawServer;
			currentHeadYaw = base.entity.ServerPos.HeadYaw;
			currentHeadPitch = base.entity.ServerPos.HeadPitch;
			currentBodyYaw = agent.BodyYawServer;
		}
		foreach (EntityBehavior behavior in base.entity.SidedProperties.Behaviors)
		{
			if (behavior is IRemotePhysics)
			{
				physics = (IRemotePhysics)(object)((behavior is IRemotePhysics) ? behavior : null);
				break;
			}
		}
	}

	public override void OnReceivedServerPos(bool isTeleport, ref EnumHandling handled)
	{
		float num = (float)((TreeAttribute)base.entity.Attributes).GetInt("tickDiff", 1) * interval;
		PushQueue(new PositionSnapshot(base.entity.ServerPos, num, isTeleport));
		if (isTeleport)
		{
			dtAccum = 0f;
			positionQueue.Clear();
			queueCount = 0;
			PushQueue(new PositionSnapshot(base.entity.ServerPos, num, isTeleport: false));
			PushQueue(new PositionSnapshot(base.entity.ServerPos, num, isTeleport: false));
			PopQueue(clear: false);
			PopQueue(clear: false);
		}
		targetYaw = base.entity.ServerPos.Yaw;
		targetPitch = base.entity.ServerPos.Pitch;
		targetRoll = base.entity.ServerPos.Roll;
		if (agent != null)
		{
			targetHeadYaw = base.entity.ServerPos.HeadYaw;
			targetHeadPitch = base.entity.ServerPos.HeadPitch;
			targetBodyYaw = agent.BodyYawServer;
		}
		if (queueCount > 20)
		{
			PopQueue(clear: true);
		}
	}

	public void OnRenderFrame(float dt, EnumRenderStage stage)
	{
		if (capi.IsGamePaused)
		{
			return;
		}
		if (queueCount < wait)
		{
			if (mountableSupplier == null)
			{
				base.entity.Pos.Yaw = LerpRotation(ref currentYaw, targetYaw, dt);
				base.entity.Pos.Pitch = LerpRotation(ref currentPitch, targetPitch, dt);
				base.entity.Pos.Roll = LerpRotation(ref currentRoll, targetRoll, dt);
				if (agent != null)
				{
					base.entity.Pos.HeadYaw = LerpRotation(ref currentHeadYaw, targetHeadYaw, dt);
					base.entity.Pos.HeadPitch = LerpRotation(ref currentHeadPitch, targetHeadPitch, dt);
					agent.BodyYaw = LerpRotation(ref currentBodyYaw, targetBodyYaw, dt);
				}
			}
			return;
		}
		dtAccum += dt * targetSpeed;
		while (dtAccum > pN.interval)
		{
			if (queueCount > 0)
			{
				if ((object)base.entity == ((IPlayer)capi.World.Player).Entity)
				{
					capi.Event.UnregisterRenderer((IRenderer)(object)this, (EnumRenderStage)0);
					return;
				}
				PopQueue(clear: false);
				wait = 0;
				continue;
			}
			wait = 1;
			break;
		}
		float num = (float)queueCount * 0.2f + 0.8f;
		targetSpeed = GameMath.Lerp(targetSpeed, num, dt * 4f);
		if (mountableSupplier != null)
		{
			IMountableSeat[] seats = mountableSupplier.Seats;
			foreach (IMountableSeat val in seats)
			{
				if ((object)val.Passenger != ((IPlayer)capi.World.Player).Entity)
				{
					Entity passenger = val.Passenger;
					if (passenger != null)
					{
						passenger.Pos.SetFrom(val.SeatPosition);
					}
					continue;
				}
				if ((object)mountableSupplier.Controller == ((IPlayer)capi.World.Player).Entity)
				{
					currentYaw = base.entity.Pos.Yaw;
					currentPitch = base.entity.Pos.Pitch;
					currentRoll = base.entity.Pos.Roll;
					return;
				}
				base.entity.OnGround = base.entity.Pos.Motion.Y == 0.0;
			}
		}
		float num2 = dtAccum / pN.interval;
		if (wait != 0)
		{
			num2 = 1f;
		}
		base.entity.Pos.Yaw = LerpRotation(ref currentYaw, targetYaw, dt);
		base.entity.Pos.Pitch = LerpRotation(ref currentPitch, targetPitch, dt);
		base.entity.Pos.Roll = LerpRotation(ref currentRoll, targetRoll, dt);
		if (agent != null)
		{
			base.entity.Pos.HeadYaw = LerpRotation(ref currentHeadYaw, targetHeadYaw, dt);
			base.entity.Pos.HeadPitch = LerpRotation(ref currentHeadPitch, targetHeadPitch, dt);
			agent.BodyYaw = LerpRotation(ref currentBodyYaw, targetBodyYaw, dt);
		}
		if (agent == null || agent.MountedOn == null)
		{
			base.entity.Pos.X = GameMath.Lerp(pL.x, pN.x, (double)num2);
			base.entity.Pos.Y = GameMath.Lerp(pL.y, pN.y, (double)num2);
			base.entity.Pos.Z = GameMath.Lerp(pL.z, pN.z, (double)num2);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float LerpRotation(ref float current, float target, float dt)
	{
		float num = Math.Abs(GameMath.AngleRadDistance(current, target)) * dt / 0.1f;
		int num2 = Math.Sign(num);
		current += 0.6f * Math.Clamp(GameMath.AngleRadDistance(current, target), (float)(-num2) * num, (float)num2 * num);
		current %= (float)Math.PI * 2f;
		return current;
	}

	public override string PropertyName()
	{
		return "entityinterpolation";
	}

	public override void OnEntityDespawn(EntityDespawnData despawn)
	{
		capi.Event.UnregisterRenderer((IRenderer)(object)this, (EnumRenderStage)0);
	}

	public void Dispose()
	{
	}
}
public static class BitmapExtensions
{
	public static void SetPixels(this Bitmap bmp, int[] pixels)
	{
		if (bmp.Width * bmp.Height != pixels.Length)
		{
			throw new ArgumentException("Pixel array must be width*height length");
		}
		Rectangle rect = new Rectangle(0, 0, bmp.Width, bmp.Height);
		BitmapData bitmapData = bmp.LockBits(rect, ImageLockMode.ReadWrite, bmp.PixelFormat);
		Marshal.Copy(pixels, 0, bitmapData.Scan0, pixels.Length);
		bmp.UnlockBits(bitmapData);
	}
}
namespace FluffyClouds
{
	public class CloudTile
	{
		public short GridXOffset;

		public short GridZOffset;

		public short TargetThickness;

		public short TargetBrightnes;

		public short TargetThinCloudMode;

		public short TargetUndulatingCloudMode;

		public short TargetCloudOpaquenes;

		public short SelfThickness;

		public short Brightness;

		public short ThinCloudMode;

		public short UndulatingCloudMode;

		public short CloudOpaqueness;

		public LCGRandom brightnessRand;

		internal bool rainValuesSet;

		internal float lerpRainCloudOverlay;

		internal float lerpRainOverlay;
	}
	public class CloudRendererBase
	{
		public int CloudTileLength = 5;

		public double windOffsetX;

		public double windOffsetZ;

		public int CloudTileSize { get; set; } = 50;

		public virtual void UpdateCloudTiles(int changeSpeed = 1)
		{
		}
	}
	public class CloudTilesState
	{
		public Vec3i CenterTilePos = new Vec3i();

		public int TileOffsetX;

		public int TileOffsetZ;

		public int WindTileOffsetX;

		public int WindTileOffsetZ;

		public void Set(CloudTilesState state)
		{
			TileOffsetX = state.TileOffsetX;
			TileOffsetZ = state.TileOffsetZ;
			WindTileOffsetX = state.WindTileOffsetX;
			WindTileOffsetZ = state.WindTileOffsetZ;
			CenterTilePos.X = state.CenterTilePos.X;
			CenterTilePos.Z = state.CenterTilePos.Z;
		}
	}
	public class CloudRendererMap : CloudRendererBase, IRenderer, IDisposable
	{
		private int TextureData1;

		private int TextureData2;

		private short[] TextureDataBuffer1;

		private short[] TextureDataBuffer2;

		private int Framebuffer;

		public int TextureMap;

		public int TextureCol;

		public Vec3f offset = new Vec3f();

		private MeshRef quad;

		private IShaderProgram prog;

		private int programId;

		private Matrixf matrix = new Matrixf();

		private float time;

		public CloudTilesState committedState = new CloudTilesState();

		public CloudTilesState mainThreadState = new CloudTilesState();

		public CloudTilesState offThreadState = new CloudTilesState();

		public CloudTile[] Tiles;

		private CloudTile[] tempTiles;

		private bool newStateRready;

		private object cloudStateLock = new object();

		internal float blendedCloudDensity;

		internal float blendedGlobalCloudBrightness;

		public int QuantityCloudTiles = 25;

		private long windChangeTimer;

		private float cloudSpeedX;

		private float cloudSpeedZ;

		private float targetCloudSpeedX;

		private float targetCloudSpeedZ;

		private Random rand;

		private bool renderCloudMap;

		public WeatherSystemClient weatherSys;

		private Thread cloudTileUpdThread;

		private bool isShuttingDown;

		private ICoreClientAPI capi;

		private ModSystem mod;

		private int cloudTileBlendSpeed = 32;

		private WeatherDataReaderPreLoad wreaderpreload;

		private bool isFirstTick = true;

		private bool requireTileRebuild;

		public bool instantTileBlend;

		private int accum = 20;

		public double RenderOrder => 0.3;

		public int RenderRange => 9999;

		public CloudRendererMap(ModSystem mod, ICoreClientAPI capi)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Expected O, but got Unknown
			WeatherSystemClient weatherSystemClient = ((ICoreAPI)capi).ModLoader.GetModSystem<WeatherSystemBase>(true) as WeatherSystemClient;
			this.capi = capi;
			this.mod = mod;
			weatherSys = weatherSystemClient;
			wreaderpreload = weatherSystemClient.getWeatherDataReaderPreLoad();
			rand = new Random(((IWorldAccessor)capi.World).Seed);
			quad = capi.Render.UploadMesh(QuadMeshUtil.GetQuad());
			capi.Event.ReloadShader += new ActionBoolReturn(LoadShader);
			LoadShader();
			double num = ((IGameCalendar)capi.World.Calendar).TotalHours * 60.0;
			windOffsetX += 2.0 * num;
			windOffsetZ += 0.10000000149011612 * num;
			mainThreadState.WindTileOffsetX += (int)(windOffsetX / (double)base.CloudTileSize);
			windOffsetX %= base.CloudTileSize;
			mainThreadState.WindTileOffsetZ += (int)(windOffsetZ / (double)base.CloudTileSize);
			windOffsetZ %= base.CloudTileSize;
			offThreadState.Set(mainThreadState);
			committedState.Set(mainThreadState);
			InitCloudTiles(8 * ((IPlayer)capi.World.Player).WorldData.DesiredViewDistance);
			capi.Settings.AddWatcher<int>("viewDistance", (OnSettingsChanged<int>)OnViewDistanceChanged);
			capi.Settings.AddWatcher<int>("cloudRenderMode", (OnSettingsChanged<int>)delegate(int val)
			{
				renderCloudMap = val == 1;
			});
			renderCloudMap = capi.Settings.Int.Get("cloudRenderMode", 0) == 1;
			capi.Event.LeaveWorld += delegate
			{
				isShuttingDown = true;
			};
			cloudTileUpdThread = new Thread((ThreadStart)delegate
			{
				while (!isShuttingDown)
				{
					if (!newStateRready)
					{
						int num2 = (int)windOffsetX / base.CloudTileSize;
						int num3 = (int)windOffsetZ / base.CloudTileSize;
						int x = offThreadState.CenterTilePos.X;
						int z = offThreadState.CenterTilePos.Z;
						offThreadState.Set(mainThreadState);
						offThreadState.WindTileOffsetX += num2;
						offThreadState.WindTileOffsetZ += num3;
						int num4 = num2 + x - offThreadState.CenterTilePos.X;
						int num5 = num3 + z - offThreadState.CenterTilePos.Z;
						if (num4 != 0 || num5 != 0)
						{
							MoveCloudTilesOffThread(num4, num5);
						}
						UpdateCloudTilesOffThread(instantTileBlend ? 32767 : cloudTileBlendSpeed);
						instantTileBlend = false;
						newStateRready = true;
					}
					Thread.Sleep(40);
				}
			});
			cloudTileUpdThread.IsBackground = true;
		}

		public bool LoadShader()
		{
			prog = capi.Shader.NewShaderProgram();
			prog.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			prog.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			prog.AssetDomain = mod.Mod.Info.ModID;
			capi.Shader.RegisterFileShaderProgram("cloudmap", prog);
			bool result = prog.Compile();
			programId = prog.ProgramId;
			return result;
		}

		private void FreeGlResources()
		{
			GL.DeleteTexture(TextureData1);
			GL.DeleteTexture(TextureData2);
			GL.DeleteTexture(TextureMap);
			GL.DeleteTexture(TextureCol);
			GL.DeleteFramebuffer(Framebuffer);
		}

		private void OnViewDistanceChanged(int newValue)
		{
			requireTileRebuild = true;
		}

		public void CloudTick(float deltaTime)
		{
			blendedCloudDensity = capi.Ambient.BlendedCloudDensity;
			blendedGlobalCloudBrightness = capi.Ambient.BlendedCloudBrightness;
			if (isFirstTick)
			{
				weatherSys.ProcessWeatherUpdates();
				UpdateCloudTilesOffThread(32767);
				cloudTileUpdThread.Start();
				isFirstTick = false;
			}
			deltaTime = Math.Min(deltaTime, 1f);
			deltaTime *= ((IGameCalendar)capi.World.Calendar).SpeedOfTime / 60f;
			if (deltaTime > 0f)
			{
				if (windChangeTimer - capi.ElapsedMilliseconds < 0)
				{
					windChangeTimer = capi.ElapsedMilliseconds + rand.Next(20000, 120000);
					targetCloudSpeedX = (float)rand.NextDouble() * 5f;
					targetCloudSpeedZ = (float)rand.NextDouble() * 0.5f;
				}
				float num = 3f * (float)weatherSys.WeatherDataAtPlayer.GetWindSpeed(((Entity)((IPlayer)capi.World.Player).Entity).Pos.Y);
				cloudSpeedX += (targetCloudSpeedX + num - cloudSpeedX) * deltaTime;
				cloudSpeedZ += (targetCloudSpeedZ - cloudSpeedZ) * deltaTime;
			}
			lock (cloudStateLock)
			{
				if (deltaTime > 0f)
				{
					windOffsetX += cloudSpeedX * deltaTime;
					windOffsetZ += cloudSpeedZ * deltaTime;
				}
				mainThreadState.CenterTilePos.X = (int)((Entity)((IPlayer)capi.World.Player).Entity).Pos.X / base.CloudTileSize;
				mainThreadState.CenterTilePos.Z = (int)((Entity)((IPlayer)capi.World.Player).Entity).Pos.Z / base.CloudTileSize;
			}
			if (newStateRready)
			{
				int num2 = offThreadState.WindTileOffsetX - committedState.WindTileOffsetX;
				int num3 = offThreadState.WindTileOffsetZ - committedState.WindTileOffsetZ;
				committedState.Set(offThreadState);
				mainThreadState.WindTileOffsetX = committedState.WindTileOffsetX;
				mainThreadState.WindTileOffsetZ = committedState.WindTileOffsetZ;
				windOffsetX -= num2 * base.CloudTileSize;
				windOffsetZ -= num3 * base.CloudTileSize;
				weatherSys.ProcessWeatherUpdates();
				if (requireTileRebuild)
				{
					InitCloudTiles(8 * ((IPlayer)capi.World.Player).WorldData.DesiredViewDistance);
					UpdateCloudTiles();
					requireTileRebuild = false;
					instantTileBlend = true;
				}
				WriteTexture();
				newStateRready = false;
			}
			((IWorldAccessor)capi.World).FrameProfiler.Mark("gt-clouds");
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Expected O, but got Unknown
			if (renderCloudMap)
			{
				if (!capi.IsGamePaused)
				{
					CloudTick(deltaTime);
					time = (time + deltaTime) % 86400f;
				}
				offset.X = (float)((double)(committedState.CenterTilePos.X * base.CloudTileSize) - ((Entity)((IPlayer)capi.World.Player).Entity).Pos.X + windOffsetX);
				offset.Y = (float)((double)(weatherSys.CloudLevelRel * (float)((IWorldAccessor)capi.World).BlockAccessor.MapSizeY) + 0.5 - ((IPlayer)capi.World.Player).Entity.CameraPos.Y);
				offset.Z = (float)((double)(committedState.CenterTilePos.Z * base.CloudTileSize) - ((Entity)((IPlayer)capi.World.Player).Entity).Pos.Z + windOffsetZ);
				Vec2f val = new Vec2f((float)(((double)committedState.CenterTilePos.X * (double)base.CloudTileSize - ((IWorldAccessor)capi.World).DefaultSpawnPosition.X + windOffsetX) / (double)base.CloudTileSize), (float)(((double)committedState.CenterTilePos.Z * (double)base.CloudTileSize - ((IWorldAccessor)capi.World).DefaultSpawnPosition.Z + windOffsetZ) / (double)base.CloudTileSize));
				matrix.Set(capi.Render.CameraMatrixOriginf);
				int num = default(int);
				GL.GetInteger((GetPName)36006, ref num);
				int[] array = new int[4];
				GL.GetInteger((GetPName)2978, array);
				prog.Use();
				prog.Uniform("dayLight", Math.Max(0f, capi.World.Calendar.DayLightStrength - capi.World.Calendar.MoonLightStrength * 0.95f));
				prog.Uniform("globalCloudBrightness", capi.Ambient.BlendedCloudBrightness);
				prog.Uniform("time", time);
				prog.Uniform("rgbaFogIn", capi.Ambient.BlendedFogColor);
				prog.Uniform("fogMinIn", capi.Ambient.BlendedFogMin);
				prog.Uniform("fogDensityIn", capi.Ambient.BlendedFogDensity);
				prog.Uniform("sunPosition", capi.World.Calendar.SunPositionNormalized);
				prog.Uniform("nightVisionStrength", capi.Render.ShaderUniforms.NightVisionStrength);
				prog.Uniform("alpha", GameMath.Clamp(1f - 1.5f * Math.Max(0f, capi.Render.ShaderUniforms.GlitchStrength - 0.1f), 0f, 1f));
				prog.Uniform("width", (float)CloudTileLength);
				prog.Uniform("mapOffset", offset);
				prog.Uniform("mapOffsetCentre", val);
				prog.BindTexture2D("mapData1", TextureData1, 8);
				prog.BindTexture2D("mapData2", TextureData2, 9);
				prog.UniformMatrix("viewMatrix", matrix.Values);
				prog.Uniform("pointLightQuantity", capi.Render.ShaderUniforms.PointLightsCount);
				if (capi.Render.ShaderUniforms.PointLightsCount > 0)
				{
					GL.Uniform3(GL.GetUniformLocation(programId, "pointLights"), capi.Render.ShaderUniforms.PointLightsCount, capi.Render.ShaderUniforms.PointLights3);
					GL.Uniform3(GL.GetUniformLocation(programId, "pointLightColors"), capi.Render.ShaderUniforms.PointLightsCount, capi.Render.ShaderUniforms.PointLightColors3);
				}
				GL.BindFramebuffer((FramebufferTarget)36160, Framebuffer);
				GL.Viewport(0, 0, CloudTileLength, CloudTileLength);
				GL.Disable((EnableCap)3042);
				GL.Disable((EnableCap)2929);
				capi.Render.RenderMesh(quad);
				GL.Enable((EnableCap)2929);
				GL.Enable((EnableCap)3042);
				GL.BindFramebuffer((FramebufferTarget)36160, num);
				GL.Viewport(array[0], array[1], array[2], array[3]);
				prog.Stop();
			}
		}

		private void WriteTexture()
		{
			for (int i = 0; i < CloudTileLength * CloudTileLength; i++)
			{
				CloudTile cloudTile = Tiles[i];
				int num = CloudTileLength / 2;
				int num2 = (cloudTile.GridZOffset + num) * CloudTileLength + cloudTile.GridXOffset + num;
				TextureDataBuffer1[num2 * 4] = cloudTile.ThinCloudMode;
				TextureDataBuffer1[num2 * 4 + 1] = cloudTile.SelfThickness;
				TextureDataBuffer1[num2 * 4 + 2] = cloudTile.CloudOpaqueness;
				TextureDataBuffer1[num2 * 4 + 3] = cloudTile.Brightness;
				TextureDataBuffer2[num2 * 4] = cloudTile.UndulatingCloudMode;
			}
			GL.BindTexture((TextureTarget)3553, TextureData1);
			GL.TexSubImage2D<short>((TextureTarget)3553, 0, 0, 0, CloudTileLength, CloudTileLength, (PixelFormat)6408, (PixelType)5122, TextureDataBuffer1);
			GL.BindTexture((TextureTarget)3553, TextureData2);
			GL.TexSubImage2D<short>((TextureTarget)3553, 0, 0, 0, CloudTileLength, CloudTileLength, (PixelFormat)6408, (PixelType)5122, TextureDataBuffer2);
		}

		private int makeTexture(int width, PixelInternalFormat internalFormat, PixelFormat format, PixelType type)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			int num = GL.GenTexture();
			GL.BindTexture((TextureTarget)3553, num);
			GL.TexImage2D((TextureTarget)3553, 0, internalFormat, width, width, 0, format, type, (IntPtr)0);
			GL.TexParameter((TextureTarget)3553, (TextureParameterName)10241, 9728);
			GL.TexParameter((TextureTarget)3553, (TextureParameterName)10240, 9728);
			GL.TexParameter((TextureTarget)3553, (TextureParameterName)10242, 33071);
			GL.TexParameter((TextureTarget)3553, (TextureParameterName)10243, 33071);
			return num;
		}

		public void InitCloudTiles(int viewDistance)
		{
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Expected O, but got Unknown
			CloudTileLength = GameMath.Clamp(viewDistance / base.CloudTileSize, 20, 200);
			QuantityCloudTiles = CloudTileLength * CloudTileLength;
			Tiles = new CloudTile[QuantityCloudTiles];
			tempTiles = new CloudTile[QuantityCloudTiles];
			int num = rand.Next();
			for (int i = 0; i < CloudTileLength; i++)
			{
				for (int j = 0; j < CloudTileLength; j++)
				{
					Tiles[i * CloudTileLength + j] = new CloudTile
					{
						GridXOffset = (short)(i - CloudTileLength / 2),
						GridZOffset = (short)(j - CloudTileLength / 2),
						brightnessRand = new LCGRandom((long)num)
					};
				}
			}
			FreeGlResources();
			TextureData1 = makeTexture(CloudTileLength, (PixelInternalFormat)32859, (PixelFormat)6408, (PixelType)5122);
			TextureData2 = makeTexture(CloudTileLength, (PixelInternalFormat)32859, (PixelFormat)6408, (PixelType)5122);
			TextureDataBuffer1 = new short[CloudTileLength * CloudTileLength * 4];
			TextureDataBuffer2 = new short[CloudTileLength * CloudTileLength * 4];
			int num2 = default(int);
			GL.GetInteger((GetPName)36006, ref num2);
			TextureMap = makeTexture(CloudTileLength, (PixelInternalFormat)34836, (PixelFormat)6408, (PixelType)5126);
			TextureCol = makeTexture(CloudTileLength, (PixelInternalFormat)34836, (PixelFormat)6408, (PixelType)5126);
			Framebuffer = GL.GenFramebuffer();
			GL.BindFramebuffer((FramebufferTarget)36160, Framebuffer);
			GL.FramebufferTexture2D((FramebufferTarget)36160, (FramebufferAttachment)36064, (TextureTarget)3553, TextureMap, 0);
			GL.FramebufferTexture2D((FramebufferTarget)36160, (FramebufferAttachment)36065, (TextureTarget)3553, TextureCol, 0);
			DrawBuffersEnum[] array = (DrawBuffersEnum[])(object)new DrawBuffersEnum[2]
			{
				(DrawBuffersEnum)36064,
				(DrawBuffersEnum)36065
			};
			GL.DrawBuffers(array.Length, array);
			GL.BindTexture((TextureTarget)3553, 0);
			GL.BindFramebuffer((FramebufferTarget)36160, num2);
		}

		public void UpdateCloudTilesOffThread(int changeSpeed)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Expected O, but got Unknown
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Expected O, but got Unknown
			bool flag = false;
			accum++;
			if (accum > 10)
			{
				accum = 0;
				flag = true;
			}
			int num = CloudTileLength * CloudTileLength;
			int num2 = -9999;
			int num3 = -9999;
			Vec3i tilePos = new Vec3i(offThreadState.TileOffsetX - offThreadState.WindTileOffsetX, 0, offThreadState.TileOffsetZ - offThreadState.WindTileOffsetZ);
			Vec3i centerTilePos = offThreadState.CenterTilePos;
			for (int i = 0; i < num; i++)
			{
				CloudTile cloudTile = Tiles[i];
				int num4 = centerTilePos.X + cloudTile.GridXOffset;
				int num5 = centerTilePos.Z + cloudTile.GridZOffset;
				cloudTile.brightnessRand.InitPositionSeed(num4 - offThreadState.WindTileOffsetX, num5 - offThreadState.WindTileOffsetZ);
				Vec3d val = new Vec3d((double)(num4 * base.CloudTileSize), (double)((IWorldAccessor)capi.World).SeaLevel, (double)(num5 * base.CloudTileSize));
				int regionSize = ((IWorldAccessor)capi.World).BlockAccessor.RegionSize;
				int num6 = (int)Math.Round(val.X / (double)regionSize) - 1;
				int num7 = (int)Math.Round(val.Z / (double)regionSize) - 1;
				if (num6 != num2 || num7 != num3)
				{
					num2 = num6;
					num3 = num7;
					wreaderpreload.LoadAdjacentSims(val);
					wreaderpreload.EnsureCloudTileCacheIsFresh(tilePos);
				}
				if (flag || !cloudTile.rainValuesSet)
				{
					wreaderpreload.LoadLerp(val);
					cloudTile.lerpRainCloudOverlay = wreaderpreload.lerpRainCloudOverlay;
					cloudTile.lerpRainOverlay = wreaderpreload.lerpRainOverlay;
					cloudTile.rainValuesSet = true;
				}
				else
				{
					wreaderpreload.LoadLerp(val, useArgValues: true, cloudTile.lerpRainCloudOverlay, cloudTile.lerpRainOverlay);
				}
				int cloudTileX = (int)val.X / base.CloudTileSize;
				int cloudTileZ = (int)val.Z / base.CloudTileSize;
				double num8 = GameMath.Clamp(wreaderpreload.GetBlendedCloudThicknessAt(cloudTileX, cloudTileZ), 0.0, 1.0);
				double num9 = wreaderpreload.GetBlendedCloudBrightness(1f) * (double)(0.85f + cloudTile.brightnessRand.NextFloat() * 0.15f);
				cloudTile.TargetBrightnes = (short)(GameMath.Clamp(num9, 0.0, 1.0) * 32767.0);
				cloudTile.TargetThickness = (short)GameMath.Clamp(num8 * 32767.0, 0.0, 32767.0);
				cloudTile.TargetThinCloudMode = (short)GameMath.Clamp(wreaderpreload.GetBlendedThinCloudModeness() * 32767.0, 0.0, 32767.0);
				cloudTile.TargetCloudOpaquenes = (short)GameMath.Clamp(wreaderpreload.GetBlendedCloudOpaqueness() * 32767.0, 0.0, 32767.0);
				cloudTile.TargetUndulatingCloudMode = (short)GameMath.Clamp(wreaderpreload.GetBlendedUndulatingCloudModeness() * 32767.0, 0.0, 32767.0);
				cloudTile.Brightness = LerpTileValue(cloudTile.TargetBrightnes, cloudTile.Brightness, changeSpeed);
				cloudTile.SelfThickness = LerpTileValue(cloudTile.TargetThickness, cloudTile.SelfThickness, changeSpeed);
				cloudTile.ThinCloudMode = LerpTileValue(cloudTile.TargetThinCloudMode, cloudTile.ThinCloudMode, changeSpeed);
				cloudTile.CloudOpaqueness = LerpTileValue(cloudTile.TargetCloudOpaquenes, cloudTile.CloudOpaqueness, changeSpeed);
				cloudTile.UndulatingCloudMode = LerpTileValue(cloudTile.TargetUndulatingCloudMode, cloudTile.UndulatingCloudMode, changeSpeed);
			}
		}

		private short LerpTileValue(int target, int current, int changeSpeed)
		{
			float num = GameMath.Clamp(target - current, -changeSpeed, changeSpeed);
			return (short)GameMath.Clamp((float)current + num, 0f, 32767f);
		}

		public void MoveCloudTilesOffThread(int dx, int dz)
		{
			for (int i = 0; i < CloudTileLength; i++)
			{
				for (int j = 0; j < CloudTileLength; j++)
				{
					int num = GameMath.Mod(i + dx, CloudTileLength);
					int num2 = GameMath.Mod(j + dz, CloudTileLength);
					CloudTile cloudTile = Tiles[i * CloudTileLength + j];
					cloudTile.GridXOffset = (short)(num - CloudTileLength / 2);
					cloudTile.GridZOffset = (short)(num2 - CloudTileLength / 2);
					tempTiles[num * CloudTileLength + num2] = cloudTile;
				}
			}
			CloudTile[] tiles = Tiles;
			Tiles = tempTiles;
			tempTiles = tiles;
		}

		public void Dispose()
		{
			FreeGlResources();
			capi.Render.DeleteMesh(quad);
		}
	}
	public class FluffyCloudsModSystem : ModSystem
	{
		private ICoreClientAPI capi;

		private CloudRendererMap map;

		private CloudRendererVolumetric volumetric;

		private string[] modes = new string[3] { "off", "volumetric", "simple" };

		public override void StartClientSide(ICoreClientAPI capi)
		{
			this.capi = capi;
			capi.Settings.Int.AddWatcher("cloudRenderMode", (OnSettingsChanged<int>)delegate(int i)
			{
				registerCloudRenderer(i);
				capi.ShowChatMessage("cloud renderer: " + modes[i]);
			});
			capi.Event.LevelFinalize += delegate
			{
				map = new CloudRendererMap((ModSystem)(object)this, capi);
				volumetric = new CloudRendererVolumetric((ModSystem)(object)this, capi, map);
				capi.Event.RegisterRenderer((IRenderer)(object)map, (EnumRenderStage)2, "cloudsmap");
				int i = capi.Settings.Int.Get("cloudRenderMode", 0);
				registerCloudRenderer(i);
			};
			capi.Event.LeaveWorld += delegate
			{
				map?.Dispose();
				volumetric?.Dispose();
			};
		}

		private void registerCloudRenderer(int i)
		{
			if (i != 1)
			{
				capi.Event.UnregisterRenderer((IRenderer)(object)volumetric, (EnumRenderStage)2);
			}
			else
			{
				capi.Event.RegisterRenderer((IRenderer)(object)volumetric, (EnumRenderStage)2, "cloudsvolumetric");
			}
		}
	}
	public class CloudRendererVolumetric : IRenderer, IDisposable
	{
		private ICoreClientAPI capi;

		private ModSystem mod;

		private CloudRendererMap map;

		private IShaderProgram program;

		private MeshRef quad;

		private Matrixf matrix = new Matrixf();

		private int frame;

		private float time;

		public double RenderOrder => 0.31;

		public int RenderRange => 1;

		public CloudRendererVolumetric(ModSystem mod, ICoreClientAPI capi, CloudRendererMap map)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Expected O, but got Unknown
			this.mod = mod;
			this.capi = capi;
			this.map = map;
			capi.Event.ReloadShader += new ActionBoolReturn(LoadShader);
			LoadShader();
			quad = capi.Render.UploadMesh(QuadMeshUtil.GetQuad());
		}

		public bool LoadShader()
		{
			program = capi.Shader.NewShaderProgram();
			program.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			program.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			program.AssetDomain = mod.Mod.Info.ModID;
			capi.Shader.RegisterFileShaderProgram("cloudvolumetric", program);
			return program.Compile();
		}

		public void Dispose()
		{
			capi.Render.DeleteMesh(quad);
			((IDisposable)program)?.Dispose();
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			program.Use();
			matrix.Set(capi.Render.PerspectiveProjectionMat).Mul(capi.Render.CameraMatrixOriginf).Invert();
			frame++;
			if (!capi.IsGamePaused)
			{
				time += deltaTime;
			}
			program.UniformMatrix("iMvpMatrix", matrix.Values);
			program.Uniform("cloudOffset", map.offset);
			program.Uniform("cloudMapWidth", (float)map.CloudTileLength);
			program.Uniform("FrameWidth", capi.Render.FrameBuffers[0].Width);
			program.Uniform("frame", frame);
			program.Uniform("time", time);
			program.Uniform("PerceptionEffectIntensity", capi.Render.ShaderUniforms.PerceptionEffectIntensity);
			program.BindTexture2D("depthTex", capi.Render.FrameBuffers[0].DepthTextureId, 0);
			program.BindTexture2D("cloudMap", map.TextureMap, 8);
			program.BindTexture2D("cloudCol", map.TextureCol, 9);
			GL.Disable((EnableCap)2929);
			GL.Enable((EnableCap)3042);
			GL.BlendFuncSeparate(0, (BlendingFactorSrc)1, (BlendingFactorDest)1, (BlendingFactorSrc)1, (BlendingFactorDest)1);
			GL.BlendFuncSeparate(1, (BlendingFactorSrc)0, (BlendingFactorDest)769, (BlendingFactorSrc)0, (BlendingFactorDest)769);
			GL.BlendFuncSeparate(2, (BlendingFactorSrc)770, (BlendingFactorDest)771, (BlendingFactorSrc)1, (BlendingFactorDest)771);
			capi.Render.RenderMesh(quad);
			GL.Enable((EnableCap)2929);
			GL.BlendFuncSeparate(0, (BlendingFactorSrc)1, (BlendingFactorDest)1, (BlendingFactorSrc)1, (BlendingFactorDest)1);
			GL.BlendFuncSeparate(1, (BlendingFactorSrc)0, (BlendingFactorDest)769, (BlendingFactorSrc)0, (BlendingFactorDest)769);
			GL.BlendFuncSeparate(2, (BlendingFactorSrc)770, (BlendingFactorDest)771, (BlendingFactorSrc)770, (BlendingFactorDest)771);
			program.Stop();
		}
	}
}
namespace VSEssentialsMod.Entity.AI.Task
{
	public enum EnumCreatureHostility
	{
		Aggressive,
		Passive,
		NeverHostile
	}
}
namespace Vintagestory.Essentials
{
	public class AStar
	{
		protected ICoreServerAPI api;

		protected ICachingBlockAccessor blockAccess;

		public int NodesChecked;

		public double centerOffsetX = 0.5;

		public double centerOffsetZ = 0.5;

		public EnumAICreatureType creatureType;

		protected CollisionTester collTester;

		public PathNodeSet openSet = new PathNodeSet();

		public HashSet<PathNode> closedSet = new HashSet<PathNode>();

		protected readonly Vec3d tmpVec = new Vec3d();

		protected readonly BlockPos tmpPos = new BlockPos();

		protected Cuboidd tmpCub = new Cuboidd();

		public AStar(ICoreServerAPI api)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Expected O, but got Unknown
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Expected O, but got Unknown
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Expected O, but got Unknown
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Expected O, but got Unknown
			this.api = api;
			collTester = new CollisionTester();
			blockAccess = ((IWorldAccessor)api.World).GetCachingBlockAccessor(true, true);
		}

		public virtual List<Vec3d> FindPathAsWaypoints(BlockPos start, BlockPos end, int maxFallHeight, float stepHeight, Cuboidf entityCollBox, int searchDepth = 9999, int mhdistanceTolerance = 0, EnumAICreatureType creatureType = (EnumAICreatureType)0)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			List<PathNode> list = FindPath(start, end, maxFallHeight, stepHeight, entityCollBox, searchDepth, mhdistanceTolerance, creatureType);
			if (list != null)
			{
				return ToWaypoints(list);
			}
			return null;
		}

		public virtual List<PathNode> FindPath(BlockPos start, BlockPos end, int maxFallHeight, float stepHeight, Cuboidf entityCollBox, int searchDepth = 9999, int mhdistanceTolerance = 0, EnumAICreatureType creatureType = (EnumAICreatureType)0)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			if (entityCollBox.XSize > 100f || entityCollBox.YSize > 100f || entityCollBox.ZSize > 100f)
			{
				((ICoreAPI)api).Logger.Warning("AStar:FindPath() was called with a entity box larger than 100 ({0}). Algo not designed for such sizes, likely coding error. Will ignore.", new object[1] { entityCollBox });
				return null;
			}
			this.creatureType = creatureType;
			blockAccess.Begin();
			centerOffsetX = 0.3 + ((IWorldAccessor)api.World).Rand.NextDouble() * 0.4;
			centerOffsetZ = 0.3 + ((IWorldAccessor)api.World).Rand.NextDouble() * 0.4;
			NodesChecked = 0;
			PathNode pathNode = new PathNode(start);
			PathNode pathNode2 = new PathNode(end);
			openSet.Clear();
			closedSet.Clear();
			openSet.Add(pathNode);
			while (openSet.Count > 0)
			{
				if (NodesChecked++ > searchDepth)
				{
					return null;
				}
				PathNode pathNode3 = openSet.RemoveNearest();
				closedSet.Add(pathNode3);
				if (pathNode3 == pathNode2 || (mhdistanceTolerance > 0 && Math.Abs(((BlockPos)pathNode3).X - ((BlockPos)pathNode2).X) <= mhdistanceTolerance && Math.Abs(((BlockPos)pathNode3).Z - ((BlockPos)pathNode2).Z) <= mhdistanceTolerance && Math.Abs(((BlockPos)pathNode3).Y - ((BlockPos)pathNode2).Y) <= mhdistanceTolerance))
				{
					return retracePath(pathNode, pathNode3);
				}
				for (int i = 0; i < Cardinal.ALL.Length; i++)
				{
					Cardinal val = Cardinal.ALL[i];
					PathNode pathNode4 = new PathNode(pathNode3, val);
					float extraCost = 0f;
					PathNode pathNode5 = openSet.TryFindValue(pathNode4);
					if ((object)pathNode5 != null)
					{
						float num = pathNode3.gCost + pathNode3.distanceTo(pathNode4);
						if (pathNode5.gCost > num + 0.0001f && traversable(pathNode4, stepHeight, maxFallHeight, entityCollBox, val, ref extraCost) && pathNode5.gCost > num + extraCost + 0.0001f)
						{
							UpdateNode(pathNode3, pathNode5, extraCost);
						}
					}
					else if (!closedSet.Contains(pathNode4) && traversable(pathNode4, stepHeight, maxFallHeight, entityCollBox, val, ref extraCost))
					{
						UpdateNode(pathNode3, pathNode4, extraCost);
						pathNode4.hCost = pathNode4.distanceTo(pathNode2);
						openSet.Add(pathNode4);
					}
				}
			}
			return null;
		}

		protected void UpdateNode(PathNode nearestNode, PathNode neighbourNode, float extraCost)
		{
			neighbourNode.gCost = nearestNode.gCost + nearestNode.distanceTo(neighbourNode) + extraCost;
			neighbourNode.Parent = nearestNode;
			neighbourNode.pathLength = nearestNode.pathLength + 1;
		}

		[Obsolete("Deprecated, please use UpdateNode() instead")]
		protected void addIfNearer(PathNode nearestNode, PathNode neighbourNode, PathNode targetNode, HashSet<PathNode> openSet, float extraCost)
		{
			UpdateNode(nearestNode, neighbourNode, extraCost);
		}

		protected bool traversable(PathNode node, float stepHeight, int maxFallHeight, Cuboidf entityCollBox, Cardinal fromDir, ref float extraCost)
		{
			//IL_0388: Unknown result type (might be due to invalid IL or missing references)
			//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Invalid comparison between Unknown and I4
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0237: Unknown result type (might be due to invalid IL or missing references)
			//IL_0264: Unknown result type (might be due to invalid IL or missing references)
			//IL_026a: Invalid comparison between Unknown and I4
			//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_031d: Unknown result type (might be due to invalid IL or missing references)
			tmpVec.Set((double)((BlockPos)node).X + centerOffsetX, (double)((BlockPos)node).Y, (double)((BlockPos)node).Z + centerOffsetZ);
			tmpPos.dimension = ((BlockPos)node).dimension;
			Block val;
			if (!collTester.IsColliding((IBlockAccessor)(object)blockAccess, entityCollBox, tmpVec, false))
			{
				int num = 0;
				while (true)
				{
					tmpPos.Set(((BlockPos)node).X, ((BlockPos)node).Y - 1, ((BlockPos)node).Z);
					val = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 1);
					if (!val.CanStep)
					{
						return false;
					}
					Block block = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 2);
					if (((CollectibleObject)block).IsLiquid())
					{
						float traversalCost = block.GetTraversalCost(tmpPos, creatureType);
						if (traversalCost > 10000f)
						{
							return false;
						}
						extraCost += traversalCost;
						break;
					}
					if ((int)block.BlockMaterial == 10)
					{
						val = block;
					}
					Cuboidf[] collisionBoxes = val.GetCollisionBoxes((IBlockAccessor)(object)blockAccess, tmpPos);
					if (collisionBoxes != null && collisionBoxes.Length != 0)
					{
						float traversalCost2 = val.GetTraversalCost(tmpPos, creatureType);
						if (traversalCost2 > 10000f)
						{
							return false;
						}
						extraCost += traversalCost2;
						break;
					}
					Vec3d obj = tmpVec;
					obj.Y -= 1.0;
					if (collTester.IsColliding((IBlockAccessor)(object)blockAccess, entityCollBox, tmpVec, false))
					{
						return false;
					}
					num++;
					((BlockPos)node).Y = ((BlockPos)node).Y - 1;
					maxFallHeight--;
					if (maxFallHeight < 0)
					{
						return false;
					}
				}
				if (fromDir.IsDiagnoal)
				{
					tmpVec.Add((double)((float)(-fromDir.Normali.X) / 2f), 0.0, (double)((float)(-fromDir.Normali.Z) / 2f));
					if (collTester.IsColliding((IBlockAccessor)(object)blockAccess, entityCollBox, tmpVec, false))
					{
						return false;
					}
				}
				tmpPos.Set(((BlockPos)node).X, ((BlockPos)node).Y, ((BlockPos)node).Z);
				float traversalCost3 = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 2).GetTraversalCost(tmpPos, creatureType);
				if (traversalCost3 > 10000f)
				{
					return false;
				}
				extraCost += traversalCost3;
				if (fromDir.IsDiagnoal && (int)creatureType == 2)
				{
					tmpPos.Set(((BlockPos)node).X - fromDir.Normali.X, ((BlockPos)node).Y, ((BlockPos)node).Z);
					traversalCost3 = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 2).GetTraversalCost(tmpPos, creatureType);
					extraCost += traversalCost3 - 1f;
					if (traversalCost3 > 10000f)
					{
						return false;
					}
					tmpPos.Set(((BlockPos)node).X, ((BlockPos)node).Y, ((BlockPos)node).Z - fromDir.Normali.Z);
					traversalCost3 = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 2).GetTraversalCost(tmpPos, creatureType);
					extraCost += traversalCost3 - 1f;
					if (traversalCost3 > 10000f)
					{
						return false;
					}
				}
				return true;
			}
			tmpPos.Set(((BlockPos)node).X, ((BlockPos)node).Y, ((BlockPos)node).Z);
			val = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 4);
			if (!val.CanStep)
			{
				return false;
			}
			float traversalCost4 = val.GetTraversalCost(tmpPos, creatureType);
			if (traversalCost4 > 10000f)
			{
				return false;
			}
			if (((CollectibleObject)val).Id != 0)
			{
				extraCost += traversalCost4;
			}
			Block block2 = ((IBlockAccessor)blockAccess).GetBlock(tmpPos, 2);
			traversalCost4 = block2.GetTraversalCost(tmpPos, creatureType);
			if (traversalCost4 > 10000f)
			{
				return false;
			}
			if (((CollectibleObject)block2).Id != 0)
			{
				extraCost += traversalCost4;
			}
			float num2 = -1f;
			Cuboidf[] collisionBoxes2 = val.GetCollisionBoxes((IBlockAccessor)(object)blockAccess, tmpPos);
			if (collisionBoxes2 != null && collisionBoxes2.Length != 0)
			{
				num2 += collisionBoxes2.Max((Cuboidf cuboid) => cuboid.Y2);
			}
			tmpVec.Set((double)((BlockPos)node).X + centerOffsetX, (double)((float)((BlockPos)node).Y + stepHeight + num2), (double)((BlockPos)node).Z + centerOffsetZ);
			if (!collTester.GetCollidingCollisionBox((IBlockAccessor)(object)blockAccess, entityCollBox, tmpVec, ref tmpCub, false, ((BlockPos)node).dimension))
			{
				if (!fromDir.IsDiagnoal)
				{
					((BlockPos)node).Y = ((BlockPos)node).Y + (int)(1f + num2);
					return true;
				}
				if (collisionBoxes2 != null && collisionBoxes2.Length != 0)
				{
					tmpVec.Add((double)((float)(-fromDir.Normali.X) / 2f), 0.0, (double)((float)(-fromDir.Normali.Z) / 2f));
					if (collTester.IsColliding((IBlockAccessor)(object)blockAccess, entityCollBox, tmpVec, false))
					{
						return false;
					}
					((BlockPos)node).Y = ((BlockPos)node).Y + (int)(1f + num2);
					return true;
				}
			}
			return false;
		}

		protected List<PathNode> retracePath(PathNode startNode, PathNode endNode)
		{
			int pathLength = endNode.pathLength;
			List<PathNode> list = new List<PathNode>(pathLength);
			for (int i = 0; i < pathLength; i++)
			{
				list.Add(null);
			}
			PathNode pathNode = endNode;
			for (int num = pathLength - 1; num >= 0; num--)
			{
				list[num] = pathNode;
				pathNode = pathNode.Parent;
			}
			return list;
		}

		public List<Vec3d> ToWaypoints(List<PathNode> path)
		{
			List<Vec3d> list = new List<Vec3d>(path.Count + 1);
			for (int i = 1; i < path.Count; i++)
			{
				list.Add(path[i].ToWaypoint().Add(centerOffsetX, 0.0, centerOffsetZ));
			}
			return list;
		}

		public void Dispose()
		{
			ICachingBlockAccessor obj = blockAccess;
			if (obj != null)
			{
				obj.Dispose();
			}
		}
	}
	public class PathfindSystem : ModSystem
	{
		public AStar astar;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			((ModSystem)this).StartServerSide(api);
			astar = new AStar(api);
		}

		public List<PathNode> FindPath(BlockPos start, BlockPos end, int maxFallHeight, float stepHeight, Cuboidf entityCollBox, EnumAICreatureType creatureType = (EnumAICreatureType)0)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			return astar.FindPath(start, end, maxFallHeight, stepHeight, entityCollBox, 9999, 1, creatureType);
		}

		public List<Vec3d> FindPathAsWaypoints(BlockPos start, BlockPos end, int maxFallHeight, float stepHeight, Cuboidf entityCollBox, int searchDepth = 9999, int mhdistanceTolerance = 0, EnumAICreatureType creatureType = (EnumAICreatureType)0)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return astar.FindPathAsWaypoints(start, end, maxFallHeight, stepHeight, entityCollBox, searchDepth, mhdistanceTolerance, creatureType);
		}

		public List<Vec3d> FindPathAsWaypoints(PathfinderTask task)
		{
			return astar.FindPathAsWaypoints(task.startBlockPos, task.targetBlockPos, task.maxFallHeight, task.stepHeight, task.collisionBox, task.searchDepth, task.mhdistanceTolerance, (EnumAICreatureType)0);
		}

		public List<Vec3d> ToWaypoints(List<PathNode> nodes)
		{
			return astar.ToWaypoints(nodes);
		}

		public override void Dispose()
		{
			astar?.Dispose();
			astar = null;
		}
	}
	public enum EnumTraverseAction
	{
		Walk,
		Climb
	}
	public class PathNode : BlockPos, IEquatable<PathNode>
	{
		public float gCost;

		public float hCost;

		public PathNode Parent;

		public int pathLength;

		public EnumTraverseAction Action;

		public float fCost => gCost + hCost;

		public int HeapIndex { get; set; }

		public PathNode(PathNode nearestNode, Cardinal card)
			: base(((BlockPos)nearestNode).X + card.Normali.X, ((BlockPos)nearestNode).Y + card.Normali.Y, ((BlockPos)nearestNode).Z + card.Normali.Z)
		{
			base.dimension = ((BlockPos)nearestNode).dimension;
		}

		public PathNode(BlockPos pos)
			: base(pos.X, pos.Y, pos.Z)
		{
			base.dimension = pos.dimension;
		}

		public bool Equals(PathNode other)
		{
			if (((BlockPos)other).X == base.X && ((BlockPos)other).Y == base.Y)
			{
				return ((BlockPos)other).Z == base.Z;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is PathNode)
			{
				return Equals(obj as PathNode);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((BlockPos)this).GetHashCode();
		}

		public static bool operator ==(PathNode left, PathNode right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		public static bool operator !=(PathNode left, PathNode right)
		{
			return !(left == right);
		}

		public float distanceTo(PathNode node)
		{
			int num = Math.Abs(((BlockPos)node).X - base.X);
			int num2 = Math.Abs(((BlockPos)node).Z - base.Z);
			if (num <= num2)
			{
				return (float)(num2 - num) + 1.4142137f * (float)num;
			}
			return (float)(num - num2) + 1.4142137f * (float)num2;
		}

		public Vec3d ToWaypoint()
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Expected O, but got Unknown
			return new Vec3d((double)base.X, (double)((BlockPos)this).InternalY, (double)base.Z);
		}

		public int CompareTo(PathNode other)
		{
			int num = fCost.CompareTo(other.fCost);
			if (num == 0)
			{
				num = hCost.CompareTo(other.hCost);
			}
			return -num;
		}
	}
	public class PathNodeSet : IEnumerable<PathNode>, IEnumerable
	{
		private int arraySize = 16;

		private PathNode[][] buckets = new PathNode[4][];

		private int[] bucketCount = new int[4];

		private int size;

		public int Count => size;

		public void Clear()
		{
			for (int i = 0; i < 4; i++)
			{
				bucketCount[i] = 0;
			}
			size = 0;
		}

		public PathNodeSet()
		{
			for (int i = 0; i < 4; i++)
			{
				buckets[i] = new PathNode[arraySize];
			}
		}

		public bool Add(PathNode value)
		{
			int num = ((BlockPos)value).Z % 2 * 2 + ((BlockPos)value).X % 2;
			num = (num + 4) % 4;
			PathNode[] array = buckets[num];
			int num2 = bucketCount[num];
			int num3 = num2;
			while (--num3 >= 0)
			{
				if (value.Equals(array[num3]))
				{
					return false;
				}
			}
			if (num2 >= arraySize)
			{
				ExpandArrays();
				array = buckets[num];
			}
			float fCost = value.fCost;
			num3 = num2 - 1;
			while (num3 >= 0 && (array[num3].fCost < fCost || (array[num3].fCost == fCost && array[num3].hCost < value.hCost)))
			{
				num3--;
			}
			num3++;
			int num4 = num2;
			while (num4 > num3)
			{
				array[num4] = array[--num4];
			}
			array[num3] = value;
			num2++;
			bucketCount[num] = num2;
			size++;
			return true;
		}

		public PathNode RemoveNearest()
		{
			if (size == 0)
			{
				return null;
			}
			PathNode pathNode = null;
			int num = 0;
			for (int i = 0; i < 4; i++)
			{
				int num2 = bucketCount[i] - 1;
				if (num2 >= 0)
				{
					PathNode pathNode2 = buckets[i][num2];
					if ((object)pathNode == null || pathNode2.fCost < pathNode.fCost || (pathNode2.fCost == pathNode.fCost && pathNode2.hCost < pathNode.hCost))
					{
						pathNode = pathNode2;
						num = i;
					}
				}
			}
			bucketCount[num]--;
			size--;
			return pathNode;
		}

		public void Remove(PathNode value)
		{
			int num = ((BlockPos)value).Z % 2 * 2 + ((BlockPos)value).X % 2;
			num = (num + 4) % 4;
			PathNode[] array = buckets[num];
			int num2 = bucketCount[num];
			int num3 = num2;
			while (--num3 >= 0)
			{
				if (value.Equals(array[num3]))
				{
					num2 = --bucketCount[num];
					while (num3 < num2)
					{
						array[num3] = array[++num3];
					}
					size--;
					break;
				}
			}
		}

		public PathNode TryFindValue(PathNode value)
		{
			int num = ((BlockPos)value).Z % 2 * 2 + ((BlockPos)value).X % 2;
			num = (num + 4) % 4;
			PathNode[] array = buckets[num];
			int num2 = bucketCount[num];
			while (--num2 >= 0)
			{
				if (value.Equals(array[num2]))
				{
					return array[num2];
				}
			}
			return null;
		}

		private void ExpandArrays()
		{
			int num = arraySize * 3 / 2;
			for (int i = 0; i < 4; i++)
			{
				PathNode[] array = new PathNode[num];
				int num2 = bucketCount[i];
				PathNode[] array2 = buckets[i];
				for (int j = 0; j < num2; j++)
				{
					array[j] = array2[j];
				}
				buckets[i] = array;
			}
			arraySize = num;
		}

		public IEnumerator<PathNode> GetEnumerator()
		{
			for (int bucket = 0; bucket < 4; bucket++)
			{
				for (int i = 0; i < bucketCount[bucket]; i++)
				{
					yield return buckets[bucket][i];
				}
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	public class WaypointsTraverser : PathTraverserBase
	{
		private float minTurnAnglePerSec;

		private float maxTurnAnglePerSec;

		private Vec3f targetVec = new Vec3f();

		private List<Vec3d> waypoints;

		private List<Vec3d> newWaypoints;

		private PathfinderTask asyncSearchObject;

		private int waypointToReachIndex;

		private long lastWaypointIncTotalMs;

		private Vec3d desiredTarget;

		private PathfindSystem psys;

		private PathfindingAsync asyncPathfinder;

		protected EnumAICreatureType creatureType;

		public bool PathFindDebug;

		private Action OnNoPath;

		public Action OnFoundPath;

		private Action OnGoalReached_New;

		private Action OnStuck_New;

		private float movingSpeed_New;

		private float targetDistance_New;

		private Vec3d prevPos = new Vec3d(0.0, -2000.0, 0.0);

		private Vec3d prevPrevPos = new Vec3d(0.0, -1000.0, 0.0);

		private float prevPosAccum;

		private float sqDistToTarget;

		private float distCheckAccum;

		private float lastDistToTarget;

		public override Vec3d CurrentTarget => waypoints[waypoints.Count - 1];

		public override bool Ready
		{
			get
			{
				if (waypoints != null)
				{
					return asyncSearchObject == null;
				}
				return false;
			}
		}

		public WaypointsTraverser(EntityAgent entity, EnumAICreatureType creatureType = (EnumAICreatureType)0)
			: base(entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Expected O, but got Unknown
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Expected O, but got Unknown
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			object obj;
			if (entity == null)
			{
				obj = null;
			}
			else
			{
				EntityServerProperties server = ((Entity)entity).Properties.Server;
				if (server == null)
				{
					obj = null;
				}
				else
				{
					ITreeAttribute attributes = ((EntitySidedProperties)server).Attributes;
					obj = ((attributes != null) ? attributes.GetTreeAttribute("pathfinder") : null);
				}
			}
			if (obj != null)
			{
				minTurnAnglePerSec = (float)((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetDecimal("minTurnAnglePerSec", 250.0);
				maxTurnAnglePerSec = (float)((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetDecimal("maxTurnAnglePerSec", 450.0);
			}
			else
			{
				minTurnAnglePerSec = 250f;
				maxTurnAnglePerSec = 450f;
			}
			psys = ((Entity)entity).World.Api.ModLoader.GetModSystem<PathfindSystem>(true);
			asyncPathfinder = ((Entity)entity).World.Api.ModLoader.GetModSystem<PathfindingAsync>(true);
			this.creatureType = creatureType;
		}

		public void FollowRoute(List<Vec3d> swoopPath, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck)
		{
			waypoints = swoopPath;
			base.WalkTowards(desiredTarget, movingSpeed, targetDistance, OnGoalReached, OnStuck, (EnumAICreatureType)0);
		}

		public override bool NavigateTo(Vec3d target, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck, Action onNoPath = null, bool giveUpWhenNoPath = false, int searchDepth = 999, int mhdistanceTolerance = 0, EnumAICreatureType? creatureType = null)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			desiredTarget = target;
			OnNoPath = onNoPath;
			OnStuck_New = OnStuck;
			OnGoalReached_New = OnGoalReached;
			movingSpeed_New = movingSpeed;
			targetDistance_New = targetDistance;
			if (creatureType.HasValue)
			{
				this.creatureType = creatureType.Value;
			}
			BlockPos asBlockPos = ((Entity)entity).ServerPos.AsBlockPos;
			if (((Entity)entity).World.BlockAccessor.IsNotTraversable(asBlockPos))
			{
				HandleNoPath();
				return false;
			}
			FindPath(asBlockPos, target.AsBlockPos, searchDepth, mhdistanceTolerance);
			return AfterFoundPath();
		}

		public override bool NavigateTo_Async(Vec3d target, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck, Action onNoPath = null, int searchDepth = 999, int mhdistanceTolerance = 0, EnumAICreatureType? creatureType = null)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (asyncSearchObject != null)
			{
				return false;
			}
			desiredTarget = target;
			if (creatureType.HasValue)
			{
				this.creatureType = creatureType.Value;
			}
			OnNoPath = onNoPath;
			OnGoalReached_New = OnGoalReached;
			OnStuck_New = OnStuck;
			movingSpeed_New = movingSpeed;
			targetDistance_New = targetDistance;
			BlockPos asBlockPos = ((Entity)entity).ServerPos.AsBlockPos;
			if (((Entity)entity).World.BlockAccessor.IsNotTraversable(asBlockPos))
			{
				HandleNoPath();
				return false;
			}
			FindPath_Async(asBlockPos, target.AsBlockPos, searchDepth, mhdistanceTolerance);
			return true;
		}

		private void FindPath(BlockPos startBlockPos, BlockPos targetBlockPos, int searchDepth, int mhdistanceTolerance = 0)
		{
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			waypointToReachIndex = 0;
			float stepHeight = ((Entity)entity).GetBehavior<EntityBehaviorControlledPhysics>()?.StepHeight ?? 0.6f;
			int maxFallHeight = (((Entity)entity).Properties.FallDamage ? (Math.Min(8, (int)Math.Round(3.51 / Math.Max(0.01, ((Entity)entity).Properties.FallDamageMultiplier))) - (int)(movingSpeed * 30f)) : 8);
			newWaypoints = psys.FindPathAsWaypoints(startBlockPos, targetBlockPos, maxFallHeight, stepHeight, ((Entity)entity).CollisionBox, searchDepth, mhdistanceTolerance, creatureType);
		}

		public PathfinderTask PreparePathfinderTask(BlockPos startBlockPos, BlockPos targetBlockPos, int searchDepth = 999, int mhdistanceTolerance = 0, EnumAICreatureType? creatureType = null)
		{
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Expected O, but got Unknown
			float num = ((Entity)entity).GetBehavior<EntityBehaviorControlledPhysics>()?.StepHeight ?? 0.6f;
			int num2;
			if (((Entity)entity).Properties.FallDamage)
			{
				JsonObject attributes = ((Entity)entity).Properties.Attributes;
				if (attributes == null || !attributes["reckless"].AsBool(false))
				{
					num2 = 4 - (int)(movingSpeed * 30f);
					goto IL_0071;
				}
			}
			num2 = 12;
			goto IL_0071;
			IL_0071:
			int num3 = num2;
			return new PathfinderTask(startBlockPos, targetBlockPos, num3, num, ((Entity)entity).CollisionBox, searchDepth, mhdistanceTolerance, (EnumAICreatureType)(((_003F?)creatureType) ?? this.creatureType));
		}

		private void FindPath_Async(BlockPos startBlockPos, BlockPos targetBlockPos, int searchDepth, int mhdistanceTolerance = 0)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			waypointToReachIndex = 0;
			asyncSearchObject = PreparePathfinderTask(startBlockPos, targetBlockPos, searchDepth, mhdistanceTolerance, creatureType);
			asyncPathfinder.EnqueuePathfinderTask(asyncSearchObject);
		}

		public bool AfterFoundPath()
		{
			if (asyncSearchObject != null)
			{
				newWaypoints = asyncSearchObject.waypoints;
				asyncSearchObject = null;
			}
			if (newWaypoints == null)
			{
				HandleNoPath();
				return false;
			}
			waypoints = newWaypoints;
			if (PathFindDebug)
			{
				List<BlockPos> list = new List<BlockPos>();
				List<int> list2 = new List<int>();
				int num = 0;
				foreach (Vec3d waypoint in waypoints)
				{
					list.Add(waypoint.AsBlockPos);
					list2.Add(ColorUtil.ColorFromRgba(128, 128, Math.Min(255, 128 + num * 8), 150));
					num++;
				}
				list.Add(desiredTarget.AsBlockPos);
				list2.Add(ColorUtil.ColorFromRgba(128, 0, 255, 255));
				IPlayer val = ((Entity)entity).World.AllOnlinePlayers[0];
				((Entity)entity).World.HighlightBlocks(val, 2, list, list2, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
			}
			waypoints.Add(desiredTarget);
			base.WalkTowards(desiredTarget, movingSpeed_New, targetDistance_New, OnGoalReached_New, OnStuck_New, (EnumAICreatureType)0);
			OnFoundPath?.Invoke();
			return true;
		}

		public void HandleNoPath()
		{
			waypoints = new List<Vec3d>();
			if (PathFindDebug)
			{
				List<BlockPos> list = new List<BlockPos>();
				List<int> list2 = new List<int>();
				int num = 0;
				foreach (PathNode item in ((Entity)entity).World.Api.ModLoader.GetModSystem<PathfindSystem>(true).astar.closedSet)
				{
					list.Add((BlockPos)(object)item);
					list2.Add(ColorUtil.ColorFromRgba(Math.Min(255, num * 4), 0, 0, 150));
					num++;
				}
				IPlayer val = ((Entity)entity).World.AllOnlinePlayers[0];
				((Entity)entity).World.HighlightBlocks(val, 2, list, list2, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
			}
			waypoints.Add(desiredTarget);
			base.WalkTowards(desiredTarget, movingSpeed_New, targetDistance_New, OnGoalReached_New, OnStuck_New, (EnumAICreatureType)0);
			if (OnNoPath != null)
			{
				Active = false;
				OnNoPath();
			}
		}

		public override bool WalkTowards(Vec3d target, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck, EnumAICreatureType creatureType = (EnumAICreatureType)0)
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			waypoints = new List<Vec3d>();
			waypoints.Add(target);
			return base.WalkTowards(target, movingSpeed, targetDistance, OnGoalReached, OnStuck, creatureType);
		}

		protected override bool BeginGo()
		{
			entity.Controls.Forward = true;
			entity.ServerControls.Forward = true;
			curTurnRadPerSec = minTurnAnglePerSec + (float)((Entity)entity).World.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
			curTurnRadPerSec *= 0.87266463f;
			stuckCounter = 0;
			waypointToReachIndex = 0;
			lastWaypointIncTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			distCheckAccum = 0f;
			prevPosAccum = 0f;
			return true;
		}

		public override void OnGameTick(float dt)
		{
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Invalid comparison between Unknown and I4
			//IL_066e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0674: Invalid comparison between Unknown and I4
			if (asyncSearchObject != null)
			{
				if (!asyncSearchObject.Finished)
				{
					return;
				}
				AfterFoundPath();
			}
			if (!Active)
			{
				return;
			}
			bool nearHorizontally = false;
			int num = 0;
			bool flag = IsNearTarget(num++, ref nearHorizontally) || IsNearTarget(num++, ref nearHorizontally) || IsNearTarget(num++, ref nearHorizontally);
			if (flag)
			{
				waypointToReachIndex += num;
				lastWaypointIncTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			}
			target = waypoints[Math.Min(waypoints.Count - 1, waypointToReachIndex)];
			_ = waypointToReachIndex;
			_ = waypoints.Count;
			if (waypointToReachIndex >= waypoints.Count)
			{
				Stop();
				OnGoalReached?.Invoke();
				return;
			}
			bool flag2 = nearHorizontally && !flag && (int)((Entity)entity).Properties.Habitat == 1;
			bool flag3 = (((Entity)entity).CollidedVertically && entity.Controls.IsClimbing) || (((Entity)entity).CollidedHorizontally && ((Entity)entity).ServerPos.Motion.Y <= 0.0) || flag2 || (((Entity)entity).CollidedHorizontally && waypoints.Count > 1 && waypointToReachIndex < waypoints.Count && ((Entity)entity).World.ElapsedMilliseconds - lastWaypointIncTotalMs > 2000);
			double num2 = prevPrevPos.SquareDistanceTo(prevPos);
			flag3 |= num2 < 0.0001 && ((Entity)entity).World.Rand.NextDouble() < GameMath.Clamp(1.0 - num2 * 1.2, 0.1, 0.9);
			prevPosAccum += dt;
			if ((double)prevPosAccum > 0.2)
			{
				prevPosAccum = 0f;
				prevPrevPos.Set(prevPos);
				prevPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z);
			}
			distCheckAccum += dt;
			if (distCheckAccum > 2f)
			{
				distCheckAccum = 0f;
				if ((double)Math.Abs(sqDistToTarget - lastDistToTarget) < 0.1)
				{
					flag3 = true;
					stuckCounter += 30;
				}
				else if (!flag3)
				{
					stuckCounter = 0;
				}
				lastDistToTarget = sqDistToTarget;
			}
			if (flag3)
			{
				stuckCounter++;
			}
			if (GlobalConstants.OverallSpeedMultiplier > 0f && (float)stuckCounter > 60f / GlobalConstants.OverallSpeedMultiplier)
			{
				Stop();
				OnStuck?.Invoke();
				return;
			}
			EntityControls val = ((entity.MountedOn == null) ? entity.Controls : entity.MountedOn.Controls);
			if (val == null)
			{
				return;
			}
			targetVec.Set((float)(target.X - ((Entity)entity).ServerPos.X), (float)(target.Y - ((Entity)entity).ServerPos.InternalY), (float)(target.Z - ((Entity)entity).ServerPos.Z));
			targetVec.Normalize();
			float num3 = 0f;
			if ((double)sqDistToTarget >= 0.01)
			{
				num3 = (float)Math.Atan2(targetVec.X, targetVec.Z);
			}
			float num4 = movingSpeed;
			if (sqDistToTarget < 1f)
			{
				num4 = Math.Max(0.005f, movingSpeed * Math.Max(sqDistToTarget, 0.2f));
			}
			float num5 = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, num3);
			float num6 = curTurnRadPerSec * dt * GlobalConstants.OverallSpeedMultiplier * movingSpeed;
			EntityPos serverPos = ((Entity)entity).ServerPos;
			serverPos.Yaw += GameMath.Clamp(num5, 0f - num6, num6);
			((Entity)entity).ServerPos.Yaw = ((Entity)entity).ServerPos.Yaw % ((float)Math.PI * 2f);
			double num7 = Math.Cos(((Entity)entity).ServerPos.Yaw);
			double num8 = Math.Sin(((Entity)entity).ServerPos.Yaw);
			val.WalkVector.Set(num8, (double)GameMath.Clamp(targetVec.Y, -1f, 1f), num7);
			val.WalkVector.Mul((double)(num4 * GlobalConstants.OverallSpeedMultiplier / Math.Max(1f, Math.Abs(num5) * 3f)));
			if (((Entity)entity).Properties.RotateModelOnClimb && entity.Controls.IsClimbing && ((Entity)entity).ClimbingIntoFace != null && ((Entity)entity).Alive)
			{
				BlockFacing climbingIntoFace = ((Entity)entity).ClimbingIntoFace;
				if (Math.Sign(climbingIntoFace.Normali.X) == Math.Sign(val.WalkVector.X))
				{
					val.WalkVector.X = 0.0;
				}
				if (Math.Sign(climbingIntoFace.Normali.Y) == Math.Sign(val.WalkVector.Y))
				{
					val.WalkVector.Y = 0.0 - val.WalkVector.Y;
				}
				if (Math.Sign(climbingIntoFace.Normali.Z) == Math.Sign(val.WalkVector.Z))
				{
					val.WalkVector.Z = 0.0;
				}
			}
			if ((int)((Entity)entity).Properties.Habitat == 3)
			{
				val.FlyVector.Set(val.WalkVector);
				Vec3d xYZ = ((Entity)entity).Pos.XYZ;
				Block blockRaw = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)xYZ.X, (int)xYZ.Y, (int)xYZ.Z, 2);
				Block blockRaw2 = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)xYZ.X, (int)(xYZ.Y + 1.0), (int)xYZ.Z, 2);
				float num9 = GameMath.Clamp((float)(int)xYZ.Y + (float)blockRaw.LiquidLevel / 8f + (((CollectibleObject)blockRaw2).IsLiquid() ? 1.125f : 0f) - (float)xYZ.Y - (float)((Entity)entity).SwimmingOffsetY, 0f, 1f);
				num9 = 1f - Math.Min(1f, num9 + 0.5f);
				if (num9 > 0f)
				{
					val.FlyVector.Y = GameMath.Clamp(val.FlyVector.Y, -0.03999999910593033, -0.019999999552965164) * (double)(1f - num9);
					return;
				}
				float num10 = movingSpeed * GlobalConstants.OverallSpeedMultiplier / (float)Math.Sqrt(targetVec.X * targetVec.X + targetVec.Z * targetVec.Z);
				val.FlyVector.Y = targetVec.Y * num10;
			}
			else if (((Entity)entity).Swimming)
			{
				val.FlyVector.Set(val.WalkVector);
				Vec3d xYZ2 = ((Entity)entity).Pos.XYZ;
				Block blockRaw3 = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)xYZ2.X, (int)xYZ2.Y, (int)xYZ2.Z, 2);
				Block blockRaw4 = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)xYZ2.X, (int)(xYZ2.Y + 1.0), (int)xYZ2.Z, 2);
				float num11 = GameMath.Clamp((float)(int)xYZ2.Y + (float)blockRaw3.LiquidLevel / 8f + (((CollectibleObject)blockRaw4).IsLiquid() ? 1.125f : 0f) - (float)xYZ2.Y - (float)((Entity)entity).SwimmingOffsetY, 0f, 1f);
				num11 = Math.Min(1f, num11 + 0.5f);
				val.FlyVector.Y = GameMath.Clamp(val.FlyVector.Y, 0.019999999552965164, 0.03999999910593033) * (double)num11;
				if (((Entity)entity).CollidedHorizontally)
				{
					val.FlyVector.Y = 0.05000000074505806;
				}
			}
		}

		private bool IsNearTarget(int waypointOffset, ref bool nearHorizontally)
		{
			if (waypoints.Count - 1 < waypointToReachIndex + waypointOffset)
			{
				return false;
			}
			int index = Math.Min(waypoints.Count - 1, waypointToReachIndex + waypointOffset);
			Vec3d val = waypoints[index];
			double internalY = ((Entity)entity).ServerPos.InternalY;
			sqDistToTarget = val.HorizontalSquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Z);
			double num = (val.Y - internalY) * (val.Y - internalY);
			bool flag = internalY > val.Y;
			sqDistToTarget += (float)Math.Max(0.0, num - (flag ? 1.0 : 0.5));
			if (!nearHorizontally)
			{
				double num2 = val.HorizontalSquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Z);
				nearHorizontally = num2 < (double)(TargetDistance * TargetDistance);
			}
			return sqDistToTarget < TargetDistance * TargetDistance;
		}

		public override void Stop()
		{
			Active = false;
			entity.Controls.Forward = false;
			entity.ServerControls.Forward = false;
			entity.Controls.WalkVector.Set(0.0, 0.0, 0.0);
			stuckCounter = 0;
			distCheckAccum = 0f;
			prevPosAccum = 0f;
			asyncSearchObject = null;
		}

		public override void Retarget()
		{
			Active = true;
			distCheckAccum = 0f;
			prevPosAccum = 0f;
			waypointToReachIndex = waypoints.Count - 1;
		}
	}
	public class PathFindDebug : ModSystem
	{
		private BlockPos start;

		private BlockPos end;

		private ICoreServerAPI sapi;

		private EnumAICreatureType ct;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Expected O, but got Unknown
			((ModSystem)this).StartServerSide(api);
			sapi = api;
			IChatCommandExt.EndSub(IChatCommandExt.WithDesc(IChatCommandExt.BeginSub(((ICoreAPI)api).ChatCommands.GetOrCreate("debug"), "astar"), "A* path finding debug testing tool").RequiresPrivilege(Privilege.controlserver).RequiresPlayer()
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[2]
				{
					(ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.WordRange("command", new string[5] { "start", "end", "bench", "clear", "ct" }),
					(ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.OptionalWord("creature type")
				})
				.HandleWith(new OnCommandDelegate(onAstarCmd)));
		}

		private TextCommandResult onAstarCmd(TextCommandCallingArgs args)
		{
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Expected O, but got Unknown
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			//IL_038d: Unknown result type (might be due to invalid IL or missing references)
			string text = (string)args[0];
			IPlayer player = args.Caller.Player;
			BlockPos asBlockPos = ((Entity)player.Entity).ServerPos.XYZ.AsBlockPos;
			PathfindSystem modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<PathfindSystem>(true);
			Cuboidf val = new Cuboidf(-0.4f, 0f, -0.4f, 0.4f, 1.5f, 0.4f);
			new Cuboidf(-0.2f, 0f, -0.2f, 0.2f, 1.5f, 0.2f);
			new Cuboidf(-0.6f, 0f, -0.6f, 0.6f, 1.5f, 0.6f);
			Cuboidf entityCollBox = val;
			int maxFallHeight = 3;
			float stepHeight = 1.01f;
			switch (text)
			{
			case "ct":
			{
				string text2 = (string)args[1];
				if (text2 == null)
				{
					return TextCommandResult.Success($"Current creature type is {text2}", (object)null);
				}
				if (Enum.TryParse<EnumAICreatureType>(text2, out EnumAICreatureType result))
				{
					ct = result;
					return TextCommandResult.Success($"Creature type set to {text2}", (object)null);
				}
				return TextCommandResult.Error($"Not a vaild enum type", "");
			}
			case "start":
				start = asBlockPos.Copy();
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 26, new List<BlockPos> { start }, new List<int> { ColorUtil.ColorFromRgba(255, 255, 0, 128) }, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
				break;
			case "end":
				end = asBlockPos.Copy();
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 27, new List<BlockPos> { end }, new List<int> { ColorUtil.ColorFromRgba(255, 0, 255, 128) }, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
				break;
			case "bench":
			{
				if (start == (BlockPos)null || end == (BlockPos)null)
				{
					return TextCommandResult.Error("Start/End not set", "");
				}
				Stopwatch stopwatch = new Stopwatch();
				stopwatch.Start();
				for (int i = 0; i < 15; i++)
				{
					modSystem.FindPath(start, end, maxFallHeight, stepHeight, entityCollBox, (EnumAICreatureType)0);
				}
				stopwatch.Stop();
				float num = (float)stopwatch.ElapsedMilliseconds / 15f;
				return TextCommandResult.Success($"15 searches average: {(int)num} ms", (object)null);
			}
			case "clear":
				start = null;
				end = null;
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 2, new List<BlockPos>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0);
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 26, new List<BlockPos>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0);
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 27, new List<BlockPos>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0);
				break;
			}
			if (start == (BlockPos)null || end == (BlockPos)null)
			{
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 2, new List<BlockPos>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0);
			}
			if (start != (BlockPos)null && end != (BlockPos)null)
			{
				Stopwatch stopwatch2 = new Stopwatch();
				stopwatch2.Start();
				List<PathNode> list = modSystem.FindPath(start, end, maxFallHeight, stepHeight, entityCollBox, ct);
				stopwatch2.Stop();
				int num2 = (int)stopwatch2.ElapsedMilliseconds;
				string text3 = $"Search took {num2} ms, {modSystem.astar.NodesChecked} nodes checked";
				if (list == null)
				{
					((IWorldAccessor)sapi.World).HighlightBlocks(player, 2, new List<BlockPos>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0);
					((IWorldAccessor)sapi.World).HighlightBlocks(player, 3, new List<BlockPos>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0);
					return TextCommandResult.Success(text3 + "\nNo path found", (object)null);
				}
				List<BlockPos> list2 = new List<BlockPos>();
				foreach (PathNode item in list)
				{
					list2.Add((BlockPos)(object)item);
				}
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 2, list2, new List<int> { ColorUtil.ColorFromRgba(128, 128, 128, 30) }, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
				List<Vec3d> list3 = modSystem.ToWaypoints(list);
				list2 = new List<BlockPos>();
				foreach (Vec3d item2 in list3)
				{
					list2.Add(item2.AsBlockPos);
				}
				((IWorldAccessor)sapi.World).HighlightBlocks(player, 3, list2, new List<int> { ColorUtil.ColorFromRgba(128, 0, 0, 100) }, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
				return TextCommandResult.Success(text3, (object)null);
			}
			return TextCommandResult.Success("", (object)null);
		}
	}
	public class PathfindingAsync : ModSystem, IAsyncServerSystem
	{
		protected ICoreServerAPI api;

		protected AStar astar_offthread;

		protected AStar astar_mainthread;

		protected bool isShuttingDown;

		public ConcurrentQueue<PathfinderTask> PathfinderTasks = new ConcurrentQueue<PathfinderTask>();

		protected readonly Stopwatch totalTime = new Stopwatch();

		protected long lastTickTimeMs;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			((ModSystem)this).StartServerSide(api);
			this.api = api;
			astar_offthread = new AStar(api);
			astar_mainthread = new AStar(api);
			api.Event.ServerRunPhase((EnumServerRunPhase)9, (Action)delegate
			{
				isShuttingDown = true;
			});
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)OnMainThreadTick, 20, 0);
			api.Server.AddServerThread("ai-pathfinding", (IAsyncServerSystem)(object)this);
		}

		public int OffThreadInterval()
		{
			return 5;
		}

		protected void OnMainThreadTick(float dt)
		{
			int count = PathfinderTasks.Count;
			if (count <= 1)
			{
				return;
			}
			((IWorldAccessor)api.World).FrameProfiler.Enter("ai-pathfinding-overflow " + count);
			int num = 1000;
			PathfinderTask val;
			while ((val = Next()) != null && num-- > 0)
			{
				val.waypoints = astar_mainthread.FindPathAsWaypoints(val.startBlockPos, val.targetBlockPos, val.maxFallHeight, val.stepHeight, val.collisionBox, val.searchDepth, val.mhdistanceTolerance, (EnumAICreatureType)0);
				val.Finished = true;
				if (isShuttingDown)
				{
					break;
				}
				if (((IWorldAccessor)api.World).FrameProfiler.Enabled)
				{
					((IWorldAccessor)api.World).FrameProfiler.Mark("path d:" + val.searchDepth + " r:" + ((val.waypoints == null) ? "fail" : val.waypoints.Count.ToString()) + " s:" + ((object)val.startBlockPos)?.ToString() + " e:" + ((object)val.targetBlockPos)?.ToString() + " w:" + val.collisionBox.Width);
				}
			}
			((IWorldAccessor)api.World).FrameProfiler.Leave();
		}

		public void OnSeparateThreadTick()
		{
			ProcessQueue(astar_offthread, 100);
		}

		public void ProcessQueue(AStar astar, int maxCount)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			PathfinderTask val;
			while ((val = Next()) != null && maxCount-- > 0)
			{
				try
				{
					val.waypoints = astar.FindPathAsWaypoints(val.startBlockPos, val.targetBlockPos, val.maxFallHeight, val.stepHeight, val.collisionBox, val.searchDepth, val.mhdistanceTolerance, val.CreatureType);
				}
				catch (Exception ex)
				{
					val.waypoints = null;
					((IWorldAccessor)api.World).Logger.Error("Exception thrown during pathfinding. Will ignore. Exception: {0}", new object[1] { ex.ToString() });
				}
				val.Finished = true;
				if (isShuttingDown)
				{
					break;
				}
			}
		}

		protected PathfinderTask Next()
		{
			if (!PathfinderTasks.TryDequeue(out var result))
			{
				return null;
			}
			return result;
		}

		public void EnqueuePathfinderTask(PathfinderTask task)
		{
			PathfinderTasks.Enqueue(task);
		}

		public override void Dispose()
		{
			astar_mainthread?.Dispose();
			astar_mainthread = null;
		}

		public void ThreadDispose()
		{
			astar_offthread.Dispose();
			astar_offthread = null;
		}
	}
	public class StraightLineTraverser : PathTraverserBase
	{
		private float minTurnAnglePerSec;

		private float maxTurnAnglePerSec;

		private Vec3f targetVec = new Vec3f();

		private Vec3d prevPos = new Vec3d();

		public StraightLineTraverser(EntityAgent entity)
			: base(entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			object obj;
			if (entity == null)
			{
				obj = null;
			}
			else
			{
				EntityServerProperties server = ((Entity)entity).Properties.Server;
				if (server == null)
				{
					obj = null;
				}
				else
				{
					ITreeAttribute attributes = ((EntitySidedProperties)server).Attributes;
					obj = ((attributes != null) ? attributes.GetTreeAttribute("pathfinder") : null);
				}
			}
			if (obj != null)
			{
				minTurnAnglePerSec = (float)((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetDecimal("minTurnAnglePerSec", 250.0);
				maxTurnAnglePerSec = (float)((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetDecimal("maxTurnAnglePerSec", 450.0);
			}
			else
			{
				minTurnAnglePerSec = 250f;
				maxTurnAnglePerSec = 450f;
			}
		}

		protected override bool BeginGo()
		{
			entity.Controls.Forward = true;
			entity.ServerControls.Forward = true;
			curTurnRadPerSec = minTurnAnglePerSec + (float)((Entity)entity).World.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
			curTurnRadPerSec *= 0.87266463f;
			stuckCounter = 0;
			return true;
		}

		public override void OnGameTick(float dt)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Invalid comparison between Unknown and I4
			if (!Active)
			{
				return;
			}
			double num = (((int)((Entity)entity).Properties.Habitat == 1) ? target.SquareDistanceTo(((Entity)entity).ServerPos.X, target.Y, ((Entity)entity).ServerPos.Z) : target.SquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z));
			if (num < (double)(TargetDistance * TargetDistance))
			{
				Stop();
				OnGoalReached?.Invoke();
				return;
			}
			bool flag = (((Entity)entity).CollidedVertically && entity.Controls.IsClimbing) || ((Entity)entity).ServerPos.SquareDistanceTo(prevPos) < 2.5E-05 || (((Entity)entity).CollidedHorizontally && ((Entity)entity).ServerPos.Motion.Y <= 0.0);
			prevPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z);
			stuckCounter = (flag ? (stuckCounter + 1) : 0);
			if (GlobalConstants.OverallSpeedMultiplier > 0f && (float)stuckCounter > 20f / GlobalConstants.OverallSpeedMultiplier)
			{
				Stop();
				OnStuck?.Invoke();
				return;
			}
			EntityControls val = ((entity.MountedOn == null) ? entity.Controls : entity.MountedOn.Controls);
			if (val != null)
			{
				targetVec.Set((float)(target.X - ((Entity)entity).ServerPos.X), (float)(target.Y - ((Entity)entity).ServerPos.InternalY), (float)(target.Z - ((Entity)entity).ServerPos.Z));
				float desiredYaw = 0f;
				if (num >= 0.01)
				{
					desiredYaw = (float)Math.Atan2(targetVec.X, targetVec.Z);
				}
				float nowMoveSpeed = movingSpeed;
				if (num < 1.0)
				{
					nowMoveSpeed = Math.Max(0.005f, movingSpeed * Math.Max((float)num, 0.2f));
				}
				yawToMotion(dt, val, desiredYaw, nowMoveSpeed);
			}
		}

		private void yawToMotion(float dt, EntityControls controls, float desiredYaw, float nowMoveSpeed)
		{
			float num = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, desiredYaw);
			float num2 = curTurnRadPerSec * dt * GlobalConstants.OverallSpeedMultiplier * movingSpeed;
			EntityPos serverPos = ((Entity)entity).ServerPos;
			serverPos.Yaw += GameMath.Clamp(num, 0f - num2, num2);
			((Entity)entity).ServerPos.Yaw = ((Entity)entity).ServerPos.Yaw % ((float)Math.PI * 2f);
			double num3 = Math.Cos(((Entity)entity).ServerPos.Yaw);
			double num4 = Math.Sin(((Entity)entity).ServerPos.Yaw);
			controls.WalkVector.Set(num4, (double)GameMath.Clamp(targetVec.Y, -1f, 1f), num3);
			controls.WalkVector.Mul((double)(nowMoveSpeed * GlobalConstants.OverallSpeedMultiplier / Math.Max(1f, num * 3f)));
			if (((Entity)entity).Properties.RotateModelOnClimb && entity.Controls.IsClimbing && ((Entity)entity).ClimbingOnFace != null && ((Entity)entity).Alive)
			{
				BlockFacing climbingOnFace = ((Entity)entity).ClimbingOnFace;
				if (Math.Sign(climbingOnFace.Normali.X) == Math.Sign(controls.WalkVector.X))
				{
					controls.WalkVector.X = 0.0;
				}
				if (Math.Sign(climbingOnFace.Normali.Z) == Math.Sign(controls.WalkVector.Z))
				{
					controls.WalkVector.Z = 0.0;
				}
			}
			if (((Entity)entity).Swimming)
			{
				controls.FlyVector.Set(controls.WalkVector);
				Vec3d xYZ = ((Entity)entity).Pos.XYZ;
				Block blockRaw = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)xYZ.X, (int)xYZ.Y, (int)xYZ.Z, 2);
				Block blockRaw2 = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)xYZ.X, (int)(xYZ.Y + 1.0), (int)xYZ.Z, 2);
				float num5 = GameMath.Clamp((float)(int)xYZ.Y + (float)blockRaw.LiquidLevel / 8f + (((CollectibleObject)blockRaw2).IsLiquid() ? 1.125f : 0f) - (float)xYZ.Y - (float)((Entity)entity).SwimmingOffsetY, 0f, 1f);
				num5 = Math.Min(1f, num5 + 0.075f);
				controls.FlyVector.Y = GameMath.Clamp(controls.FlyVector.Y, 0.0020000000949949026, 0.004000000189989805) * (double)num5;
				if (((Entity)entity).CollidedHorizontally)
				{
					controls.FlyVector.Y = 0.05000000074505806;
				}
			}
		}

		public override void Stop()
		{
			Active = false;
			entity.Controls.Forward = false;
			entity.ServerControls.Forward = false;
			entity.Controls.WalkVector.Set(0.0, 0.0, 0.0);
			stuckCounter = 0;
		}
	}
}
namespace Vintagestory.API.Common
{
	public enum EnumGoalTrigger
	{
		Never,
		Always,
		OnHurt
	}
	public abstract class AiGoalBase
	{
		public Random rand;

		public EntityAgent entity;

		public IWorldAccessor world;

		protected float priority;

		protected float priorityForCancel;

		protected int mincooldown;

		protected int maxcooldown;

		protected double mincooldownHours;

		protected double maxcooldownHours;

		protected long cooldownUntilMs;

		protected double cooldownUntilTotalHours;

		protected PathTraverserBase pathTraverser;

		private Queue<AiActionBase> activeActions = new Queue<AiActionBase>();

		public virtual float Priority => priority;

		public virtual float PriorityForCancel => priorityForCancel;

		public AiGoalBase(EntityAgent entity)
		{
			this.entity = entity;
			world = ((Entity)entity).World;
			rand = new Random((int)((Entity)entity).EntityId);
			pathTraverser = ((Entity)entity).GetBehavior<EntityBehaviorGoalAI>().PathTraverser;
		}

		public virtual void LoadConfig(JsonObject taskConfig, JsonObject aiConfig)
		{
			priority = taskConfig["priority"].AsFloat(0f);
			priorityForCancel = taskConfig["priorityForCancel"].AsFloat(priority);
			JsonObject obj = taskConfig["mincooldown"];
			mincooldown = ((obj != null) ? new int?(obj.AsInt(0)) : ((int?)null)).Value;
			JsonObject obj2 = taskConfig["maxcooldown"];
			maxcooldown = ((obj2 != null) ? new int?(obj2.AsInt(100)) : ((int?)null)).Value;
			JsonObject obj3 = taskConfig["mincooldownHours"];
			mincooldownHours = ((obj3 != null) ? new double?(obj3.AsDouble(0.0)) : ((double?)null)).Value;
			JsonObject obj4 = taskConfig["maxcooldownHours"];
			maxcooldownHours = ((obj4 != null) ? new double?(obj4.AsDouble(0.0)) : ((double?)null)).Value;
			JsonObject obj5 = taskConfig["initialMinCoolDown"];
			int value = ((obj5 != null) ? new int?(obj5.AsInt(mincooldown)) : ((int?)null)).Value;
			JsonObject obj6 = taskConfig["initialMaxCoolDown"];
			int value2 = ((obj6 != null) ? new int?(obj6.AsInt(maxcooldown)) : ((int?)null)).Value;
			cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + value + ((Entity)entity).World.Rand.Next(value2 - value);
		}

		public virtual bool ShouldExecuteAll()
		{
			if (cooldownUntilMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilTotalHours > ((Entity)entity).World.Calendar.TotalHours)
			{
				return false;
			}
			return ShouldExecute();
		}

		protected abstract bool ShouldExecute();

		public virtual void StartExecuteAll()
		{
			StartExecute();
		}

		protected virtual void StartExecute()
		{
		}

		public virtual bool ContinueExecuteAll(float dt)
		{
			return ContinueExecute(dt);
		}

		protected abstract bool ContinueExecute(float dt);

		public virtual void FinishExecuteAll(bool cancelled)
		{
			cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + mincooldown + ((Entity)entity).World.Rand.Next(maxcooldown - mincooldown);
			cooldownUntilTotalHours = ((Entity)entity).World.Calendar.TotalHours + mincooldownHours + ((Entity)entity).World.Rand.NextDouble() * (maxcooldownHours - mincooldownHours);
			FinishExecute(cancelled);
		}

		protected virtual void FinishExecute(bool cancelled)
		{
		}

		public virtual void OnStateChanged(EnumEntityState beforeState)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			if ((int)((Entity)entity).State == 0)
			{
				cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + mincooldown + ((Entity)entity).World.Rand.Next(maxcooldown - mincooldown);
			}
		}

		public virtual bool Notify(string key, object data)
		{
			return false;
		}
	}
	public enum EnumComparison
	{
		SameAs,
		LessThan,
		MoreThan
	}
	public abstract class GoapCondition
	{
	}
	public class BlockConditon : GoapCondition
	{
		private ActionConsumable<Block> matcher;

		public BlockConditon(ActionConsumable<Block> matcher)
		{
			this.matcher = matcher;
		}

		public bool Satisfies(Block block)
		{
			return matcher.Invoke(block);
		}
	}
	public abstract class AiTaskBase : IAiTask
	{
		[ThreadStatic]
		private static Random randTL;

		public EntityAgent entity;

		public IWorldAccessor world;

		public AnimationMetaData animMeta;

		protected float priority;

		protected float priorityForCancel;

		protected int slot;

		public int Mincooldown;

		public int Maxcooldown;

		protected double mincooldownHours;

		protected double maxcooldownHours;

		protected AssetLocation finishSound;

		protected AssetLocation sound;

		protected float soundRange = 16f;

		protected int soundStartMs;

		protected int soundRepeatMs;

		protected float soundChance = 1.01f;

		protected long lastSoundTotalMs;

		public string WhenInEmotionState;

		public bool? WhenSwimming;

		public string WhenNotInEmotionState;

		protected long cooldownUntilMs;

		protected double cooldownUntilTotalHours;

		protected WaypointsTraverser pathTraverser;

		protected EntityBehaviorEmotionStates bhEmo;

		public DayTimeFrame[] duringDayTimeFrames;

		protected double defaultTimeoutSec = 30.0;

		protected TimeSpan timeout;

		protected long executeStartTimeMs;

		private string profilerName;

		public Random rand => randTL ?? (randTL = new Random());

		public string Id { get; set; }

		public string ProfilerName
		{
			get
			{
				return profilerName;
			}
			set
			{
				profilerName = value;
			}
		}

		public virtual int Slot => slot;

		public virtual float Priority
		{
			get
			{
				return priority;
			}
			set
			{
				priority = value;
			}
		}

		public virtual float PriorityForCancel => priorityForCancel;

		public AiTaskBase(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
		{
			//IL_0324: Unknown result type (might be due to invalid IL or missing references)
			//IL_0329: Unknown result type (might be due to invalid IL or missing references)
			//IL_0336: Unknown result type (might be due to invalid IL or missing references)
			//IL_0343: Unknown result type (might be due to invalid IL or missing references)
			this.entity = entity;
			world = ((Entity)entity).World;
			if (randTL == null)
			{
				randTL = new Random((int)((Entity)entity).EntityId);
			}
			pathTraverser = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().PathTraverser;
			bhEmo = ((Entity)entity).GetBehavior<EntityBehaviorEmotionStates>();
			priority = taskConfig["priority"].AsFloat(0f);
			priorityForCancel = taskConfig["priorityForCancel"].AsFloat(priority);
			Id = taskConfig["id"].AsString((string)null);
			JsonObject obj = taskConfig["slot"];
			slot = ((obj != null) ? new int?(obj.AsInt(0)) : ((int?)null)).Value;
			JsonObject obj2 = taskConfig["mincooldown"];
			Mincooldown = ((obj2 != null) ? new int?(obj2.AsInt(0)) : ((int?)null)).Value;
			JsonObject obj3 = taskConfig["maxcooldown"];
			Maxcooldown = ((obj3 != null) ? new int?(obj3.AsInt(100)) : ((int?)null)).Value;
			JsonObject obj4 = taskConfig["mincooldownHours"];
			mincooldownHours = ((obj4 != null) ? new double?(obj4.AsDouble(0.0)) : ((double?)null)).Value;
			JsonObject obj5 = taskConfig["maxcooldownHours"];
			maxcooldownHours = ((obj5 != null) ? new double?(obj5.AsDouble(0.0)) : ((double?)null)).Value;
			JsonObject obj6 = taskConfig["initialMinCoolDown"];
			int value = ((obj6 != null) ? new int?(obj6.AsInt(Mincooldown)) : ((int?)null)).Value;
			JsonObject obj7 = taskConfig["initialMaxCoolDown"];
			int value2 = ((obj7 != null) ? new int?(obj7.AsInt(Maxcooldown)) : ((int?)null)).Value;
			JsonObject obj8 = taskConfig["timeoutSec"];
			timeout = TimeSpan.FromSeconds((obj8 != null) ? obj8.AsDouble(defaultTimeoutSec) : defaultTimeoutSec);
			JsonObject val = taskConfig["animation"];
			if (val.Exists)
			{
				string code = val.AsString((string)null)?.ToLowerInvariant();
				JsonObject val2 = taskConfig["animationSpeed"];
				float animationSpeed = val2.AsFloat(1f);
				AnimationMetaData val3 = ((IEnumerable<AnimationMetaData>)((Entity)this.entity).Properties.Client.Animations).FirstOrDefault((Func<AnimationMetaData, bool>)((AnimationMetaData a) => a.Code == code));
				if (val3 != null)
				{
					if (val2.Exists)
					{
						animMeta = val3.Clone();
						animMeta.AnimationSpeed = animationSpeed;
					}
					else
					{
						animMeta = val3;
					}
				}
				else
				{
					animMeta = new AnimationMetaData
					{
						Code = code,
						Animation = code,
						AnimationSpeed = animationSpeed
					}.Init();
					animMeta.EaseInSpeed = 1f;
					animMeta.EaseOutSpeed = 1f;
				}
			}
			JsonObject obj9 = taskConfig["whenSwimming"];
			WhenSwimming = ((obj9 != null) ? new bool?(obj9.AsBool(false)) : ((bool?)null));
			WhenInEmotionState = taskConfig["whenInEmotionState"].AsString((string)null);
			WhenNotInEmotionState = taskConfig["whenNotInEmotionState"].AsString((string)null);
			JsonObject val4 = taskConfig["sound"];
			if (val4.Exists)
			{
				sound = AssetLocation.Create(val4.AsString((string)null), ((RegistryObject)entity).Code.Domain).WithPathPrefixOnce("sounds/");
				soundRange = taskConfig["soundRange"].AsFloat(16f);
				soundStartMs = taskConfig["soundStartMs"].AsInt(0);
				soundRepeatMs = taskConfig["soundRepeatMs"].AsInt(0);
			}
			JsonObject val5 = taskConfig["finishSound"];
			if (val5.Exists)
			{
				finishSound = AssetLocation.Create(val5.AsString((string)null), ((RegistryObject)entity).Code.Domain).WithPathPrefixOnce("sounds/");
			}
			duringDayTimeFrames = taskConfig["duringDayTimeFrames"].AsObject<DayTimeFrame[]>((DayTimeFrame[])null);
			cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + value + ((Entity)entity).World.Rand.Next(value2 - value);
		}

		protected bool PreconditionsSatisifed()
		{
			if (WhenSwimming.HasValue && WhenSwimming != ((Entity)entity).Swimming)
			{
				return false;
			}
			if (WhenInEmotionState != null && !IsInEmotionState(WhenInEmotionState))
			{
				return false;
			}
			if (WhenNotInEmotionState != null && IsInEmotionState(WhenNotInEmotionState))
			{
				return false;
			}
			if (!IsInValidDayTimeHours(initialRandomness: true))
			{
				return false;
			}
			return true;
		}

		protected bool IsInValidDayTimeHours(bool initialRandomness)
		{
			if (duringDayTimeFrames != null)
			{
				double num = ((Entity)entity).World.Calendar.HourOfDay / ((Entity)entity).World.Calendar.HoursPerDay * 24f;
				if (initialRandomness)
				{
					num += ((Entity)entity).World.Rand.NextDouble() * 0.30000001192092896 - 0.15000000596046448;
				}
				for (int i = 0; i < duringDayTimeFrames.Length; i++)
				{
					if (duringDayTimeFrames[i].Matches(num))
					{
						return true;
					}
				}
				return false;
			}
			return true;
		}

		protected bool IsInEmotionState(string emostate)
		{
			if (bhEmo == null)
			{
				return false;
			}
			if (StringUtil.ContainsFast(emostate, '|'))
			{
				string[] array = emostate.Split("|");
				for (int i = 0; i < array.Length; i++)
				{
					if (bhEmo.IsInEmotionState(array[i]))
					{
						return true;
					}
				}
				return false;
			}
			return bhEmo.IsInEmotionState(emostate);
		}

		public virtual void AfterInitialize()
		{
		}

		public abstract bool ShouldExecute();

		public virtual void StartExecute()
		{
			if (animMeta != null)
			{
				((Entity)entity).AnimManager.StartAnimation(animMeta);
			}
			if (sound != (AssetLocation)null && ((Entity)entity).World.Rand.NextDouble() <= (double)soundChance)
			{
				if (soundStartMs > 0)
				{
					((Entity)entity).World.RegisterCallback((Action<float>)delegate
					{
						((Entity)entity).World.PlaySoundAt(sound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, true, soundRange, 1f);
						lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
					}, soundStartMs);
				}
				else
				{
					((Entity)entity).World.PlaySoundAt(sound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, true, soundRange, 1f);
					lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
				}
			}
			executeStartTimeMs = ((Entity)entity).World.ElapsedMilliseconds;
		}

		public virtual bool ContinueExecute(float dt)
		{
			if (sound != (AssetLocation)null && soundRepeatMs > 0 && ((Entity)entity).World.ElapsedMilliseconds > lastSoundTotalMs + soundRepeatMs)
			{
				((Entity)entity).World.PlaySoundAt(sound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, true, soundRange, 1f);
				lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			}
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			return true;
		}

		public virtual void FinishExecute(bool cancelled)
		{
			cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + Mincooldown + ((Entity)entity).World.Rand.Next(Maxcooldown - Mincooldown);
			cooldownUntilTotalHours = ((Entity)entity).World.Calendar.TotalHours + mincooldownHours + ((Entity)entity).World.Rand.NextDouble() * (maxcooldownHours - mincooldownHours);
			if (animMeta != null && animMeta.Code != "attack" && animMeta.Code != "idle")
			{
				((Entity)entity).AnimManager.StopAnimation(animMeta.Code);
			}
			if (finishSound != (AssetLocation)null)
			{
				((Entity)entity).World.PlaySoundAt(finishSound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, true, soundRange, 1f);
			}
		}

		public virtual void OnStateChanged(EnumEntityState beforeState)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			if ((int)((Entity)entity).State == 0)
			{
				IWorldAccessor val = ((Entity)entity).World;
				cooldownUntilMs = val.ElapsedMilliseconds + Mincooldown + val.Rand.Next(Maxcooldown - Mincooldown);
			}
		}

		public virtual bool Notify(string key, object data)
		{
			return false;
		}

		public virtual void OnEntityLoaded()
		{
		}

		public virtual void OnEntitySpawn()
		{
		}

		public virtual void OnEntityDespawn(EntityDespawnData reason)
		{
		}

		public virtual void OnEntityHurt(DamageSource source, float damage)
		{
		}

		public virtual void OnNoPath(Vec3d target)
		{
		}

		public virtual bool CanContinueExecute()
		{
			return true;
		}

		protected virtual bool timeoutExceeded()
		{
			return (double)(((Entity)entity).World.ElapsedMilliseconds - executeStartTimeMs) > timeout.TotalMilliseconds;
		}
	}
	public interface IAiTask
	{
		string Id { get; }

		int Slot { get; }

		float Priority { get; }

		float PriorityForCancel { get; }

		string ProfilerName { get; set; }

		bool ShouldExecute();

		void StartExecute();

		bool ContinueExecute(float dt);

		void FinishExecute(bool cancelled);

		void AfterInitialize();

		void OnStateChanged(EnumEntityState beforeState);

		bool Notify(string key, object data);

		void OnEntityLoaded();

		void OnEntitySpawn();

		void OnEntityDespawn(EntityDespawnData reason);

		void OnEntityHurt(DamageSource source, float damage);

		bool CanContinueExecute();
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskBaseConfig
	{
		[JsonProperty]
		public string Code = "";

		[JsonProperty]
		public bool Enabled = true;

		[JsonProperty]
		public string Id = "";

		[JsonProperty]
		public float Priority;

		[JsonProperty]
		private float? priorityForCancel;

		[JsonProperty]
		public int Slot;

		[JsonProperty]
		public int MinCooldownMs;

		[JsonProperty]
		public int MaxCooldownMs = 100;

		[JsonProperty]
		public double MinCooldownHours;

		[JsonProperty]
		public double MaxCooldownHours;

		[JsonProperty]
		public int InitialMinCooldownMs;

		[JsonProperty]
		public int InitialMaxCooldownMs;

		[JsonProperty]
		private string[]? tagsAppliedToEntity = Array.Empty<string>();

		[JsonProperty]
		public bool? WhenSwimming;

		[JsonProperty]
		public bool? WhenFeetInLiquid;

		[JsonProperty]
		public string[] WhenInEmotionState = Array.Empty<string>();

		[JsonProperty]
		public string[] WhenNotInEmotionState = Array.Empty<string>();

		[JsonProperty]
		private string animation = "";

		[JsonProperty]
		private float? animationSpeed;

		[JsonProperty]
		public AssetLocation? Sound;

		[JsonProperty]
		public float SoundRange = 16f;

		[JsonProperty]
		public int SoundStartMs;

		[JsonProperty]
		public int SoundRepeatMs;

		[JsonProperty]
		public bool RandomizePitch = true;

		[JsonProperty]
		public float SoundVolume = 1f;

		[JsonProperty]
		public float SoundChance = 1f;

		[JsonProperty]
		public AssetLocation? FinishSound;

		[JsonProperty]
		public int[] EntityLightLevels = new int[2] { 0, 32 };

		[JsonProperty]
		public EnumLightLevelType EntityLightLevelType = (EnumLightLevelType)3;

		[JsonProperty]
		private float[][]? duringDayTimeFramesHours = Array.Empty<float[]>();

		[JsonProperty]
		public float DayTimeFrameInaccuracy = 3f;

		[JsonProperty]
		public bool StopIfOutOfDayTimeFrames;

		[JsonProperty]
		public float[]? TemperatureRange;

		[JsonProperty]
		public float ExecutionChance = 0.1f;

		[JsonProperty]
		public bool StopOnHurt;

		[JsonProperty]
		public int MinDurationMs;

		[JsonProperty]
		public int MaxDurationMs;

		[JsonProperty]
		public int RecentlyAttackedTimeoutMs = 30000;

		[JsonProperty]
		public bool DontExecuteIfRecentlyAttacked;

		public EntityTagArray TagsAppliedToEntity = EntityTagArray.Empty;

		public AnimationMetaData? AnimationMeta;

		public DayTimeFrame[] DuringDayTimeFrames = Array.Empty<DayTimeFrame>();

		protected const int maxLightLevel = 32;

		private bool initialized;

		public float PriorityForCancel => priorityForCancel ?? Priority;

		public bool Initialized => initialized;

		public virtual void Init(EntityAgent entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0118: Unknown result type (might be due to invalid IL or missing references)
			if (tagsAppliedToEntity != null)
			{
				TagsAppliedToEntity = ((Entity)entity).Api.TagRegistry.EntityTagsToTagArray(tagsAppliedToEntity);
			}
			if (duringDayTimeFramesHours != null)
			{
				DuringDayTimeFrames = duringDayTimeFramesHours.Select((float[] frame) => new DayTimeFrame(frame[0], frame[1])).ToArray();
			}
			duringDayTimeFramesHours = null;
			tagsAppliedToEntity = null;
			if (animation != "")
			{
				string animationCode = animation.ToLowerInvariant();
				AnimationMetaData val = Array.Find(((Entity)entity).Properties.Client.Animations, (AnimationMetaData a) => a.Code == animationCode);
				if (val != null)
				{
					if (animationSpeed.HasValue)
					{
						AnimationMeta = val.Clone();
						AnimationMeta.AnimationSpeed = animationSpeed.Value;
					}
					else
					{
						AnimationMeta = val;
					}
				}
				else
				{
					AnimationMeta = new AnimationMetaData
					{
						Code = animationCode,
						Animation = animationCode,
						AnimationSpeed = (animationSpeed ?? 1f)
					}.Init();
					AnimationMeta.EaseInSpeed = 1f;
					AnimationMeta.EaseOutSpeed = 1f;
				}
			}
			if (Sound != (AssetLocation)null)
			{
				Sound = Sound.WithPathPrefixOnce("sounds/");
			}
			if (FinishSound != (AssetLocation)null)
			{
				FinishSound = FinishSound.WithPathPrefixOnce("sounds/");
			}
			initialized = true;
		}

		public virtual void Init(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
		{
			Init(entity);
			initialized = true;
		}
	}
	public abstract class AiTaskBaseR : IAiTask
	{
		protected AiTaskBaseConfig baseConfig;

		[ThreadStatic]
		private static Random? randThreadStatic;

		protected readonly EntityAgent entity;

		protected readonly IWorldAccessor world;

		protected WaypointsTraverser pathTraverser;

		protected EntityBehaviorEmotionStates? emotionStatesBehavior;

		protected EntityBehaviorTaskAI taskAiBehavior;

		protected EntityPartitioning partitionUtil;

		protected const int maxLightLevel = 32;

		protected const int standardHoursPerDay = 24;

		protected bool stopTask;

		protected bool active;

		protected long durationUntilMs;

		protected float currentDayTimeInaccuracy;

		protected Entity? attackedByEntity;

		protected long attackedByEntityMs;

		protected long lastSoundTotalMs;

		protected long cooldownUntilMs;

		protected double cooldownUntilTotalHours;

		protected long executionStartTimeMs;

		protected EntityTagArray tagsAppliedOnStart;

		public virtual string Id => Config.Id;

		public virtual int Slot => Config.Slot;

		public virtual float Priority => Config.Priority;

		public virtual float PriorityForCancel => Config.PriorityForCancel;

		public string ProfilerName { get; set; } = "";

		public string[] WhenInEmotionState => Config.WhenInEmotionState;

		public Entity? AttackedByEntity => attackedByEntity;

		private AiTaskBaseConfig Config => baseConfig;

		protected Random Rand => randThreadStatic ?? (randThreadStatic = new Random());

		protected bool RecentlyAttacked => ((Entity)entity).World.ElapsedMilliseconds - attackedByEntityMs < Config.RecentlyAttackedTimeoutMs;

		protected AiTaskBaseR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
		{
			if (randThreadStatic == null)
			{
				randThreadStatic = new Random((int)((Entity)entity).EntityId);
			}
			this.entity = entity;
			world = ((Entity)entity).World;
			pathTraverser = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().PathTraverser ?? throw new ArgumentException($"PathTraverser should not be null, possible error on EntityBehaviorTaskAI initialization for entity: {((RegistryObject)entity).Code}.");
			emotionStatesBehavior = ((Entity)entity).GetBehavior<EntityBehaviorEmotionStates>();
			taskAiBehavior = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>() ?? throw new ArgumentException($"Entity '{((RegistryObject)entity).Code}' does not have EntityBehaviorTaskAI.");
			partitionUtil = ((Entity)entity).Api.ModLoader.GetModSystem<EntityPartitioning>(true) ?? throw new ArgumentException("EntityPartitioning mod system is not found");
			baseConfig = LoadConfig<AiTaskBaseConfig>(entity, taskConfig, aiConfig);
			int initialMinCooldownMs = Config.InitialMinCooldownMs;
			int initialMaxCooldownMs = Config.InitialMaxCooldownMs;
			if (Config.TemperatureRange != null && Config.TemperatureRange.Length != 2)
			{
				((Entity)entity).Api.Logger.Error($"Invalid 'temperatureRange' value in AI task '{Config.Code}' for entity '{((RegistryObject)entity).Code}'");
				throw new ArgumentException($"Invalid 'temperatureRange' value in AI task '{Config.Code}' for entity '{((RegistryObject)entity).Code}'");
			}
			cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + initialMinCooldownMs + ((Entity)entity).World.Rand.Next(initialMaxCooldownMs - initialMinCooldownMs);
			attackedByEntityMs = -Config.RecentlyAttackedTimeoutMs;
		}

		protected AiTaskBaseR(EntityAgent entity)
		{
			if (randThreadStatic == null)
			{
				randThreadStatic = new Random((int)((Entity)entity).EntityId);
			}
			this.entity = entity;
			world = ((Entity)entity).World;
			pathTraverser = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().PathTraverser ?? throw new ArgumentException($"PathTraverser should not be null, possible error on EntityBehaviorTaskAI initialization for entity: {((RegistryObject)entity).Code}.");
			emotionStatesBehavior = ((Entity)entity).GetBehavior<EntityBehaviorEmotionStates>();
			taskAiBehavior = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>() ?? throw new ArgumentException($"Entity '{((RegistryObject)entity).Code}' does not have EntityBehaviorTaskAI.");
			partitionUtil = ((Entity)entity).Api.ModLoader.GetModSystem<EntityPartitioning>(true) ?? throw new ArgumentException("EntityPartitioning mod system is not found");
			AiTaskRegistry.TaskCodes.TryGetValue(GetType(), out string value);
			baseConfig = new AiTaskBaseConfig();
			baseConfig.Code = ((baseConfig.Code == "") ? (value ?? "") : baseConfig.Code);
			baseConfig.Init(entity);
		}

		public virtual void AfterInitialize()
		{
			if (!baseConfig.Initialized)
			{
				throw new InvalidOperationException($"Config was not initialized for task '{Config.Code}' and entity '{((RegistryObject)entity).Code}'. Have you forgot to call 'base.Init()' method in 'Init()'?");
			}
		}

		public abstract bool ShouldExecute();

		public virtual void StartExecute()
		{
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
			if (Config.AnimationMeta != null)
			{
				((Entity)entity).AnimManager.StartAnimation(Config.AnimationMeta);
			}
			if (Config.Sound != (AssetLocation)null && ((Entity)entity).World.Rand.NextDouble() <= (double)Config.SoundChance)
			{
				if (Config.SoundStartMs > 0)
				{
					((Entity)entity).World.RegisterCallback((Action<float>)delegate
					{
						((Entity)entity).World.PlaySoundAt(Config.Sound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
						lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
					}, Config.SoundStartMs);
				}
				else
				{
					((Entity)entity).World.PlaySoundAt(Config.Sound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
					lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
				}
			}
			if (Config.MaxDurationMs <= 0)
			{
				durationUntilMs = 0L;
			}
			else
			{
				durationUntilMs = ((Entity)entity).World.ElapsedMilliseconds + Config.MinDurationMs + ((Entity)entity).World.Rand.Next(Config.MaxDurationMs - Config.MinDurationMs);
			}
			executionStartTimeMs = ((Entity)entity).World.ElapsedMilliseconds;
			tagsAppliedOnStart = ~((Entity)entity).Tags & Config.TagsAppliedToEntity;
			if (tagsAppliedOnStart != EntityTagArray.Empty)
			{
				EntityAgent obj = entity;
				((Entity)obj).Tags = ((Entity)obj).Tags | tagsAppliedOnStart;
				((Entity)entity).MarkTagsDirty();
			}
			active = true;
			stopTask = false;
		}

		public virtual bool ContinueExecute(float dt)
		{
			return ContinueExecuteChecks(dt);
		}

		public virtual void FinishExecute(bool cancelled)
		{
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0191: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01af: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + Config.MinCooldownMs + ((Entity)entity).World.Rand.Next(Config.MaxCooldownMs - Config.MinCooldownMs);
			cooldownUntilTotalHours = ((Entity)entity).World.Calendar.TotalHours + Config.MinCooldownHours + ((Entity)entity).World.Rand.NextDouble() * (Config.MaxCooldownHours - Config.MinCooldownHours);
			if (Config.AnimationMeta != null && Config.AnimationMeta.Code != "attack" && Config.AnimationMeta.Code != "idle")
			{
				((Entity)entity).AnimManager.StopAnimation(Config.AnimationMeta.Code);
			}
			if (Config.FinishSound != (AssetLocation)null)
			{
				((Entity)entity).World.PlaySoundAt(Config.FinishSound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
			}
			if (tagsAppliedOnStart != EntityTagArray.Empty)
			{
				EntityAgent obj = entity;
				((Entity)obj).Tags = ((Entity)obj).Tags & ~tagsAppliedOnStart;
				((Entity)entity).MarkTagsDirty();
			}
			active = false;
		}

		public virtual void OnStateChanged(EnumEntityState beforeState)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			if ((int)((Entity)entity).State == 0)
			{
				IWorldAccessor val = ((Entity)entity).World;
				cooldownUntilMs = val.ElapsedMilliseconds + Config.MinCooldownMs + val.Rand.Next(Config.MaxCooldownMs - Config.MinCooldownMs);
			}
		}

		public virtual bool Notify(string key, object data)
		{
			return false;
		}

		public virtual void OnEntityLoaded()
		{
		}

		public virtual void OnEntitySpawn()
		{
		}

		public virtual void OnEntityDespawn(EntityDespawnData reason)
		{
		}

		public virtual void OnEntityHurt(DamageSource source, float damage)
		{
			if (Config.StopOnHurt)
			{
				stopTask = true;
			}
			attackedByEntity = source.GetCauseEntity();
			if (attackedByEntity != null)
			{
				attackedByEntityMs = ((Entity)entity).World.ElapsedMilliseconds;
			}
		}

		public virtual void OnNoPath(Vec3d target)
		{
		}

		public virtual bool CanContinueExecute()
		{
			return true;
		}

		protected static TConfig LoadConfig<TConfig>(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig) where TConfig : AiTaskBaseConfig
		{
			TConfig val;
			try
			{
				val = taskConfig.AsObject<TConfig>((TConfig)null);
				if (val == null)
				{
					JsonObject obj = taskConfig["code"];
					string value = ((obj != null) ? obj.AsString("") : null) ?? "";
					string text = $"Failed to parse task config '{value} ({typeof(TConfig)})' for entity '{((RegistryObject)entity).Code}'.";
					((Entity)entity).Api.Logger.Error(text);
					throw new ArgumentNullException(text);
				}
			}
			catch (Exception value2)
			{
				JsonObject obj2 = taskConfig["code"];
				string value3 = ((obj2 != null) ? obj2.AsString("") : null) ?? "";
				((Entity)entity).Api.Logger.Error($"Failed to parse task config '{value3} ({typeof(TConfig)})' for entity '{((RegistryObject)entity).Code}'. Exception:\n{value2}\n");
				throw;
			}
			try
			{
				val.Init(entity, taskConfig, aiConfig);
			}
			catch (Exception value4)
			{
				JsonObject obj3 = taskConfig["code"];
				string value5 = ((obj3 != null) ? obj3.AsString("") : null) ?? "";
				((Entity)entity).Api.Logger.Error($"Failed initiate config for task '{value5} ({typeof(TConfig)})' for entity '{((RegistryObject)entity).Code}'. Exception:\n{value4}\n");
				throw;
			}
			if (!val.Initialized)
			{
				string text2 = $"Config was not initialized for task '{val.Code}' and entity '{((RegistryObject)entity).Code}'. Have you forgot to call 'base.Init()' method in '{typeof(TConfig)}.Init()'?";
				((Entity)entity).Api.Logger.Error(text2);
				throw new InvalidOperationException(text2);
			}
			return val;
		}

		protected TConfig GetConfig<TConfig>() where TConfig : AiTaskBaseConfig
		{
			return (baseConfig as TConfig) ?? throw new InvalidOperationException($"Wrong type of config '{baseConfig.GetType()}', should be '{typeof(TConfig)}' or it subclass.");
		}

		protected virtual bool PreconditionsSatisficed()
		{
			if (!CheckExecutionChance())
			{
				return false;
			}
			if (!CheckCooldowns())
			{
				return false;
			}
			if (!CheckEntityState())
			{
				return false;
			}
			if (!CheckEmotionStates())
			{
				return false;
			}
			if (!CheckEntityLightLevel())
			{
				return false;
			}
			currentDayTimeInaccuracy = (float)((Entity)entity).World.Rand.NextDouble() * Config.DayTimeFrameInaccuracy - Config.DayTimeFrameInaccuracy / 2f;
			if (!CheckDayTimeFrames())
			{
				return false;
			}
			if (!CheckTemperature())
			{
				return false;
			}
			if (Config.DontExecuteIfRecentlyAttacked && RecentlyAttacked)
			{
				return false;
			}
			return true;
		}

		protected virtual bool IsInEmotionState(params string[] emotionStates)
		{
			if (emotionStatesBehavior == null)
			{
				return false;
			}
			if (emotionStates.Length == 0)
			{
				return true;
			}
			for (int i = 0; i < emotionStates.Length; i++)
			{
				if (emotionStatesBehavior.IsInEmotionState(emotionStates[i]))
				{
					return true;
				}
			}
			return false;
		}

		protected virtual bool DurationExceeded()
		{
			if (durationUntilMs > 0)
			{
				return ((Entity)entity).World.ElapsedMilliseconds > durationUntilMs;
			}
			return false;
		}

		protected virtual bool CheckEntityLightLevel()
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			if (Config.EntityLightLevels[0] == 0 && Config.EntityLightLevels[1] == 32)
			{
				return true;
			}
			int lightLevel = ((Entity)entity).World.BlockAccessor.GetLightLevel((int)((Entity)entity).Pos.X, (int)((Entity)entity).Pos.InternalY, (int)((Entity)entity).Pos.Z, Config.EntityLightLevelType);
			if (Config.EntityLightLevels[0] <= lightLevel)
			{
				return lightLevel <= Config.EntityLightLevels[1];
			}
			return false;
		}

		protected virtual bool CheckDayTimeFrames()
		{
			if (Config.DuringDayTimeFrames.Length == 0)
			{
				return true;
			}
			double hourOfDay = ((Entity)entity).World.Calendar.HourOfDay / ((Entity)entity).World.Calendar.HoursPerDay * 24f + currentDayTimeInaccuracy;
			DayTimeFrame[] duringDayTimeFrames = Config.DuringDayTimeFrames;
			foreach (DayTimeFrame dayTimeFrame in duringDayTimeFrames)
			{
				if (dayTimeFrame.Matches(hourOfDay))
				{
					return true;
				}
			}
			return false;
		}

		protected virtual bool CheckTemperature()
		{
			if (Config.TemperatureRange == null)
			{
				return true;
			}
			float temperature = ((Entity)entity).World.BlockAccessor.GetClimateAt(((Entity)entity).Pos.AsBlockPos, (EnumGetClimateMode)3, ((Entity)entity).World.Calendar.TotalDays).Temperature;
			if (Config.TemperatureRange[0] <= temperature)
			{
				return temperature <= Config.TemperatureRange[1];
			}
			return false;
		}

		protected virtual bool CheckCooldowns()
		{
			if (cooldownUntilMs <= ((Entity)entity).World.ElapsedMilliseconds)
			{
				return cooldownUntilTotalHours <= ((Entity)entity).World.Calendar.TotalHours;
			}
			return false;
		}

		protected virtual bool CheckEntityState()
		{
			if (Config.WhenSwimming.HasValue && Config.WhenSwimming != ((Entity)entity).Swimming)
			{
				return false;
			}
			if (Config.WhenFeetInLiquid.HasValue && Config.WhenFeetInLiquid != ((Entity)entity).FeetInLiquid)
			{
				return false;
			}
			return true;
		}

		protected virtual bool CheckEmotionStates()
		{
			if (Config.WhenInEmotionState.Length != 0 && !IsInEmotionState(Config.WhenInEmotionState))
			{
				return false;
			}
			if (Config.WhenNotInEmotionState.Length != 0 && IsInEmotionState(Config.WhenNotInEmotionState))
			{
				return false;
			}
			return true;
		}

		protected virtual bool CheckExecutionChance()
		{
			return Rand.NextDouble() <= (double)Config.ExecutionChance;
		}

		protected virtual bool ContinueExecuteChecks(float dt)
		{
			if (stopTask)
			{
				stopTask = false;
				return false;
			}
			if (DurationExceeded())
			{
				durationUntilMs = 0L;
				return false;
			}
			if (Config.Sound != (AssetLocation)null && Config.SoundRepeatMs > 0 && ((Entity)entity).World.ElapsedMilliseconds > lastSoundTotalMs + Config.SoundRepeatMs)
			{
				((Entity)entity).World.PlaySoundAt(Config.Sound, ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
				lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			}
			if (Config.StopIfOutOfDayTimeFrames && !CheckDayTimeFrames())
			{
				return false;
			}
			return true;
		}

		protected virtual int GetOwnGeneration()
		{
			int num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetInt("generation", 0);
			JsonObject attributes = ((Entity)entity).Properties.Attributes;
			if (attributes != null && attributes.IsTrue("tamed"))
			{
				num += 10;
			}
			return num;
		}
	}
	public class DayTimeFrameJson
	{
		public double FromHour;

		public double ToHour;

		public DayTimeFrame ToStruct()
		{
			return new DayTimeFrame(FromHour, ToHour);
		}
	}
	public readonly struct DayTimeFrame
	{
		public readonly double FromHour;

		public readonly double ToHour;

		public DayTimeFrame(double fromHour, double toHour)
		{
			FromHour = fromHour;
			ToHour = toHour;
		}

		public bool Matches(double hourOfDay)
		{
			if (FromHour <= hourOfDay)
			{
				return ToHour >= hourOfDay;
			}
			return false;
		}
	}
	public abstract class PathTraverserBase
	{
		protected EntityAgent entity;

		protected Vec3d target;

		public Action OnGoalReached;

		public Action OnStuck;

		protected int stuckCounter;

		public bool Active;

		protected float movingSpeed;

		public float curTurnRadPerSec;

		public float TargetDistance;

		public virtual Vec3d CurrentTarget => target;

		public virtual bool Ready => true;

		public PathTraverserBase(EntityAgent entity)
		{
			this.entity = entity;
		}

		public bool NavigateTo(Vec3d target, float movingSpeed, Action OnGoalReached, Action OnStuck, Action onNoPath = null, int mhdistanceTolerance = 0, EnumAICreatureType? creatureType = null)
		{
			return NavigateTo(target, movingSpeed, 0.12f, OnGoalReached, OnStuck, onNoPath, giveUpWhenNoPath: false, 10000, mhdistanceTolerance, creatureType);
		}

		public virtual bool NavigateTo(Vec3d target, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck, Action onNoPath = null, bool giveUpWhenNoPath = false, int searchDepth = 10000, int mhdistanceTolerance = 0, EnumAICreatureType? creatureType = null)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			return WalkTowards(target, movingSpeed, targetDistance, OnGoalReached, OnStuck, creatureType.GetValueOrDefault());
		}

		public virtual bool NavigateTo_Async(Vec3d target, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck, Action OnNoPath = null, int searchDepth = 10000, int mhdistanceTolerance = 0, EnumAICreatureType? creatureType = null)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			return WalkTowards(target, movingSpeed, targetDistance, OnGoalReached, OnStuck, creatureType.GetValueOrDefault());
		}

		public virtual bool WalkTowards(Vec3d target, float movingSpeed, float targetDistance, Action OnGoalReached, Action OnStuck, EnumAICreatureType creatureType = (EnumAICreatureType)0)
		{
			stuckCounter = 0;
			this.OnGoalReached = OnGoalReached;
			this.OnStuck = OnStuck;
			this.movingSpeed = movingSpeed;
			TargetDistance = targetDistance;
			this.target = target;
			Active = true;
			return BeginGo();
		}

		public virtual void OnGameTick(float dt)
		{
		}

		protected abstract bool BeginGo();

		public abstract void Stop();

		public virtual void Retarget()
		{
		}
	}
}
namespace Vintagestory.ServerMods
{
	public class Core : ModSystem
	{
		private ICoreAPI api;

		private ICoreClientAPI capi;

		private IShaderProgram prog;

		public override double ExecuteOrder()
		{
			return 0.0;
		}

		public override bool ShouldLoad(EnumAppSide side)
		{
			return true;
		}

		public override void StartPre(ICoreAPI api)
		{
			GameVersion.EnsureEqualVersionOrKillExecutable(api, FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion, "1.21.5", "VSEssentials");
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			api.RegisterEntityRendererClass("Item", typeof(EntityItemRenderer));
			api.RegisterEntityRendererClass("Dummy", typeof(EntityRendererInvisible));
			api.RegisterEntityRendererClass("BlockFalling", typeof(EntityBlockFallingRenderer));
			api.RegisterEntityRendererClass("Shape", typeof(EntityShapeRenderer));
			api.RegisterEntityRendererClass("PlayerShape", typeof(EntityPlayerShapeRenderer));
			api.Event.BlockTexturesLoaded += Event_BlockTexturesLoaded;
			capi = api;
		}

		private void Event_BlockTexturesLoaded()
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Expected O, but got Unknown
			capi.Event.ReloadShader += new ActionBoolReturn(LoadShader);
			LoadShader();
		}

		public bool LoadShader()
		{
			prog = capi.Shader.NewShaderProgram();
			prog.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			prog.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			capi.Shader.RegisterFileShaderProgram("instanced", prog);
			return prog.Compile();
		}

		public override void Start(ICoreAPI api)
		{
			this.api = api;
			RegisterDefaultBlocks();
			RegisterDefaultBlockBehaviors();
			RegisterDefaultCropBehaviors();
			RegisterDefaultItems();
			RegisterDefaultEntities();
			RegisterDefaultEntityBehaviors();
			RegisterDefaultBlockEntities();
			((ICoreAPICommon)api).RegisterCollectibleBehaviorClass("AnimationAuthoritative", typeof(CollectibleBehaviorAnimationAuthoritative));
			((ICoreAPICommon)api).RegisterCollectibleBehaviorClass("HeldBag", typeof(CollectibleBehaviorHeldBag));
		}

		public override void AssetsFinalize(ICoreAPI api)
		{
			EntityBehaviorEntityStateTags.GetTagsIds(api.TagRegistry);
		}

		private void RegisterDefaultBlocks()
		{
			((ICoreAPICommon)api).RegisterBlockClass("BlockMultiblock", typeof(BlockMultiblock));
		}

		private void RegisterDefaultBlockBehaviors()
		{
			((ICoreAPICommon)api).RegisterBlockBehaviorClass("Decor", typeof(BlockBehaviorDecor));
			((ICoreAPICommon)api).RegisterBlockBehaviorClass("Multiblock", typeof(BlockBehaviorMultiblock));
			((ICoreAPICommon)api).RegisterBlockBehaviorClass("TransformBreak", typeof(BlockBehaviorTransformBreak));
		}

		private void RegisterDefaultBlockEntities()
		{
			((ICoreAPICommon)api).RegisterBlockEntityClass("ParticleEmitter", typeof(BlockEntityParticleEmitter));
			((ICoreAPICommon)api).RegisterBlockEntityClass("Transient", typeof(BlockEntityTransient));
			((ICoreAPICommon)api).RegisterBlockEntityClass("Generic", typeof(BlockEntityGeneric));
		}

		private void RegisterDefaultCropBehaviors()
		{
		}

		private void RegisterDefaultItems()
		{
		}

		private void RegisterDefaultEntities()
		{
			((ICoreAPICommon)api).RegisterEntity("EntityBlockfalling", typeof(EntityBlockFalling));
		}

		private void RegisterDefaultEntityBehaviors()
		{
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("collectitems", typeof(EntityBehaviorCollectEntities));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("health", typeof(EntityBehaviorHealth));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("hunger", typeof(EntityBehaviorHunger));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("drunktyping", typeof(EntityBehaviorDrunkTyping));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("breathe", typeof(EntityBehaviorBreathe));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("playerphysics", typeof(EntityBehaviorPlayerPhysics));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("controlledphysics", typeof(EntityBehaviorControlledPhysics));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("taskai", typeof(EntityBehaviorTaskAI));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("goalai", typeof(EntityBehaviorGoalAI));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("interpolateposition", typeof(EntityBehaviorInterpolatePosition));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("despawn", typeof(EntityBehaviorDespawn));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("grow", typeof(EntityBehaviorGrow));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("multiply", typeof(EntityBehaviorMultiply));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("multiplybase", typeof(EntityBehaviorMultiplyBase));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("gait", typeof(EntityBehaviorGait));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("aimingaccuracy", typeof(EntityBehaviorAimingAccuracy));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("emotionstates", typeof(EntityBehaviorEmotionStates));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("repulseagents", typeof(EntityBehaviorRepulseAgents));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("ellipsoidalrepulseagents", typeof(EntityBehaviorEllipsoidalRepulseAgents));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("tiredness", typeof(EntityBehaviorTiredness));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("nametag", typeof(EntityBehaviorNameTag));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("placeblock", typeof(EntityBehaviorPlaceBlock));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("deaddecay", typeof(EntityBehaviorDeadDecay));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("floatupwhenstuck", typeof(EntityBehaviorFloatUpWhenStuck));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("harvestable", typeof(EntityBehaviorHarvestable));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("reviveondeath", typeof(EntityBehaviorReviveOnDeath));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("mouthinventory", typeof(EntityBehaviorMouthInventory));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("openablecontainer", typeof(EntityBehaviorOpenableContainer));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("playerinventory", typeof(EntityBehaviorPlayerInventory));
			((ICoreAPICommon)api).RegisterEntityBehaviorClass("entitystatetags", typeof(EntityBehaviorEntityStateTags));
		}
	}
	public class ModCompatiblityUtil : ModSystem
	{
		public static AssetCategory compatibility;

		public static string[] partiallyWorkingCategories = new string[2] { "shapes", "textures" };

		public static List<string> LoadedModIds { get; private set; } = new List<string>();

		public override double ExecuteOrder()
		{
			return 0.04;
		}

		public override void StartPre(ICoreAPI api)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Expected O, but got Unknown
			compatibility = new AssetCategory("compatibility", true, (EnumAppSide)3);
		}

		public override void AssetsLoaded(ICoreAPI api)
		{
			LoadedModIds = api.ModLoader.Mods.Select((Mod m) => m.Info.ModID).ToList();
			RemapFromCompatbilityFolder(api);
		}

		private void RemapFromCompatbilityFolder(ICoreAPI api)
		{
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Expected O, but got Unknown
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			int num2 = 0;
			foreach (Mod mod in api.ModLoader.Mods)
			{
				string text = "compatibility/" + mod.Info.ModID + "/";
				foreach (IAsset item in api.Assets.GetManyInCategory("compatibility", mod.Info.ModID + "/", (string)null, true))
				{
					AssetLocation val = new AssetLocation(mod.Info.ModID, item.Location.Path.Remove(0, text.Length));
					if (api.Assets.AllAssets.ContainsKey(val))
					{
						num2++;
					}
					else
					{
						num++;
					}
					if ((val.Category.SideType & api.Side) != 0)
					{
						api.Assets.Add(val, item);
					}
				}
			}
			api.World.Logger.Notification("Compatibility lib: {0} assets added, {1} assets replaced.", new object[2] { num, num2 });
		}
	}
	public class JsonExport : ModSystem
	{
		private ICoreServerAPI api;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Expected O, but got Unknown
			((ModSystem)this).StartServerSide(api);
			((ICoreAPI)api).ChatCommands.GetOrCreate("dev").BeginSubCommand("jsonexport").WithDescription("Export items and blocks as json files")
				.RequiresPrivilege(Privilege.controlserver)
				.HandleWith(new OnCommandDelegate(CmdExport))
				.EndSubCommand();
			this.api = api;
		}

		private TextCommandResult CmdExport(TextCommandCallingArgs textCommandCallingArgs)
		{
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("[");
			int num = 0;
			for (int i = 0; i < ((IWorldAccessor)api.World).Blocks.Count; i++)
			{
				Block val = ((IWorldAccessor)api.World).Blocks[i];
				if (val != null && !(((RegistryObject)val).Code == (AssetLocation)null))
				{
					if (num > 0)
					{
						stringBuilder.Append(",");
					}
					stringBuilder.Append("{");
					stringBuilder.Append($"\"name\": \"{new ItemStack(val, 1).GetName()}\", ");
					stringBuilder.Append($"\"code\": \"{((RegistryObject)val).Code}\", ");
					stringBuilder.Append($"\"material\": \"{val.BlockMaterial}\", ");
					stringBuilder.Append($"\"shape\": \"{val.Shape.Base.Path}\", ");
					stringBuilder.Append($"\"tool\": \"{((CollectibleObject)val).Tool}\"");
					stringBuilder.Append("}");
					num++;
				}
			}
			stringBuilder.Append("]");
			File.WriteAllText("blocks.json", stringBuilder.ToString());
			stringBuilder = new StringBuilder();
			stringBuilder.Append("[");
			num = 0;
			for (int j = 0; j < ((IWorldAccessor)api.World).Items.Count; j++)
			{
				Item val2 = ((IWorldAccessor)api.World).Items[j];
				if (val2 != null && !(((RegistryObject)val2).Code == (AssetLocation)null))
				{
					if (num > 0)
					{
						stringBuilder.Append(",");
					}
					stringBuilder.Append("{");
					stringBuilder.Append($"\"name\": \"{new ItemStack(val2, 1).GetName()}\", ");
					stringBuilder.Append($"\"code\": \"{((RegistryObject)val2).Code}\", ");
					StringBuilder stringBuilder2 = stringBuilder;
					CompositeShape shape = val2.Shape;
					object arg;
					if (shape == null)
					{
						arg = null;
					}
					else
					{
						AssetLocation obj = shape.Base;
						arg = ((obj != null) ? obj.Path : null);
					}
					stringBuilder2.Append($"\"shape\": \"{arg}\", ");
					stringBuilder.Append($"\"tool\": \"{((CollectibleObject)val2).Tool}\"");
					stringBuilder.Append("}");
					num++;
				}
			}
			stringBuilder.Append("]");
			File.WriteAllText("items.json", stringBuilder.ToString());
			return TextCommandResult.Success("All Blocks and Items written to block.json and item.json in " + AppDomain.CurrentDomain.BaseDirectory, (object)null);
		}
	}
	public class ModBasicBlocksLoader : ModSystem
	{
		private ICoreServerAPI api;

		public override bool ShouldLoad(EnumAppSide side)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)side == 1;
		}

		public override double ExecuteOrder()
		{
			return 0.1;
		}

		public override void Start(ICoreAPI manager)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Expected O, but got Unknown
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Expected O, but got Unknown
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Expected O, but got Unknown
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected O, but got Unknown
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Expected O, but got Unknown
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Expected O, but got Unknown
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Expected O, but got Unknown
			//IL_00c3: Expected O, but got Unknown
			//IL_00cd: Expected O, but got Unknown
			ICoreServerAPI val = (ICoreServerAPI)(object)((manager is ICoreServerAPI) ? manager : null);
			if (val != null)
			{
				api = val;
				Block val2 = new Block();
				((RegistryObject)val2).Code = new AssetLocation("mantle");
				val2.Textures = (IDictionary<string, CompositeTexture>)new FastSmallDictionary<string, CompositeTexture>("all", new CompositeTexture(new AssetLocation("block/mantle")));
				val2.DrawType = (EnumDrawType)10;
				((CollectibleObject)val2).MatterState = (EnumMatterState)2;
				val2.BlockMaterial = (EnumBlockMaterial)12;
				val2.Replaceable = 0;
				val2.Resistance = 31337f;
				val2.RequiredMiningTier = 196;
				val2.Sounds = new BlockSounds
				{
					Walk = new AssetLocation("sounds/walk/stone"),
					ByTool = new Dictionary<EnumTool, BlockSounds> { 
					{
						(EnumTool)1,
						new BlockSounds
						{
							Hit = new AssetLocation("sounds/block/rock-hit-pickaxe"),
							Break = new AssetLocation("sounds/block/rock-hit-pickaxe")
						}
					} }
				};
				((CollectibleObject)val2).CreativeInventoryTabs = new string[1] { "general" };
				Block val3 = val2;
				api.RegisterBlock(val3);
			}
		}
	}
	public class GridRecipeLoader : ModSystem
	{
		private ICoreServerAPI api;

		private bool classExclusiveRecipes = true;

		public override double ExecuteOrder()
		{
			return 1.0;
		}

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void AssetsLoaded(ICoreAPI api)
		{
			ICoreServerAPI val = (ICoreServerAPI)(object)((api is ICoreServerAPI) ? api : null);
			if (val != null)
			{
				this.api = val;
				classExclusiveRecipes = ((IWorldAccessor)val.World).Config.GetBool("classExclusiveRecipes", true);
				LoadGridRecipes();
			}
		}

		public void LoadGridRecipes()
		{
			Dictionary<AssetLocation, JToken> many = ((ICoreAPI)api).Assets.GetMany<JToken>(api.Server.Logger, "recipes/grid", (string)null);
			int num = 0;
			foreach (var (val3, val4) in many)
			{
				if (val4 is JObject)
				{
					LoadRecipe(val3, JsonUtil.ToObject<GridRecipe>(val4, val3.Domain, (JsonSerializerSettings)null));
					num++;
				}
				if (!(val4 is JArray))
				{
					continue;
				}
				foreach (JToken item in (JArray)((val4 is JArray) ? val4 : null))
				{
					LoadRecipe(val3, JsonUtil.ToObject<GridRecipe>(item, val3.Domain, (JsonSerializerSettings)null));
					num++;
				}
			}
			((IWorldAccessor)api.World).Logger.Event($"{num} crafting recipes loaded from {many.Count} files");
			((IWorldAccessor)api.World).Logger.StoryEvent(Lang.Get("Grand inventions...", Array.Empty<object>()));
		}

		public void LoadRecipe(AssetLocation assetLocation, GridRecipe recipe)
		{
			if (!recipe.Enabled)
			{
				return;
			}
			if (!classExclusiveRecipes)
			{
				recipe.RequiresTrait = null;
			}
			if (recipe.Name == (AssetLocation)null)
			{
				recipe.Name = assetLocation;
			}
			Dictionary<string, string[]> nameToCodeMapping = recipe.GetNameToCodeMapping((IWorldAccessor)(object)api.World);
			if (nameToCodeMapping.Count <= 0)
			{
				if (recipe.ResolveIngredients((IWorldAccessor)(object)api.World))
				{
					api.RegisterCraftingRecipe(recipe);
				}
				return;
			}
			List<GridRecipe> list = new List<GridRecipe>();
			int num = 1;
			string key;
			string[] value;
			foreach (KeyValuePair<string, string[]> item in nameToCodeMapping)
			{
				item.Deconstruct(out key, out value);
				string[] array = value;
				num *= array.Length;
			}
			bool flag = true;
			int num2 = 1;
			foreach (KeyValuePair<string, string[]> item2 in nameToCodeMapping)
			{
				item2.Deconstruct(out key, out value);
				string text = key;
				string[] array2 = value;
				if (array2.Length == 0)
				{
					continue;
				}
				for (int i = 0; i < num; i++)
				{
					string text2 = array2[i / num2 % array2.Length];
					GridRecipe val;
					if (flag)
					{
						val = recipe.Clone();
						list.Add(val);
					}
					else
					{
						val = list[i];
					}
					foreach (CraftingRecipeIngredient value2 in val.Ingredients.Values)
					{
						if (value2.IsBasicWildCard)
						{
							if (value2.Name == text)
							{
								value2.FillPlaceHolder(text, text2);
								value2.Code.Path = value2.Code.Path.Replace("*", text2);
								value2.IsBasicWildCard = false;
							}
						}
						else if (value2.IsAdvancedWildCard)
						{
							value2.FillPlaceHolder(text, text2);
							value2.IsAdvancedWildCard = GridRecipe.IsAdvancedWildcard(AssetLocation.op_Implicit(value2.Code));
						}
						if (value2.ReturnedStack?.Code != (AssetLocation)null)
						{
							value2.ReturnedStack.Code.Path = value2.ReturnedStack.Code.Path.Replace("{" + text + "}", text2);
						}
					}
					val.Output.FillPlaceHolder(text, text2);
				}
				num2 *= array2.Length;
				flag = false;
			}
			foreach (GridRecipe item3 in list)
			{
				if (item3.ResolveIngredients((IWorldAccessor)(object)api.World))
				{
					api.RegisterCraftingRecipe(item3);
				}
			}
		}
	}
	public class LoadColorMaps : ModSystem
	{
		private ICoreAPI api;

		public override double ExecuteOrder()
		{
			return 0.3;
		}

		public override void Start(ICoreAPI api)
		{
			this.api = api;
		}

		public override void AssetsLoaded(ICoreAPI api)
		{
			if (api is ICoreClientAPI)
			{
				loadColorMaps();
			}
		}

		private void loadColorMaps()
		{
			try
			{
				IAsset val = api.Assets.TryGet(AssetLocation.op_Implicit("config/colormaps.json"), true);
				if (val != null)
				{
					ColorMap[] array = val.ToObject<ColorMap[]>((JsonSerializerSettings)null);
					foreach (ColorMap val2 in array)
					{
						((ICoreAPICommon)api).RegisterColorMap(val2);
					}
				}
			}
			catch (Exception ex)
			{
				api.World.Logger.Error("Failed loading config/colormap.json. Will skip");
				api.World.Logger.Error(ex);
			}
		}
	}
	[DocumentAsJson]
	public class RegistryObjectVariantGroup
	{
		[DocumentAsJson]
		public AssetLocation LoadFromProperties;

		[DocumentAsJson]
		public AssetLocation[] LoadFromPropertiesCombine;

		[DocumentAsJson]
		public string Code;

		[DocumentAsJson]
		public string[] States;

		[DocumentAsJson]
		public EnumCombination Combine = (EnumCombination)1;

		[DocumentAsJson]
		public string OnVariant;

		public string IsValue;
	}
}
namespace Vintagestory.ServerMods.NoObf
{
	public class InerhitableRotatableCube
	{
		public float? X1;

		public float? Y1;

		public float? Z1;

		public float? X2;

		public float? Y2;

		public float? Z2;

		public float RotateX;

		public float RotateY;

		public float RotateZ;

		public Cuboidf InheritedCopy(Cuboidf parent)
		{
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Expected O, but got Unknown
			return new Cuboidf((!X1.HasValue) ? parent.X1 : X1.Value, (!Y1.HasValue) ? parent.Y1 : Y1.Value, (!Z1.HasValue) ? parent.Z1 : Z1.Value, (!X2.HasValue) ? parent.X2 : X2.Value, (!Y2.HasValue) ? parent.Y2 : Y2.Value, (!Z2.HasValue) ? parent.Z2 : Z2.Value).RotatedCopy(RotateX, RotateY, RotateZ, new Vec3d(0.5, 0.5, 0.5));
		}
	}
	[DocumentAsJson]
	public class BlockCropPropertiesType
	{
		[DocumentAsJson]
		public EnumSoilNutrient RequiredNutrient;

		[DocumentAsJson]
		public float NutrientConsumption;

		[DocumentAsJson]
		public int GrowthStages;

		[DocumentAsJson]
		public float TotalGrowthDays;

		[DocumentAsJson]
		public float TotalGrowthMonths;

		[DocumentAsJson]
		public bool MultipleHarvests;

		[DocumentAsJson]
		public int HarvestGrowthStageLoss;

		[DocumentAsJson]
		public float ColdDamageBelow = -5f;

		[DocumentAsJson]
		public float DamageGrowthStuntMul = 0.5f;

		[DocumentAsJson]
		public float ColdDamageRipeMul = 0.5f;

		[DocumentAsJson]
		public float HeatDamageAbove = 40f;

		[DocumentAsJson]
		public CropBehaviorType[] Behaviors;
	}
	[DocumentAsJson]
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class BlockType : CollectibleType
	{
		public static Cuboidf DefaultCollisionBox = new Cuboidf(0f, 0f, 0f, 1f, 1f, 1f);

		public static RotatableCube DefaultCollisionBoxR = new RotatableCube(0f, 0f, 0f, 1f, 1f, 1f);

		[JsonProperty]
		public string EntityClass;

		[JsonProperty]
		public BlockEntityBehaviorType[] EntityBehaviors = Array.Empty<BlockEntityBehaviorType>();

		[JsonProperty]
		public EnumDrawType DrawType = (EnumDrawType)8;

		[JsonProperty]
		public EnumRandomizeAxes RandomizeAxes;

		[JsonProperty]
		public bool RandomDrawOffset;

		[JsonProperty]
		public bool RandomizeRotations;

		[JsonProperty]
		public float RandomSizeAdjust;

		[JsonProperty]
		public EnumChunkRenderPass RenderPass;

		[JsonProperty]
		public EnumFaceCullMode FaceCullMode;

		[JsonProperty]
		public CompositeShape ShapeInventory;

		[JsonProperty]
		public CompositeShape Lod0Shape;

		[JsonProperty]
		public CompositeShape Lod2Shape;

		[JsonProperty]
		public bool DoNotRenderAtLod2;

		[JsonProperty]
		public bool Ambientocclusion = true;

		[JsonProperty]
		public BlockSounds Sounds;

		[JsonProperty]
		public Dictionary<string, CompositeTexture> TexturesInventory;

		[JsonProperty]
		public Dictionary<string, bool> SideOpaque;

		[JsonProperty]
		public Dictionary<string, bool> SideAo;

		[JsonProperty]
		public Dictionary<string, bool> EmitSideAo;

		[JsonProperty]
		public Dictionary<string, bool> SideSolid;

		[JsonProperty]
		public Dictionary<string, bool> SideSolidOpaqueAo;

		[JsonProperty]
		public string ClimateColorMap;

		[JsonProperty]
		public string SeasonColorMap;

		[JsonProperty]
		public int Replaceable;

		[JsonProperty]
		public int Fertility;

		[JsonProperty]
		public VertexFlags VertexFlags;

		[JsonProperty]
		public bool Frostable;

		[JsonProperty]
		public ushort LightAbsorption = 99;

		[JsonProperty]
		public float Resistance = 6f;

		[JsonProperty]
		public EnumBlockMaterial BlockMaterial = (EnumBlockMaterial)6;

		[JsonProperty]
		public int RequiredMiningTier;

		[JsonProperty("CollisionBox")]
		private RotatableCube CollisionBoxR = DefaultCollisionBoxR.Clone();

		[JsonProperty("SelectionBox")]
		private RotatableCube SelectionBoxR = DefaultCollisionBoxR.Clone();

		[JsonProperty("CollisionSelectionBox")]
		private RotatableCube CollisionSelectionBoxR;

		[JsonProperty("ParticleCollisionBox")]
		private RotatableCube ParticleCollisionBoxR;

		[JsonProperty("CollisionBoxes")]
		private RotatableCube[] CollisionBoxesR;

		[JsonProperty("SelectionBoxes")]
		private RotatableCube[] SelectionBoxesR;

		[JsonProperty("CollisionSelectionBoxes")]
		private RotatableCube[] CollisionSelectionBoxesR;

		[JsonProperty("ParticleCollisionBoxes")]
		private RotatableCube[] ParticleCollisionBoxesR;

		public Cuboidf[] CollisionBoxes;

		public Cuboidf[] SelectionBoxes;

		public Cuboidf[] ParticleCollisionBoxes;

		[JsonProperty]
		public bool Climbable;

		[JsonProperty]
		public bool RainPermeable;

		[JsonProperty]
		public int LiquidLevel;

		[JsonProperty]
		public string LiquidCode;

		[JsonProperty]
		public float WalkspeedMultiplier = 1f;

		[JsonProperty]
		public float DragMultiplier = 1f;

		[JsonProperty]
		public BlockDropItemStack[] Drops;

		[JsonProperty]
		public BlockCropPropertiesType CropProps;

		[JsonProperty]
		public string[] AllowSpawnCreatureGroups = Block.DefaultAllowAllSpawns;

		[ThreadStatic]
		private static List<BlockBehavior> reusableBehaviorList;

		[ThreadStatic]
		private static List<CollectibleBehavior> reusableCollectibleBehaviorList;

		[ThreadStatic]
		private static List<string> reusableStringList;

		public BlockType()
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Expected O, but got Unknown
			//IL_00a5: Expected O, but got Unknown
			Class = "Block";
			Shape = new CompositeShape
			{
				Base = new AssetLocation("game", "block/basic/cube")
			};
			GuiTransform = ModelTransform.BlockDefaultGui();
			FpHandTransform = ModelTransform.BlockDefaultFp();
			TpHandTransform = ModelTransform.BlockDefaultTp();
			GroundTransform = ModelTransform.BlockDefaultGround();
			MaxStackSize = 64;
		}

		internal override RegistryObjectType CreateAndPopulate(ICoreServerAPI api, AssetLocation fullcode, JObject jobject, JsonSerializer deserializer, OrderedDictionary<string, string> variant)
		{
			return CreateResolvedType<BlockType>(api, fullcode, jobject, deserializer, variant);
		}

		public Block CreateBlock(ICoreServerAPI api)
		{
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Expected O, but got Unknown
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0203: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_0249: Unknown result type (might be due to invalid IL or missing references)
			//IL_024e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0225: Unknown result type (might be due to invalid IL or missing references)
			//IL_0359: Unknown result type (might be due to invalid IL or missing references)
			//IL_035e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0389: Unknown result type (might be due to invalid IL or missing references)
			//IL_038e: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0496: Unknown result type (might be due to invalid IL or missing references)
			//IL_049b: Unknown result type (might be due to invalid IL or missing references)
			//IL_04bf: Unknown result type (might be due to invalid IL or missing references)
			Block val;
			if (((ICoreAPI)api).ClassRegistry.GetBlockClass(Class) == null)
			{
				api.Server.Logger.Error("Block with code {0} has defined a block class {1}, no such class registered. Will ignore.", new object[2] { Code, Class });
				val = new Block();
			}
			else
			{
				val = ((ICoreAPI)api).ClassRegistry.CreateBlock(Class);
			}
			if (EntityClass != null)
			{
				if (((ICoreAPI)api).ClassRegistry.GetBlockEntity(EntityClass) != null)
				{
					val.EntityClass = EntityClass;
				}
				else
				{
					api.Server.Logger.Error("Block with code {0} has defined a block entity class {1}, no such class registered. Will ignore.", new object[2] { Code, EntityClass });
				}
			}
			((RegistryObject)val).Code = Code;
			((RegistryObject)val).VariantStrict = Variant;
			((RegistryObject)val).Variant = new RelaxedReadOnlyDictionary<string, string>((IDictionary<string, string>)Variant);
			((RegistryObject)val).Class = Class;
			((CollectibleObject)val).LiquidSelectable = LiquidSelectable;
			val.LiquidCode = LiquidCode;
			val.BlockEntityBehaviors = ((BlockEntityBehaviorType[])EntityBehaviors?.Clone()) ?? Array.Empty<BlockEntityBehaviorType>();
			val.Tags = ((ICoreAPI)api).TagRegistry.BlockTagsToTagArray(Tags);
			if (val.EntityClass == null && val.BlockEntityBehaviors != null && val.BlockEntityBehaviors.Length != 0)
			{
				val.EntityClass = "Generic";
			}
			val.WalkSpeedMultiplier = WalkspeedMultiplier;
			val.DragMultiplier = DragMultiplier;
			((CollectibleObject)val).Durability = Durability;
			((CollectibleObject)val).Dimensions = Size ?? CollectibleObject.DefaultSize;
			((CollectibleObject)val).DamagedBy = (EnumItemDamageSource[])DamagedBy?.Clone();
			((CollectibleObject)val).Tool = Tool;
			val.DrawType = DrawType;
			val.Replaceable = Replaceable;
			val.Fertility = Fertility;
			val.LightAbsorption = LightAbsorption;
			((CollectibleObject)val).LightHsv = ThreeBytes.op_Implicit(LightHsv);
			Block obj = val;
			VertexFlags vertexFlags = VertexFlags;
			obj.VertexFlags = (VertexFlags)(((object)((vertexFlags != null) ? vertexFlags.Clone() : null)) ?? ((object)new VertexFlags(0)));
			val.Frostable = Frostable;
			val.Resistance = Resistance;
			val.BlockMaterial = BlockMaterial;
			val.Shape = Shape;
			val.Lod0Shape = Lod0Shape;
			val.Lod2Shape = Lod2Shape;
			val.ShapeInventory = ShapeInventory;
			val.DoNotRenderAtLod2 = DoNotRenderAtLod2;
			val.TexturesInventory = (IDictionary<string, CompositeTexture>)((TexturesInventory == null) ? null : new FastSmallDictionary<string, CompositeTexture>((IDictionary<string, CompositeTexture>)TexturesInventory));
			val.Textures = (IDictionary<string, CompositeTexture>)((Textures == null) ? null : new FastSmallDictionary<string, CompositeTexture>((IDictionary<string, CompositeTexture>)Textures));
			val.ClimateColorMap = ClimateColorMap;
			val.SeasonColorMap = SeasonColorMap;
			val.Ambientocclusion = Ambientocclusion;
			val.CollisionBoxes = CollisionBoxes;
			val.SelectionBoxes = SelectionBoxes;
			val.ParticleCollisionBoxes = ParticleCollisionBoxes;
			((CollectibleObject)val).MaterialDensity = MaterialDensity;
			((CollectibleObject)val).GuiTransform = GuiTransform;
			((CollectibleObject)val).FpHandTransform = FpHandTransform;
			((CollectibleObject)val).TpHandTransform = TpHandTransform;
			((CollectibleObject)val).TpOffHandTransform = TpOffHandTransform;
			((CollectibleObject)val).GroundTransform = GroundTransform;
			val.RenderPass = RenderPass;
			((CollectibleObject)val).ParticleProperties = ParticleProperties;
			val.Climbable = Climbable;
			val.RainPermeable = RainPermeable;
			val.FaceCullMode = FaceCullMode;
			val.Drops = Drops;
			((CollectibleObject)val).MaxStackSize = MaxStackSize;
			((CollectibleObject)val).MatterState = MatterState;
			if (Attributes != null)
			{
				((CollectibleObject)val).Attributes = Attributes.Clone();
			}
			((CollectibleObject)val).NutritionProps = NutritionProps;
			((CollectibleObject)val).TransitionableProps = TransitionableProps;
			((CollectibleObject)val).GrindingProps = GrindingProps;
			((CollectibleObject)val).CrushingProps = CrushingProps;
			val.LiquidLevel = LiquidLevel;
			((CollectibleObject)val).AttackPower = AttackPower;
			((CollectibleObject)val).MiningSpeed = MiningSpeed;
			((CollectibleObject)val).ToolTier = ToolTier;
			val.RequiredMiningTier = RequiredMiningTier;
			Block obj2 = val;
			HeldSounds heldSounds = HeldSounds;
			((CollectibleObject)obj2).HeldSounds = ((heldSounds != null) ? heldSounds.Clone() : null);
			((CollectibleObject)val).AttackRange = AttackRange;
			if (Sounds != null)
			{
				val.Sounds = Sounds.Clone();
			}
			val.RandomDrawOffset = (RandomDrawOffset ? 1 : 0);
			val.RandomizeRotations = RandomizeRotations;
			val.RandomizeAxes = RandomizeAxes;
			val.RandomSizeAdjust = RandomSizeAdjust;
			((CollectibleObject)val).CombustibleProps = CombustibleProps;
			((CollectibleObject)val).StorageFlags = (EnumItemStorageFlags)StorageFlags;
			((CollectibleObject)val).RenderAlphaTest = RenderAlphaTest;
			((CollectibleObject)val).HeldTpHitAnimation = HeldTpHitAnimation;
			((CollectibleObject)val).HeldRightTpIdleAnimation = HeldRightTpIdleAnimation;
			((CollectibleObject)val).HeldLeftTpIdleAnimation = HeldLeftTpIdleAnimation;
			((CollectibleObject)val).HeldLeftReadyAnimation = HeldLeftReadyAnimation;
			((CollectibleObject)val).HeldRightReadyAnimation = HeldRightReadyAnimation;
			((CollectibleObject)val).HeldTpUseAnimation = HeldTpUseAnimation;
			((CollectibleObject)val).CreativeInventoryStacks = ((CreativeInventoryStacks == null) ? null : ((CreativeTabAndStackList[])CreativeInventoryStacks.Clone()));
			val.AllowSpawnCreatureGroups = AllowSpawnCreatureGroups;
			val.AllCreaturesAllowed = AllowSpawnCreatureGroups.Length == 1 && AllowSpawnCreatureGroups[0] == "*";
			EnsureClientServerAccuracy(val.CollisionBoxes);
			EnsureClientServerAccuracy(val.SelectionBoxes);
			EnsureClientServerAccuracy(val.ParticleCollisionBoxes);
			InitBlock(((ICoreAPI)api).ClassRegistry, ((IWorldAccessor)api.World).Logger, val, Variant);
			return val;
		}

		private void EnsureClientServerAccuracy(Cuboidf[] boxes)
		{
			if (boxes != null)
			{
				for (int i = 0; i < boxes.Length; i++)
				{
					boxes[i].RoundToFracsOfOne10thousand();
				}
			}
		}

		private Cuboidf[] ToCuboidf(params RotatableCube[] cubes)
		{
			Cuboidf[] array = (Cuboidf[])(object)new Cuboidf[cubes.Length];
			for (int i = 0; i < cubes.Length; i++)
			{
				array[i] = cubes[i].RotatedCopy();
			}
			return array;
		}

		internal override void OnDeserialized()
		{
			base.OnDeserialized();
			if (CollisionBoxR != null)
			{
				CollisionBoxes = ToCuboidf(CollisionBoxR);
			}
			if (SelectionBoxR != null)
			{
				SelectionBoxes = ToCuboidf(SelectionBoxR);
			}
			if (ParticleCollisionBoxR != null)
			{
				ParticleCollisionBoxes = ToCuboidf(ParticleCollisionBoxR);
			}
			if (CollisionBoxesR != null)
			{
				CollisionBoxes = ToCuboidf(CollisionBoxesR);
			}
			if (SelectionBoxesR != null)
			{
				SelectionBoxes = ToCuboidf(SelectionBoxesR);
			}
			if (ParticleCollisionBoxesR != null)
			{
				ParticleCollisionBoxes = ToCuboidf(ParticleCollisionBoxesR);
			}
			if (CollisionSelectionBoxR != null)
			{
				CollisionBoxes = ToCuboidf(CollisionSelectionBoxR);
				SelectionBoxes = CloneArray(CollisionBoxes);
			}
			if (CollisionSelectionBoxesR != null)
			{
				CollisionBoxes = ToCuboidf(CollisionSelectionBoxesR);
				SelectionBoxes = CloneArray(CollisionBoxes);
			}
			ResolveStringBoolDictFaces(SideSolidOpaqueAo);
			ResolveStringBoolDictFaces(SideSolid);
			ResolveStringBoolDictFaces(SideOpaque);
			ResolveStringBoolDictFaces(SideAo);
			ResolveStringBoolDictFaces(EmitSideAo);
			if (SideSolidOpaqueAo != null && SideSolidOpaqueAo.Count > 0)
			{
				ResolveDict(SideSolidOpaqueAo, ref SideSolid);
				ResolveDict(SideSolidOpaqueAo, ref SideOpaque);
				ResolveDict(SideSolidOpaqueAo, ref EmitSideAo);
			}
			if (EmitSideAo == null)
			{
				EmitSideAo = new Dictionary<string, bool> { 
				{
					"all",
					LightAbsorption > 0
				} };
				ResolveStringBoolDictFaces(EmitSideAo);
			}
			if (LightHsv == null)
			{
				LightHsv = new byte[3];
			}
			LightHsv[0] = (byte)GameMath.Clamp((int)LightHsv[0], 0, ColorUtil.HueQuantities - 1);
			LightHsv[1] = (byte)GameMath.Clamp((int)LightHsv[1], 0, ColorUtil.SatQuantities - 1);
			LightHsv[2] = (byte)GameMath.Clamp((int)LightHsv[2], 0, ColorUtil.BrightQuantities - 1);
		}

		private Cuboidf[] CloneArray(Cuboidf[] array)
		{
			if (array == null)
			{
				return null;
			}
			int num = array.Length;
			Cuboidf[] array2 = (Cuboidf[])(object)new Cuboidf[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = array[i].Clone();
			}
			return array2;
		}

		private void ResolveDict(Dictionary<string, bool> sideSolidOpaqueAo, ref Dictionary<string, bool> targetDict)
		{
			bool flag = targetDict == null;
			if (flag)
			{
				targetDict = new Dictionary<string, bool> { { "all", true } };
			}
			foreach (KeyValuePair<string, bool> item in sideSolidOpaqueAo)
			{
				if (flag || !targetDict.ContainsKey(item.Key))
				{
					targetDict[item.Key] = item.Value;
				}
			}
			ResolveStringBoolDictFaces(targetDict);
		}

		public void InitBlock(IClassRegistryAPI instancer, ILogger logger, Block block, OrderedDictionary<string, string> searchReplace)
		{
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Expected O, but got Unknown
			//IL_0200: Unknown result type (might be due to invalid IL or missing references)
			//IL_0205: Unknown result type (might be due to invalid IL or missing references)
			//IL_032f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0334: Unknown result type (might be due to invalid IL or missing references)
			//IL_0340: Unknown result type (might be due to invalid IL or missing references)
			//IL_0342: Unknown result type (might be due to invalid IL or missing references)
			//IL_0347: Unknown result type (might be due to invalid IL or missing references)
			//IL_0353: Expected O, but got Unknown
			//IL_038a: Unknown result type (might be due to invalid IL or missing references)
			//IL_038f: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Expected O, but got Unknown
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Expected O, but got Unknown
			CollectibleBehaviorType[] behaviors = Behaviors;
			if (behaviors != null)
			{
				List<BlockBehavior> list = reusableBehaviorList ?? (reusableBehaviorList = new List<BlockBehavior>());
				List<CollectibleBehavior> list2 = reusableCollectibleBehaviorList ?? (reusableCollectibleBehaviorList = new List<CollectibleBehavior>());
				list.Clear();
				list2.Clear();
				foreach (CollectibleBehaviorType collectibleBehaviorType in behaviors)
				{
					CollectibleBehavior val = null;
					if (instancer.GetCollectibleBehaviorClass(collectibleBehaviorType.name) != null)
					{
						val = instancer.CreateCollectibleBehavior((CollectibleObject)(object)block, collectibleBehaviorType.name);
					}
					if (instancer.GetBlockBehaviorClass(collectibleBehaviorType.name) != null)
					{
						val = (CollectibleBehavior)(object)instancer.CreateBlockBehavior(block, collectibleBehaviorType.name);
					}
					if (val == null)
					{
						logger.Warning(Lang.Get("Block or Collectible behavior {0} for block {1} not found", new object[2]
						{
							collectibleBehaviorType.name,
							((RegistryObject)block).Code
						}));
						continue;
					}
					if (collectibleBehaviorType.properties == null)
					{
						collectibleBehaviorType.properties = new JsonObject((JToken)new JObject());
					}
					try
					{
						val.Initialize(collectibleBehaviorType.properties);
					}
					catch (Exception ex)
					{
						logger.Error("Failed calling Initialize() on collectible or block behavior {0} for block {1}, using properties {2}. Will continue anyway. Exception", new object[3]
						{
							collectibleBehaviorType.name,
							((RegistryObject)block).Code,
							((object)collectibleBehaviorType.properties).ToString()
						});
						logger.Error(ex);
					}
					list2.Add(val);
					BlockBehavior val2 = (BlockBehavior)(object)((val is BlockBehavior) ? val : null);
					if (val2 != null)
					{
						list.Add(val2);
					}
				}
				block.BlockBehaviors = list.ToArray();
				((CollectibleObject)block).CollectibleBehaviors = list2.ToArray();
				list.Clear();
				list2.Clear();
			}
			if (CropProps != null)
			{
				block.CropProps = new BlockCropProperties();
				block.CropProps.GrowthStages = CropProps.GrowthStages;
				block.CropProps.HarvestGrowthStageLoss = CropProps.HarvestGrowthStageLoss;
				block.CropProps.MultipleHarvests = CropProps.MultipleHarvests;
				block.CropProps.NutrientConsumption = CropProps.NutrientConsumption;
				block.CropProps.RequiredNutrient = CropProps.RequiredNutrient;
				block.CropProps.TotalGrowthDays = CropProps.TotalGrowthDays;
				block.CropProps.TotalGrowthMonths = CropProps.TotalGrowthMonths;
				block.CropProps.ColdDamageBelow = CropProps.ColdDamageBelow;
				block.CropProps.HeatDamageAbove = CropProps.HeatDamageAbove;
				block.CropProps.DamageGrowthStuntMul = CropProps.DamageGrowthStuntMul;
				block.CropProps.ColdDamageRipeMul = CropProps.ColdDamageRipeMul;
				if (CropProps.Behaviors != null)
				{
					block.CropProps.Behaviors = (CropBehavior[])(object)new CropBehavior[CropProps.Behaviors.Length];
					for (int j = 0; j < CropProps.Behaviors.Length; j++)
					{
						CropBehaviorType cropBehaviorType = CropProps.Behaviors[j];
						CropBehavior val3 = instancer.CreateCropBehavior(block, cropBehaviorType.name);
						if (cropBehaviorType.properties != null)
						{
							val3.Initialize(cropBehaviorType.properties);
						}
						block.CropProps.Behaviors[j] = val3;
					}
				}
			}
			if (block.Drops == null)
			{
				block.Drops = (BlockDropItemStack[])(object)new BlockDropItemStack[1]
				{
					new BlockDropItemStack
					{
						Code = ((RegistryObject)block).Code,
						Type = (EnumItemClass)0,
						Quantity = NatFloat.One
					}
				};
			}
			((CollectibleObject)block).CreativeInventoryTabs = GetCreativeTabs(((RegistryObject)block).Code, CreativeInventory, searchReplace);
			if (SideOpaque != null && SideOpaque.Count > 0)
			{
				block.SideOpaque = new SmallBoolArray(63);
			}
			if (SideAo != null && SideAo.Count > 0)
			{
				block.SideAo = new SmallBoolArray(63);
			}
			BlockFacing[] aLLFACES = BlockFacing.ALLFACES;
			foreach (BlockFacing val4 in aLLFACES)
			{
				if (SideAo != null && SideAo.TryGetValue(val4.Code, out var value))
				{
					((SmallBoolArray)(ref block.SideAo))[val4.Index] = value;
				}
				if (EmitSideAo != null && EmitSideAo.TryGetValue(val4.Code, out var value2) && value2)
				{
					block.EmitSideAo |= val4.Flag;
				}
				if (SideSolid != null && SideSolid.TryGetValue(val4.Code, out var value3))
				{
					((SmallBoolArray)(ref block.SideSolid))[val4.Index] = value3;
				}
				if (SideOpaque != null && SideOpaque.TryGetValue(val4.Code, out var value4))
				{
					((SmallBoolArray)(ref block.SideOpaque))[val4.Index] = value4;
				}
			}
			if (HeldRightReadyAnimation != null && HeldRightReadyAnimation == HeldRightTpIdleAnimation)
			{
				logger.Error("Block {0} HeldRightReadyAnimation and HeldRightTpIdleAnimation is set to the same animation {1}. This invalid and breaks stuff. Will set HeldRightReadyAnimation to null", new object[2] { Code, HeldRightTpIdleAnimation });
				HeldRightReadyAnimation = null;
			}
		}

		public static string[] GetCreativeTabs(AssetLocation code, Dictionary<string, string[]> CreativeInventory, OrderedDictionary<string, string> searchReplace)
		{
			List<string> list = reusableStringList ?? (reusableStringList = new List<string>());
			list.Clear();
			foreach (KeyValuePair<string, string[]> item in CreativeInventory)
			{
				for (int i = 0; i < item.Value.Length; i++)
				{
					if (WildcardUtil.Match(RegistryObject.FillPlaceHolder(item.Value[i], searchReplace), code.Path))
					{
						string key = item.Key;
						list.Add(string.Intern(key));
					}
				}
			}
			string[] result = list.ToArray();
			list.Clear();
			return result;
		}

		private void ResolveStringBoolDictFaces(Dictionary<string, bool> stringBoolDict)
		{
			if (stringBoolDict == null)
			{
				return;
			}
			BlockFacing[] hORIZONTALS;
			if (stringBoolDict.ContainsKey("horizontals"))
			{
				hORIZONTALS = BlockFacing.HORIZONTALS;
				foreach (BlockFacing val in hORIZONTALS)
				{
					if (!stringBoolDict.ContainsKey(val.Code))
					{
						stringBoolDict[val.Code] = stringBoolDict["horizontals"];
					}
				}
			}
			if (stringBoolDict.ContainsKey("verticals"))
			{
				hORIZONTALS = BlockFacing.VERTICALS;
				foreach (BlockFacing val2 in hORIZONTALS)
				{
					if (!stringBoolDict.ContainsKey(val2.Code))
					{
						stringBoolDict[val2.Code] = stringBoolDict["verticals"];
					}
				}
			}
			if (!stringBoolDict.ContainsKey("all"))
			{
				return;
			}
			hORIZONTALS = BlockFacing.ALLFACES;
			foreach (BlockFacing val3 in hORIZONTALS)
			{
				if (!stringBoolDict.ContainsKey(val3.Code))
				{
					stringBoolDict[val3.Code] = stringBoolDict["all"];
				}
			}
		}
	}
	[DocumentAsJson]
	public class CollectibleBehaviorType
	{
		[JsonProperty]
		public string name;

		[JsonProperty]
		[JsonConverter(typeof(JsonAttributesConverter))]
		public JsonObject properties;
	}
	[DocumentAsJson]
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public abstract class CollectibleType : RegistryObjectType
	{
		[JsonProperty]
		public CollectibleBehaviorType[] Behaviors = Array.Empty<CollectibleBehaviorType>();

		[JsonProperty]
		public byte[] LightHsv = new byte[3];

		[JsonProperty]
		public float RenderAlphaTest = 0.05f;

		[JsonProperty]
		public int StorageFlags = 1;

		[JsonProperty]
		public int MaxStackSize = 1;

		[JsonProperty]
		public float AttackPower = 0.5f;

		[JsonProperty]
		public int Durability;

		[JsonProperty]
		public Size3f Size;

		[JsonProperty]
		public EnumItemDamageSource[] DamagedBy;

		[JsonProperty]
		public EnumTool? Tool;

		[JsonProperty]
		public float AttackRange = GlobalConstants.DefaultAttackRange;

		[JsonProperty]
		public Dictionary<EnumBlockMaterial, float> MiningSpeed;

		[JsonProperty]
		public int ToolTier;

		[JsonProperty]
		public EnumMatterState MatterState = (EnumMatterState)2;

		[JsonProperty]
		public HeldSounds HeldSounds;

		[JsonProperty]
		public int MaterialDensity = 9999;

		[JsonProperty]
		[JsonConverter(typeof(JsonAttributesConverter))]
		public JsonObject Attributes;

		[JsonProperty]
		public CompositeShape Shape;

		[JsonProperty]
		public ModelTransform GuiTransform;

		[JsonProperty]
		public ModelTransform FpHandTransform;

		[JsonProperty]
		public ModelTransform TpHandTransform;

		[JsonProperty]
		public ModelTransform TpOffHandTransform;

		[JsonProperty]
		public ModelTransform GroundTransform;

		[JsonProperty]
		public CompositeTexture Texture;

		[JsonProperty]
		public Dictionary<string, CompositeTexture> Textures;

		[JsonProperty]
		public CombustibleProperties CombustibleProps;

		[JsonProperty]
		public FoodNutritionProperties NutritionProps;

		[JsonProperty]
		public TransitionableProperties[] TransitionableProps;

		[JsonProperty]
		public GrindingProperties GrindingProps;

		[JsonProperty]
		public CrushingProperties CrushingProps;

		[JsonProperty]
		public bool LiquidSelectable;

		[JsonProperty]
		public Dictionary<string, string[]> CreativeInventory = new Dictionary<string, string[]>();

		[JsonProperty]
		public CreativeTabAndStackList[] CreativeInventoryStacks;

		[JsonProperty]
		public string HeldTpHitAnimation = "breakhand";

		[JsonProperty]
		public string HeldRightTpIdleAnimation;

		[JsonProperty]
		public string HeldLeftTpIdleAnimation;

		[JsonProperty]
		public string HeldLeftReadyAnimation = "helditemready";

		[JsonProperty]
		public string HeldRightReadyAnimation = "helditemready";

		[JsonProperty("heldTpIdleAnimation")]
		private string HeldOldTpIdleAnimation;

		[JsonProperty]
		public string HeldTpUseAnimation = "interactstatic";

		[JsonProperty]
		public AdvancedParticleProperties[] ParticleProperties;

		[JsonProperty]
		[Obsolete("Use Size instead from game version 1.20.4 onwards, with the same values")]
		public Size3f Dimensions
		{
			get
			{
				return Size;
			}
			set
			{
				Size = value;
			}
		}

		[JsonProperty]
		[Obsolete("Use tool tier")]
		public int MiningTier
		{
			get
			{
				return ToolTier;
			}
			set
			{
				ToolTier = value;
			}
		}

		[OnDeserialized]
		internal void OnDeserializedMethod(StreamingContext context)
		{
			OnDeserialized();
		}

		internal virtual void OnDeserialized()
		{
			if (Texture != null)
			{
				if (Textures == null)
				{
					Textures = new Dictionary<string, CompositeTexture>(1);
				}
				Textures["all"] = Texture;
			}
			if (HeldOldTpIdleAnimation != null && HeldRightTpIdleAnimation == null)
			{
				HeldRightTpIdleAnimation = HeldOldTpIdleAnimation;
			}
		}
	}
	[DocumentAsJson]
	public class CropBehaviorType
	{
		[JsonProperty]
		public string name;

		[JsonProperty]
		[JsonConverter(typeof(JsonAttributesConverter))]
		public JsonObject properties;
	}
	[DocumentAsJson]
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class EntityType : RegistryObjectType
	{
		[JsonProperty]
		public EnumHabitat Habitat = (EnumHabitat)1;

		[JsonProperty]
		public Vec2f CollisionBoxSize = new Vec2f(0.5f, 0.5f);

		[JsonProperty]
		public Vec2f DeadCollisionBoxSize = new Vec2f(0.5f, 0.25f);

		[JsonProperty]
		public Vec2f SelectionBoxSize;

		[JsonProperty]
		public Vec2f DeadSelectionBoxSize;

		[JsonProperty]
		public double EyeHeight = 0.1;

		[JsonProperty]
		public double? SwimmingEyeHeight;

		[JsonProperty]
		public float Weight = 25f;

		[JsonProperty]
		public bool CanClimb;

		[JsonProperty]
		public bool CanClimbAnywhere;

		[JsonProperty]
		public float FallDamageMultiplier = 1f;

		[JsonProperty]
		public float ClimbTouchDistance = 0.5f;

		[JsonProperty]
		public bool RotateModelOnClimb;

		[JsonProperty]
		public float KnockbackResistance;

		[JsonProperty]
		[JsonConverter(typeof(JsonAttributesConverter))]
		public JsonObject Attributes;

		[JsonProperty(ItemConverterType = typeof(JsonAttributesConverter))]
		public Dictionary<string, JsonObject> BehaviorConfigs;

		[JsonProperty]
		public ClientEntityConfig Client;

		[JsonProperty]
		public ServerEntityConfig Server;

		[JsonProperty]
		public Dictionary<string, AssetLocation> Sounds;

		[JsonProperty]
		public float IdleSoundChance = 0.05f;

		[JsonProperty]
		public float IdleSoundRange = 24f;

		[JsonProperty]
		public BlockDropItemStack[] Drops;

		[JsonProperty]
		public Vec2f HitBoxSize
		{
			get
			{
				return null;
			}
			set
			{
				CollisionBoxSize = value;
				SelectionBoxSize = value;
			}
		}

		[JsonProperty]
		public Vec2f DeadHitBoxSize
		{
			get
			{
				return null;
			}
			set
			{
				DeadCollisionBoxSize = value;
				DeadSelectionBoxSize = value;
			}
		}

		public EntityProperties CreateProperties(ICoreAPI api)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_014c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Expected O, but got Unknown
			//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0262: Expected O, but got Unknown
			//IL_027c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0281: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b9: Expected O, but got Unknown
			BlockDropItemStack[] array;
			if (Drops == null)
			{
				array = null;
			}
			else
			{
				array = (BlockDropItemStack[])(object)new BlockDropItemStack[Drops.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Drops[i].Clone();
				}
			}
			EntityProperties val = new EntityProperties
			{
				Code = Code,
				Tags = api.TagRegistry.EntityTagsToTagArray(Tags),
				Variant = new OrderedDictionary<string, string>(Variant),
				Class = Class,
				Habitat = Habitat,
				CollisionBoxSize = CollisionBoxSize,
				DeadCollisionBoxSize = DeadCollisionBoxSize,
				SelectionBoxSize = SelectionBoxSize,
				DeadSelectionBoxSize = DeadSelectionBoxSize,
				Weight = Weight,
				CanClimb = CanClimb,
				CanClimbAnywhere = CanClimbAnywhere,
				FallDamage = (FallDamageMultiplier > 0f),
				FallDamageMultiplier = FallDamageMultiplier,
				ClimbTouchDistance = ClimbTouchDistance,
				RotateModelOnClimb = RotateModelOnClimb,
				KnockbackResistance = KnockbackResistance,
				Attributes = Attributes,
				Sounds = ((Sounds == null) ? new Dictionary<string, AssetLocation>() : new Dictionary<string, AssetLocation>(Sounds)),
				IdleSoundChance = IdleSoundChance,
				IdleSoundRange = IdleSoundRange,
				Drops = array,
				EyeHeight = EyeHeight,
				SwimmingEyeHeight = (SwimmingEyeHeight ?? EyeHeight)
			};
			if (Client != null)
			{
				val.Client = new EntityClientProperties(Client.Behaviors, BehaviorConfigs)
				{
					RendererName = Client.Renderer,
					Textures = (IDictionary<string, CompositeTexture>)new FastSmallDictionary<string, CompositeTexture>((IDictionary<string, CompositeTexture>)Client.Textures),
					GlowLevel = Client.GlowLevel,
					PitchStep = Client.PitchStep,
					Shape = Client.Shape,
					Size = Client.Size,
					SizeGrowthFactor = Client.SizeGrowthFactor,
					Animations = Client.Animations,
					AnimationsByMetaCode = Client.AnimationsByMetaCode
				};
			}
			if (Server != null)
			{
				EntityServerProperties val2 = new EntityServerProperties(Server.Behaviors, BehaviorConfigs);
				JsonObject attributes = Server.Attributes;
				ref ITreeAttribute attributes2 = ref ((EntitySidedProperties)val2).Attributes;
				IAttribute obj = ((attributes != null) ? attributes.ToAttribute() : null);
				attributes2 = (ITreeAttribute)(object)((obj is TreeAttribute) ? obj : null);
				val2.SpawnConditions = Server.SpawnConditions;
				val.Server = val2;
			}
			return val;
		}

		internal override RegistryObjectType CreateAndPopulate(ICoreServerAPI api, AssetLocation fullcode, JObject jobject, JsonSerializer deserializer, OrderedDictionary<string, string> variant)
		{
			return CreateResolvedType<EntityType>(api, fullcode, jobject, deserializer, variant);
		}
	}
	[DocumentAsJson]
	public class ClientEntityConfig
	{
		[JsonProperty]
		public string Renderer;

		[JsonProperty]
		protected CompositeTexture Texture;

		[JsonProperty]
		public int GlowLevel;

		[JsonProperty]
		public CompositeShape Shape;

		[JsonProperty(ItemConverterType = typeof(JsonAttributesConverter))]
		public JsonObject[] Behaviors;

		[JsonProperty]
		public float Size = 1f;

		[JsonProperty]
		public float SizeGrowthFactor;

		[JsonProperty]
		public AnimationMetaData[] Animations;

		[JsonProperty]
		public bool PitchStep = true;

		public Dictionary<string, AnimationMetaData> AnimationsByMetaCode = new Dictionary<string, AnimationMetaData>(StringComparer.OrdinalIgnoreCase);

		[JsonProperty]
		public Dictionary<string, CompositeTexture> Textures { get; set; } = new Dictionary<string, CompositeTexture>();

		public CompositeTexture FirstTexture
		{
			get
			{
				if (Textures != null && Textures.Count != 0)
				{
					return Textures.First().Value;
				}
				return null;
			}
		}

		[OnDeserialized]
		internal void OnDeserializedMethod(StreamingContext context)
		{
			if (Texture != null)
			{
				Textures["all"] = Texture;
			}
			Init();
		}

		public void Init()
		{
			if (Animations == null)
			{
				return;
			}
			for (int i = 0; i < Animations.Length; i++)
			{
				AnimationMetaData val = Animations[i];
				if (val.Animation != null)
				{
					AnimationsByMetaCode[val.Code] = val;
				}
			}
		}
	}
	[DocumentAsJson]
	public class ServerEntityConfig
	{
		[JsonProperty(ItemConverterType = typeof(JsonAttributesConverter))]
		public JsonObject[] Behaviors;

		[JsonProperty]
		[JsonConverter(typeof(JsonAttributesConverter))]
		public JsonObject Attributes;

		[JsonProperty]
		public SpawnConditions SpawnConditions;
	}
	[DocumentAsJson]
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class ItemType : CollectibleType
	{
		public ItemType()
		{
			Class = "Item";
			GuiTransform = ModelTransform.ItemDefaultGui();
			FpHandTransform = ModelTransform.ItemDefaultFp();
			TpHandTransform = ModelTransform.ItemDefaultTp();
			TpOffHandTransform = null;
			GroundTransform = ModelTransform.ItemDefaultGround();
		}

		internal override RegistryObjectType CreateAndPopulate(ICoreServerAPI api, AssetLocation fullcode, JObject jobject, JsonSerializer deserializer, OrderedDictionary<string, string> variant)
		{
			ItemType itemType = CreateResolvedType<ItemType>(api, fullcode, jobject, deserializer, variant);
			if (itemType.Shape != null && !itemType.Shape.VoxelizeTexture)
			{
				JToken obj = jobject["guiTransform"];
				if (((obj != null) ? obj[(object)"rotate"] : null) == null)
				{
					GuiTransform = ModelTransform.ItemDefaultGui();
					((ModelTransformNoDefaults)GuiTransform).Rotate = true;
				}
			}
			return itemType;
		}

		public void InitItem(IClassRegistryAPI instancer, ILogger logger, Item item, OrderedDictionary<string, string> searchReplace)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Expected O, but got Unknown
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Expected O, but got Unknown
			((CollectibleObject)item).CreativeInventoryTabs = BlockType.GetCreativeTabs(((RegistryObject)item).Code, CreativeInventory, searchReplace);
			CollectibleBehaviorType[] behaviors = Behaviors;
			if (behaviors == null)
			{
				return;
			}
			List<CollectibleBehavior> list = new List<CollectibleBehavior>();
			foreach (CollectibleBehaviorType collectibleBehaviorType in behaviors)
			{
				if (instancer.GetCollectibleBehaviorClass(collectibleBehaviorType.name) != null)
				{
					CollectibleBehavior val = instancer.CreateCollectibleBehavior((CollectibleObject)(object)item, collectibleBehaviorType.name);
					if (collectibleBehaviorType.properties == null)
					{
						collectibleBehaviorType.properties = new JsonObject((JToken)new JObject());
					}
					try
					{
						val.Initialize(collectibleBehaviorType.properties);
					}
					catch (Exception ex)
					{
						logger.Error("Failed calling Initialize() on collectible behavior {0} for item {1}, using properties {2}. Will continue anyway.", new object[3]
						{
							collectibleBehaviorType.name,
							((RegistryObject)item).Code,
							((object)collectibleBehaviorType.properties).ToString()
						});
						logger.Error(ex);
					}
					list.Add(val);
				}
				else
				{
					logger.Warning(Lang.Get("Collectible behavior {0} for item {1} not found", new object[2]
					{
						collectibleBehaviorType.name,
						((RegistryObject)item).Code
					}));
				}
			}
			((CollectibleObject)item).CollectibleBehaviors = list.ToArray();
		}

		public Item CreateItem(ICoreServerAPI api)
		{
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Expected O, but got Unknown
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_021e: Unknown result type (might be due to invalid IL or missing references)
			//IL_029a: Unknown result type (might be due to invalid IL or missing references)
			//IL_029f: Unknown result type (might be due to invalid IL or missing references)
			Item val;
			if (((ICoreAPI)api).ClassRegistry.GetItemClass(Class) == null)
			{
				api.Server.Logger.Error("Item with code {0} has defined an item class {1}, but no such class registered. Will ignore.", new object[2] { Code, Class });
				val = new Item();
			}
			else
			{
				val = ((ICoreAPI)api).ClassRegistry.CreateItem(Class);
			}
			((RegistryObject)val).Code = Code;
			((RegistryObject)val).VariantStrict = Variant;
			((RegistryObject)val).Variant = new RelaxedReadOnlyDictionary<string, string>((IDictionary<string, string>)Variant);
			((RegistryObject)val).Class = Class;
			val.Textures = Textures;
			((CollectibleObject)val).MaterialDensity = MaterialDensity;
			val.Tags = ((ICoreAPI)api).TagRegistry.ItemTagsToTagArray(Tags);
			((CollectibleObject)val).GuiTransform = GuiTransform;
			((CollectibleObject)val).FpHandTransform = FpHandTransform;
			((CollectibleObject)val).TpHandTransform = TpHandTransform;
			((CollectibleObject)val).TpOffHandTransform = TpOffHandTransform;
			((CollectibleObject)val).GroundTransform = GroundTransform;
			((CollectibleObject)val).LightHsv = ThreeBytes.op_Implicit(LightHsv);
			((CollectibleObject)val).DamagedBy = (EnumItemDamageSource[])DamagedBy?.Clone();
			((CollectibleObject)val).MaxStackSize = MaxStackSize;
			if (Attributes != null)
			{
				((CollectibleObject)val).Attributes = Attributes;
			}
			((CollectibleObject)val).CombustibleProps = CombustibleProps;
			((CollectibleObject)val).NutritionProps = NutritionProps;
			((CollectibleObject)val).TransitionableProps = TransitionableProps;
			((CollectibleObject)val).GrindingProps = GrindingProps;
			((CollectibleObject)val).CrushingProps = CrushingProps;
			val.Shape = Shape;
			((CollectibleObject)val).Tool = Tool;
			((CollectibleObject)val).AttackPower = AttackPower;
			((CollectibleObject)val).LiquidSelectable = LiquidSelectable;
			((CollectibleObject)val).ToolTier = ToolTier;
			Item obj = val;
			HeldSounds heldSounds = HeldSounds;
			((CollectibleObject)obj).HeldSounds = ((heldSounds != null) ? heldSounds.Clone() : null);
			((CollectibleObject)val).Durability = Durability;
			((CollectibleObject)val).Dimensions = Size ?? CollectibleObject.DefaultSize;
			((CollectibleObject)val).MiningSpeed = MiningSpeed;
			((CollectibleObject)val).AttackRange = AttackRange;
			((CollectibleObject)val).StorageFlags = (EnumItemStorageFlags)StorageFlags;
			((CollectibleObject)val).RenderAlphaTest = RenderAlphaTest;
			((CollectibleObject)val).HeldTpHitAnimation = HeldTpHitAnimation;
			((CollectibleObject)val).HeldRightTpIdleAnimation = HeldRightTpIdleAnimation;
			((CollectibleObject)val).HeldLeftTpIdleAnimation = HeldLeftTpIdleAnimation;
			((CollectibleObject)val).HeldLeftReadyAnimation = HeldLeftReadyAnimation;
			((CollectibleObject)val).HeldRightReadyAnimation = HeldRightReadyAnimation;
			((CollectibleObject)val).HeldTpUseAnimation = HeldTpUseAnimation;
			((CollectibleObject)val).CreativeInventoryStacks = ((CreativeInventoryStacks == null) ? null : ((CreativeTabAndStackList[])CreativeInventoryStacks.Clone()));
			((CollectibleObject)val).MatterState = MatterState;
			((CollectibleObject)val).ParticleProperties = ParticleProperties;
			InitItem(((ICoreAPI)api).ClassRegistry, ((IWorldAccessor)api.World).Logger, val, Variant);
			return val;
		}
	}
	[DocumentAsJson]
	public enum EnumJsonPatchOp
	{
		Add,
		AddEach,
		Remove,
		Replace,
		Copy,
		Move,
		AddMerge
	}
	[DocumentAsJson]
	public class PatchCondition
	{
		[DocumentAsJson]
		public string When;

		[DocumentAsJson]
		public string IsValue;

		[DocumentAsJson]
		public bool useValue;
	}
	[DocumentAsJson]
	public class PatchModDependence
	{
		[DocumentAsJson]
		public string modid;

		[DocumentAsJson]
		public bool invert;
	}
	[DocumentAsJson]
	public class JsonPatch
	{
		[DocumentAsJson]
		public EnumJsonPatchOp Op;

		[DocumentAsJson]
		public AssetLocation File;

		[DocumentAsJson]
		public string FromPath;

		[DocumentAsJson]
		public string Path;

		[DocumentAsJson]
		public PatchModDependence[] DependsOn;

		[DocumentAsJson]
		public bool Enabled = true;

		[DocumentAsJson]
		public EnumAppSide? Side = (EnumAppSide)3;

		[DocumentAsJson]
		public PatchCondition Condition;

		[JsonProperty]
		[JsonConverter(typeof(JsonAttributesConverter))]
		public JsonObject Value;

		[Obsolete("Use Side instead")]
		[DocumentAsJson]
		public EnumAppSide? SideType
		{
			get
			{
				return Side;
			}
			set
			{
				Side = value;
			}
		}
	}
	public class ModJsonPatchLoader : ModSystem
	{
		private ICoreAPI api;

		private ITreeAttribute worldConfig;

		public override bool ShouldLoad(EnumAppSide side)
		{
			return true;
		}

		public override double ExecuteOrder()
		{
			return 0.05;
		}

		public override void AssetsLoaded(ICoreAPI api)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Expected O, but got Unknown
			this.api = api;
			worldConfig = api.World.Config;
			if (worldConfig == null)
			{
				worldConfig = (ITreeAttribute)new TreeAttribute();
			}
			ApplyPatches();
		}

		public void ApplyPatches(string forPartialPath = null)
		{
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Expected O, but got Unknown
			List<IAsset> many = api.Assets.GetMany("patches/", (string)null, true);
			int applied = 0;
			int notFound = 0;
			int errorCount = 0;
			int num = 0;
			int num2 = 0;
			HashSet<string> hashSet = new HashSet<string>(api.ModLoader.Mods.Select((Mod m) => m.Info.ModID).ToList());
			foreach (IAsset item in many)
			{
				JsonPatch[] array = null;
				try
				{
					array = item.ToObject<JsonPatch[]>((JsonSerializerSettings)null);
				}
				catch (Exception ex)
				{
					api.Logger.Error("Failed loading patches file {0}:", new object[1] { item.Location });
					api.Logger.Error(ex);
				}
				for (int num3 = 0; array != null && num3 < array.Length; num3++)
				{
					JsonPatch jsonPatch = array[num3];
					if (!jsonPatch.Enabled)
					{
						continue;
					}
					if (jsonPatch.Condition != null)
					{
						IAttribute val = worldConfig[jsonPatch.Condition.When];
						if (val == null)
						{
							continue;
						}
						if (jsonPatch.Condition.useValue)
						{
							jsonPatch.Value = new JsonObject(JToken.Parse(val.ToJsonToken()));
						}
						else if (!jsonPatch.Condition.IsValue.Equals(val.GetValue()?.ToString() ?? "", StringComparison.InvariantCultureIgnoreCase))
						{
							api.Logger.VerboseDebug("Patch file {0}, patch {1}: Unmet IsValue condition ({2}!={3})", new object[4]
							{
								item.Location,
								num3,
								jsonPatch.Condition.IsValue,
								val.GetValue()?.ToString() ?? ""
							});
							num2++;
							continue;
						}
					}
					if (jsonPatch.DependsOn != null)
					{
						bool flag = true;
						PatchModDependence[] dependsOn = jsonPatch.DependsOn;
						foreach (PatchModDependence patchModDependence in dependsOn)
						{
							bool flag2 = hashSet.Contains(patchModDependence.modid);
							flag = flag && (flag2 ^ patchModDependence.invert);
						}
						if (!flag)
						{
							num2++;
							api.Logger.VerboseDebug("Patch file {0}, patch {1}: Unmet DependsOn condition ({2})", new object[3]
							{
								item.Location,
								num3,
								string.Join(",", jsonPatch.DependsOn.Select((PatchModDependence pd) => (pd.invert ? "!" : "") + pd.modid))
							});
							continue;
						}
					}
					if (forPartialPath == null || jsonPatch.File.PathStartsWith(forPartialPath))
					{
						num++;
						ApplyPatch(num3, item.Location, jsonPatch, ref applied, ref notFound, ref errorCount);
					}
				}
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("JsonPatch Loader: ");
			if (num == 0)
			{
				stringBuilder.Append("Nothing to patch");
			}
			else
			{
				stringBuilder.Append($"{num} patches total");
				if (applied > 0)
				{
					stringBuilder.Append($", successfully applied {applied} patches");
				}
				if (notFound > 0)
				{
					stringBuilder.Append($", missing files on {notFound} patches");
				}
				if (num2 > 0)
				{
					stringBuilder.Append($", unmet conditions on {num2} patches");
				}
				if (errorCount > 0)
				{
					stringBuilder.Append($", had errors on {errorCount} patches");
				}
				else
				{
					stringBuilder.Append(string.Format(", no errors", errorCount));
				}
			}
			api.Logger.Notification(stringBuilder.ToString());
			api.Logger.VerboseDebug("Patchloader finished");
		}

		public void ApplyPatch(int patchIndex, AssetLocation patchSourcefile, JsonPatch jsonPatch, ref int applied, ref int notFound, ref int errorCount)
		{
			//IL_04e0: Expected O, but got Unknown
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Invalid comparison between Unknown and I4
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_035a: Unknown result type (might be due to invalid IL or missing references)
			//IL_035f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0366: Unknown result type (might be due to invalid IL or missing references)
			//IL_0370: Expected O, but got Unknown
			//IL_0371: Expected O, but got Unknown
			//IL_03de: Unknown result type (might be due to invalid IL or missing references)
			//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f4: Expected O, but got Unknown
			//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0405: Expected O, but got Unknown
			//IL_0406: Expected O, but got Unknown
			//IL_0408: Unknown result type (might be due to invalid IL or missing references)
			//IL_040d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0414: Unknown result type (might be due to invalid IL or missing references)
			//IL_041e: Expected O, but got Unknown
			//IL_041e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0425: Unknown result type (might be due to invalid IL or missing references)
			//IL_042f: Expected O, but got Unknown
			//IL_0430: Expected O, but got Unknown
			//IL_0432: Unknown result type (might be due to invalid IL or missing references)
			//IL_0437: Unknown result type (might be due to invalid IL or missing references)
			//IL_043e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0448: Expected O, but got Unknown
			//IL_0448: Unknown result type (might be due to invalid IL or missing references)
			//IL_045a: Expected O, but got Unknown
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Invalid comparison between Unknown and I4
			//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d8: Expected O, but got Unknown
			//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ea: Expected O, but got Unknown
			//IL_032d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0332: Unknown result type (might be due to invalid IL or missing references)
			//IL_0339: Unknown result type (might be due to invalid IL or missing references)
			//IL_0343: Expected O, but got Unknown
			//IL_0343: Unknown result type (might be due to invalid IL or missing references)
			//IL_0355: Expected O, but got Unknown
			//IL_0464: Unknown result type (might be due to invalid IL or missing references)
			//IL_046a: Expected O, but got Unknown
			//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ca: Expected O, but got Unknown
			//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_03dc: Expected O, but got Unknown
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			if ((int)((!jsonPatch.Side.HasValue) ? jsonPatch.File.Category.SideType : jsonPatch.Side.Value) != 3 && jsonPatch.Side != (EnumAppSide?)api.Side)
			{
				return;
			}
			if (jsonPatch.File == (AssetLocation)null)
			{
				api.World.Logger.Error("Patch {0} in {1} failed because it is missing the target file property", new object[2] { patchIndex, patchSourcefile });
				return;
			}
			AssetLocation val = jsonPatch.File.Clone();
			if (jsonPatch.File.Path.EndsWith('*'))
			{
				foreach (IAsset item in api.Assets.GetMany(jsonPatch.File.Path.TrimEnd('*'), jsonPatch.File.Domain, false))
				{
					jsonPatch.File = item.Location;
					ApplyPatch(patchIndex, patchSourcefile, jsonPatch, ref applied, ref notFound, ref errorCount);
				}
				jsonPatch.File = val;
				return;
			}
			if (!StringUtil.EndsWithOrdinal(val.Path, ".json"))
			{
				val.Path += ".json";
			}
			IAsset val2 = api.Assets.TryGet(val, true);
			if (val2 == null)
			{
				if (jsonPatch.File.Category == null)
				{
					api.World.Logger.VerboseDebug("Patch {0} in {1}: File {2} not found. Wrong asset category", new object[3] { patchIndex, patchSourcefile, val });
				}
				else
				{
					EnumAppSide sideType = jsonPatch.File.Category.SideType;
					if ((int)sideType != 3 && api.Side != sideType)
					{
						api.World.Logger.VerboseDebug("Patch {0} in {1}: File {2} not found. Hint: This asset is usually only loaded {3} side", new object[4] { patchIndex, patchSourcefile, val, sideType });
					}
					else
					{
						api.World.Logger.VerboseDebug("Patch {0} in {1}: File {2} not found", new object[3] { patchIndex, patchSourcefile, val });
					}
				}
				notFound++;
				return;
			}
			Operation val3 = null;
			switch (jsonPatch.Op)
			{
			case EnumJsonPatchOp.Add:
				if (jsonPatch.Value == null)
				{
					api.World.Logger.Error("Patch {0} in {1} failed probably because it is an add operation and the value property is not set or misspelled", new object[2] { patchIndex, patchSourcefile });
					errorCount++;
					return;
				}
				val3 = (Operation)new AddReplaceOperation
				{
					Path = new JsonPointer(jsonPatch.Path),
					Value = jsonPatch.Value.Token
				};
				break;
			case EnumJsonPatchOp.AddEach:
				if (jsonPatch.Value == null)
				{
					api.World.Logger.Error("Patch {0} in {1} failed probably because it is an add each operation and the value property is not set or misspelled", new object[2] { patchIndex, patchSourcefile });
					errorCount++;
					return;
				}
				val3 = (Operation)new AddEachOperation
				{
					Path = new JsonPointer(jsonPatch.Path),
					Value = jsonPatch.Value.Token
				};
				break;
			case EnumJsonPatchOp.Remove:
				val3 = (Operation)new RemoveOperation
				{
					Path = new JsonPointer(jsonPatch.Path)
				};
				break;
			case EnumJsonPatchOp.Replace:
				if (jsonPatch.Value == null)
				{
					api.World.Logger.Error("Patch {0} in {1} failed probably because it is a replace operation and the value property is not set or misspelled", new object[2] { patchIndex, patchSourcefile });
					errorCount++;
					return;
				}
				val3 = (Operation)new ReplaceOperation
				{
					Path = new JsonPointer(jsonPatch.Path),
					Value = jsonPatch.Value.Token
				};
				break;
			case EnumJsonPatchOp.Copy:
				val3 = (Operation)new CopyOperation
				{
					Path = new JsonPointer(jsonPatch.Path),
					FromPath = new JsonPointer(jsonPatch.FromPath)
				};
				break;
			case EnumJsonPatchOp.Move:
				val3 = (Operation)new MoveOperation
				{
					Path = new JsonPointer(jsonPatch.Path),
					FromPath = new JsonPointer(jsonPatch.FromPath)
				};
				break;
			case EnumJsonPatchOp.AddMerge:
				val3 = (Operation)new AddMergeOperation
				{
					Path = new JsonPointer(jsonPatch.Path),
					Value = jsonPatch.Value.Token
				};
				break;
			}
			PatchDocument val4 = new PatchDocument((Operation[])(object)new Operation[1] { val3 });
			JToken val5;
			try
			{
				val5 = JToken.Parse(val2.ToText());
			}
			catch (Exception ex)
			{
				api.World.Logger.Error("Patch {0} (target: {2}) in {1} failed probably because the syntax of the value is broken:", new object[3] { patchIndex, patchSourcefile, val });
				api.World.Logger.Error(ex);
				errorCount++;
				return;
			}
			try
			{
				val4.ApplyTo(val5);
			}
			catch (PathNotFoundException ex2)
			{
				PathNotFoundException ex3 = ex2;
				api.World.Logger.Error("Patch {0} (target: {4}) in {1} failed because supplied path {2} is invalid: {3}", new object[5]
				{
					patchIndex,
					patchSourcefile,
					jsonPatch.Path,
					((Exception)(object)ex3).Message,
					val
				});
				errorCount++;
				return;
			}
			catch (Exception ex4)
			{
				api.World.Logger.Error("Patch {0} (target: {2}) in {1} failed, following Exception was thrown:", new object[3] { patchIndex, patchSourcefile, val });
				api.World.Logger.Error(ex4);
				errorCount++;
				return;
			}
			string s = ((object)val5).ToString();
			val2.Data = Encoding.UTF8.GetBytes(s);
			val2.IsPatched = true;
			applied++;
		}
	}
	[DocumentAsJson]
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public abstract class RegistryObjectType
	{
		internal volatile int parseStarted;

		[DocumentAsJson]
		public bool Enabled = true;

		public JObject jsonObject;

		[DocumentAsJson]
		public AssetLocation Code;

		[DocumentAsJson]
		public RegistryObjectVariantGroup[] VariantGroups;

		public OrderedDictionary<string, string> Variant = new OrderedDictionary<string, string>();

		[JsonProperty]
		public WorldInteraction[] Interactions;

		[JsonProperty]
		public AssetLocation[] SkipVariants;

		[JsonProperty]
		public AssetLocation[] AllowedVariants;

		public HashSet<AssetLocation> AllowedVariantsQuickLookup = new HashSet<AssetLocation>();

		[JsonProperty]
		public string Class;

		[JsonProperty]
		public string[] Tags = Array.Empty<string>();

		public bool WildCardMatch(AssetLocation[] wildcards)
		{
			foreach (AssetLocation wildCard in wildcards)
			{
				if (WildCardMatch(wildCard))
				{
					return true;
				}
			}
			return false;
		}

		public bool WildCardMatch(AssetLocation wildCard)
		{
			if (wildCard == Code)
			{
				return true;
			}
			if (Code == (AssetLocation)null || wildCard.Domain != Code.Domain)
			{
				return false;
			}
			string text = Regex.Escape(wildCard.Path).Replace("\\*", "(.*)");
			return Regex.IsMatch(Code.Path, "^" + text + "$", RegexOptions.IgnoreCase);
		}

		public static bool WildCardMatches(string blockCode, List<string> wildCards, out string matchingWildcard)
		{
			foreach (string wildCard in wildCards)
			{
				if (WildcardUtil.Match(wildCard, blockCode))
				{
					matchingWildcard = wildCard;
					return true;
				}
			}
			matchingWildcard = null;
			return false;
		}

		public static bool WildCardMatch(AssetLocation wildCard, AssetLocation blockCode)
		{
			if (wildCard == blockCode)
			{
				return true;
			}
			string text = Regex.Escape(wildCard.Path).Replace("\\*", "(.*)");
			return Regex.IsMatch(blockCode.Path, "^" + text + "$", RegexOptions.IgnoreCase);
		}

		public static bool WildCardMatches(AssetLocation blockCode, List<AssetLocation> wildCards, out AssetLocation matchingWildcard)
		{
			foreach (AssetLocation wildCard in wildCards)
			{
				if (WildCardMatch(wildCard, blockCode))
				{
					matchingWildcard = wildCard;
					return true;
				}
			}
			matchingWildcard = null;
			return false;
		}

		internal virtual void CreateBasetype(ICoreAPI api, string filepathForLogging, string entryDomain, JObject entityTypeObject)
		{
			loadInherits(api, ref entityTypeObject, entryDomain, filepathForLogging);
			AssetLocation code;
			try
			{
				code = JsonUtil.ToObject<AssetLocation>(entityTypeObject.GetValue("code", StringComparison.InvariantCultureIgnoreCase), entryDomain, (JsonSerializerSettings)null);
			}
			catch (Exception innerException)
			{
				throw new Exception("Asset has no valid code property. Will ignore. Exception thrown:-", innerException);
			}
			Code = code;
			JToken val = default(JToken);
			if (entityTypeObject.TryGetValue("variantgroups", StringComparison.InvariantCultureIgnoreCase, ref val))
			{
				VariantGroups = val.ToObject<RegistryObjectVariantGroup[]>();
				entityTypeObject.Remove(val.Path);
			}
			if (entityTypeObject.TryGetValue("skipVariants", StringComparison.InvariantCultureIgnoreCase, ref val))
			{
				SkipVariants = JsonUtil.ToObject<AssetLocation[]>(val, entryDomain, (JsonSerializerSettings)null);
				entityTypeObject.Remove(val.Path);
			}
			if (entityTypeObject.TryGetValue("allowedVariants", StringComparison.InvariantCultureIgnoreCase, ref val))
			{
				AllowedVariants = JsonUtil.ToObject<AssetLocation[]>(val, entryDomain, (JsonSerializerSettings)null);
				entityTypeObject.Remove(val.Path);
			}
			if (entityTypeObject.TryGetValue("enabled", StringComparison.InvariantCultureIgnoreCase, ref val))
			{
				Enabled = val.ToObject<bool>();
				entityTypeObject.Remove(val.Path);
			}
			else
			{
				Enabled = true;
			}
			jsonObject = entityTypeObject;
		}

		private void loadInherits(ICoreAPI api, ref JObject entityTypeObject, string entryDomain, string parentFileNameForLogging)
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Expected O, but got Unknown
			JToken val = default(JToken);
			if (!entityTypeObject.TryGetValue("inheritFrom", StringComparison.InvariantCultureIgnoreCase, ref val))
			{
				return;
			}
			AssetLocation val2 = JsonUtil.ToObject<AssetLocation>(val, entryDomain, (JsonSerializerSettings)null).WithPathAppendixOnce(".json");
			IAsset val3 = api.Assets.TryGet(val2, true);
			if (val3 != null)
			{
				try
				{
					JObject entityTypeObject2 = JObject.Parse(val3.ToText());
					loadInherits(api, ref entityTypeObject2, entryDomain, val2.ToShortString());
					((JContainer)entityTypeObject2).Merge((object)entityTypeObject, new JsonMergeSettings
					{
						MergeArrayHandling = (MergeArrayHandling)2,
						PropertyNameComparison = StringComparison.InvariantCultureIgnoreCase
					});
					entityTypeObject = entityTypeObject2;
					entityTypeObject.Remove("inheritFrom");
					return;
				}
				catch (Exception ex)
				{
					api.Logger.Error(Lang.Get("File {0} wants to inherit from {1}, but this is not valid json. Exception: {2}.", new object[3] { parentFileNameForLogging, val2, ex }));
					return;
				}
			}
			api.Logger.Error(Lang.Get("File {0} wants to inherit from {1}, but this file does not exist. Will ignore.", new object[2] { parentFileNameForLogging, val2 }));
		}

		internal virtual RegistryObjectType CreateAndPopulate(ICoreServerAPI api, AssetLocation fullcode, JObject jobject, JsonSerializer deserializer, OrderedDictionary<string, string> variant)
		{
			return this;
		}

		protected T CreateResolvedType<T>(ICoreServerAPI api, AssetLocation fullcode, JObject jobject, JsonSerializer deserializer, OrderedDictionary<string, string> variant) where T : RegistryObjectType, new()
		{
			T val = new T
			{
				Code = Code,
				VariantGroups = VariantGroups,
				Enabled = Enabled,
				jsonObject = jobject,
				Variant = variant
			};
			try
			{
				solveByType((JToken)(object)jobject, fullcode.Path, variant);
			}
			catch (Exception ex)
			{
				api.Server.Logger.Error("Exception thrown while trying to resolve *byType properties of type {0}, variant {1}. Will ignore most of the attributes. Exception thrown:", new object[2] { Code, fullcode });
				api.Server.Logger.Error(ex);
			}
			try
			{
				JsonUtil.PopulateObject((object)val, (JToken)(object)jobject, deserializer);
			}
			catch (Exception ex2)
			{
				api.Server.Logger.Error("Exception thrown while trying to parse json data of the type with code {0}, variant {1}. Will ignore most of the attributes. Exception:", new object[2] { Code, fullcode });
				api.Server.Logger.Error(ex2);
			}
			val.Code = fullcode;
			val.jsonObject = null;
			return val;
		}

		protected static void solveByType(JToken json, string codePath, OrderedDictionary<string, string> searchReplace)
		{
			//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Invalid comparison between Unknown and I4
			JObject val = (JObject)(object)((json is JObject) ? json : null);
			if (val != null)
			{
				List<string> list = null;
				Dictionary<string, JToken> dictionary = null;
				foreach (KeyValuePair<string, JToken> item in val)
				{
					if (!item.Key.EndsWith("byType", StringComparison.OrdinalIgnoreCase))
					{
						continue;
					}
					string key = item.Key.Substring(0, item.Key.Length - "byType".Length);
					JToken value = item.Value;
					foreach (KeyValuePair<string, JToken> item2 in (JObject)(((value is JObject) ? value : null) ?? throw new FormatException("Invalid value at key: " + item.Key)))
					{
						if (WildcardUtil.Match(item2.Key, codePath))
						{
							JToken value2 = item2.Value;
							if (dictionary == null)
							{
								dictionary = new Dictionary<string, JToken>();
							}
							dictionary.Add(key, value2);
							break;
						}
					}
					if (list == null)
					{
						list = new List<string>();
					}
					list.Add(item.Key);
				}
				if (list != null)
				{
					foreach (string item3 in list)
					{
						val.Remove(item3);
					}
					if (dictionary != null)
					{
						foreach (KeyValuePair<string, JToken> item4 in dictionary)
						{
							JToken obj = val[item4.Key];
							JObject val2 = (JObject)(object)((obj is JObject) ? obj : null);
							if (val2 != null)
							{
								((JContainer)val2).Merge((object)item4.Value);
							}
							else
							{
								val[item4.Key] = item4.Value;
							}
						}
					}
				}
				{
					foreach (KeyValuePair<string, JToken> item5 in val)
					{
						solveByType(item5.Value, codePath, searchReplace);
					}
					return;
				}
			}
			if ((int)json.Type == 8)
			{
				string text = (string)((JValue)((json is JValue) ? json : null)).Value;
				if (text.Contains("{"))
				{
					((JValue)((json is JValue) ? json : null)).Value = RegistryObject.FillPlaceHolder(text, searchReplace);
				}
				return;
			}
			JArray val3 = (JArray)(object)((json is JArray) ? json : null);
			if (val3 == null)
			{
				return;
			}
			foreach (JToken item6 in val3)
			{
				solveByType(item6, codePath, searchReplace);
			}
		}
	}
	public class VariantEntry
	{
		public string Code;

		public List<string> Codes;

		public List<string> Types;
	}
	public class ResolvedVariant
	{
		public OrderedDictionary<string, string> CodeParts = new OrderedDictionary<string, string>();

		public AssetLocation Code;

		public void ResolveCode(AssetLocation baseCode)
		{
			Code = baseCode.Clone();
			foreach (string value in CodeParts.Values)
			{
				if (value.Length > 0)
				{
					AssetLocation code = Code;
					code.Path = code.Path + "-" + value;
				}
			}
		}

		public void AddCodePart(string key, string val)
		{
			CodeParts.Add(string.Intern(key), string.Intern(val));
		}
	}
	public class ModRegistryObjectTypeLoader : ModSystem
	{
		public Dictionary<AssetLocation, StandardWorldProperty> worldProperties;

		public Dictionary<AssetLocation, VariantEntry[]> worldPropertiesVariants;

		private Dictionary<AssetLocation, RegistryObjectType> blockTypes;

		private Dictionary<AssetLocation, RegistryObjectType> itemTypes;

		private Dictionary<AssetLocation, RegistryObjectType> entityTypes;

		private List<RegistryObjectType>[] itemVariants;

		private List<RegistryObjectType>[] blockVariants;

		private List<RegistryObjectType>[] entityVariants;

		private ICoreServerAPI api;

		public override bool ShouldLoad(EnumAppSide side)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)side == 1;
		}

		public override double ExecuteOrder()
		{
			return 0.2;
		}

		public override void AssetsLoaded(ICoreAPI coreApi)
		{
			ICoreServerAPI val = (ICoreServerAPI)(object)((coreApi is ICoreServerAPI) ? coreApi : null);
			if (val == null)
			{
				return;
			}
			api = val;
			((ICoreAPI)val).Logger.VerboseDebug("Starting to gather blocktypes, itemtypes and entities");
			LoadWorldProperties();
			int num = (val.Server.IsDedicated ? 3 : 8);
			int threadsCount = GameMath.Clamp(Environment.ProcessorCount / 2 - 2, 1, num);
			if (val.Server.ReducedServerThreads)
			{
				threadsCount = 1;
			}
			itemTypes = new Dictionary<AssetLocation, RegistryObjectType>();
			blockTypes = new Dictionary<AssetLocation, RegistryObjectType>();
			entityTypes = new Dictionary<AssetLocation, RegistryObjectType>();
			foreach (KeyValuePair<AssetLocation, JObject> item in ((ICoreAPI)val).Assets.GetMany<JObject>(val.Server.Logger, "itemtypes/", (string)null))
			{
				if (StringUtil.EndsWithOrdinal(item.Key.Path, ".json"))
				{
					try
					{
						ItemType itemType = new ItemType();
						itemType.CreateBasetype((ICoreAPI)(object)val, item.Key.Path, item.Key.Domain, item.Value);
						itemTypes.Add(item.Key, itemType);
					}
					catch (Exception ex)
					{
						((IWorldAccessor)val.World).Logger.Error("Item type {0} could not be loaded. Will ignore. Exception thrown:", new object[1] { item.Key });
						((IWorldAccessor)val.World).Logger.Error(ex);
					}
				}
			}
			itemVariants = new List<RegistryObjectType>[itemTypes.Count];
			((ICoreAPI)val).Logger.VerboseDebug("Starting parsing ItemTypes in " + threadsCount + " threads");
			PrepareForLoading(threadsCount);
			foreach (KeyValuePair<AssetLocation, JObject> item2 in ((ICoreAPI)val).Assets.GetMany<JObject>(val.Server.Logger, "entities/", (string)null))
			{
				if (StringUtil.EndsWithOrdinal(item2.Key.Path, ".json"))
				{
					try
					{
						EntityType entityType = new EntityType();
						entityType.CreateBasetype((ICoreAPI)(object)val, item2.Key.Path, item2.Key.Domain, item2.Value);
						entityTypes.Add(item2.Key, entityType);
					}
					catch (Exception ex2)
					{
						((IWorldAccessor)val.World).Logger.Error("Entity type {0} could not be loaded. Will ignore. Exception thrown:", new object[1] { item2.Key });
						((IWorldAccessor)val.World).Logger.Error(ex2);
					}
				}
			}
			entityVariants = new List<RegistryObjectType>[entityTypes.Count];
			foreach (KeyValuePair<AssetLocation, JObject> item3 in ((ICoreAPI)val).Assets.GetMany<JObject>(val.Server.Logger, "blocktypes/", (string)null))
			{
				if (StringUtil.EndsWithOrdinal(item3.Key.Path, ".json"))
				{
					try
					{
						BlockType blockType = new BlockType();
						blockType.CreateBasetype((ICoreAPI)(object)val, item3.Key.Path, item3.Key.Domain, item3.Value);
						blockTypes.Add(item3.Key, blockType);
					}
					catch (Exception ex3)
					{
						((IWorldAccessor)val.World).Logger.Error("Block type {0} could not be loaded. Will ignore. Exception thrown:", new object[1] { item3.Key });
						((IWorldAccessor)val.World).Logger.Error(ex3);
					}
				}
			}
			blockVariants = new List<RegistryObjectType>[blockTypes.Count];
			TyronThreadPool.QueueTask((Action)GatherAllTypes_Async, "gatheralltypes");
			((ICoreAPI)val).Logger.StoryEvent(Lang.Get("It remembers...", Array.Empty<object>()));
			((ICoreAPI)val).Logger.VerboseDebug("Gathered all types, starting to load items");
			LoadItems(itemVariants);
			((ICoreAPI)val).Logger.VerboseDebug("Parsed and loaded items");
			((ICoreAPI)val).Logger.StoryEvent(Lang.Get("...all that came before", Array.Empty<object>()));
			LoadBlocks(blockVariants);
			((ICoreAPI)val).Logger.VerboseDebug("Parsed and loaded blocks");
			LoadEntities(entityVariants);
			((ICoreAPI)val).Logger.VerboseDebug("Parsed and loaded entities");
			((ICoreAPI)val).TagRegistry.LoadTagsFromAssets(val);
			val.Server.LogNotification("BlockLoader: Entities, Blocks and Items loaded", Array.Empty<object>());
			FreeRam();
			val.TriggerOnAssetsFirstLoaded();
		}

		private void LoadWorldProperties()
		{
			worldProperties = new Dictionary<AssetLocation, StandardWorldProperty>();
			foreach (KeyValuePair<AssetLocation, StandardWorldProperty> item in ((ICoreAPI)api).Assets.GetMany<StandardWorldProperty>(api.Server.Logger, "worldproperties/", (string)null))
			{
				AssetLocation val = item.Key.Clone();
				val.Path = val.Path.Replace("worldproperties/", "");
				val.RemoveEnding();
				((WorldProperty<WorldPropertyVariant>)(object)item.Value).Code.Domain = item.Key.Domain;
				worldProperties.Add(val, item.Value);
			}
			worldPropertiesVariants = new Dictionary<AssetLocation, VariantEntry[]>();
			foreach (KeyValuePair<AssetLocation, StandardWorldProperty> worldProperty in worldProperties)
			{
				if (worldProperty.Value == null)
				{
					continue;
				}
				WorldPropertyVariant[] variants = ((WorldProperty<WorldPropertyVariant>)(object)worldProperty.Value).Variants;
				if (variants == null)
				{
					continue;
				}
				if (((WorldProperty<WorldPropertyVariant>)(object)worldProperty.Value).Code == (AssetLocation)null)
				{
					api.Server.LogError("Error in worldproperties {0}, code is null, so I won't load it", new object[1] { worldProperty.Key });
					continue;
				}
				worldPropertiesVariants[((WorldProperty<WorldPropertyVariant>)(object)worldProperty.Value).Code] = new VariantEntry[variants.Length];
				for (int i = 0; i < variants.Length; i++)
				{
					if (variants[i].Code == (AssetLocation)null)
					{
						api.Server.LogError("Error in worldproperties {0}, variant {1}, code is null, so I won't load it", new object[2] { worldProperty.Key, i });
						worldPropertiesVariants[((WorldProperty<WorldPropertyVariant>)(object)worldProperty.Value).Code] = ArrayExtensions.RemoveAt<VariantEntry>(worldPropertiesVariants[((WorldProperty<WorldPropertyVariant>)(object)worldProperty.Value).Code], i);
					}
					else
					{
						worldPropertiesVariants[((WorldProperty<WorldPropertyVariant>)(object)worldProperty.Value).Code][i] = new VariantEntry
						{
							Code = variants[i].Code.Path
						};
					}
				}
			}
		}

		private void LoadEntities(List<RegistryObjectType>[] variantLists)
		{
			LoadFromVariants(variantLists, "entitie", delegate(List<RegistryObjectType> variants)
			{
				foreach (EntityType variant in variants)
				{
					((ICoreAPI)api).TagRegistry.RegisterEntityTags(variant.Tags);
					((ICoreAPI)api).RegisterEntityClass(variant.Class, variant.CreateProperties((ICoreAPI)(object)api));
				}
			});
		}

		private void LoadItems(List<RegistryObjectType>[] variantLists)
		{
			LoadFromVariants(variantLists, "item", delegate(List<RegistryObjectType> variants)
			{
				foreach (ItemType variant in variants)
				{
					((ICoreAPI)api).TagRegistry.RegisterItemTags(variant.Tags);
					Item val = variant.CreateItem(api);
					try
					{
						api.RegisterItem(val);
					}
					catch (Exception ex)
					{
						api.Server.Logger.Error("Failed registering item {0}:", new object[1] { ((RegistryObject)val).Code });
						api.Server.Logger.Error(ex);
					}
				}
			});
		}

		private void LoadBlocks(List<RegistryObjectType>[] variantLists)
		{
			LoadFromVariants(variantLists, "block", delegate(List<RegistryObjectType> variants)
			{
				foreach (BlockType variant in variants)
				{
					((ICoreAPI)api).TagRegistry.RegisterBlockTags(variant.Tags);
					Block val = variant.CreateBlock(api);
					try
					{
						api.RegisterBlock(val);
					}
					catch (Exception ex)
					{
						api.Server.Logger.Error("Failed registering block {0}", new object[1] { ((RegistryObject)val).Code });
						api.Server.Logger.Error(ex);
					}
				}
			});
		}

		private void PrepareForLoading(int threadsCount)
		{
			for (int i = 0; i < threadsCount; i++)
			{
				TyronThreadPool.QueueTask((Action)GatherAllTypes_Async, "gatheralltypes" + i);
			}
		}

		private void GatherAllTypes_Async()
		{
			GatherTypes_Async(itemVariants, itemTypes);
			int num = 1000;
			bool flag = false;
			while (blockVariants == null)
			{
				if (--num == 0)
				{
					return;
				}
				if (!flag)
				{
					((ICoreAPI)api).Logger.VerboseDebug("Waiting for entityTypes to be gathered");
					flag = true;
				}
				Thread.Sleep(10);
			}
			if (flag)
			{
				((ICoreAPI)api).Logger.VerboseDebug("EntityTypes now all gathered");
			}
			GatherTypes_Async(blockVariants, blockTypes);
			num = 1000;
			flag = false;
			while (entityVariants == null)
			{
				if (--num == 0)
				{
					return;
				}
				if (!flag)
				{
					((ICoreAPI)api).Logger.VerboseDebug("Waiting for blockTypes to be gathered");
					flag = true;
				}
				Thread.Sleep(10);
			}
			if (flag)
			{
				((ICoreAPI)api).Logger.VerboseDebug("BlockTypes now all gathered");
			}
			GatherTypes_Async(entityVariants, entityTypes);
		}

		private void GatherTypes_Async(List<RegistryObjectType>[] resolvedTypeLists, Dictionary<AssetLocation, RegistryObjectType> baseTypes)
		{
			int num = 0;
			foreach (RegistryObjectType value in baseTypes.Values)
			{
				if (AsyncHelper.CanProceedOnThisThread(ref value.parseStarted))
				{
					List<RegistryObjectType> list = new List<RegistryObjectType>();
					try
					{
						if (value.Enabled)
						{
							GatherVariantsAndPopulate(value, list);
						}
					}
					finally
					{
						resolvedTypeLists[num] = list;
					}
				}
				num++;
			}
		}

		private void GatherVariantsAndPopulate(RegistryObjectType baseType, List<RegistryObjectType> typesResolved)
		{
			List<ResolvedVariant> list = null;
			if (baseType.VariantGroups != null && baseType.VariantGroups.Length != 0)
			{
				try
				{
					list = GatherVariants(baseType.Code, baseType.VariantGroups, baseType.Code, baseType.AllowedVariants, baseType.SkipVariants);
				}
				catch (Exception ex)
				{
					api.Server.Logger.Error("Exception thrown while trying to gather all variants of the block/item/entity type with code {0}. May lead to the whole type being ignored. Exception:", new object[1] { baseType.Code });
					api.Server.Logger.Error(ex);
					return;
				}
			}
			JsonSerializer deserializer = JsonUtil.CreateSerializerForDomain(baseType.Code.Domain, (JsonSerializerSettings)null);
			if (list == null || list.Count == 0)
			{
				RegistryObjectType item = baseType.CreateAndPopulate(api, baseType.Code.Clone(), baseType.jsonObject, deserializer, new OrderedDictionary<string, string>());
				typesResolved.Add(item);
			}
			else
			{
				int num = 1;
				foreach (ResolvedVariant item3 in list)
				{
					JObject jobject = (JObject)((num++ == list.Count) ? ((object)baseType.jsonObject) : ((object)/*isinst with value type is only supported in some contexts*/));
					RegistryObjectType item2 = baseType.CreateAndPopulate(api, item3.Code, jobject, deserializer, item3.CodeParts);
					typesResolved.Add(item2);
				}
			}
			baseType.jsonObject = null;
		}

		private void LoadFromVariants(List<RegistryObjectType>[] variantLists, string typeForLog, Action<List<RegistryObjectType>> register)
		{
			int num = 0;
			for (int i = 0; i < variantLists.Length; i++)
			{
				List<RegistryObjectType> list;
				for (list = variantLists[i]; list == null; list = variantLists[i])
				{
					Thread.Sleep(10);
				}
				num += list.Count;
				register(list);
			}
			api.Server.LogNotification("Loaded " + num + " unique " + typeForLog + "s", Array.Empty<object>());
		}

		public StandardWorldProperty GetWorldPropertyByCode(AssetLocation code)
		{
			worldProperties.TryGetValue(code, out var value);
			return value;
		}

		private List<ResolvedVariant> GatherVariants(AssetLocation baseCode, RegistryObjectVariantGroup[] variantgroups, AssetLocation location, AssetLocation[] allowedVariants, AssetLocation[] skipVariants)
		{
			List<ResolvedVariant> list = new List<ResolvedVariant>();
			OrderedDictionary<string, VariantEntry[]> val = new OrderedDictionary<string, VariantEntry[]>();
			for (int i = 0; i < variantgroups.Length; i++)
			{
				if (variantgroups[i].LoadFromProperties != (AssetLocation)null)
				{
					CollectFromWorldProperties(variantgroups[i], variantgroups, val, list, location);
				}
				if (variantgroups[i].LoadFromPropertiesCombine != null)
				{
					CollectFromWorldPropertiesCombine(variantgroups[i].LoadFromPropertiesCombine, variantgroups[i], variantgroups, val, list, location);
				}
				if (variantgroups[i].States != null)
				{
					CollectFromStateList(variantgroups[i], variantgroups, val, list, location);
				}
			}
			VariantEntry[,] array = MultiplyProperties(val.Values.ToArray());
			for (int j = 0; j < array.GetLength(0); j++)
			{
				ResolvedVariant resolvedVariant = new ResolvedVariant();
				for (int k = 0; k < array.GetLength(1); k++)
				{
					VariantEntry variantEntry = array[j, k];
					if (variantEntry.Codes != null)
					{
						for (int l = 0; l < variantEntry.Codes.Count; l++)
						{
							resolvedVariant.AddCodePart(variantEntry.Types[l], variantEntry.Codes[l]);
						}
					}
					else
					{
						resolvedVariant.AddCodePart(val.GetKeyAtIndex(k), variantEntry.Code);
					}
				}
				list.Add(resolvedVariant);
			}
			foreach (ResolvedVariant item in list)
			{
				item.ResolveCode(baseCode);
			}
			if (skipVariants != null)
			{
				List<ResolvedVariant> list2 = new List<ResolvedVariant>();
				HashSet<AssetLocation> hashSet = new HashSet<AssetLocation>();
				List<AssetLocation> list3 = new List<AssetLocation>();
				AssetLocation[] array2 = skipVariants;
				foreach (AssetLocation val2 in array2)
				{
					if (val2.IsWildCard)
					{
						list3.Add(val2);
					}
					else
					{
						hashSet.Add(val2);
					}
				}
				foreach (ResolvedVariant var in list)
				{
					if (!hashSet.Contains(var.Code) && !(((IEnumerable<AssetLocation>)list3).FirstOrDefault((Func<AssetLocation, bool>)((AssetLocation v) => WildcardUtil.Match(v, var.Code))) != (AssetLocation)null))
					{
						list2.Add(var);
					}
				}
				list = list2;
			}
			if (allowedVariants != null)
			{
				List<ResolvedVariant> list4 = new List<ResolvedVariant>();
				HashSet<AssetLocation> hashSet2 = new HashSet<AssetLocation>();
				List<AssetLocation> list5 = new List<AssetLocation>();
				AssetLocation[] array2 = allowedVariants;
				foreach (AssetLocation val3 in array2)
				{
					if (val3.IsWildCard)
					{
						list5.Add(val3);
					}
					else
					{
						hashSet2.Add(val3);
					}
				}
				foreach (ResolvedVariant var2 in list)
				{
					if (hashSet2.Contains(var2.Code) || ((IEnumerable<AssetLocation>)list5).FirstOrDefault((Func<AssetLocation, bool>)((AssetLocation v) => WildcardUtil.Match(v, var2.Code))) != (AssetLocation)null)
					{
						list4.Add(var2);
					}
				}
				list = list4;
			}
			return list;
		}

		private void CollectFromStateList(RegistryObjectVariantGroup variantGroup, RegistryObjectVariantGroup[] variantgroups, OrderedDictionary<string, VariantEntry[]> variantsMul, List<ResolvedVariant> blockvariantsFinal, AssetLocation filename)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Invalid comparison between Unknown and I4
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Invalid comparison between Unknown and I4
			if (variantGroup.Code == null)
			{
				api.Server.LogError("Error in itemtype {0}, a variantgroup using a state list must have a code. Ignoring.", new object[1] { filename });
				return;
			}
			string[] states = variantGroup.States;
			string code = variantGroup.Code;
			if ((int)variantGroup.Combine == 0)
			{
				for (int i = 0; i < states.Length; i++)
				{
					ResolvedVariant resolvedVariant = new ResolvedVariant();
					resolvedVariant.AddCodePart(code, states[i]);
					blockvariantsFinal.Add(resolvedVariant);
				}
			}
			if ((int)variantGroup.Combine != 1)
			{
				return;
			}
			List<VariantEntry> list = new List<VariantEntry>();
			for (int j = 0; j < states.Length; j++)
			{
				list.Add(new VariantEntry
				{
					Code = states[j]
				});
			}
			foreach (RegistryObjectVariantGroup registryObjectVariantGroup in variantgroups)
			{
				if ((int)registryObjectVariantGroup.Combine != 2 || !(registryObjectVariantGroup.OnVariant == variantGroup.Code))
				{
					continue;
				}
				for (int l = 0; l < list.Count; l++)
				{
					VariantEntry variantEntry = list[l];
					if (!(registryObjectVariantGroup.Code != variantEntry.Code))
					{
						list.RemoveAt(l);
						for (int m = 0; m < registryObjectVariantGroup.States.Length; m++)
						{
							List<string> list2 = variantEntry.Codes ?? new List<string> { variantEntry.Code };
							List<string> list3 = variantEntry.Types ?? new List<string> { variantGroup.Code };
							string text = registryObjectVariantGroup.States[m];
							list2.Add(text);
							list3.Add(registryObjectVariantGroup.Code);
							list.Insert(l, new VariantEntry
							{
								Code = ((text.Length == 0) ? variantEntry.Code : (variantEntry.Code + "-" + text)),
								Codes = list2,
								Types = list3
							});
						}
					}
				}
			}
			if (variantsMul.ContainsKey(code))
			{
				list.AddRange(variantsMul[code]);
				variantsMul[code] = list.ToArray();
			}
			else
			{
				variantsMul.Add(code, list.ToArray());
			}
		}

		private void CollectFromWorldProperties(RegistryObjectVariantGroup variantGroup, RegistryObjectVariantGroup[] variantgroups, OrderedDictionary<string, VariantEntry[]> blockvariantsMul, List<ResolvedVariant> blockvariantsFinal, AssetLocation location)
		{
			CollectFromWorldPropertiesCombine((AssetLocation[])(object)new AssetLocation[1] { variantGroup.LoadFromProperties }, variantGroup, variantgroups, blockvariantsMul, blockvariantsFinal, location);
		}

		private void CollectFromWorldPropertiesCombine(AssetLocation[] propList, RegistryObjectVariantGroup variantGroup, RegistryObjectVariantGroup[] variantgroups, OrderedDictionary<string, VariantEntry[]> blockvariantsMul, List<ResolvedVariant> blockvariantsFinal, AssetLocation location)
		{
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Invalid comparison between Unknown and I4
			if (propList.Length > 1 && variantGroup.Code == null)
			{
				api.Server.LogError("Error in item or block {0}, defined a variantgroup with loadFromPropertiesCombine (first element: {1}), but did not explicitly declare a code for this variant group, hence I do not know which code to use. Ignoring.", new object[2]
				{
					location,
					propList[0]
				});
				return;
			}
			VariantEntry[] array = default(VariantEntry[]);
			foreach (AssetLocation code in propList)
			{
				StandardWorldProperty worldPropertyByCode = GetWorldPropertyByCode(code);
				if (worldPropertyByCode == null)
				{
					api.Server.LogError("Error in item or block {0}, worldproperty {1} does not exist (or is empty). Ignoring.", new object[2] { location, variantGroup.LoadFromProperties });
					break;
				}
				string text = ((variantGroup.Code == null) ? ((WorldProperty<WorldPropertyVariant>)(object)worldPropertyByCode).Code.Path : variantGroup.Code);
				if ((int)variantGroup.Combine == 0)
				{
					WorldPropertyVariant[] variants = ((WorldProperty<WorldPropertyVariant>)(object)worldPropertyByCode).Variants;
					foreach (WorldPropertyVariant val in variants)
					{
						ResolvedVariant resolvedVariant = new ResolvedVariant();
						resolvedVariant.AddCodePart(text, val.Code.Path);
						blockvariantsFinal.Add(resolvedVariant);
					}
				}
				if ((int)variantGroup.Combine == 1)
				{
					if (blockvariantsMul.TryGetValue(text, ref array))
					{
						blockvariantsMul[text] = ArrayExtensions.Append<VariantEntry>(array, worldPropertiesVariants[((WorldProperty<WorldPropertyVariant>)(object)worldPropertyByCode).Code]);
					}
					else
					{
						blockvariantsMul.Add(text, worldPropertiesVariants[((WorldProperty<WorldPropertyVariant>)(object)worldPropertyByCode).Code]);
					}
				}
			}
		}

		private VariantEntry[,] MultiplyProperties(VariantEntry[][] variants)
		{
			int num = 1;
			for (int i = 0; i < variants.Length; i++)
			{
				num *= variants[i].Length;
			}
			VariantEntry[,] array = new VariantEntry[num, variants.Length];
			for (int j = 0; j < num; j++)
			{
				int num2 = j;
				for (int k = 0; k < variants.Length; k++)
				{
					int num3 = variants[k].Length;
					VariantEntry variantEntry = variants[k][num2 % num3];
					array[j, k] = new VariantEntry
					{
						Code = variantEntry.Code,
						Codes = variantEntry.Codes,
						Types = variantEntry.Types
					};
					num2 /= num3;
				}
			}
			return array;
		}

		private void FreeRam()
		{
			blockTypes = null;
			blockVariants = null;
			itemTypes = null;
			itemVariants = null;
			entityTypes = null;
			entityVariants = null;
			worldProperties = null;
			worldPropertiesVariants = null;
		}
	}
}
namespace Vintagestory.GameContent
{
	public interface ILongInteractable : IInteractable
	{
		void OnBlockInteractStop(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling);

		bool OnBlockInteractStep(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling);

		bool OnBlockInteractCancel(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling);
	}
	public interface IInteractable
	{
		bool OnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling);
	}
	public class BlockBehaviorBlockEntityInteract : BlockBehavior
	{
		public BlockBehaviorBlockEntityInteract(Block block)
			: base(block)
		{
		}

		public override bool OnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling)
		{
			handling = (EnumHandling)0;
			return getInteractable(world, blockSel.Position)?.OnBlockInteractStart(world, byPlayer, blockSel, ref handling) ?? false;
		}

		public override bool OnBlockInteractCancel(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling)
		{
			handling = (EnumHandling)0;
			if (getInteractable(world, blockSel.Position) is ILongInteractable longInteractable)
			{
				return longInteractable.OnBlockInteractCancel(secondsUsed, world, byPlayer, blockSel, ref handling);
			}
			return false;
		}

		public override bool OnBlockInteractStep(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling)
		{
			handling = (EnumHandling)0;
			if (getInteractable(world, blockSel.Position) is ILongInteractable longInteractable)
			{
				return longInteractable.OnBlockInteractStep(secondsUsed, world, byPlayer, blockSel, ref handling);
			}
			return false;
		}

		public override void OnBlockInteractStop(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling)
		{
			handling = (EnumHandling)0;
			if (getInteractable(world, blockSel.Position) is ILongInteractable longInteractable)
			{
				longInteractable.OnBlockInteractStop(secondsUsed, world, byPlayer, blockSel, ref handling);
			}
		}

		private IInteractable getInteractable(IWorldAccessor world, BlockPos pos)
		{
			BlockEntity blockEntity = world.BlockAccessor.GetBlockEntity(pos);
			if (blockEntity is IInteractable result)
			{
				return result;
			}
			if (blockEntity == null)
			{
				return null;
			}
			foreach (BlockEntityBehavior behavior in blockEntity.Behaviors)
			{
				if (behavior is IInteractable)
				{
					return behavior as IInteractable;
				}
			}
			return null;
		}
	}
	[AddDocumentationProperty("Sides", "A list of sides that this decor block can be placed on.", "System.String[]", "Required", "", false)]
	[AddDocumentationProperty("DrawIfCulled", "If true, do not cull even if parent face was culled (used e.g. for medium carpet, which stick out beyond the parent face)", "System.Boolean", "Optional", "False", false)]
	[AddDocumentationProperty("AlternateZOffset", "If true, alternates z-offset vertexflag by 1 in odd/even XZ positions to reduce z-fighting (used e.g. for medium carpets overlaying neighbours)", "System.Boolean", "Optional", "False", false)]
	[AddDocumentationProperty("NotFullFace", "If true, this decor is NOT (at least) a full opaque face so that the parent block face still needs to be drawn", "System.Boolean", "Optional", "False", false)]
	[AddDocumentationProperty("Removable", "If true, this decor is removable using the players hands, without breaking the parent block", "System.Boolean", "Optional", "False", false)]
	[AddDocumentationProperty("Thickness", "The thickness of this decor block. Used to adjust selection box of the parent block.", "System.Single", "Optional", "0.03125", false)]
	[DocumentAsJson]
	public class BlockBehaviorDecor : BlockBehavior
	{
		private BlockFacing[] sides;

		[DocumentAsJson("Optional", "False", false)]
		private bool sidedVariants;

		[DocumentAsJson("Optional", "False", false)]
		private bool nwOrientable;

		public BlockBehaviorDecor(Block block)
			: base(block)
		{
			block.decorBehaviorFlags = 1;
		}

		public override void Initialize(JsonObject properties)
		{
			string[] array = properties["sides"].AsArray<string>(Array.Empty<string>(), (string)null);
			sides = (BlockFacing[])(object)new BlockFacing[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != null)
				{
					sides[i] = BlockFacing.FromFirstLetter(array[i][0]);
				}
			}
			sidedVariants = properties["sidedVariants"].AsBool(false);
			nwOrientable = properties["nwOrientable"].AsBool(false);
			if (properties["drawIfCulled"].AsBool(false))
			{
				Block block = base.block;
				block.decorBehaviorFlags |= 2;
			}
			if (properties["alternateZOffset"].AsBool(false))
			{
				Block block2 = base.block;
				block2.decorBehaviorFlags |= 4;
			}
			if (properties["notFullFace"].AsBool(false))
			{
				Block block3 = base.block;
				block3.decorBehaviorFlags |= 8;
			}
			if (properties["removable"].AsBool(false))
			{
				Block block4 = base.block;
				block4.decorBehaviorFlags |= 0x10;
			}
			if (sidedVariants)
			{
				Block block5 = base.block;
				block5.decorBehaviorFlags |= 0x20;
			}
			base.block.DecorThickness = properties["thickness"].AsFloat(1f / 32f);
			((CollectibleBehavior)this).Initialize(properties);
		}

		public override bool TryPlaceBlock(IWorldAccessor world, IPlayer byPlayer, ItemStack itemstack, BlockSelection blockSel, ref EnumHandling handling, ref string failureCode)
		{
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_0198: Invalid comparison between Unknown and I4
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Invalid comparison between Unknown and I4
			//IL_019a: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Invalid comparison between Unknown and I4
			//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Expected O, but got Unknown
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Expected O, but got Unknown
			//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Invalid comparison between Unknown and I4
			handling = (EnumHandling)2;
			DecorBits val4 = default(DecorBits);
			for (int i = 0; i < sides.Length; i++)
			{
				if (sides[i] != blockSel.Face)
				{
					continue;
				}
				BlockPos val = blockSel.Position.AddCopy(blockSel.Face.Opposite);
				Block block;
				if (sidedVariants)
				{
					block = world.BlockAccessor.GetBlock(((RegistryObject)base.block).CodeWithParts(blockSel.Face.Opposite.Code));
					if (block == null)
					{
						failureCode = "decorvariantnotfound";
						return false;
					}
				}
				else if (nwOrientable)
				{
					string text = (((int)Block.SuggestedHVOrientation(byPlayer, blockSel)[0].Axis == 0) ? "we" : "ns");
					block = world.BlockAccessor.GetBlock(((RegistryObject)base.block).CodeWithParts(text));
					if (block == null)
					{
						failureCode = "decorvariantnotfound";
						return false;
					}
				}
				else
				{
					block = base.block;
				}
				Block block2 = world.BlockAccessor.GetBlock(val);
				IAcceptsDecor val2 = block2.GetInterface<IAcceptsDecor>(world, val);
				if (val2 != null && val2.CanAccept(block))
				{
					if ((int)byPlayer.WorldData.CurrentGameMode == 1)
					{
						int decor = val2.GetDecor(blockSel.Face);
						if (decor > 0)
						{
							Block block3 = world.BlockAccessor.GetBlock(decor);
							ItemStack val3 = new ItemStack(((CollectibleObject)block3).Id, ((CollectibleObject)block3).ItemClass, 1, new TreeAttribute(), world);
							world.SpawnItemEntity(val3, val.AddCopy(blockSel.Face).ToVec3d(), (Vec3d)null);
						}
					}
					val2.SetDecor(block, blockSel.Face);
					return true;
				}
				EnumBlockMaterial blockMaterial = block2.GetBlockMaterial(world.BlockAccessor, val, (ItemStack)null);
				if (!block2.CanAttachBlockAt(world.BlockAccessor, block, val, blockSel.Face, (Cuboidi)null) || (int)blockMaterial == 9 || (int)blockMaterial == 10)
				{
					failureCode = "decorrequiressolid";
					return false;
				}
				((DecorBits)(ref val4))._002Ector(blockSel.Face);
				Block decor2 = world.BlockAccessor.GetDecor(val, DecorBits.op_Implicit(val4));
				if (world.BlockAccessor.SetDecor(block, val, DecorBits.op_Implicit(val4)))
				{
					if ((int)byPlayer.WorldData.CurrentGameMode == 1 && decor2 != null && (decor2.decorBehaviorFlags & 0x10) != 0)
					{
						ItemStack val5 = decor2.OnPickBlock(world, val);
						world.SpawnItemEntity(val5, val.AddCopy(blockSel.Face).ToVec3d(), (Vec3d)null);
					}
					return true;
				}
				failureCode = "existingdecorinplace";
				return false;
			}
			failureCode = "cannotplacedecorhere";
			return false;
		}

		public override AssetLocation GetRotatedBlockCode(int angle, ref EnumHandling handled)
		{
			if (nwOrientable)
			{
				handled = (EnumHandling)2;
				string[] array = new string[2] { "ns", "we" };
				int num = angle / 90;
				if (((RegistryObject)base.block).LastCodePart(0) == "we")
				{
					num++;
				}
				return ((RegistryObject)base.block).CodeWithParts(array[num % 2]);
			}
			return ((BlockBehavior)this).GetRotatedBlockCode(angle, ref handled);
		}
	}
	[DocumentAsJson]
	public class BlockBehaviorMultiblock : BlockBehavior
	{
		[DocumentAsJson("Recommended", "3", false)]
		private int SizeX;

		[DocumentAsJson("Recommended", "3", false)]
		private int SizeY;

		[DocumentAsJson("Recommended", "3", false)]
		private int SizeZ;

		[DocumentAsJson("Recommended", "(1, 0, 1)", false)]
		private Vec3i ControllerPositionRel;

		private string type;

		public BlockBehaviorMultiblock(Block block)
			: base(block)
		{
		}

		public override void Initialize(JsonObject properties)
		{
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Expected O, but got Unknown
			((CollectibleBehavior)this).Initialize(properties);
			SizeX = properties["sizex"].AsInt(3);
			SizeY = properties["sizey"].AsInt(3);
			SizeZ = properties["sizez"].AsInt(3);
			type = properties["type"].AsString("monolithic");
			ControllerPositionRel = properties["cposition"].AsObject<Vec3i>(new Vec3i(1, 0, 1));
		}

		public override bool CanPlaceBlock(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling, ref string failureCode)
		{
			bool blocked = false;
			IterateOverEach(blockSel.Position, delegate(BlockPos mpos)
			{
				if (mpos == blockSel.Position)
				{
					return true;
				}
				if (!world.BlockAccessor.GetBlock(mpos).IsReplacableBy(base.block))
				{
					blocked = true;
					return false;
				}
				return true;
			});
			if (blocked)
			{
				handling = (EnumHandling)2;
				failureCode = "notenoughspace";
				return false;
			}
			return true;
		}

		public override void OnBlockPlaced(IWorldAccessor world, BlockPos pos, ref EnumHandling handling)
		{
			handling = (EnumHandling)0;
			IterateOverEach(pos, delegate(BlockPos mpos)
			{
				//IL_0122: Unknown result type (might be due to invalid IL or missing references)
				//IL_0129: Expected O, but got Unknown
				if (mpos == pos)
				{
					return true;
				}
				int num = mpos.X - pos.X;
				int num2 = mpos.Y - pos.Y;
				int num3 = mpos.Z - pos.Z;
				string text = ((num < 0) ? "n" : ((num > 0) ? "p" : "")) + Math.Abs(num);
				string text2 = ((num2 < 0) ? "n" : ((num2 > 0) ? "p" : "")) + Math.Abs(num2);
				string text3 = ((num3 < 0) ? "n" : ((num3 > 0) ? "p" : "")) + Math.Abs(num3);
				AssetLocation val = new AssetLocation("multiblock-" + type + "-" + text + "-" + text2 + "-" + text3);
				Block block = world.GetBlock(val);
				if (block == null)
				{
					throw new IndexOutOfRangeException("Multiblocks are currently limited to 5x5x5 with the controller being in the middle of it, yours likely exceeds the limit because I could not find block with code " + val.Path);
				}
				world.BlockAccessor.SetBlock(((CollectibleObject)block).Id, mpos);
				return true;
			});
		}

		public void IterateOverEach(BlockPos controllerPos, ActionConsumable<BlockPos> onBlock)
		{
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Expected O, but got Unknown
			int num = controllerPos.X - ControllerPositionRel.X;
			int num2 = controllerPos.Y - ControllerPositionRel.Y;
			int num3 = controllerPos.Z - ControllerPositionRel.Z;
			BlockPos val = new BlockPos(controllerPos.dimension);
			for (int i = 0; i < SizeX; i++)
			{
				for (int j = 0; j < SizeY; j++)
				{
					for (int k = 0; k < SizeZ; k++)
					{
						val.Set(num + i, num2 + j, num3 + k);
						if (!onBlock.Invoke(val))
						{
							return;
						}
					}
				}
			}
		}

		public override void OnBlockRemoved(IWorldAccessor world, BlockPos pos, ref EnumHandling handling)
		{
			IterateOverEach(pos, delegate(BlockPos mpos)
			{
				if (mpos == pos)
				{
					return true;
				}
				if (world.BlockAccessor.GetBlock(mpos) is BlockMultiblock)
				{
					world.BlockAccessor.SetBlock(0, mpos);
				}
				return true;
			});
			world.BlockAccessor.MarkBlockModified(pos);
		}
	}
	[DocumentAsJson]
	public class BlockBehaviorRopeTieable : BlockBehavior
	{
		private ClothManager cm;

		public BlockBehaviorRopeTieable(Block block)
			: base(block)
		{
		}

		public override void Initialize(JsonObject properties)
		{
			((CollectibleBehavior)this).Initialize(properties);
		}

		public override void OnLoaded(ICoreAPI api)
		{
			((CollectibleBehavior)this).OnLoaded(api);
			cm = api.ModLoader.GetModSystem<ClothManager>(true);
		}

		public override bool OnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ref EnumHandling handling)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f9: Expected O, but got Unknown
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Expected O, but got Unknown
			//IL_0280: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Expected O, but got Unknown
			//IL_0373: Unknown result type (might be due to invalid IL or missing references)
			//IL_037d: Expected O, but got Unknown
			ItemSlot activeHotbarSlot = byPlayer.InventoryManager.ActiveHotbarSlot;
			ClothSystem cs = cm.GetClothSystemAttachedToBlock(blockSel.Position);
			if (cs != null)
			{
				Entity byEntity = (Entity)(object)byPlayer.Entity;
				Vec3d val = new Vec3d(0.0, byEntity.LocalEyePos.Y - 0.25, 0.0).AheadCopy(0.25, byEntity.SidedPos.Pitch, byEntity.SidedPos.Yaw);
				if (!activeHotbarSlot.Empty && ((RegistryObject)activeHotbarSlot.Itemstack.Collectible).Code.Path == "rope")
				{
					if (cs.FirstPoint.PinnedToEntity?.EntityId == ((Entity)byPlayer.Entity).EntityId || cs.LastPoint.PinnedToEntity?.EntityId == ((Entity)byPlayer.Entity).EntityId)
					{
						return ((BlockBehavior)this).OnBlockInteractStart(world, byPlayer, blockSel, ref handling);
					}
					int num = activeHotbarSlot.Itemstack.Attributes.GetInt("clothId", 0);
					if (((num == 0) ? null : cm.GetClothSystem(num)) != null)
					{
						return ((BlockBehavior)this).OnBlockInteractStart(world, byPlayer, blockSel, ref handling);
					}
					return false;
				}
				ClothPoint clothPoint = ((cs.FirstPoint.PinnedToBlockPos == blockSel.Position) ? cs.FirstPoint : cs.LastPoint);
				ItemStack val2 = new ItemStack(world.GetItem(new AssetLocation("rope")), 1);
				val2.Attributes.SetInt("clothId", cs.ClothId);
				val2.Attributes.SetLong("ropeHeldByEntityId", byEntity.EntityId);
				ItemStack ropestack = null;
				if (cs.FirstPoint.PinnedToEntity == byEntity || cs.LastPoint.PinnedToEntity == byEntity)
				{
					((EntityAgent)byPlayer.Entity).WalkInventory((OnInventorySlot)delegate(ItemSlot slot)
					{
						if (!slot.Empty && slot.Itemstack.Attributes != null && slot.Itemstack.Attributes.GetInt("clothId", 0) == cs.ClothId)
						{
							ropestack = slot.Itemstack;
							return false;
						}
						return true;
					});
					cs.WalkPoints(delegate(ClothPoint point)
					{
						if (point.PinnedToBlockPos != (BlockPos)null || point.PinnedToEntity?.EntityId == byEntity.EntityId)
						{
							point.UnPin();
						}
					});
					if (!cs.PinnedAnywhere)
					{
						cm.UnregisterCloth(cs.ClothId);
						if (ropestack != null)
						{
							ropestack.Attributes.RemoveAttribute("clothId");
							ropestack.Attributes.RemoveAttribute("ropeHeldByEntityId");
						}
					}
				}
				if (ropestack == null)
				{
					if (activeHotbarSlot.Empty)
					{
						activeHotbarSlot.Itemstack = val2;
						activeHotbarSlot.MarkDirty();
						clothPoint.PinTo(byEntity, val.ToVec3f());
					}
					else if (byPlayer.InventoryManager.TryGiveItemstack(val2, true))
					{
						clothPoint.PinTo(byEntity, val.ToVec3f());
					}
					else
					{
						Entity val3 = world.SpawnItemEntity(val2, blockSel.Position, (Vec3d)null);
						if (val3 != null)
						{
							clothPoint.PinTo(val3, new Vec3f(0f, 0.1f, 0f));
						}
					}
				}
				handling = (EnumHandling)2;
				return true;
			}
			return ((BlockBehavior)this).OnBlockInteractStart(world, byPlayer, blockSel, ref handling);
		}
	}
	[DocumentAsJson]
	[AddDocumentationProperty("TransformIntoBlock", "The asset location of the block to replace this one with.", "Vintagestory.API.Common.AssetLocation", "Required", "", false)]
	public class BlockBehaviorTransformBreak : BlockBehavior
	{
		private Block transformIntoBlock;

		private JsonObject properties;

		[DocumentAsJson("Optional", "False", false)]
		private bool withDrops;

		public BlockBehaviorTransformBreak(Block block)
			: base(block)
		{
		}

		public override void OnLoaded(ICoreAPI api)
		{
			if (!properties["transformIntoBlock"].Exists)
			{
				api.Logger.Error("Block {0}, required property transformIntoBlock does not exist", new object[1] { ((RegistryObject)base.block).Code });
				return;
			}
			AssetLocation val = AssetLocation.Create(properties["transformIntoBlock"].AsString((string)null), ((RegistryObject)base.block).Code.Domain);
			transformIntoBlock = api.World.GetBlock(val);
			if (transformIntoBlock == null)
			{
				api.Logger.Error("Block {0}, transformIntoBlock code '{1}' - no such block exists. Block will not transform upon breakage.", new object[2]
				{
					((RegistryObject)base.block).Code,
					val
				});
			}
			else
			{
				withDrops = properties["withDrops"].AsBool(false);
			}
		}

		public override void Initialize(JsonObject properties)
		{
			((CollectibleBehavior)this).Initialize(properties);
			this.properties = properties;
		}

		public override void OnBlockBroken(IWorldAccessor world, BlockPos pos, IPlayer byPlayer, ref EnumHandling handling)
		{
			if (transformIntoBlock != null)
			{
				handling = (EnumHandling)2;
				world.BlockAccessor.SetBlock(((CollectibleObject)transformIntoBlock).Id, pos);
				if (withDrops)
				{
					spawnDrops(world, pos, byPlayer);
				}
				base.block.SpawnBlockBrokenParticles(pos, byPlayer);
			}
		}

		private void spawnDrops(IWorldAccessor world, BlockPos pos, IPlayer byPlayer)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Invalid comparison between Unknown and I4
			if ((int)world.Side != 1 || (byPlayer != null && (int)byPlayer.WorldData.CurrentGameMode == 2))
			{
				return;
			}
			ItemStack[] drops = base.block.GetDrops(world, pos, byPlayer, 1f);
			if (drops != null)
			{
				for (int i = 0; i < drops.Length; i++)
				{
					if (base.block.SplitDropStacks)
					{
						for (int j = 0; j < drops[i].StackSize; j++)
						{
							ItemStack val = drops[i].Clone();
							val.StackSize = 1;
							world.SpawnItemEntity(val, pos, (Vec3d)null);
						}
					}
					else
					{
						world.SpawnItemEntity(drops[i].Clone(), pos, (Vec3d)null);
					}
				}
			}
			BlockSounds sounds = base.block.Sounds;
			world.PlaySoundAt((sounds != null) ? sounds.GetBreakSound(byPlayer) : null, pos, 0.0, byPlayer, true, 32f, 1f);
		}
	}
	public class BEBehaviorAnimatable : BlockEntityBehavior
	{
		public BlockEntityAnimationUtil animUtil;

		public BEBehaviorAnimatable(BlockEntity blockentity)
			: base(blockentity)
		{
		}

		public override void Initialize(ICoreAPI api, JsonObject properties)
		{
			((BlockEntityBehavior)this).Initialize(api, properties);
			animUtil = new BlockEntityAnimationUtil(api, base.Blockentity);
		}

		public override void OnBlockUnloaded()
		{
			((BlockEntityBehavior)this).OnBlockUnloaded();
			BlockEntityAnimationUtil blockEntityAnimationUtil = animUtil;
			if (blockEntityAnimationUtil != null)
			{
				((AnimationUtil)blockEntityAnimationUtil).Dispose();
			}
		}

		public override void OnBlockBroken(IPlayer byPlayer = null)
		{
			((BlockEntityBehavior)this).OnBlockBroken(byPlayer);
			BlockEntityAnimationUtil blockEntityAnimationUtil = animUtil;
			if (blockEntityAnimationUtil != null)
			{
				((AnimationUtil)blockEntityAnimationUtil).Dispose();
			}
		}

		public override void OnBlockRemoved()
		{
			((BlockEntityBehavior)this).OnBlockRemoved();
			BlockEntityAnimationUtil blockEntityAnimationUtil = animUtil;
			if (blockEntityAnimationUtil != null)
			{
				((AnimationUtil)blockEntityAnimationUtil).Dispose();
			}
		}

		public override void FromTreeAttributes(ITreeAttribute tree, IWorldAccessor worldAccessForResolve)
		{
			((BlockEntityBehavior)this).FromTreeAttributes(tree, worldAccessForResolve);
		}

		public override void ToTreeAttributes(ITreeAttribute tree)
		{
			((BlockEntityBehavior)this).ToTreeAttributes(tree);
		}

		public override bool OnTesselation(ITerrainMeshPool mesher, ITesselatorAPI tessThreadTesselator)
		{
			if (((AnimationUtil)animUtil).activeAnimationsByAnimCode.Count <= 0)
			{
				if (((AnimationUtil)animUtil).animator != null)
				{
					return ((AnimationUtil)animUtil).animator.ActiveAnimationCount > 0;
				}
				return false;
			}
			return true;
		}

		public override void GetBlockInfo(IPlayer forPlayer, StringBuilder dsc)
		{
			ICoreAPI api = base.Api;
			ICoreClientAPI val = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			if (val != null && val.Settings.Bool["extendedDebugInfo"])
			{
				dsc.AppendLine(string.Format("Active animations: {0}", string.Join(", ", ((AnimationUtil)animUtil).activeAnimationsByAnimCode.Keys)));
			}
		}
	}
	public class BlockEntityAnimationUtil : AnimationUtil
	{
		private BlockEntity be;

		public Action<MeshData> OnAfterTesselate;

		public BlockEntityAnimationUtil(ICoreAPI api, BlockEntity be)
			: base(api, be.Pos.ToVec3d())
		{
			this.be = be;
		}

		public virtual MeshData InitializeAnimator(string cacheDictKey, Shape shape = null, ITexPositionSource texSource = null, Vec3f rotationDeg = null)
		{
			Shape resultingShape;
			MeshData val = CreateMesh(cacheDictKey, shape, out resultingShape, texSource);
			if (base.renderer != null && Environment.CurrentManagedThreadId != RuntimeEnv.MainThreadId)
			{
				throw new InvalidOperationException("If the renderer has already been created, then InitializeAnimator() cannot be safely called outside the main thread");
			}
			((AnimationUtil)this).InitializeAnimator(cacheDictKey, val, resultingShape, rotationDeg, (EnumRenderStage)1);
			return val;
		}

		public virtual MeshData CreateMesh(string nameForLogging, Shape shape, out Shape resultingShape, ITexPositionSource texSource)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Expected O, but got Unknown
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Expected O, but got Unknown
			if ((int)base.api.Side != 2)
			{
				throw new NotImplementedException("Server side animation system not implemented yet.");
			}
			ICoreAPI api = base.api;
			ICoreClientAPI val = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			Block block = base.api.World.BlockAccessor.GetBlock(be.Pos);
			if (texSource == null)
			{
				texSource = val.Tesselator.GetTextureSource(block, 0, false);
			}
			if (shape == null)
			{
				AssetLocation val2 = block.Shape.Base.Clone().WithPathPrefixOnce("shapes/").WithPathAppendixOnce(".json");
				shape = Shape.TryGet(base.api, val2);
				if (shape == null)
				{
					base.api.World.Logger.Error("Shape for block {0} not found or errored, was supposed to be at {1}. Block animations not loaded!", new object[2]
					{
						((RegistryObject)be.Block).Code,
						val2
					});
					resultingShape = shape;
					return new MeshData(true);
				}
			}
			Dictionary<string, ShapeElement> dictionary = shape.CollectAndResolveReferences(base.api.World.Logger, nameForLogging);
			shape.CacheInvTransforms();
			shape.ResolveAndFindJoints(base.api.World.Logger, nameForLogging, dictionary, Array.Empty<string>());
			TesselationMetaData val3 = new TesselationMetaData
			{
				QuantityElements = block.Shape.QuantityElements,
				SelectiveElements = block.Shape.SelectiveElements,
				IgnoreElements = block.Shape.IgnoreElements,
				TexSource = texSource,
				WithJointIds = true,
				WithDamageEffect = true,
				TypeForLogging = nameForLogging
			};
			MeshData val4 = default(MeshData);
			val.Tesselator.TesselateShape(val3, shape, ref val4);
			OnAfterTesselate?.Invoke(val4);
			resultingShape = shape;
			return val4;
		}

		public override void InitializeAnimatorServer(string cacheDictKey, Shape blockShape)
		{
			((AnimationUtil)this).InitializeAnimatorServer(cacheDictKey, blockShape);
			be.RegisterGameTickListener((Action<float>)base.AnimationTickServer, 20, 0);
		}

		protected override void OnAnimationsStateChange(bool animsNowActive)
		{
			if (animsNowActive)
			{
				if (base.renderer != null)
				{
					base.api.World.BlockAccessor.MarkBlockDirty(be.Pos, (Action)delegate
					{
						base.renderer.ShouldRender = true;
					});
				}
			}
			else
			{
				base.api.World.BlockAccessor.MarkBlockDirty(be.Pos, (Action)delegate
				{
					base.renderer.ShouldRender = false;
				});
			}
		}
	}
	public class BlockEntityGeneric : BlockEntity, IRotatable
	{
		public void OnTransformed(IWorldAccessor worldAccessor, ITreeAttribute tree, int degreeRotation, Dictionary<int, AssetLocation> oldBlockIdMapping, Dictionary<int, AssetLocation> oldItemIdMapping, EnumAxis? flipAxis)
		{
			foreach (BlockEntityBehavior behavior in base.Behaviors)
			{
				IRotatable val = (IRotatable)(object)((behavior is IRotatable) ? behavior : null);
				if (val != null)
				{
					val.OnTransformed(worldAccessor, tree, degreeRotation, oldBlockIdMapping, oldItemIdMapping, flipAxis);
				}
			}
		}
	}
	public enum EnumTransientCondition
	{
		TimePassed,
		Temperature
	}
	public class TransientProperties
	{
		public EnumTransientCondition Condition;

		public float InGameHours = 24f;

		public float WhenBelowTemperature = -999f;

		public float WhenAboveTemperature = 999f;

		public float ResetBelowTemperature = -999f;

		public float StopBelowTemperature = -999f;

		public string ConvertTo;

		public string ConvertFrom;
	}
	public class BlockEntityTransient : BlockEntity
	{
		private double lastCheckAtTotalDays;

		private double transitionHoursLeft = -1.0;

		private TransientProperties props;

		private long listenerId;

		private double? transitionAtTotalDaysOld;

		public string ConvertToOverride;

		public virtual int CheckIntervalMs { get; set; } = 2000;

		public override void Initialize(ICoreAPI api)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Invalid comparison between Unknown and I4
			//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0205: Invalid comparison between Unknown and I4
			((BlockEntity)this).Initialize(api);
			JsonObject attributes = ((CollectibleObject)((BlockEntity)this).Block).Attributes;
			if (attributes == null || !attributes["transientProps"].Exists)
			{
				return;
			}
			if ((int)api.Side == 1)
			{
				Block block = base.Api.World.BlockAccessor.GetBlock(base.Pos, 1);
				if (((CollectibleObject)block).Id != ((CollectibleObject)((BlockEntity)this).Block).Id)
				{
					if (!(block.EntityClass == ((BlockEntity)this).Block.EntityClass))
					{
						base.Api.World.Logger.Warning("BETransient @{0} for Block {1}, but there is {2} at this position? Will delete BE", new object[3]
						{
							base.Pos,
							((RegistryObject)((BlockEntity)this).Block).Code.ToShortString(),
							((RegistryObject)block).Code.ToShortString()
						});
						api.Event.EnqueueMainThreadTask((Action)delegate
						{
							api.World.BlockAccessor.RemoveBlockEntity(base.Pos);
						}, "delete betransient");
						return;
					}
					if (!(((RegistryObject)block).Code.FirstCodePart() == ((RegistryObject)((BlockEntity)this).Block).Code.FirstCodePart()))
					{
						base.Api.World.Logger.Warning("BETransient @{0} for Block {1}, but there is {2} at this position? Will delete BE and attempt to recreate it", new object[3]
						{
							base.Pos,
							((RegistryObject)((BlockEntity)this).Block).Code.ToShortString(),
							((RegistryObject)block).Code.ToShortString()
						});
						api.Event.EnqueueMainThreadTask((Action)delegate
						{
							api.World.BlockAccessor.RemoveBlockEntity(base.Pos);
							Block block2 = api.World.BlockAccessor.GetBlock(base.Pos, 1);
							api.World.BlockAccessor.SetBlock(((CollectibleObject)block2).Id, base.Pos, 1);
						}, "delete betransient");
						return;
					}
					((BlockEntity)this).Block = block;
				}
			}
			props = ((CollectibleObject)((BlockEntity)this).Block).Attributes["transientProps"].AsObject<TransientProperties>((TransientProperties)null);
			if (props == null)
			{
				return;
			}
			if (transitionHoursLeft <= 0.0)
			{
				transitionHoursLeft = props.InGameHours;
			}
			if ((int)api.Side == 1)
			{
				if (listenerId != 0L)
				{
					throw new InvalidOperationException("Initializing BETransient twice would create a memory and performance leak");
				}
				listenerId = ((BlockEntity)this).RegisterGameTickListener((Action<float>)CheckTransition, CheckIntervalMs, 0);
				if (transitionAtTotalDaysOld.HasValue)
				{
					lastCheckAtTotalDays = base.Api.World.Calendar.TotalDays;
					transitionHoursLeft = (transitionAtTotalDaysOld.Value - lastCheckAtTotalDays) * (double)base.Api.World.Calendar.HoursPerDay;
				}
			}
		}

		public override void OnBlockPlaced(ItemStack byItemStack = null)
		{
			lastCheckAtTotalDays = base.Api.World.Calendar.TotalDays;
		}

		public virtual void CheckTransition(float dt)
		{
			if (((CollectibleObject)base.Api.World.BlockAccessor.GetBlock(base.Pos)).Attributes == null)
			{
				base.Api.World.Logger.Error("BETransient @{0}: cannot find block attributes for {1}. Will stop transient timer", new object[2]
				{
					base.Pos,
					((RegistryObject)((BlockEntity)this).Block).Code.ToShortString()
				});
				((BlockEntity)this).UnregisterGameTickListener(listenerId);
				return;
			}
			lastCheckAtTotalDays = Math.Min(lastCheckAtTotalDays, base.Api.World.Calendar.TotalDays);
			ClimateCondition climateAt = base.Api.World.BlockAccessor.GetClimateAt(base.Pos, (EnumGetClimateMode)0, 0.0);
			if (climateAt == null)
			{
				return;
			}
			float temperature = climateAt.Temperature;
			float num = 1f / base.Api.World.Calendar.HoursPerDay;
			double totalDays = base.Api.World.Calendar.TotalDays;
			while (totalDays - lastCheckAtTotalDays > (double)num)
			{
				lastCheckAtTotalDays += num;
				transitionHoursLeft -= 1.0;
				climateAt.Temperature = temperature;
				ClimateCondition climateAt2 = base.Api.World.BlockAccessor.GetClimateAt(base.Pos, climateAt, (EnumGetClimateMode)3, lastCheckAtTotalDays);
				if (props.Condition == EnumTransientCondition.Temperature)
				{
					if (climateAt2.Temperature < props.WhenBelowTemperature || climateAt2.Temperature > props.WhenAboveTemperature)
					{
						tryTransition(props.ConvertTo);
					}
					continue;
				}
				bool flag = climateAt2.Temperature < props.ResetBelowTemperature;
				if (climateAt2.Temperature < props.StopBelowTemperature || flag)
				{
					transitionHoursLeft += 1.0;
					if (flag)
					{
						transitionHoursLeft = props.InGameHours;
					}
				}
				else if (transitionHoursLeft <= 0.0)
				{
					tryTransition(ConvertToOverride ?? props.ConvertTo);
					break;
				}
			}
		}

		public void tryTransition(string toCode)
		{
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Expected O, but got Unknown
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Expected O, but got Unknown
			//IL_00aa: Expected O, but got Unknown
			Block block = base.Api.World.BlockAccessor.GetBlock(base.Pos);
			if (((CollectibleObject)block).Attributes == null)
			{
				return;
			}
			string text = props.ConvertFrom;
			if (text != null && toCode != null)
			{
				if (text.IndexOf(':') == -1)
				{
					text = ((RegistryObject)block).Code.Domain + ":" + text;
				}
				if (toCode.IndexOf(':') == -1)
				{
					toCode = ((RegistryObject)block).Code.Domain + ":" + toCode;
				}
				AssetLocation val = (AssetLocation)((text != null && toCode.Contains('*')) ? ((object)WildcardUtil.WildCardReplace(((RegistryObject)block).Code, new AssetLocation(text), new AssetLocation(toCode))) : ((object)new AssetLocation(toCode)));
				Block block2 = base.Api.World.GetBlock(val);
				if (block2 != null)
				{
					base.Api.World.BlockAccessor.SetBlock(block2.BlockId, base.Pos, 1);
				}
			}
		}

		public override void FromTreeAttributes(ITreeAttribute tree, IWorldAccessor worldForResolving)
		{
			((BlockEntity)this).FromTreeAttributes(tree, worldForResolving);
			transitionHoursLeft = tree.GetDouble("transitionHoursLeft", 0.0);
			if (tree.HasAttribute("transitionAtTotalDays"))
			{
				transitionAtTotalDaysOld = tree.GetDouble("transitionAtTotalDays", 0.0);
			}
			lastCheckAtTotalDays = tree.GetDouble("lastCheckAtTotalDays", 0.0);
			ConvertToOverride = tree.GetString("convertToOverride", (string)null);
		}

		public override void ToTreeAttributes(ITreeAttribute tree)
		{
			((BlockEntity)this).ToTreeAttributes(tree);
			tree.SetDouble("transitionHoursLeft", transitionHoursLeft);
			tree.SetDouble("lastCheckAtTotalDays", lastCheckAtTotalDays);
			if (ConvertToOverride != null)
			{
				tree.SetString("convertToOverride", ConvertToOverride);
			}
		}

		public void SetPlaceTime(double totalHours)
		{
			float inGameHours = props.InGameHours;
			transitionHoursLeft = (double)inGameHours + totalHours - base.Api.World.Calendar.TotalHours;
		}

		public bool IsDueTransition()
		{
			return transitionHoursLeft <= 0.0;
		}
	}
	public class BlockForFluidsLayer : Block
	{
		public float InsideDamage;

		public EnumDamageType DamageType;

		public override bool ForFluidsLayer => true;

		public override void OnLoaded(ICoreAPI api)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			((Block)this).OnLoaded(api);
			JsonObject attributes = ((CollectibleObject)this).Attributes;
			InsideDamage = ((attributes != null) ? attributes["insideDamage"].AsFloat(0f) : 0f);
			Type? typeFromHandle = typeof(EnumDamageType);
			JsonObject attributes2 = ((CollectibleObject)this).Attributes;
			DamageType = (EnumDamageType)Enum.Parse(typeFromHandle, ((attributes2 != null) ? attributes2["damageType"].AsString("Fire") : null) ?? "Fire");
		}

		public override void OnEntityInside(IWorldAccessor world, Entity entity, BlockPos pos)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Invalid comparison between Unknown and I4
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Expected O, but got Unknown
			if (InsideDamage > 0f && (int)world.Side == 1)
			{
				entity.ReceiveDamage(new DamageSource
				{
					Type = DamageType,
					Source = (EnumDamageSource)0,
					SourceBlock = (Block)(object)this,
					SourcePos = pos.ToVec3d()
				}, InsideDamage);
			}
		}

		public override bool DoPlaceBlock(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, ItemStack byItemStack)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Invalid comparison between Unknown and I4
			bool flag = true;
			bool flag2 = false;
			BlockBehavior[] blockBehaviors = base.BlockBehaviors;
			foreach (BlockBehavior obj in blockBehaviors)
			{
				EnumHandling val = (EnumHandling)0;
				bool flag3 = obj.DoPlaceBlock(world, byPlayer, blockSel, byItemStack, ref val);
				if ((int)val != 0)
				{
					flag = flag && flag3;
					flag2 = true;
				}
				if ((int)val == 3)
				{
					return flag;
				}
			}
			if (flag2)
			{
				return flag;
			}
			world.BlockAccessor.SetBlock(base.BlockId, blockSel.Position, 2);
			return true;
		}
	}
	public interface IMultiBlockColSelBoxes
	{
		Cuboidf[] MBGetCollisionBoxes(IBlockAccessor blockAccessor, BlockPos pos, Vec3i offset);

		Cuboidf[] MBGetSelectionBoxes(IBlockAccessor blockAccessor, BlockPos pos, Vec3i offset);
	}
	public interface IMultiBlockActivate
	{
		void MBActivate(IWorldAccessor world, Caller caller, BlockSelection blockSel, ITreeAttribute activationArgs, Vec3i offset);
	}
	public interface IMultiBlockInteract
	{
		bool MBDoParticalSelection(IWorldAccessor world, BlockPos pos, Vec3i offset);

		bool MBOnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, Vec3i offset);

		bool MBOnBlockInteractStep(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, Vec3i offset);

		void MBOnBlockInteractStop(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, Vec3i offset);

		bool MBOnBlockInteractCancel(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, EnumItemUseCancelReason cancelReason, Vec3i offset);

		ItemStack MBOnPickBlock(IWorldAccessor world, BlockPos pos, Vec3i offset);

		WorldInteraction[] MBGetPlacedBlockInteractionHelp(IWorldAccessor world, BlockSelection blockSel, IPlayer forPlayer, Vec3i offset);

		BlockSounds MBGetSounds(IBlockAccessor blockAccessor, BlockSelection blockSel, ItemStack stack, Vec3i offset);
	}
	public interface IMultiBlockBlockBreaking
	{
		void MBOnBlockBroken(IWorldAccessor world, BlockPos pos, Vec3i offset, IPlayer byPlayer, float dropQuantityMultiplier = 1f);

		int MBGetRandomColor(ICoreClientAPI capi, BlockPos pos, BlockFacing facing, int rndIndex, Vec3i offsetInv);

		int MBGetColorWithoutTint(ICoreClientAPI capi, BlockPos pos, Vec3i offsetInv);

		float MBOnGettingBroken(IPlayer player, BlockSelection blockSel, ItemSlot itemslot, float remainingResistance, float dt, int counter, Vec3i offsetInv);
	}
	public interface IMultiBlockBlockProperties
	{
		bool MBCanAttachBlockAt(IBlockAccessor blockAccessor, Block block, BlockPos pos, BlockFacing blockFace, Cuboidi attachmentArea, Vec3i offsetInv);

		float MBGetLiquidBarrierHeightOnSide(BlockFacing face, BlockPos pos, Vec3i offsetInv);

		int MBGetRetention(BlockPos pos, BlockFacing facing, EnumRetentionType type, Vec3i offsetInv);

		JsonObject MBGetAttributes(IBlockAccessor blockAccessor, BlockPos pos);
	}
	public class BlockMultiblock : Block, IMultiblockOffset
	{
		public delegate T BlockCallDelegateInterface<T, K>(K block);

		public delegate T BlockCallDelegateBlock<T>(Block block);

		public delegate void BlockCallDelegateInterface<K>(K block);

		public delegate void BlockCallDelegateBlock(Block block);

		public Vec3i Offset;

		public Vec3i OffsetInv;

		public override void OnLoaded(ICoreAPI api)
		{
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Expected O, but got Unknown
			((Block)this).OnLoaded(api);
			Offset = new Vec3i(StringUtil.ToInt(((RegistryObject)this).Variant["dx"].Replace("n", "-").Replace("p", ""), 0), StringUtil.ToInt(((RegistryObject)this).Variant["dy"].Replace("n", "-").Replace("p", ""), 0), StringUtil.ToInt(((RegistryObject)this).Variant["dz"].Replace("n", "-").Replace("p", ""), 0));
			OffsetInv = -Offset;
		}

		private T Handle<T, K>(IBlockAccessor ba, int x, int y, int z, BlockCallDelegateInterface<T, K> onImplementsInterface, BlockCallDelegateBlock<T> onIsMultiblock, BlockCallDelegateBlock<T> onOtherwise) where K : class
		{
			Block block = ba.GetBlock(x, y, z);
			K val = block as K;
			if (val == null)
			{
				val = block.GetBehavior(typeof(K), true) as K;
			}
			if (val != null)
			{
				return onImplementsInterface(val);
			}
			if (block is BlockMultiblock)
			{
				return onIsMultiblock(block);
			}
			return onOtherwise(block);
		}

		private void Handle<K>(IBlockAccessor ba, int x, int y, int z, BlockCallDelegateInterface<K> onImplementsInterface, BlockCallDelegateBlock onIsMultiblock, BlockCallDelegateBlock onOtherwise) where K : class
		{
			Block block = ba.GetBlock(x, y, z);
			K val = block as K;
			if (val == null)
			{
				val = block.GetBehavior(typeof(K), true) as K;
			}
			if (val != null)
			{
				onImplementsInterface(val);
			}
			else if (block is BlockMultiblock)
			{
				onIsMultiblock(block);
			}
			else
			{
				onOtherwise(block);
			}
		}

		public override void Activate(IWorldAccessor world, Caller caller, BlockSelection blockSel, ITreeAttribute activationArgs = null)
		{
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			Handle(world.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, delegate(IMultiBlockActivate inf)
			{
				inf.MBActivate(world, caller, bsOffseted, activationArgs, OffsetInv);
			}, delegate
			{
				_003C_003En__0(world, caller, bsOffseted, activationArgs);
			}, delegate(Block block)
			{
				block.Activate(world, caller, bsOffseted, activationArgs);
			});
		}

		public override BlockSounds GetSounds(IBlockAccessor ba, BlockSelection blockSel, ItemStack stack = null)
		{
			return Handle(ba, blockSel.Position.X + OffsetInv.X, blockSel.Position.InternalY + OffsetInv.Y, blockSel.Position.Z + OffsetInv.Z, (IMultiBlockInteract inf) => inf.MBGetSounds(ba, blockSel, stack, OffsetInv), (Block block) => _003C_003En__1(ba, blockSel.AddPosCopy(OffsetInv), stack), (Block block) => block.GetSounds(ba, blockSel.AddPosCopy(OffsetInv), stack));
		}

		public override Cuboidf[] GetSelectionBoxes(IBlockAccessor ba, BlockPos pos)
		{
			return Handle(ba, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockColSelBoxes inf) => inf.MBGetSelectionBoxes(ba, pos, OffsetInv), (Block block) => (Cuboidf[])(object)new Cuboidf[1] { Cuboidf.Default() }, (Block block) => (Cuboidf[])((((CollectibleObject)block).Id == 0) ? ((Array)new Cuboidf[1] { Cuboidf.Default() }) : ((Array)block.GetSelectionBoxes(ba, pos.AddCopy(OffsetInv)))));
		}

		public override Cuboidf[] GetCollisionBoxes(IBlockAccessor ba, BlockPos pos)
		{
			return Handle(ba, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockColSelBoxes inf) => inf.MBGetCollisionBoxes(ba, pos, OffsetInv), (Block block) => (Cuboidf[])(object)new Cuboidf[1] { Cuboidf.Default() }, (Block block) => block.GetCollisionBoxes(ba, pos.AddCopy(OffsetInv)));
		}

		public override bool DoParticalSelection(IWorldAccessor world, BlockPos pos)
		{
			return Handle(world.BlockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockInteract inf) => inf.MBDoParticalSelection(world, pos, OffsetInv), (Block block) => _003C_003En__2(world, pos.AddCopy(OffsetInv)), (Block block) => block.DoParticalSelection(world, pos.AddCopy(OffsetInv)));
		}

		public override float OnGettingBroken(IPlayer player, BlockSelection blockSel, ItemSlot itemslot, float remainingResistance, float dt, int counter)
		{
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			return Handle(((CollectibleObject)this).api.World.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, (IMultiBlockBlockBreaking inf) => inf.MBOnGettingBroken(player, blockSel, itemslot, remainingResistance, dt, counter, OffsetInv), (Block block) => _003C_003En__3(player, bsOffseted, itemslot, remainingResistance, dt, counter), delegate(Block block)
			{
				ICoreAPI api = ((CollectibleObject)this).api;
				ICoreClientAPI val = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
				if (val != null)
				{
					val.World.CloneBlockDamage(blockSel.Position, blockSel.Position.AddCopy(OffsetInv));
				}
				return block.OnGettingBroken(player, bsOffseted, itemslot, remainingResistance, dt, counter);
			});
		}

		public override void OnBlockBroken(IWorldAccessor world, BlockPos pos, IPlayer byPlayer, float dropQuantityMultiplier = 1f)
		{
			Block block = world.BlockAccessor.GetBlock(pos.AddCopy(OffsetInv));
			if (((CollectibleObject)block).Id == 0)
			{
				((Block)this).OnBlockBroken(world, pos, byPlayer, dropQuantityMultiplier);
				return;
			}
			IMultiBlockBlockBreaking multiBlockBlockBreaking = block as IMultiBlockBlockBreaking;
			if (multiBlockBlockBreaking == null)
			{
				multiBlockBlockBreaking = block.GetBehavior(typeof(IMultiBlockBlockBreaking), true) as IMultiBlockBlockBreaking;
			}
			if (multiBlockBlockBreaking != null)
			{
				multiBlockBlockBreaking.MBOnBlockBroken(world, pos, OffsetInv, byPlayer);
			}
			else if (!(block is BlockMultiblock))
			{
				block.OnBlockBroken(world, pos.AddCopy(OffsetInv), byPlayer, dropQuantityMultiplier);
			}
		}

		public override ItemStack OnPickBlock(IWorldAccessor world, BlockPos pos)
		{
			return Handle(world.BlockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockInteract inf) => inf.MBOnPickBlock(world, pos, OffsetInv), (Block block) => _003C_003En__4(world, pos.AddCopy(OffsetInv)), (Block block) => block.OnPickBlock(world, pos.AddCopy(OffsetInv)));
		}

		public override bool OnBlockInteractStart(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel)
		{
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			return Handle(world.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, (IMultiBlockInteract inf) => inf.MBOnBlockInteractStart(world, byPlayer, blockSel, OffsetInv), (Block block) => _003C_003En__5(world, byPlayer, bsOffseted), (Block block) => block.OnBlockInteractStart(world, byPlayer, bsOffseted));
		}

		public override bool OnBlockInteractStep(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel)
		{
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			return Handle(world.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, (IMultiBlockInteract inf) => inf.MBOnBlockInteractStep(secondsUsed, world, byPlayer, blockSel, OffsetInv), (Block block) => _003C_003En__6(secondsUsed, world, byPlayer, bsOffseted), (Block block) => block.OnBlockInteractStep(secondsUsed, world, byPlayer, bsOffseted));
		}

		public override void OnBlockInteractStop(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel)
		{
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			Handle(world.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, delegate(IMultiBlockInteract inf)
			{
				inf.MBOnBlockInteractStop(secondsUsed, world, byPlayer, blockSel, OffsetInv);
			}, delegate
			{
				_003C_003En__7(secondsUsed, world, byPlayer, bsOffseted);
			}, delegate(Block block)
			{
				block.OnBlockInteractStop(secondsUsed, world, byPlayer, bsOffseted);
			});
		}

		public override bool OnBlockInteractCancel(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, EnumItemUseCancelReason cancelReason)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			return Handle(world.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, (IMultiBlockInteract inf) => inf.MBOnBlockInteractCancel(secondsUsed, world, byPlayer, blockSel, cancelReason, OffsetInv), (Block block) => _003C_003En__8(secondsUsed, world, byPlayer, bsOffseted, cancelReason), (Block block) => block.OnBlockInteractCancel(secondsUsed, world, byPlayer, bsOffseted, cancelReason));
		}

		public override WorldInteraction[] GetPlacedBlockInteractionHelp(IWorldAccessor world, BlockSelection blockSel, IPlayer forPlayer)
		{
			BlockSelection bsOffseted = blockSel.Clone();
			bsOffseted.Position.Add(OffsetInv);
			return Handle(world.BlockAccessor, bsOffseted.Position.X, bsOffseted.Position.InternalY, bsOffseted.Position.Z, (IMultiBlockInteract inf) => inf.MBGetPlacedBlockInteractionHelp(world, blockSel, forPlayer, OffsetInv), (Block block) => _003C_003En__9(world, bsOffseted, forPlayer), (Block block) => block.GetPlacedBlockInteractionHelp(world, bsOffseted, forPlayer));
		}

		public override string GetPlacedBlockInfo(IWorldAccessor world, BlockPos pos, IPlayer forPlayer)
		{
			BlockPos val = pos.AddCopy(OffsetInv);
			Block block = world.BlockAccessor.GetBlock(val);
			if (block is BlockMultiblock)
			{
				return "";
			}
			return block.GetPlacedBlockInfo(world, val, forPlayer);
		}

		public override int GetRandomColor(ICoreClientAPI capi, BlockPos pos, BlockFacing facing, int rndIndex = -1)
		{
			IClientWorldAccessor world = capi.World;
			return Handle(((IWorldAccessor)world).BlockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockBlockBreaking inf) => inf.MBGetRandomColor(capi, pos, facing, rndIndex, OffsetInv), (Block block) => _003C_003En__10(capi, pos, facing, rndIndex), (Block block) => block.GetRandomColor(capi, pos, facing, rndIndex));
		}

		public override int GetColorWithoutTint(ICoreClientAPI capi, BlockPos pos)
		{
			IClientWorldAccessor world = capi.World;
			return Handle(((IWorldAccessor)world).BlockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockBlockBreaking inf) => inf.MBGetColorWithoutTint(capi, pos, OffsetInv), (Block block) => _003C_003En__11(capi, pos), (Block block) => block.GetColorWithoutTint(capi, pos));
		}

		public override bool CanAttachBlockAt(IBlockAccessor blockAccessor, Block block, BlockPos pos, BlockFacing blockFace, Cuboidi attachmentArea = null)
		{
			return Handle(blockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockBlockProperties inf) => inf.MBCanAttachBlockAt(blockAccessor, block, pos, blockFace, attachmentArea, OffsetInv), (Block nblock) => _003C_003En__12(blockAccessor, block, pos, blockFace, attachmentArea), (Block nblock) => nblock.CanAttachBlockAt(blockAccessor, block, pos, blockFace, attachmentArea));
		}

		public override JsonObject GetAttributes(IBlockAccessor blockAccessor, BlockPos pos)
		{
			return Handle(blockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockBlockProperties inf) => inf.MBGetAttributes(blockAccessor, pos), (Block nblock) => _003C_003En__13(blockAccessor, pos), (Block nblock) => nblock.GetAttributes(blockAccessor, pos));
		}

		public override int GetRetention(BlockPos pos, BlockFacing facing, EnumRetentionType type)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			IBlockAccessor blockAccessor = ((CollectibleObject)this).api.World.BlockAccessor;
			return Handle(blockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockBlockProperties inf) => inf.MBGetRetention(pos, facing, type, OffsetInv), (Block nblock) => _003C_003En__14(pos, facing, (EnumRetentionType)0), (Block nblock) => nblock.GetRetention(pos, facing, (EnumRetentionType)0));
		}

		public override float GetLiquidBarrierHeightOnSide(BlockFacing face, BlockPos pos)
		{
			IBlockAccessor blockAccessor = ((CollectibleObject)this).api.World.BlockAccessor;
			return Handle(blockAccessor, pos.X + OffsetInv.X, pos.InternalY + OffsetInv.Y, pos.Z + OffsetInv.Z, (IMultiBlockBlockProperties inf) => inf.MBGetLiquidBarrierHeightOnSide(face, pos, OffsetInv), (Block nblock) => _003C_003En__15(face, pos), (Block nblock) => nblock.GetLiquidBarrierHeightOnSide(face, pos));
		}

		public override T GetBlockEntity<T>(BlockPos position)
		{
			Block block = ((CollectibleObject)this).api.World.BlockAccessor.GetBlock(position.AddCopy(OffsetInv));
			if (block is BlockMultiblock)
			{
				return ((Block)this).GetBlockEntity<T>(position);
			}
			return block.GetBlockEntity<T>(position.AddCopy(OffsetInv));
		}

		public override T GetBlockEntity<T>(BlockSelection blockSel)
		{
			Block block = ((CollectibleObject)this).api.World.BlockAccessor.GetBlock(blockSel.Position.AddCopy(OffsetInv));
			if (block is BlockMultiblock)
			{
				return ((Block)this).GetBlockEntity<T>(blockSel);
			}
			BlockSelection val = blockSel.Clone();
			val.Position.Add(OffsetInv);
			return block.GetBlockEntity<T>(val);
		}

		public override AssetLocation GetRotatedBlockCode(int angle)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Expected O, but got Unknown
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Expected O, but got Unknown
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Expected O, but got Unknown
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Expected O, but got Unknown
			Vec3i val;
			switch ((angle / 90 % 4 + 4) % 4)
			{
			case 0:
				return ((RegistryObject)this).Code;
			case 1:
				val = new Vec3i(-Offset.Z, Offset.Y, Offset.X);
				break;
			case 2:
				val = new Vec3i(-Offset.X, Offset.Y, -Offset.Z);
				break;
			case 3:
				val = new Vec3i(Offset.Z, Offset.Y, -Offset.X);
				break;
			default:
				val = null;
				break;
			}
			return new AssetLocation(((RegistryObject)this).Code.Domain, "multiblock-monolithic" + OffsetToString(val.X) + OffsetToString(val.Y) + OffsetToString(val.Z));
		}

		private string OffsetToString(int x)
		{
			if (x == 0)
			{
				return "-0";
			}
			if (x < 0)
			{
				return "-n" + -x;
			}
			return "-p" + x;
		}

		public virtual BlockPos GetControlBlockPos(BlockPos pos)
		{
			return pos.AddCopy(OffsetInv);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private void _003C_003En__0(IWorldAccessor world, Caller caller, BlockSelection blockSel, ITreeAttribute activationArgs = null)
		{
			((Block)this).Activate(world, caller, blockSel, activationArgs);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private BlockSounds _003C_003En__1(IBlockAccessor blockAccessor, BlockSelection blockSel, ItemStack stack = null)
		{
			return ((Block)this).GetSounds(blockAccessor, blockSel, stack);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private bool _003C_003En__2(IWorldAccessor world, BlockPos pos)
		{
			return ((Block)this).DoParticalSelection(world, pos);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private float _003C_003En__3(IPlayer player, BlockSelection blockSel, ItemSlot itemslot, float remainingResistance, float dt, int counter)
		{
			return ((Block)this).OnGettingBroken(player, blockSel, itemslot, remainingResistance, dt, counter);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private ItemStack _003C_003En__4(IWorldAccessor world, BlockPos pos)
		{
			return ((Block)this).OnPickBlock(world, pos);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private bool _003C_003En__5(IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel)
		{
			return ((Block)this).OnBlockInteractStart(world, byPlayer, blockSel);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private bool _003C_003En__6(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel)
		{
			return ((Block)this).OnBlockInteractStep(secondsUsed, world, byPlayer, blockSel);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private void _003C_003En__7(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel)
		{
			((Block)this).OnBlockInteractStop(secondsUsed, world, byPlayer, blockSel);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private bool _003C_003En__8(float secondsUsed, IWorldAccessor world, IPlayer byPlayer, BlockSelection blockSel, EnumItemUseCancelReason cancelReason)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return ((Block)this).OnBlockInteractCancel(secondsUsed, world, byPlayer, blockSel, cancelReason);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private WorldInteraction[] _003C_003En__9(IWorldAccessor world, BlockSelection selection, IPlayer forPlayer)
		{
			return ((Block)this).GetPlacedBlockInteractionHelp(world, selection, forPlayer);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private int _003C_003En__10(ICoreClientAPI capi, BlockPos pos, BlockFacing facing, int rndIndex = -1)
		{
			return ((Block)this).GetRandomColor(capi, pos, facing, rndIndex);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private int _003C_003En__11(ICoreClientAPI capi, BlockPos pos)
		{
			return ((Block)this).GetColorWithoutTint(capi, pos);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private bool _003C_003En__12(IBlockAccessor blockAccessor, Block block, BlockPos pos, BlockFacing blockFace, Cuboidi attachmentArea = null)
		{
			return ((Block)this).CanAttachBlockAt(blockAccessor, block, pos, blockFace, attachmentArea);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private JsonObject _003C_003En__13(IBlockAccessor blockAccessor, BlockPos pos)
		{
			return ((Block)this).GetAttributes(blockAccessor, pos);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private int _003C_003En__14(BlockPos pos, BlockFacing facing, EnumRetentionType type)
		{
			//IL_0003: Unknown result type (might be due to invalid IL or missing references)
			return ((Block)this).GetRetention(pos, facing, type);
		}

		[CompilerGenerated]
		[DebuggerHidden]
		private float _003C_003En__15(BlockFacing face, BlockPos pos)
		{
			return ((Block)this).GetLiquidBarrierHeightOnSide(face, pos);
		}
	}
	public class CollectibleBehaviorAnimationAuthoritative : CollectibleBehavior
	{
		public delegate void OnBeginHitEntityDelegate(EntityAgent byEntity, ref EnumHandling handling);

		protected AssetLocation strikeSound;

		public EnumHandInteract strikeSoundHandInteract = (EnumHandInteract)1;

		private bool onlyOnEntity;

		public event OnBeginHitEntityDelegate OnBeginHitEntity;

		public CollectibleBehaviorAnimationAuthoritative(CollectibleObject collObj)
			: base(collObj)
		{
		}//IL_0002: Unknown result type (might be due to invalid IL or missing references)


		public override void Initialize(JsonObject properties)
		{
			((CollectibleBehavior)this).Initialize(properties);
			strikeSound = AssetLocation.Create(properties["strikeSound"].AsString("sounds/player/strike"), ((RegistryObject)base.collObj).Code.Domain);
			onlyOnEntity = properties["onlyOnEntity"].AsBool(false);
		}

		public static float getHitDamageAtFrame(EntityAgent byEntity, string animCode)
		{
			if (((Entity)byEntity).Properties.Client.AnimationsByMetaCode.TryGetValue(animCode, out var value))
			{
				JsonObject attributes = value.Attributes;
				if (attributes != null && attributes["damageAtFrame"].Exists)
				{
					return value.Attributes["damageAtFrame"].AsFloat(-1f) / value.AnimationSpeed;
				}
			}
			return -1f;
		}

		public static float getSoundAtFrame(EntityAgent byEntity, string animCode)
		{
			if (((Entity)byEntity).Properties.Client.AnimationsByMetaCode.TryGetValue(animCode, out var value))
			{
				JsonObject attributes = value.Attributes;
				if (attributes != null && attributes["soundAtFrame"].Exists)
				{
					return value.Attributes["soundAtFrame"].AsFloat(-1f) / value.AnimationSpeed;
				}
			}
			return -1f;
		}

		public override string GetHeldTpUseAnimation(ItemSlot activeHotbarSlot, Entity byEntity, ref EnumHandling bhHandling)
		{
			bhHandling = (EnumHandling)2;
			return "interactstatic";
		}

		public override void OnHeldAttackStart(ItemSlot slot, EntityAgent byEntity, BlockSelection blockSel, EntitySelection entitySel, ref EnumHandHandling handHandling, ref EnumHandling handling)
		{
			if (!onlyOnEntity || entitySel != null)
			{
				StartAttack(slot, byEntity);
				handling = (EnumHandling)3;
				handHandling = (EnumHandHandling)4;
			}
		}

		public override bool OnHeldAttackCancel(float secondsPassed, ItemSlot slot, EntityAgent byEntity, BlockSelection blockSelection, EntitySelection entitySel, EnumItemUseCancelReason cancelReason, ref EnumHandling handling)
		{
			handling = (EnumHandling)3;
			return false;
		}

		public override bool OnHeldAttackStep(float secondsPassed, ItemSlot slot, EntityAgent byEntity, BlockSelection blockSelection, EntitySelection entitySel, ref EnumHandling handling)
		{
			handling = (EnumHandling)3;
			return StepAttack(slot, byEntity);
		}

		public override void OnHeldAttackStop(float secondsPassed, ItemSlot slot, EntityAgent byEntity, BlockSelection blockSelection, EntitySelection entitySel, ref EnumHandling handling)
		{
		}

		public void StartAttack(ItemSlot slot, EntityAgent byEntity)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Expected O, but got Unknown
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Expected O, but got Unknown
			string heldTpHitAnimation = base.collObj.GetHeldTpHitAnimation(slot, (Entity)(object)byEntity);
			((TreeAttribute)((Entity)byEntity).Attributes).SetInt("didattack", 0);
			((Entity)byEntity).AnimManager.RegisterFrameCallback(new AnimFrameCallback
			{
				Animation = heldTpHitAnimation,
				Frame = getSoundAtFrame(byEntity, heldTpHitAnimation),
				Callback = delegate
				{
					playStrikeSound(byEntity);
				}
			});
			((Entity)byEntity).AnimManager.RegisterFrameCallback(new AnimFrameCallback
			{
				Animation = heldTpHitAnimation,
				Frame = getHitDamageAtFrame(byEntity, heldTpHitAnimation),
				Callback = delegate
				{
					hitEntity(byEntity);
				}
			});
		}

		public bool StepAttack(ItemSlot slot, EntityAgent byEntity)
		{
			string heldTpHitAnimation = base.collObj.GetHeldTpHitAnimation(slot, (Entity)(object)byEntity);
			return ((Entity)byEntity).AnimManager.IsAnimationActive(new string[1] { heldTpHitAnimation });
		}

		protected virtual void playStrikeSound(EntityAgent byEntity)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			IPlayer player = ((EntityPlayer)((byEntity is EntityPlayer) ? byEntity : null)).Player;
			if (player != null && byEntity.Controls.HandUse == strikeSoundHandInteract)
			{
				((Entity)player.Entity).World.PlaySoundAt(strikeSound, (Entity)(object)player.Entity, player, 0.9f + (float)((Entity)byEntity).World.Rand.NextDouble() * 0.2f, 16f, 0.35f);
			}
		}

		public virtual void hitEntity(EntityAgent byEntity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Invalid comparison between Unknown and I4
			EnumHandling handling = (EnumHandling)0;
			this.OnBeginHitEntity?.Invoke(byEntity, ref handling);
			if ((int)handling != 0)
			{
				return;
			}
			EntitySelection val = ((EntityPlayer)(((byEntity is EntityPlayer) ? byEntity : null)?)).EntitySelection;
			long valueOrDefault = (val?.Entity?.EntityId).GetValueOrDefault();
			long? obj;
			if (byEntity == null)
			{
				obj = null;
			}
			else
			{
				IMountableSeat mountedOn = byEntity.MountedOn;
				obj = ((mountedOn == null) ? ((long?)null) : mountedOn.Entity?.EntityId);
			}
			long? num = obj;
			long valueOrDefault2 = num.GetValueOrDefault();
			if ((int)((Entity)byEntity).World.Side == 2)
			{
				IWorldAccessor world = ((Entity)byEntity).World;
				IClientWorldAccessor val2 = (IClientWorldAccessor)(object)((world is IClientWorldAccessor) ? world : null);
				if (((TreeAttribute)((Entity)byEntity).Attributes).GetInt("didattack", 0) == 0)
				{
					if (val != null && valueOrDefault != valueOrDefault2)
					{
						val2.TryAttackEntity(val);
					}
					((TreeAttribute)((Entity)byEntity).Attributes).SetInt("didattack", 1);
					val2.AddCameraShake(0.25f);
				}
			}
			else if (((TreeAttribute)((Entity)byEntity).Attributes).GetInt("didattack", 0) == 0 && val != null && valueOrDefault != valueOrDefault2)
			{
				((TreeAttribute)((Entity)byEntity).Attributes).SetInt("didattack", 1);
			}
		}
	}
	public interface IAttachedListener
	{
		void OnAttached(ItemSlot itemslot, int slotIndex, Entity toEntity, EntityAgent byEntity);

		void OnDetached(ItemSlot itemslot, int slotIndex, Entity fromEntity, EntityAgent byEntity);
	}
	public interface IAttachedInteractions : IAttachedListener
	{
		bool OnTryAttach(ItemSlot itemslot, int slotIndex, Entity toEntity);

		bool OnTryDetach(ItemSlot itemslot, int slotIndex, Entity toEntity);

		void OnInteract(ItemSlot itemslot, int slotIndex, Entity onEntity, EntityAgent byEntity, Vec3d hitPosition, EnumInteractMode mode, ref EnumHandling handled, Action onRequireSave);

		void OnEntityDespawn(ItemSlot itemslot, int slotIndex, Entity onEntity, EntityDespawnData despawn);

		void OnEntityDeath(ItemSlot itemslot, int slotIndex, Entity onEntity, DamageSource damageSourceForDeath);

		void OnReceivedClientPacket(ItemSlot itemslot, int slotIndex, Entity onEntity, IServerPlayer player, int packetid, byte[] data, ref EnumHandling handled, Action onRequireSave);
	}
	public class CollectibleBehaviorHeldBag : CollectibleBehavior, IHeldBag, IAttachedInteractions, IAttachedListener
	{
		public const int PacketIdBitShift = 11;

		private const int defaultFlags = 189;

		public CollectibleBehaviorHeldBag(CollectibleObject collObj)
			: base(collObj)
		{
		}

		public override void Initialize(JsonObject properties)
		{
			((CollectibleBehavior)this).Initialize(properties);
		}

		public void Clear(ItemStack backPackStack)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			backPackStack.Attributes.GetTreeAttribute("backpack")["slots"] = (IAttribute)new TreeAttribute();
		}

		public ItemStack[] GetContents(ItemStack bagstack, IWorldAccessor world)
		{
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Expected O, but got Unknown
			ITreeAttribute treeAttribute = bagstack.Attributes.GetTreeAttribute("backpack");
			if (treeAttribute == null)
			{
				return null;
			}
			List<ItemStack> list = new List<ItemStack>();
			foreach (KeyValuePair<string, IAttribute> item in treeAttribute.GetTreeAttribute("slots").SortedCopy(false))
			{
				IAttribute value = item.Value;
				ItemStack val = (ItemStack)((value != null) ? value.GetValue() : null);
				if (val != null)
				{
					val.ResolveBlockOrItem(world);
				}
				list.Add(val);
			}
			return list.ToArray();
		}

		public virtual bool IsEmpty(ItemStack bagstack)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			ITreeAttribute treeAttribute = bagstack.Attributes.GetTreeAttribute("backpack");
			if (treeAttribute == null)
			{
				return true;
			}
			foreach (KeyValuePair<string, IAttribute> item in (IEnumerable<KeyValuePair<string, IAttribute>>)treeAttribute.GetTreeAttribute("slots"))
			{
				IAttribute value = item.Value;
				IItemStack val = (IItemStack)((value != null) ? value.GetValue() : null);
				if (val != null && val.StackSize > 0)
				{
					return false;
				}
			}
			return true;
		}

		public virtual int GetQuantitySlots(ItemStack bagstack)
		{
			if (bagstack == null || bagstack.Collectible.Attributes == null)
			{
				return 0;
			}
			return bagstack.Collectible.Attributes["backpack"]["quantitySlots"].AsInt(0);
		}

		public void Store(ItemStack bagstack, ItemSlotBagContent slot)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Expected O, but got Unknown
			bagstack.Attributes.GetTreeAttribute("backpack").GetTreeAttribute("slots")["slot-" + slot.SlotIndex] = (IAttribute)new ItemstackAttribute(((ItemSlot)slot).Itemstack);
		}

		public virtual string GetSlotBgColor(ItemStack bagstack)
		{
			return bagstack.ItemAttributes["backpack"]["slotBgColor"].AsString((string)null);
		}

		public virtual EnumItemStorageFlags GetStorageFlags(ItemStack bagstack)
		{
			return (EnumItemStorageFlags)bagstack.ItemAttributes["backpack"]["storageFlags"].AsInt(189);
		}

		public List<ItemSlotBagContent> GetOrCreateSlots(ItemStack bagstack, InventoryBase parentinv, int bagIndex, IWorldAccessor world)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Expected O, but got Unknown
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected O, but got Unknown
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Expected O, but got Unknown
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Expected O, but got Unknown
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Expected O, but got Unknown
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Expected O, but got Unknown
			List<ItemSlotBagContent> list = new List<ItemSlotBagContent>();
			string slotBgColor = GetSlotBgColor(bagstack);
			EnumItemStorageFlags storageFlags = GetStorageFlags(bagstack);
			int quantitySlots = GetQuantitySlots(bagstack);
			ITreeAttribute treeAttribute = bagstack.Attributes.GetTreeAttribute("backpack");
			if (treeAttribute == null)
			{
				treeAttribute = (ITreeAttribute)new TreeAttribute();
				ITreeAttribute val = (ITreeAttribute)new TreeAttribute();
				for (int i = 0; i < quantitySlots; i++)
				{
					ItemSlotBagContent val2 = new ItemSlotBagContent(parentinv, bagIndex, i, storageFlags);
					((ItemSlot)val2).HexBackgroundColor = slotBgColor;
					list.Add(val2);
					val["slot-" + i] = (IAttribute)new ItemstackAttribute((ItemStack)null);
				}
				treeAttribute["slots"] = (IAttribute)(object)val;
				bagstack.Attributes["backpack"] = (IAttribute)(object)treeAttribute;
			}
			else
			{
				foreach (KeyValuePair<string, IAttribute> item in (IEnumerable<KeyValuePair<string, IAttribute>>)treeAttribute.GetTreeAttribute("slots"))
				{
					int num = StringUtil.ToInt(item.Key.Split("-")[1], 0);
					ItemSlotBagContent val3 = new ItemSlotBagContent(parentinv, bagIndex, num, storageFlags);
					((ItemSlot)val3).HexBackgroundColor = slotBgColor;
					IAttribute value = item.Value;
					if (((value != null) ? value.GetValue() : null) != null)
					{
						ItemstackAttribute val4 = (ItemstackAttribute)item.Value;
						((ItemSlot)val3).Itemstack = val4.value;
						((ItemSlot)val3).Itemstack.ResolveBlockOrItem(world);
					}
					while (list.Count <= num)
					{
						list.Add(null);
					}
					list[num] = val3;
				}
			}
			return list;
		}

		public void OnAttached(ItemSlot itemslot, int slotIndex, Entity toEntity, EntityAgent byEntity)
		{
		}

		public void OnDetached(ItemSlot itemslot, int slotIndex, Entity fromEntity, EntityAgent byEntity)
		{
			getOrCreateContainerWorkspace(slotIndex, fromEntity, null).Close(((EntityPlayer)((byEntity is EntityPlayer) ? byEntity : null)).Player);
		}

		public AttachedContainerWorkspace getOrCreateContainerWorkspace(int slotIndex, Entity onEntity, Action onRequireSave)
		{
			return ObjectCacheUtil.GetOrCreate<AttachedContainerWorkspace>(onEntity.Api, "att-cont-workspace-" + slotIndex + "-" + onEntity.EntityId + "-" + base.collObj.Id, (CreateCachableObjectDelegate<AttachedContainerWorkspace>)(() => new AttachedContainerWorkspace(onEntity, onRequireSave)));
		}

		public AttachedContainerWorkspace getContainerWorkspace(int slotIndex, Entity onEntity)
		{
			return ObjectCacheUtil.TryGet<AttachedContainerWorkspace>(onEntity.Api, "att-cont-workspace-" + slotIndex + "-" + onEntity.EntityId + "-" + base.collObj.Id);
		}

		public virtual void OnInteract(ItemSlot bagSlot, int slotIndex, Entity onEntity, EntityAgent byEntity, Vec3d hitPosition, EnumInteractMode mode, ref EnumHandling handled, Action onRequireSave)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Invalid comparison between Unknown and I4
			IMountableSeat mountedOn = byEntity.MountedOn;
			if (!(((mountedOn != null) ? mountedOn.Controls : null) ?? byEntity.Controls).CtrlKey)
			{
				handled = (EnumHandling)2;
				if ((int)onEntity.Api.Side == 2)
				{
					getOrCreateContainerWorkspace(slotIndex, onEntity, onRequireSave).OnInteract(bagSlot, slotIndex, onEntity, byEntity, hitPosition);
				}
			}
		}

		public void OnReceivedClientPacket(ItemSlot bagSlot, int slotIndex, Entity onEntity, IServerPlayer player, int packetid, byte[] data, ref EnumHandling handled, Action onRequireSave)
		{
			int num = packetid >> 11;
			if (slotIndex == num)
			{
				int num2 = 2047;
				packetid &= num2;
				getOrCreateContainerWorkspace(slotIndex, onEntity, onRequireSave).OnReceivedClientPacket(player, packetid, data, bagSlot, slotIndex, ref handled);
			}
		}

		public bool OnTryAttach(ItemSlot itemslot, int slotIndex, Entity toEntity)
		{
			return true;
		}

		public bool OnTryDetach(ItemSlot itemslot, int slotIndex, Entity fromEntity)
		{
			return IsEmpty(itemslot.Itemstack);
		}

		public void OnEntityDespawn(ItemSlot itemslot, int slotIndex, Entity onEntity, EntityDespawnData despawn)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			if ((int)despawn.Reason == 0)
			{
				ItemStack[] contents = GetContents(itemslot.Itemstack, onEntity.World);
				if (contents != null)
				{
					ItemStack[] array = contents;
					foreach (ItemStack val in array)
					{
						if (val != null)
						{
							onEntity.World.SpawnItemEntity(val, onEntity.Pos.XYZ, (Vec3d)null);
						}
					}
				}
			}
			getContainerWorkspace(slotIndex, onEntity)?.OnDespawn(despawn);
		}

		public void OnEntityDeath(ItemSlot itemslot, int slotIndex, Entity onEntity, DamageSource damageSourceForDeath)
		{
		}
	}
	public class DlgPositioner : ICustomDialogPositioning
	{
		public Entity entity;

		public int slotIndex;

		public DlgPositioner(Entity entity, int slotIndex)
		{
			this.entity = entity;
			this.slotIndex = slotIndex;
		}

		public Vec3d GetDialogPosition()
		{
			Vec3d centerPosOfBox = entity.GetBehavior<EntityBehaviorSelectionBoxes>().GetCenterPosOfBox(slotIndex);
			if (centerPosOfBox == null)
			{
				return null;
			}
			return centerPosOfBox.Add(0.0, 1.0, 0.0);
		}
	}
	public class AttachedContainerWorkspace
	{
		public enum EntityClientPacketId
		{
			OpenAttachedInventory = 1001
		}

		private const int mouseBuildRepeatDelayMs = 250;

		public Entity entity;

		protected BagInventory bagInv;

		protected GuiDialogCreatureContents dlg;

		protected InventoryGeneric wrapperInv;

		protected Action onRequireSave;

		private long lastMouseActionTime;

		public BagInventory BagInventory => bagInv;

		public InventoryGeneric WrapperInv => wrapperInv;

		public AttachedContainerWorkspace(Entity entity, Action onRequireSave)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			this.entity = entity;
			this.onRequireSave = onRequireSave;
			bagInv = new BagInventory(entity.Api, (ItemSlot[])null);
		}

		public void OnInteract(ItemSlot bagSlot, int slotIndex, Entity onEntity, EntityAgent byEntity, Vec3d hitPosition)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Invalid comparison between Unknown and I4
			if (!TryLoadInv(bagSlot, slotIndex, onEntity))
			{
				return;
			}
			EntityPlayer val = (EntityPlayer)(object)((byEntity is EntityPlayer) ? byEntity : null);
			IPlayer player = onEntity.World.PlayerByUid(val.PlayerUID);
			bool flag = false;
			if ((int)onEntity.World.Side == 2)
			{
				long tickCount = Environment.TickCount64;
				if (tickCount - lastMouseActionTime < 250)
				{
					return;
				}
				lastMouseActionTime = tickCount;
				if (((IEnumerable<IInventory>)player.InventoryManager.OpenedInventories).FirstOrDefault((Func<IInventory, bool>)((IInventory val2) => val2.InventoryID == ((InventoryBase)wrapperInv).InventoryID)) != null)
				{
					Close(player);
					return;
				}
				player.InventoryManager.OpenInventory((IInventory)(object)wrapperInv);
				ref GuiDialogCreatureContents reference = ref dlg;
				InventoryGeneric inv = wrapperInv;
				ICoreAPI api = onEntity.Api;
				reference = new GuiDialogCreatureContents(inv, onEntity, (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null), "attachedcontainer-" + slotIndex, bagSlot.GetStackName(), new DlgPositioner(entity, slotIndex));
				dlg.packetIdOffset = slotIndex << 11;
				if (((GuiDialog)dlg).TryOpen())
				{
					ICoreAPI api2 = onEntity.World.Api;
					ICoreAPI obj = ((api2 is ICoreClientAPI) ? api2 : null);
					((InventoryBase)wrapperInv).Open(player);
					((ICoreClientAPI)obj).Network.SendEntityPacket(onEntity.EntityId, 1001 + dlg.packetIdOffset, (byte[])null);
					flag = true;
				}
				((GuiDialog)dlg).OnClosed += delegate
				{
					Close(player);
				};
			}
			else
			{
				IPlayerInventoryManager inventoryManager = player.InventoryManager;
				if (inventoryManager != null)
				{
					inventoryManager.OpenInventory((IInventory)(object)wrapperInv);
				}
				flag = true;
			}
			if (flag)
			{
				ILogger logger = entity.World.Logger;
				object[] array = new object[4];
				IPlayer obj2 = player;
				array[0] = ((obj2 != null) ? obj2.PlayerName : null);
				array[1] = entity.EntityId;
				array[2] = entity.GetName();
				array[3] = ((InventoryBase)wrapperInv).InventoryID;
				logger.Audit("{0} opened held bag inventory ({3}) on entity {1}/{2}", array);
			}
		}

		public void Close(IPlayer player)
		{
			if (dlg != null && ((GuiDialog)dlg).IsOpened())
			{
				GuiDialogCreatureContents guiDialogCreatureContents = dlg;
				if (guiDialogCreatureContents != null)
				{
					((GuiDialog)guiDialogCreatureContents).TryClose();
				}
			}
			GuiDialogCreatureContents guiDialogCreatureContents2 = dlg;
			if (guiDialogCreatureContents2 != null)
			{
				((GuiDialog)guiDialogCreatureContents2).Dispose();
			}
			dlg = null;
			if (player != null && wrapperInv != null)
			{
				player.InventoryManager.CloseInventoryAndSync((IInventory)(object)wrapperInv);
				entity.World.Logger.Audit("{0} closed held bag inventory {3} on entity {1}/{2}", new object[4]
				{
					(player != null) ? player.PlayerName : null,
					entity.EntityId,
					entity.GetName(),
					((InventoryBase)wrapperInv).InventoryID
				});
			}
		}

		public bool TryLoadInv(ItemSlot bagSlot, int slotIndex, Entity entity)
		{
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Expected O, but got Unknown
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Expected O, but got Unknown
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Invalid comparison between Unknown and I4
			if (bagSlot.Empty)
			{
				return false;
			}
			IHeldBag collectibleInterface = bagSlot.Itemstack.Collectible.GetCollectibleInterface<IHeldBag>();
			if (collectibleInterface == null || collectibleInterface.GetQuantitySlots(bagSlot.Itemstack) <= 0)
			{
				return false;
			}
			List<ItemSlot> list = new List<ItemSlot> { bagSlot };
			if (wrapperInv != null)
			{
				bagInv.ReloadBagInventory((InventoryBase)(object)wrapperInv, list.ToArray());
				return true;
			}
			wrapperInv = new InventoryGeneric(entity.Api);
			bagInv.ReloadBagInventory((InventoryBase)(object)wrapperInv, list.ToArray());
			wrapperInv.Init(bagInv.Count, "mountedbaginv", slotIndex + "-" + entity.EntityId, new NewSlotDelegate(onNewSlot));
			if ((int)entity.World.Side == 1)
			{
				((InventoryBase)wrapperInv).SlotModified += Inv_SlotModified;
			}
			return true;
		}

		private ItemSlot onNewSlot(int slotId, InventoryGeneric self)
		{
			return bagInv[slotId];
		}

		private void Inv_SlotModified(int slotid)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Expected O, but got Unknown
			ItemSlot val = ((InventoryBase)wrapperInv)[slotid];
			bagInv.SaveSlotIntoBag((ItemSlotBagContent)val);
			onRequireSave?.Invoke();
		}

		public void OnReceivedClientPacket(IServerPlayer player, int packetid, byte[] data, ItemSlot bagSlot, int slotIndex, ref EnumHandling handled)
		{
			if (packetid < 1000)
			{
				if (wrapperInv != null && ((InventoryBase)wrapperInv).HasOpened((IPlayer)(object)player))
				{
					((InventoryBase)wrapperInv).InvNetworkUtil.HandleClientPacket((IPlayer)(object)player, packetid, data);
					handled = (EnumHandling)3;
				}
			}
			else if (packetid == 1001)
			{
				OnInteract(bagSlot, slotIndex, entity, (EntityAgent)(object)((IPlayer)player).Entity, null);
			}
		}

		public void OnDespawn(EntityDespawnData despawn)
		{
			GuiDialogCreatureContents guiDialogCreatureContents = dlg;
			if (guiDialogCreatureContents != null)
			{
				((GuiDialog)guiDialogCreatureContents).TryClose();
			}
			if (wrapperInv == null)
			{
				return;
			}
			foreach (string openedByPlayerGUId in ((InventoryBase)wrapperInv).openedByPlayerGUIds)
			{
				IPlayer val = entity.Api.World.PlayerByUid(openedByPlayerGUId);
				if (val != null)
				{
					val.InventoryManager.CloseInventoryAndSync((IInventory)(object)wrapperInv);
				}
				if (val != null)
				{
					entity.World.Logger.Audit("{0} closed held bag inventory {3} on entity {1}/{2}", new object[4]
					{
						(val != null) ? val.PlayerName : null,
						entity.EntityId,
						entity.GetName(),
						((InventoryBase)wrapperInv).InventoryID
					});
				}
			}
		}
	}
	public class EntityBlockFallingRenderer : EntityRenderer, ITerrainMeshPool
	{
		protected EntityBlockFalling blockFallingEntity;

		protected MultiTextureMeshRef meshRef;

		protected Block block;

		protected Matrixf ModelMat = new Matrixf();

		private Vec3d prevPos = new Vec3d();

		private Vec3d curPos = new Vec3d();

		internal bool DoRender;

		private MeshData mesh = new MeshData(4, 3, false, true, true, true);

		private double rotaccum;

		public EntityBlockFallingRenderer(Entity entity, ICoreClientAPI api)
			: base(entity, api)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Expected O, but got Unknown
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Expected O, but got Unknown
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0145: Expected O, but got Unknown
			blockFallingEntity = (EntityBlockFalling)(object)entity;
			block = blockFallingEntity.Block;
			entity.PhysicsUpdateWatcher = new PhysicsTickDelegate(OnPhysicsTick);
			if (!blockFallingEntity.InitialBlockRemoved)
			{
				TreeAttribute blockEntityAttributes = blockFallingEntity.blockEntityAttributes;
				int num = ((blockEntityAttributes != null) ? blockEntityAttributes.GetInt("posx", blockFallingEntity.initialPos.X) : blockFallingEntity.initialPos.X);
				TreeAttribute blockEntityAttributes2 = blockFallingEntity.blockEntityAttributes;
				int num2 = ((blockEntityAttributes2 != null) ? blockEntityAttributes2.GetInt("posy", blockFallingEntity.initialPos.Y) : blockFallingEntity.initialPos.Y);
				TreeAttribute blockEntityAttributes3 = blockFallingEntity.blockEntityAttributes;
				int num3 = ((blockEntityAttributes3 != null) ? blockEntityAttributes3.GetInt("posz", blockFallingEntity.initialPos.Z) : blockFallingEntity.initialPos.Z);
				BlockEntity blockEntity = ((IWorldAccessor)api.World).BlockAccessor.GetBlockEntity(new BlockPos(num, num2, num3));
				if (blockEntity != null)
				{
					blockEntity.OnTesselation((ITerrainMeshPool)(object)this, base.capi.Tesselator);
				}
				if (mesh.VerticesCount > 0)
				{
					mesh.CustomBytes = null;
					mesh.CustomFloats = null;
					mesh.CustomInts = null;
					meshRef = base.capi.Render.UploadMultiTextureMesh(mesh);
				}
			}
			if (meshRef == null)
			{
				MeshData defaultBlockMesh = api.TesselatorManager.GetDefaultBlockMesh(block);
				meshRef = api.Render.UploadMultiTextureMesh(defaultBlockMesh);
			}
			_ = block.FirstTextureInventory.Baked.TextureSubId;
			prevPos.Set(entity.Pos.X + (double)entity.SelectionBox.X1, entity.Pos.Y + (double)entity.SelectionBox.Y1, entity.Pos.Z + (double)entity.SelectionBox.Z1);
		}

		public void OnPhysicsTick(float nextAccum, Vec3d prevPos)
		{
			this.prevPos.Set(prevPos.X + (double)base.entity.SelectionBox.X1, prevPos.Y + (double)base.entity.SelectionBox.Y1, prevPos.Z + (double)base.entity.SelectionBox.Z1);
		}

		public void AddMeshData(MeshData data, int lodlevel = 1)
		{
			if (data != null)
			{
				mesh.AddMeshData(data);
			}
		}

		public void AddMeshData(MeshData data, ColorMapData colormapdata, int lodlevel = 1)
		{
			if (data != null)
			{
				mesh.AddMeshData(data);
			}
		}

		public void AddMeshData(MeshData data, float[] tfMatrix, int lodLevel = 1)
		{
			if (data != null)
			{
				mesh.AddMeshData(data);
			}
		}

		public override void DoRender3DOpaque(float dt, bool isShadowPass)
		{
			if (!isShadowPass && DoRender && (blockFallingEntity.InitialBlockRemoved || ((CollectibleObject)base.entity.World.BlockAccessor.GetBlock(blockFallingEntity.initialPos)).Id == 0))
			{
				rotaccum += dt;
				curPos.Set(base.entity.Pos.X + (double)base.entity.SelectionBox.X1, base.entity.Pos.Y + (double)base.entity.SelectionBox.Y1, base.entity.Pos.Z + (double)base.entity.SelectionBox.Z1);
				RenderFallingBlockEntity();
			}
		}

		private void RenderFallingBlockEntity()
		{
			IRenderAPI render = base.capi.Render;
			render.GlDisableCullFace();
			render.GlToggleBlend(true, (EnumBlendMode)0);
			float num = (base.entity.Collided ? 4f : 1.5f);
			IStandardShaderProgram obj = render.PreparedStandardShader((int)base.entity.Pos.X, (int)(base.entity.Pos.Y + 0.2), (int)base.entity.Pos.Z, (Vec4f)null);
			Vec3d cameraPos = ((IPlayer)base.capi.World.Player).Entity.CameraPos;
			obj.ModelMatrix = ModelMat.Identity().Translate(curPos.X - cameraPos.X + (double)(GameMath.Sin((float)base.capi.InWorldEllapsedMilliseconds / 120f + 30f) / 20f / num), curPos.Y - cameraPos.Y, curPos.Z - cameraPos.Z + (double)(GameMath.Cos((float)base.capi.InWorldEllapsedMilliseconds / 110f + 20f) / 20f / num)).RotateX((float)(Math.Sin(rotaccum * 10.0) / 10.0 / (double)num))
				.RotateZ((float)(Math.Cos(10.0 + rotaccum * 9.0) / 10.0 / (double)num))
				.Values;
			obj.ViewMatrix = render.CameraMatrixOriginf;
			obj.ProjectionMatrix = render.CurrentProjectionMatrix;
			render.RenderMultiTextureMesh(meshRef, "tex", 0);
			((IShaderProgram)obj).Stop();
		}

		public override void Dispose()
		{
			MultiTextureMeshRef obj = meshRef;
			if (obj != null)
			{
				obj.Dispose();
			}
		}
	}
	public class ModSystemItemRendererOptimizer : ModSystem, IRenderer, IDisposable
	{
		private int itemCount;

		private ICoreClientAPI capi;

		public double RenderOrder => 1.0;

		public int RenderRange => 1;

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			EntityItemRenderer.RenderCount = 0;
		}

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			capi = api;
			api.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)0, (string)null);
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)onTick, 1001, 0);
		}

		private void onTick(float dt)
		{
			itemCount = 0;
			foreach (KeyValuePair<long, Entity> loadedEntity in capi.World.LoadedEntities)
			{
				if (loadedEntity.Value is EntityItem)
				{
					itemCount++;
				}
			}
			EntityItemRenderer.RunWittySkipRenderAlgorithm = itemCount > 400;
			EntityItemRenderer.RenderModulo = itemCount / 200;
			EntityItemRenderer.LastPos.Set(-99, -99, -99);
		}
	}
	public class EntityItemRenderer : EntityRenderer
	{
		public static bool RunWittySkipRenderAlgorithm;

		public static BlockPos LastPos = new BlockPos();

		public static int LastCollectibleId;

		public static int RenderCount;

		public static int RenderModulo;

		private EntityItem entityitem;

		private long touchGroundMS;

		public float[] ModelMat = Mat4f.Create();

		private float scaleRand;

		private float yRotRand;

		private Vec3d lerpedPos = new Vec3d();

		private ItemSlot inslot;

		private float accum;

		private Vec4f particleOutTransform = new Vec4f();

		private Vec4f glowRgb = new Vec4f();

		private bool rotateWhenFalling;

		private float xangle;

		private float yangle;

		private float zangle;

		public EntityItemRenderer(Entity entity, ICoreClientAPI api)
			: base(entity, api)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Expected O, but got Unknown
			entityitem = (EntityItem)entity;
			inslot = (ItemSlot)(object)entityitem.Slot;
			ItemStack itemstack = inslot.Itemstack;
			bool? obj;
			if (itemstack == null)
			{
				obj = null;
			}
			else
			{
				CollectibleObject collectible = itemstack.Collectible;
				if (collectible == null)
				{
					obj = null;
				}
				else
				{
					JsonObject attributes = collectible.Attributes;
					obj = ((attributes != null) ? new bool?(attributes["rotateWhenFalling"].AsBool(true)) : ((bool?)null));
				}
			}
			rotateWhenFalling = obj ?? true;
			scaleRand = (float)((IWorldAccessor)api.World).Rand.NextDouble() / 20f - 0.025f;
			touchGroundMS = entityitem.itemSpawnedMilliseconds - ((IWorldAccessor)api.World).Rand.Next(5000);
			yRotRand = (float)((IWorldAccessor)api.World).Rand.NextDouble() * ((float)Math.PI * 2f);
			lerpedPos = entity.Pos.XYZ;
		}

		public override void DoRender3DOpaque(float dt, bool isShadowPass)
		{
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0245: Unknown result type (might be due to invalid IL or missing references)
			//IL_024f: Expected O, but got Unknown
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0364: Unknown result type (might be due to invalid IL or missing references)
			//IL_036e: Expected O, but got Unknown
			//IL_0387: Unknown result type (might be due to invalid IL or missing references)
			//IL_0391: Expected O, but got Unknown
			//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_03bd: Expected O, but got Unknown
			//IL_0597: Unknown result type (might be due to invalid IL or missing references)
			//IL_05a7: Expected O, but got Unknown
			if (isShadowPass && !base.entity.IsRendered)
			{
				return;
			}
			if (RunWittySkipRenderAlgorithm)
			{
				int num = (int)base.entity.Pos.X;
				int num2 = (int)base.entity.Pos.Y;
				int num3 = (int)base.entity.Pos.Z;
				int num4 = (((int)entityitem.Itemstack.Class != 0) ? 1 : (-1)) * entityitem.Itemstack.Id;
				if (LastPos.X == num && LastPos.Y == num2 && LastPos.Z == num3 && LastCollectibleId == num4)
				{
					if (base.entity.EntityId % RenderModulo != 0L)
					{
						return;
					}
				}
				else
				{
					LastPos.Set(num, num2, num3);
				}
				LastCollectibleId = num4;
			}
			IRenderAPI render = base.capi.Render;
			Vec3d obj = lerpedPos;
			obj.X += (base.entity.Pos.X - lerpedPos.X) * 22.0 * (double)dt;
			Vec3d obj2 = lerpedPos;
			obj2.Y += (base.entity.Pos.InternalY - lerpedPos.Y) * 22.0 * (double)dt;
			Vec3d obj3 = lerpedPos;
			obj3.Z += (base.entity.Pos.Z - lerpedPos.Z) * 22.0 * (double)dt;
			ItemRenderInfo itemStackRenderInfo = render.GetItemStackRenderInfo(inslot, (EnumItemRenderTarget)4, dt);
			if (itemStackRenderInfo.ModelRef == null || itemStackRenderInfo.Transform == null)
			{
				return;
			}
			IStandardShaderProgram val = null;
			LoadModelMatrix(itemStackRenderInfo, isShadowPass, dt);
			string text = "tex";
			if (isShadowPass)
			{
				text = "tex2d";
				float[] array = Mat4f.Mul(ModelMat, base.capi.Render.CurrentModelviewMatrix, ModelMat);
				Mat4f.Mul(array, base.capi.Render.CurrentProjectionMatrix, array);
				base.capi.Render.CurrentActiveShader.UniformMatrix("mvpMatrix", array);
				base.capi.Render.CurrentActiveShader.Uniform("origin", new Vec3f());
			}
			else
			{
				val = render.StandardShader;
				((IShaderProgram)val).Use();
				val.RgbaTint = (Vec4f)((!base.entity.Swimming) ? ((object)ColorUtil.WhiteArgbVec) : ((object)new Vec4f(0.5f, 0.5f, 0.5f, 1f)));
				val.DontWarpVertices = 0;
				val.NormalShaded = 1;
				val.AlphaTest = itemStackRenderInfo.AlphaTest;
				val.DamageEffect = itemStackRenderInfo.DamageEffect;
				if (base.entity.Swimming)
				{
					val.AddRenderFlags = (int)(((entityitem.Itemstack.Collectible.MaterialDensity <= 1000) ? 1u : 0u) << 12);
					val.WaterWaveCounter = base.capi.Render.ShaderUniforms.WaterWaveCounter;
				}
				else
				{
					val.AddRenderFlags = 0;
				}
				val.OverlayOpacity = itemStackRenderInfo.OverlayOpacity;
				if (itemStackRenderInfo.OverlayTexture != null && itemStackRenderInfo.OverlayOpacity > 0f)
				{
					val.Tex2dOverlay2D = itemStackRenderInfo.OverlayTexture.TextureId;
					val.OverlayTextureSize = new Vec2f((float)itemStackRenderInfo.OverlayTexture.Width, (float)itemStackRenderInfo.OverlayTexture.Height);
					val.BaseTextureSize = new Vec2f((float)itemStackRenderInfo.TextureSize.Width, (float)itemStackRenderInfo.TextureSize.Height);
					TextureAtlasPosition textureAtlasPosition = render.GetTextureAtlasPosition(entityitem.Itemstack);
					val.BaseUvOrigin = new Vec2f(textureAtlasPosition.x1, textureAtlasPosition.y1);
				}
				BlockPos asBlockPos = ((Entity)entityitem).Pos.AsBlockPos;
				Vec4f lightRGBs = ((IWorldAccessor)base.capi.World).BlockAccessor.GetLightRGBs(asBlockPos.X, asBlockPos.InternalY, asBlockPos.Z);
				int num5 = (int)entityitem.Itemstack.Collectible.GetTemperature((IWorldAccessor)(object)base.capi.World, entityitem.Itemstack);
				float[] incandescenceColorAsColor4f = ColorUtil.GetIncandescenceColorAsColor4f(num5);
				int num6 = GameMath.Clamp((num5 - 550) / 2, 0, 255);
				glowRgb.R = incandescenceColorAsColor4f[0];
				glowRgb.G = incandescenceColorAsColor4f[1];
				glowRgb.B = incandescenceColorAsColor4f[2];
				glowRgb.A = (float)num6 / 255f;
				val.ExtraGlow = num6;
				val.RgbaAmbientIn = render.AmbientColor;
				val.RgbaLightIn = lightRGBs;
				val.RgbaGlowIn = glowRgb;
				val.RgbaFogIn = render.FogColor;
				val.FogMinIn = render.FogMin;
				val.FogDensityIn = render.FogDensity;
				val.ExtraGodray = 0f;
				val.NormalShaded = (itemStackRenderInfo.NormalShaded ? 1 : 0);
				val.ProjectionMatrix = render.CurrentProjectionMatrix;
				val.ViewMatrix = render.CameraMatrixOriginf;
				val.ModelMatrix = ModelMat;
				ItemStack itemstack = entityitem.Itemstack;
				AdvancedParticleProperties[] array2 = ((CollectibleObject)(itemstack.Block?)).ParticleProperties;
				if (itemstack.Block != null && !base.capi.IsGamePaused)
				{
					Mat4f.MulWithVec4(ModelMat, new Vec4f(((CollectibleObject)itemstack.Block).TopMiddlePos.X, ((CollectibleObject)itemstack.Block).TopMiddlePos.Y - 0.4f, ((CollectibleObject)itemstack.Block).TopMiddlePos.Z - 0.5f, 0f), particleOutTransform);
					accum += dt;
					if (array2 != null && array2.Length != 0 && accum > 0.025f)
					{
						accum %= 0.025f;
						foreach (AdvancedParticleProperties val2 in array2)
						{
							val2.basePos.X = (double)particleOutTransform.X + base.entity.Pos.X;
							val2.basePos.Y = (double)particleOutTransform.Y + base.entity.Pos.InternalY;
							val2.basePos.Z = (double)particleOutTransform.Z + base.entity.Pos.Z;
							((Entity)entityitem).World.SpawnParticles((IParticlePropertiesProvider)(object)val2, (IPlayer)null);
						}
					}
				}
			}
			if (!itemStackRenderInfo.CullFaces)
			{
				render.GlDisableCullFace();
			}
			render.RenderMultiTextureMesh(itemStackRenderInfo.ModelRef, text, 0);
			if (!itemStackRenderInfo.CullFaces)
			{
				render.GlEnableCullFace();
			}
			if (!isShadowPass)
			{
				val.AddRenderFlags = 0;
				val.DamageEffect = 0f;
				((IShaderProgram)val).Stop();
			}
		}

		private void LoadModelMatrix(ItemRenderInfo renderInfo, bool isShadowPass, float dt)
		{
			//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_033a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0377: Unknown result type (might be due to invalid IL or missing references)
			//IL_039d: Unknown result type (might be due to invalid IL or missing references)
			EntityPlayer entity = ((IPlayer)base.capi.World.Player).Entity;
			Mat4f.Identity(ModelMat);
			Mat4f.Translate(ModelMat, ModelMat, (float)(lerpedPos.X - entity.CameraPos.X), (float)(lerpedPos.Y - entity.CameraPos.Y), (float)(lerpedPos.Z - entity.CameraPos.Z));
			float num = 0.2f * ((ModelTransformNoDefaults)renderInfo.Transform).ScaleXYZ.X;
			float num2 = 0.2f * ((ModelTransformNoDefaults)renderInfo.Transform).ScaleXYZ.Y;
			float num3 = 0.2f * ((ModelTransformNoDefaults)renderInfo.Transform).ScaleXYZ.Z;
			float num4 = 0f;
			float num5 = 0f;
			if (!isShadowPass)
			{
				long elapsedMilliseconds = ((IWorldAccessor)base.capi.World).ElapsedMilliseconds;
				bool flag = !base.entity.Collided && !base.entity.Swimming && !base.capi.IsGamePaused;
				if (!flag)
				{
					touchGroundMS = elapsedMilliseconds;
				}
				if (base.entity.Collided)
				{
					xangle *= 0.55f;
					yangle *= 0.55f;
					zangle *= 0.55f;
				}
				else if (rotateWhenFalling)
				{
					float num6 = Math.Min(1L, (elapsedMilliseconds - touchGroundMS) / 200);
					float num7 = (flag ? (1000f * dt / 7f * num6) : 0f);
					yangle += num7;
					xangle += num7;
					zangle += num7;
				}
				if (base.entity.Swimming)
				{
					float num8 = 1f;
					if (entityitem.Itemstack.Collectible.MaterialDensity > 1000)
					{
						num4 = GameMath.Sin((float)((double)elapsedMilliseconds / 1000.0)) / 50f;
						num5 = (0f - GameMath.Sin((float)((double)elapsedMilliseconds / 3000.0))) / 50f;
						num8 = 0.1f;
					}
					xangle = GameMath.Sin((float)((double)elapsedMilliseconds / 1000.0)) * 8f * num8;
					yangle = GameMath.Cos((float)((double)elapsedMilliseconds / 2000.0)) * 3f * num8;
					zangle = (0f - GameMath.Sin((float)((double)elapsedMilliseconds / 3000.0))) * 8f * num8;
				}
			}
			ModelTransform transform = renderInfo.Transform;
			FastVec3f translation = ((ModelTransformNoDefaults)transform).Translation;
			FastVec3f rotation = ((ModelTransformNoDefaults)transform).Rotation;
			Mat4f.Translate(ModelMat, ModelMat, num4 + translation.X, translation.Y, num5 + translation.Z);
			Mat4f.Scale(ModelMat, ModelMat, new float[3]
			{
				num + scaleRand,
				num2 + scaleRand,
				num3 + scaleRand
			});
			Mat4f.RotateY(ModelMat, ModelMat, (float)Math.PI / 180f * (rotation.Y + yangle) + (((ModelTransformNoDefaults)transform).Rotate ? yRotRand : 0f));
			Mat4f.RotateZ(ModelMat, ModelMat, (float)Math.PI / 180f * (rotation.Z + zangle));
			Mat4f.RotateX(ModelMat, ModelMat, (float)Math.PI / 180f * (rotation.X + xangle));
			Mat4f.Translate(ModelMat, ModelMat, 0f - ((ModelTransformNoDefaults)transform).Origin.X, 0f - ((ModelTransformNoDefaults)transform).Origin.Y, 0f - ((ModelTransformNoDefaults)transform).Origin.Z);
		}

		public override void Dispose()
		{
		}
	}
	public enum RenderMode
	{
		FirstPerson,
		ImmersiveFirstPerson,
		ThirdPerson
	}
	public class EntityPlayerShapeRenderer : EntityShapeRenderer
	{
		private MultiTextureMeshRef firstPersonMeshRef;

		private MultiTextureMeshRef thirdPersonMeshRef;

		private bool watcherRegistered;

		private EntityPlayer entityPlayer;

		private ModSystemFpHands modSys;

		private RenderMode renderMode;

		private float smoothedBodyYaw;

		private bool previfpMode;

		private static ModelTransform DefaultTongTransform = new ModelTransform
		{
			Translation = new FastVec3f(-0.68f, -0.52f, -0.6f),
			Rotation = new FastVec3f(-26f, -13f, -88f),
			Origin = new FastVec3f(0.5f, 0f, 0.5f),
			Scale = 0.7f
		};

		public float? HeldItemPitchFollowOverride { get; set; }

		protected bool IsSelf => ((EntityRenderer)this).entity.EntityId == ((Entity)((IPlayer)((EntityRenderer)this).capi.World.Player).Entity).EntityId;

		public override bool DisplayChatMessages => true;

		public virtual float HandRenderFov => (float)((EntityRenderer)this).capi.Settings.Int["fpHandsFoV"] * ((float)Math.PI / 180f);

		public EntityPlayerShapeRenderer(Entity entity, ICoreClientAPI api)
			: base(entity, api)
		{
			entityPlayer = (EntityPlayer)(object)((entity is EntityPlayer) ? entity : null);
			modSys = ((ICoreAPI)api).ModLoader.GetModSystem<ModSystemFpHands>(true);
		}

		public override void OnEntityLoaded()
		{
			base.OnEntityLoaded();
		}

		public override void TesselateShape()
		{
			if (((Entity)entityPlayer).GetBehavior<EntityBehaviorPlayerInventory>().Inventory == null)
			{
				return;
			}
			defaultTexSource = GetTextureSource();
			Tesselate();
			if (watcherRegistered)
			{
				return;
			}
			previfpMode = ((EntityRenderer)this).capi.Settings.Bool["immersiveFpMode"];
			if (IsSelf)
			{
				((EntityRenderer)this).capi.Settings.Bool.AddWatcher("immersiveFpMode", (OnSettingsChanged<bool>)delegate(bool on)
				{
					((EntityRenderer)this).entity.MarkShapeModified();
					IAnimationManager animManager = ((Entity)entityPlayer).AnimManager;
					((PlayerAnimationManager)((animManager is PlayerAnimationManager) ? animManager : null)).OnIfpModeChanged(previfpMode, on);
				});
			}
			watcherRegistered = true;
		}

		protected override void onMeshReady(MeshData meshData)
		{
			base.onMeshReady(meshData);
			if (!IsSelf)
			{
				thirdPersonMeshRef = meshRefOpaque;
			}
		}

		public void Tesselate()
		{
			if (!IsSelf)
			{
				base.TesselateShape();
			}
			else
			{
				if (!loaded)
				{
					return;
				}
				TesselateShape(delegate(MeshData meshData)
				{
					//IL_0143: Unknown result type (might be due to invalid IL or missing references)
					//IL_014d: Expected O, but got Unknown
					//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
					//IL_00c5: Expected O, but got Unknown
					disposeMeshes();
					if (!((EntityRenderer)this).capi.IsShuttingDown && meshData.VerticesCount > 0)
					{
						MeshData val = meshData.EmptyClone();
						thirdPersonMeshRef = ((EntityRenderer)this).capi.Render.UploadMultiTextureMesh(meshData);
						determineRenderMode();
						if (renderMode == RenderMode.ImmersiveFirstPerson)
						{
							HashSet<int> skipJointIds = new HashSet<int>();
							loadJointIdsRecursive(((EntityRenderer)this).entity.AnimManager.Animator.GetPosebyName("Neck", StringComparison.InvariantCultureIgnoreCase), skipJointIds);
							val.AddMeshData(meshData, (MeshDataFilterDelegate)((int i) => !skipJointIds.Contains(((CustomMeshDataPart<int>)(object)meshData.CustomInts).Values[i * 4])));
						}
						else
						{
							HashSet<int> includeJointIds = new HashSet<int>();
							loadJointIdsRecursive(((EntityRenderer)this).entity.AnimManager.Animator.GetPosebyName("UpperArmL", StringComparison.InvariantCultureIgnoreCase), includeJointIds);
							loadJointIdsRecursive(((EntityRenderer)this).entity.AnimManager.Animator.GetPosebyName("UpperArmR", StringComparison.InvariantCultureIgnoreCase), includeJointIds);
							val.AddMeshData(meshData, (MeshDataFilterDelegate)((int i) => includeJointIds.Contains(((CustomMeshDataPart<int>)(object)meshData.CustomInts).Values[i * 4])));
						}
						firstPersonMeshRef = ((EntityRenderer)this).capi.Render.UploadMultiTextureMesh(val);
					}
				});
			}
		}

		private void loadJointIdsRecursive(ElementPose elementPose, HashSet<int> outList)
		{
			outList.Add(elementPose.ForElement.JointId);
			foreach (ElementPose childElementPose in elementPose.ChildElementPoses)
			{
				loadJointIdsRecursive(childElementPose, outList);
			}
		}

		private void disposeMeshes()
		{
			if (firstPersonMeshRef != null)
			{
				firstPersonMeshRef.Dispose();
				firstPersonMeshRef = null;
			}
			if (thirdPersonMeshRef != null)
			{
				thirdPersonMeshRef.Dispose();
				thirdPersonMeshRef = null;
			}
			if (meshRefOpaque != null)
			{
				meshRefOpaque.Dispose();
				meshRefOpaque = null;
			}
		}

		public override void BeforeRender(float dt)
		{
			RenderMode renderMode = this.renderMode;
			determineRenderMode();
			if ((renderMode == RenderMode.FirstPerson && this.renderMode == RenderMode.ImmersiveFirstPerson) || (renderMode == RenderMode.ImmersiveFirstPerson && this.renderMode == RenderMode.FirstPerson))
			{
				((EntityRenderer)this).entity.MarkShapeModified();
				IAnimationManager animManager = ((Entity)entityPlayer).AnimManager;
				((PlayerAnimationManager)((animManager is PlayerAnimationManager) ? animManager : null)).OnIfpModeChanged(previfpMode, this.renderMode == RenderMode.ImmersiveFirstPerson);
			}
			base.BeforeRender(dt);
		}

		private void determineRenderMode()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Invalid comparison between Unknown and I4
			if (IsSelf)
			{
				IClientPlayer obj = player;
				if (obj != null && (int)obj.CameraMode == 0)
				{
					if (((EntityRenderer)this).capi.Settings.Bool["immersiveFpMode"] && !((EntityRenderer)this).capi.Render.CameraStuck)
					{
						ITreeAttribute treeAttribute = ((TreeAttribute)((EntityRenderer)this).entity.WatchedAttributes).GetTreeAttribute("tiredness");
						if (treeAttribute == null || treeAttribute.GetInt("isSleeping", 0) != 1)
						{
							renderMode = RenderMode.ImmersiveFirstPerson;
							return;
						}
					}
					renderMode = RenderMode.FirstPerson;
					return;
				}
			}
			renderMode = RenderMode.ThirdPerson;
		}

		public override void RenderToGui(float dt, double posX, double posY, double posZ, float yawDelta, float size)
		{
			if (IsSelf)
			{
				meshRefOpaque = thirdPersonMeshRef;
			}
			base.RenderToGui(dt, posX, posY, posZ, yawDelta, size);
		}

		public override void DoRender2D(float dt)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Invalid comparison between Unknown and I4
			if (IsSelf)
			{
				IClientPlayer obj = player;
				if (obj != null && (int)obj.CameraMode == 0)
				{
					return;
				}
			}
			base.DoRender2D(dt);
		}

		public override Vec3d getAboveHeadPosition(EntityPlayer entityPlayer)
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Expected O, but got Unknown
			if (IsSelf)
			{
				return new Vec3d(entityPlayer.CameraPos.X + ((Entity)entityPlayer).LocalEyePos.X, entityPlayer.CameraPos.Y + 0.4 + ((Entity)entityPlayer).LocalEyePos.Y, entityPlayer.CameraPos.Z + ((Entity)entityPlayer).LocalEyePos.Z);
			}
			return base.getAboveHeadPosition(entityPlayer);
		}

		public override void DoRender3DOpaque(float dt, bool isShadowPass)
		{
			if (IsSelf)
			{
				entityPlayer.selfNowShadowPass = isShadowPass;
			}
			bool flag = renderMode == RenderMode.FirstPerson && !isShadowPass;
			loadModelMatrixForPlayer(((EntityRenderer)this).entity, IsSelf, dt, isShadowPass);
			if (IsSelf && (renderMode == RenderMode.ImmersiveFirstPerson || isShadowPass))
			{
				OriginPos.Set(0f, 0f, 0f);
			}
			if (flag && ((EntityRenderer)this).capi.HideGuis)
			{
				return;
			}
			if (flag)
			{
				pMatrixNormalFov = (float[])((EntityRenderer)this).capi.Render.CurrentProjectionMatrix.Clone();
				((EntityRenderer)this).capi.Render.Set3DProjection(((EntityRenderer)this).capi.Render.ShaderUniforms.ZFar, HandRenderFov);
				pMatrixHandFov = (float[])((EntityRenderer)this).capi.Render.CurrentProjectionMatrix.Clone();
			}
			else
			{
				pMatrixHandFov = null;
				pMatrixNormalFov = null;
			}
			if (isShadowPass)
			{
				((EntityRenderer)this).DoRender3DAfterOIT(dt, true);
			}
			if (DoRenderHeldItem && !((EntityRenderer)this).entity.AnimManager.ActiveAnimationsByAnimCode.ContainsKey("lie") && !isSpectator)
			{
				RenderHeldItem(dt, isShadowPass, right: false);
				RenderHeldItem(dt, isShadowPass, right: true);
			}
			if (flag)
			{
				if (!((EntityRenderer)this).capi.Settings.Bool["hideFpHands"] && !((Entity)entityPlayer).GetBehavior<EntityBehaviorTiredness>().IsSleeping)
				{
					IShaderProgram fpModeHandShader = modSys.fpModeHandShader;
					meshRefOpaque = firstPersonMeshRef;
					fpModeHandShader.Use();
					fpModeHandShader.Uniform("rgbaAmbientIn", ((EntityRenderer)this).capi.Render.AmbientColor);
					fpModeHandShader.Uniform("rgbaFogIn", ((EntityRenderer)this).capi.Render.FogColor);
					fpModeHandShader.Uniform("fogMinIn", ((EntityRenderer)this).capi.Render.FogMin);
					fpModeHandShader.Uniform("fogDensityIn", ((EntityRenderer)this).capi.Render.FogDensity);
					fpModeHandShader.UniformMatrix("projectionMatrix", ((EntityRenderer)this).capi.Render.CurrentProjectionMatrix);
					fpModeHandShader.Uniform("alphaTest", 0.05f);
					fpModeHandShader.Uniform("lightPosition", ((EntityRenderer)this).capi.Render.ShaderUniforms.LightPosition3D);
					fpModeHandShader.Uniform("depthOffset", -0.3f - GameMath.Max(0f, (float)((EntityRenderer)this).capi.Settings.Int["fieldOfView"] / 90f - 1f) / 2f);
					((EntityRenderer)this).capi.Render.GlPushMatrix();
					((EntityRenderer)this).capi.Render.GlLoadMatrix(((EntityRenderer)this).capi.Render.CameraMatrixOrigin);
					base.DoRender3DOpaqueBatched(dt, isShadowPass: false);
					((EntityRenderer)this).capi.Render.GlPopMatrix();
					fpModeHandShader.Stop();
				}
				((EntityRenderer)this).capi.Render.Reset3DProjection();
			}
		}

		protected override IShaderProgram getReadyShader()
		{
			if (!entityPlayer.selfNowShadowPass && renderMode == RenderMode.FirstPerson)
			{
				IShaderProgram fpModeItemShader = modSys.fpModeItemShader;
				fpModeItemShader.Use();
				fpModeItemShader.Uniform("depthOffset", -0.3f - GameMath.Max(0f, (float)((EntityRenderer)this).capi.Settings.Int["fieldOfView"] / 90f - 1f) / 2f);
				fpModeItemShader.Uniform("ssaoAttn", 1f);
				return fpModeItemShader;
			}
			return base.getReadyShader();
		}

		protected override void RenderHeldItem(float dt, bool isShadowPass, bool right)
		{
			if (IsSelf)
			{
				entityPlayer.selfNowShadowPass = isShadowPass;
			}
			if (right)
			{
				EntityAgent obj = eagent;
				ItemSlot val = ((obj != null) ? obj.RightHandItemSlot : null);
				if (val is ItemSlotSkill)
				{
					return;
				}
				ItemStack val2 = ((val != null) ? val.Itemstack : null);
				EntityAgent obj2 = eagent;
				object obj3;
				if (obj2 == null)
				{
					obj3 = null;
				}
				else
				{
					ItemSlot leftHandItemSlot = obj2.LeftHandItemSlot;
					obj3 = ((leftHandItemSlot != null) ? leftHandItemSlot.Itemstack : null);
				}
				ItemStack val3 = (ItemStack)obj3;
				if (val2 != null && val2.Collectible.GetTemperature(((EntityRenderer)this).entity.World, val2) > 200f && val3 != null)
				{
					JsonObject itemAttributes = val3.ItemAttributes;
					if (((itemAttributes != null) ? new bool?(itemAttributes.IsTrue("heatResistant")) : ((bool?)null)) == true)
					{
						IAnimationManager animManager = ((EntityRenderer)this).entity.AnimManager;
						object obj4;
						if (animManager == null)
						{
							obj4 = null;
						}
						else
						{
							IAnimator animator = animManager.Animator;
							obj4 = ((animator != null) ? animator.GetAttachmentPointPose("LeftHand") : null);
						}
						AttachmentPointAndPose apap = (AttachmentPointAndPose)obj4;
						ItemRenderInfo itemStackRenderInfo = ((EntityRenderer)this).capi.Render.GetItemStackRenderInfo(val, (EnumItemRenderTarget)3, dt);
						JsonObject itemAttributes2 = val2.ItemAttributes;
						itemStackRenderInfo.Transform = ((itemAttributes2 != null) ? itemAttributes2["onTongTransform"].AsObject<ModelTransform>(DefaultTongTransform) : null) ?? DefaultTongTransform;
						RenderItem(dt, isShadowPass, val2, apap, itemStackRenderInfo);
						return;
					}
				}
			}
			bool flag = renderMode == RenderMode.FirstPerson;
			if ((flag && !((EntityRenderer)this).capi.Settings.Bool["hideFpHands"]) || !flag)
			{
				base.RenderHeldItem(dt, isShadowPass, right);
			}
		}

		public override void DoRender3DOpaqueBatched(float dt, bool isShadowPass)
		{
			if (renderMode != RenderMode.FirstPerson || isShadowPass)
			{
				if (isShadowPass)
				{
					meshRefOpaque = thirdPersonMeshRef;
				}
				else
				{
					meshRefOpaque = ((renderMode == RenderMode.ImmersiveFirstPerson) ? firstPersonMeshRef : thirdPersonMeshRef);
				}
				base.DoRender3DOpaqueBatched(dt, isShadowPass);
			}
		}

		public void loadModelMatrixForPlayer(Entity entity, bool isSelf, float dt, bool isShadowPass)
		{
			//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c3: Invalid comparison between Unknown and I4
			EntityPlayer entity2 = ((IPlayer)((EntityRenderer)this).capi.World.Player).Entity;
			Mat4f.Identity(ModelMat);
			if (isSelf)
			{
				IMountableSeat mountedOn = ((EntityAgent)entity2).MountedOn;
				Matrixf val = ((mountedOn != null) ? mountedOn.RenderTransform : null);
				if (val != null)
				{
					ModelMat = Mat4f.Mul(ModelMat, ModelMat, val.Values);
				}
			}
			else
			{
				Vec3f otherPlayerRenderOffset = GetOtherPlayerRenderOffset();
				Mat4f.Translate(ModelMat, ModelMat, otherPlayerRenderOffset.X, otherPlayerRenderOffset.Y, otherPlayerRenderOffset.Z);
				IMountableSeat mountedOn2 = ((EntityAgent)entityPlayer).MountedOn;
				Matrixf val2 = ((mountedOn2 != null) ? mountedOn2.RenderTransform : null);
				if (val2 != null)
				{
					ModelMat = Mat4f.Mul(ModelMat, ModelMat, val2.Values);
				}
			}
			float num = ((entity.Properties.Client.Shape != null) ? entity.Properties.Client.Shape.rotateX : 0f);
			float num2 = ((entity.Properties.Client.Shape != null) ? entity.Properties.Client.Shape.rotateY : 0f);
			float num3 = ((entity.Properties.Client.Shape != null) ? entity.Properties.Client.Shape.rotateZ : 0f);
			float num4 = Math.Min(0.05f, dt);
			if (!isSelf)
			{
				IMountableSeat mountedOn3 = ((EntityAgent)entityPlayer).MountedOn;
				if (((mountedOn3 != null) ? mountedOn3.Entity : null) != null)
				{
					smoothedBodyYaw = (bodyYawLerped = ((EntityAgent)entityPlayer).MountedOn.Entity.Pos.Yaw);
					goto IL_024c;
				}
			}
			IClientPlayer obj = player;
			if (obj == null || (int)obj.CameraMode > 0)
			{
				float num5 = GameMath.AngleRadDistance(bodyYawLerped, eagent.BodyYaw);
				bodyYawLerped += GameMath.Clamp(num5, (0f - num4) * 8f, num4 * 8f);
				float num6 = bodyYawLerped;
				smoothedBodyYaw = num6;
			}
			else
			{
				float num6 = ((renderMode != RenderMode.ThirdPerson) ? eagent.BodyYaw : ((Entity)eagent).Pos.Yaw);
				if (!isShadowPass)
				{
					smoothCameraTurning(num6, num4);
				}
			}
			goto IL_024c;
			IL_024c:
			float num7 = ((entityPlayer == null) ? 0f : entityPlayer.WalkPitch);
			IMountableSeat mountedOn4 = ((EntityAgent)entityPlayer).MountedOn;
			float? obj2;
			if (mountedOn4 == null)
			{
				obj2 = null;
			}
			else
			{
				EntityPos seatPosition = mountedOn4.SeatPosition;
				obj2 = ((seatPosition != null) ? new float?(seatPosition.Pitch) : ((float?)null));
			}
			float? num8 = obj2;
			float valueOrDefault = num8.GetValueOrDefault();
			Mat4f.RotateX(ModelMat, ModelMat, entity.Pos.Roll + num * ((float)Math.PI / 180f));
			Mat4f.RotateY(ModelMat, ModelMat, smoothedBodyYaw + (90f + num2) * ((float)Math.PI / 180f));
			if ((!isSelf || !((Entity)eagent).Swimming || renderMode != RenderMode.FirstPerson) && (((entity2 == null || !((EntityAgent)entity2).Controls.Gliding) && ((EntityAgent)entity2).MountedOn == null) || renderMode != RenderMode.FirstPerson))
			{
				Mat4f.RotateZ(ModelMat, ModelMat, num7 + num3 * ((float)Math.PI / 180f));
				if (valueOrDefault != 0f)
				{
					Mat4f.Translate(ModelMat, ModelMat, 0f, -0.5f, 0f);
					Mat4f.RotateZ(ModelMat, ModelMat, valueOrDefault);
					Mat4f.Translate(ModelMat, ModelMat, 0f, 0.5f, 0f);
				}
			}
			Mat4f.RotateX(ModelMat, ModelMat, nowSwivelRad);
			if (entity2 != null && renderMode == RenderMode.FirstPerson && !isShadowPass)
			{
				ItemSlot rightHandItemSlot = eagent.RightHandItemSlot;
				float? obj3;
				if (rightHandItemSlot == null)
				{
					obj3 = null;
				}
				else
				{
					ItemStack itemstack = rightHandItemSlot.Itemstack;
					if (itemstack == null)
					{
						obj3 = null;
					}
					else
					{
						JsonObject itemAttributes = itemstack.ItemAttributes;
						obj3 = ((itemAttributes != null) ? new float?(itemAttributes["heldItemPitchFollow"].AsFloat(0.75f)) : ((float?)null));
					}
				}
				float num9 = obj3 ?? 0.75f;
				IMountableSeat mountedOn5 = eagent.MountedOn;
				float num10 = ((mountedOn5 != null) ? mountedOn5.FpHandPitchFollow : 1f);
				float num11 = ((entity2 != null && ((EntityAgent)entity2).Controls.IsFlying) ? 1f : (HeldItemPitchFollowOverride ?? (num9 * num10)));
				Mat4f.Translate(ModelMat, ModelMat, 0f, (float)entity.LocalEyePos.Y, 0f);
				Mat4f.RotateZ(ModelMat, ModelMat, (entity.Pos.Pitch - (float)Math.PI) * num11);
				Mat4f.Translate(ModelMat, ModelMat, 0f, 0f - (float)entity.LocalEyePos.Y, 0f);
			}
			if (renderMode == RenderMode.FirstPerson && !isShadowPass)
			{
				Mat4f.Translate(ModelMat, ModelMat, 0f, ((EntityRenderer)this).capi.Settings.Float["fpHandsYOffset"], 0f);
			}
			float num12 = ((TreeAttribute)entity.WatchedAttributes).GetFloat("intoxication", 0f);
			intoxIntensity += (num12 - intoxIntensity) * dt / 3f;
			((EntityRenderer)this).capi.Render.PerceptionEffects.ApplyToTpPlayer((EntityPlayer)(object)((entity is EntityPlayer) ? entity : null), ModelMat, (float?)intoxIntensity);
			float size = entity.Properties.Client.Size;
			Mat4f.Scale(ModelMat, ModelMat, new float[3] { size, size, size });
			Mat4f.Translate(ModelMat, ModelMat, -0.5f, 0f, -0.5f);
		}

		private void smoothCameraTurning(float bodyYaw, float mdt)
		{
			float value = GameMath.AngleRadDistance(smoothedBodyYaw, bodyYaw);
			smoothedBodyYaw += Math.Max(0f, Math.Abs(value) - 0.6f) * (float)Math.Sign(value);
			value = GameMath.AngleRadDistance(smoothedBodyYaw, eagent.BodyYaw);
			smoothedBodyYaw += value * mdt * 25f;
		}

		protected Vec3f GetOtherPlayerRenderOffset()
		{
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Expected O, but got Unknown
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Expected O, but got Unknown
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Expected O, but got Unknown
			EntityPlayer entity = ((IPlayer)((EntityRenderer)this).capi.World.Player).Entity;
			IMountableSeat mountedOn = ((EntityAgent)entity).MountedOn;
			IMountable val = ((mountedOn != null) ? mountedOn.MountSupplier : null);
			Entity entity2 = ((EntityRenderer)this).entity;
			IMountableSeat mountedOn2 = ((EntityAgent)((entity2 is EntityAgent) ? entity2 : null)).MountedOn;
			IMountable val2 = ((mountedOn2 != null) ? mountedOn2.MountSupplier : null);
			if (val != null && val == val2)
			{
				EntityPos seatPosition = ((EntityAgent)entity).MountedOn.SeatPosition;
				EntityPos seatPosition2 = mountedOn2.SeatPosition;
				return new Vec3f((float)(0.0 - seatPosition.X + seatPosition2.X), (float)(0.0 - seatPosition.Y + seatPosition2.Y), (float)(0.0 - seatPosition.Z + seatPosition2.Z));
			}
			if (mountedOn2 == null)
			{
				return new Vec3f((float)(((EntityRenderer)this).entity.Pos.X - entity.CameraPos.X), (float)(((EntityRenderer)this).entity.Pos.InternalY - entity.CameraPos.Y), (float)(((EntityRenderer)this).entity.Pos.Z - entity.CameraPos.Z));
			}
			return new Vec3f((float)(mountedOn2.SeatPosition.X - entity.CameraPos.X), (float)(mountedOn2.SeatPosition.InternalY - entity.CameraPos.Y), (float)(mountedOn2.SeatPosition.Z - entity.CameraPos.Z));
		}

		protected override void determineSidewaysSwivel(float dt)
		{
			if (((EntityAgent)entityPlayer).MountedOn != null)
			{
				((EntityAgent)entityPlayer).sidewaysSwivelAngle = (nowSwivelRad = 0f);
				return;
			}
			double num = Math.Atan2(((EntityRenderer)this).entity.Pos.Motion.Z, ((EntityRenderer)this).entity.Pos.Motion.X);
			double num2 = ((EntityRenderer)this).entity.Pos.Motion.LengthSq();
			if (num2 > 0.001 && ((EntityRenderer)this).entity.OnGround)
			{
				float num3 = GameMath.AngleRadDistance((float)prevAngleSwing, (float)num);
				float num4 = nowSwivelRad;
				float num5 = GameMath.Clamp(num3, -0.05f, 0.05f) * dt * 40f * (float)Math.Min(0.02500000037252903, num2) * 80f;
				EntityAgent obj = eagent;
				nowSwivelRad = num4 - num5 * (float)((obj == null || !obj.Controls.Backward) ? 1 : (-1));
				nowSwivelRad = GameMath.Clamp(nowSwivelRad, -0.3f, 0.3f);
			}
			nowSwivelRad *= Math.Min(0.99f, 1f - 0.1f * dt * 60f);
			prevAngleSwing = num;
			((EntityAgent)entityPlayer).sidewaysSwivelAngle = nowSwivelRad;
		}

		public override void Dispose()
		{
			base.Dispose();
			MultiTextureMeshRef obj = firstPersonMeshRef;
			if (obj != null)
			{
				obj.Dispose();
			}
			MultiTextureMeshRef obj2 = thirdPersonMeshRef;
			if (obj2 != null)
			{
				obj2.Dispose();
			}
		}
	}
	public class EntityRendererInvisible : EntityRenderer
	{
		public EntityRendererInvisible(Entity entity, ICoreClientAPI api)
			: base(entity, api)
		{
		}

		public override void Dispose()
		{
		}
	}
	public class MessageTexture
	{
		public LoadedTexture tex;

		public string message;

		public long receivedTime;
	}
	public delegate void OnEntityShapeTesselationDelegate(ref Shape entityShape, string shapePathForLogging, ref bool shapeIsCloned);
	public delegate float OnGetFrostAlpha();
	public class EntityShapeRenderer : EntityRenderer, ITexPositionSource
	{
		protected long listenerId;

		protected LoadedTexture debugTagTexture;

		protected MultiTextureMeshRef meshRefOpaque;

		protected Vec4f color = new Vec4f(1f, 1f, 1f, 1f);

		protected long lastDebugInfoChangeMs;

		protected bool isSpectator;

		protected IClientPlayer player;

		public float bodyYawLerped;

		public Vec3f OriginPos = new Vec3f();

		public float[] ModelMat = Mat4f.Create();

		protected float[] tmpMvMat = Mat4f.Create();

		protected Matrixf ItemModelMat = new Matrixf();

		public bool DoRenderHeldItem;

		public int AddRenderFlags;

		public double WindWaveIntensity = 1.0;

		public bool glitchFlicker;

		public bool frostable;

		public float frostAlpha;

		public float targetFrostAlpha;

		public OnGetFrostAlpha getFrostAlpha;

		public float frostAlphaAccum;

		protected List<MessageTexture> messageTextures;

		protected EntityAgent eagent;

		public CompositeShape OverrideCompositeShape;

		public Shape OverrideEntityShape;

		public string[] OverrideSelectiveElements;

		public bool glitchAffected;

		protected IInventory gearInv;

		protected ITexPositionSource defaultTexSource;

		protected Vec4f lightrgbs;

		protected float intoxIntensity;

		public TextureAtlasPosition skinTexPos;

		protected bool loaded;

		private float accum;

		protected float[] pMatrixHandFov;

		protected float[] pMatrixNormalFov;

		public double stepPitch;

		private double prevY;

		private double prevYAccum;

		public float xangle;

		public float yangle;

		public float zangle;

		private IMountable ims;

		private float stepingAccum;

		private float fallingAccum;

		public float targetSwivelRad;

		public float nowSwivelRad;

		protected double prevAngleSwing;

		protected double prevPosXSwing;

		protected double prevPosZSwing;

		private float swivelaccum;

		public long LastJumpMs;

		public bool shouldSwivelFromMotion = true;

		public float maxSwivelAngle = 22.91831f;

		public virtual bool DisplayChatMessages { get; set; }

		public Size2i AtlasSize => base.capi.EntityTextureAtlas.Size;

		public virtual TextureAtlasPosition this[string textureCode] => defaultTexSource[textureCode] ?? skinTexPos;

		public EntityShapeRenderer(Entity entity, ICoreClientAPI api)
			: base(entity, api)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Expected O, but got Unknown
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Expected O, but got Unknown
			//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ed: Expected O, but got Unknown
			EntityShapeRenderer entityShapeRenderer = this;
			ref EntityAgent reference = ref eagent;
			Entity obj = entity;
			reference = (EntityAgent)(object)((obj is EntityAgent) ? obj : null);
			DoRenderHeldItem = true;
			glitchAffected = true;
			JsonObject attributes = entity.Properties.Attributes;
			glitchFlicker = attributes != null && attributes["glitchFlicker"].AsBool(false);
			JsonObject attributes2 = entity.Properties.Attributes;
			frostable = attributes2 == null || attributes2["frostable"].AsBool(true);
			JsonObject attributes3 = entity.Properties.Attributes;
			shouldSwivelFromMotion = attributes3 == null || attributes3["shouldSwivelFromMotion"].AsBool(true);
			JsonObject attributes4 = entity.Properties.Attributes;
			maxSwivelAngle = ((attributes4 != null) ? attributes4["maxSwivelAngle"].AsFloat(22.91831f) : 22.91831f);
			frostAlphaAccum = (float)((IWorldAccessor)api.World).Rand.NextDouble();
			listenerId = ((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)UpdateDebugInfo, 250, 0);
			OnDebugInfoChanged();
			if (DisplayChatMessages)
			{
				messageTextures = new List<MessageTexture>();
				api.Event.ChatMessage += new ChatLineDelegate(OnChatMessage);
			}
			api.Event.ReloadShapes += entity.MarkShapeModified;
			getFrostAlpha = delegate
			{
				BlockPos asBlockPos = entity.Pos.AsBlockPos;
				ClimateCondition climateAt = ((IWorldAccessor)api.World).BlockAccessor.GetClimateAt(asBlockPos, (EnumGetClimateMode)1, 0.0);
				if (climateAt == null)
				{
					return entityShapeRenderer.targetFrostAlpha;
				}
				float num = 1f - GameMath.Clamp((float)(((IWorldAccessor)api.World).BlockAccessor.GetDistanceToRainFall(asBlockPos, 5, 1) - 2) / 3f, 0f, 1f);
				float num2 = GameMath.Clamp((Math.Max(0f, 0f - climateAt.Temperature) - 2f) / 5f, 0f, 1f) * num;
				if (num2 > 0f)
				{
					float num3 = Math.Max(((IWorldAccessor)api.World).BlockAccessor.GetClimateAt(asBlockPos, (EnumGetClimateMode)2, ((IGameCalendar)api.World.Calendar).TotalDays - (double)(4f / ((IGameCalendar)api.World.Calendar).HoursPerDay)).Rainfall, climateAt.Rainfall);
					num2 *= num3;
				}
				return Math.Max(0f, num2);
			};
		}

		public override void OnEntityLoaded()
		{
			loaded = true;
			prevY = base.entity.Pos.Y;
			prevPosXSwing = base.entity.Pos.X;
			prevPosZSwing = base.entity.Pos.Z;
		}

		protected void OnChatMessage(int groupId, string message, EnumChatType chattype, string data)
		{
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Expected O, but got Unknown
			//IL_0150: Expected O, but got Unknown
			if (data == null || !data.Contains("from:") || !(base.entity.Pos.SquareDistanceTo(((Entity)((IPlayer)base.capi.World.Player).Entity).Pos.XYZ) < 400.0) || message.Length <= 0)
			{
				return;
			}
			string[] array = data.Split(new char[1] { ',' }, 2);
			if (array.Length < 2)
			{
				return;
			}
			string[] array2 = array[0].Split(new char[1] { ':' }, 2);
			string[] array3 = array[1].Split(new char[1] { ':' }, 2);
			if (!(array2[0] != "from"))
			{
				int.TryParse(array2[1], out var result);
				if (base.entity.EntityId == result)
				{
					message = array3[1];
					message = message.Replace("&lt;", "<").Replace("&gt;", ">");
					LoadedTexture tex = base.capi.Gui.TextTexture.GenTextTexture(message, new CairoFont(25.0, GuiStyle.StandardFontName, ColorUtil.WhiteArgbDouble, (double[])null), 350, new TextBackground
					{
						FillColor = GuiStyle.DialogLightBgColor,
						Padding = 3,
						Radius = GuiStyle.ElementBGRadius
					}, (EnumTextOrientation)2);
					messageTextures.Insert(0, new MessageTexture
					{
						tex = tex,
						message = message,
						receivedTime = ((IWorldAccessor)base.capi.World).ElapsedMilliseconds
					});
				}
			}
		}

		public virtual void TesselateShape()
		{
			if (loaded)
			{
				ims = base.entity.GetInterface<IMountable>();
				TesselateShape(onMeshReady);
			}
		}

		protected virtual void onMeshReady(MeshData meshData)
		{
			if (meshRefOpaque != null)
			{
				meshRefOpaque.Dispose();
				meshRefOpaque = null;
			}
			if (!base.capi.IsShuttingDown && meshData.VerticesCount > 0)
			{
				meshRefOpaque = base.capi.Render.UploadMultiTextureMesh(meshData);
			}
		}

		public virtual void TesselateShape(Action<MeshData> onMeshDataReady, string[] overrideSelectiveElements = null)
		{
			if (!loaded)
			{
				return;
			}
			CompositeShape compositeShape = ((OverrideCompositeShape != null) ? OverrideCompositeShape : base.entity.Properties.Client.Shape);
			Shape entityShape = ((OverrideEntityShape != null) ? OverrideEntityShape : base.entity.Properties.Client.LoadedShapeForEntity);
			if (entityShape == null)
			{
				return;
			}
			base.entity.OnTesselation(ref entityShape, ((object)compositeShape.Base).ToString());
			defaultTexSource = GetTextureSource();
			string[] ovse = overrideSelectiveElements ?? OverrideSelectiveElements;
			TyronThreadPool.QueueTask((Action)delegate
			{
				//IL_0141: Unknown result type (might be due to invalid IL or missing references)
				//IL_0146: Unknown result type (might be due to invalid IL or missing references)
				//IL_0157: Unknown result type (might be due to invalid IL or missing references)
				//IL_0172: Unknown result type (might be due to invalid IL or missing references)
				//IL_0183: Unknown result type (might be due to invalid IL or missing references)
				//IL_018f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0196: Unknown result type (might be due to invalid IL or missing references)
				//IL_019d: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
				//IL_01d4: Expected O, but got Unknown
				//IL_01d6: Expected O, but got Unknown
				MeshData meshdata = default(MeshData);
				if (base.entity.Properties.Client.Shape.VoxelizeTexture)
				{
					int num = ((TreeAttribute)base.entity.WatchedAttributes).GetInt("textureIndex", 0);
					TextureAtlasPosition val = defaultTexSource["all"];
					CompositeTexture firstTexture = base.entity.Properties.Client.FirstTexture;
					CompositeTexture[] alternates = firstTexture.Alternates;
					CompositeTexture val2 = ((num == 0) ? firstTexture : alternates[num % alternates.Length]);
					meshdata = base.capi.Tesselator.VoxelizeTexture(val2, base.capi.EntityTextureAtlas.Size, val);
					for (int i = 0; i < meshdata.xyz.Length; i += 3)
					{
						meshdata.xyz[i] -= 0.125f;
						meshdata.xyz[i + 1] -= 0.5f;
						meshdata.xyz[i + 2] += 0.0625f;
					}
				}
				else
				{
					try
					{
						TesselationMetaData val3 = new TesselationMetaData
						{
							QuantityElements = compositeShape.QuantityElements,
							SelectiveElements = (ovse ?? compositeShape.SelectiveElements),
							IgnoreElements = compositeShape.IgnoreElements,
							TexSource = (ITexPositionSource)(object)this,
							WithJointIds = true,
							WithDamageEffect = true,
							TypeForLogging = "entity",
							Rotation = new Vec3f(compositeShape.rotateX, compositeShape.rotateY, compositeShape.rotateZ)
						};
						base.capi.Tesselator.TesselateShape(val3, entityShape, ref meshdata);
						meshdata.Translate(compositeShape.offsetX, compositeShape.offsetY, compositeShape.offsetZ);
					}
					catch (Exception ex)
					{
						((IWorldAccessor)base.capi.World).Logger.Fatal("Failed tesselating entity {0} with id {1}. Entity will probably be invisible!.", new object[2]
						{
							((RegistryObject)base.entity).Code,
							base.entity.EntityId
						});
						((IWorldAccessor)base.capi.World).Logger.Fatal(ex);
						return;
					}
				}
				((IEventAPI)base.capi.Event).EnqueueMainThreadTask((Action)delegate
				{
					onMeshDataReady(meshdata);
					base.entity.OnTesselated();
				}, "uploadentitymesh");
				base.capi.TesselatorManager.ThreadDispose();
			});
		}

		protected virtual ITexPositionSource GetTextureSource()
		{
			return base.entity.GetTextureSource();
		}

		protected void UpdateDebugInfo(float dt)
		{
			OnDebugInfoChanged();
			base.entity.DebugAttributes.MarkClean();
		}

		protected void OnDebugInfoChanged()
		{
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0145: Unknown result type (might be due to invalid IL or missing references)
			//IL_014c: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Expected O, but got Unknown
			//IL_015c: Expected O, but got Unknown
			bool flag = base.capi.Settings.Bool["showEntityDebugInfo"];
			if (flag && !base.entity.DebugAttributes.AllDirty && !base.entity.DebugAttributes.PartialDirty && debugTagTexture != null)
			{
				return;
			}
			if (debugTagTexture != null)
			{
				if (flag && ((Entity)((IPlayer)base.capi.World.Player).Entity).Pos.SquareDistanceTo(base.entity.Pos) > 225f && debugTagTexture.Width > 10)
				{
					return;
				}
				debugTagTexture.Dispose();
				debugTagTexture = null;
			}
			if (!flag)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			foreach (KeyValuePair<string, IAttribute> item in (TreeAttribute)base.entity.DebugAttributes)
			{
				stringBuilder.AppendLine(item.Key + ": " + ((object)item.Value).ToString());
			}
			debugTagTexture = base.capi.Gui.TextTexture.GenUnscaledTextTexture(stringBuilder.ToString(), new CairoFont(20.0, GuiStyle.StandardFontName, ColorUtil.WhiteArgbDouble, (double[])null), new TextBackground
			{
				FillColor = GuiStyle.DialogDefaultBgColor,
				Padding = 3,
				Radius = GuiStyle.ElementBGRadius
			});
			lastDebugInfoChangeMs = base.entity.World.ElapsedMilliseconds;
		}

		public override void BeforeRender(float dt)
		{
			//IL_022c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0232: Invalid comparison between Unknown and I4
			if (!base.entity.ShapeFresh)
			{
				TesselateShape();
				((IWorldAccessor)base.capi.World).FrameProfiler.Mark("esr-tesseleateshape");
			}
			lightrgbs = ((IWorldAccessor)base.capi.World).BlockAccessor.GetLightRGBs((int)(base.entity.Pos.X + (double)base.entity.SelectionBox.X1 - (double)base.entity.OriginSelectionBox.X1), (int)base.entity.Pos.InternalY, (int)(base.entity.Pos.Z + (double)base.entity.SelectionBox.Z1 - (double)base.entity.OriginSelectionBox.Z1));
			if (base.entity.SelectionBox.Y2 > 1f)
			{
				Vec4f lightRGBs = ((IWorldAccessor)base.capi.World).BlockAccessor.GetLightRGBs((int)(base.entity.Pos.X + (double)base.entity.SelectionBox.X1 - (double)base.entity.OriginSelectionBox.X1), (int)base.entity.Pos.InternalY + 1, (int)(base.entity.Pos.Z + (double)base.entity.SelectionBox.Z1 - (double)base.entity.OriginSelectionBox.Z1));
				if (lightRGBs.W > lightrgbs.W)
				{
					lightrgbs = lightRGBs;
				}
			}
			if (meshRefOpaque == null)
			{
				return;
			}
			if (player == null && base.entity is EntityPlayer)
			{
				ref IClientPlayer reference = ref player;
				IPlayer obj = ((IWorldAccessor)base.capi.World).PlayerByUid(((EntityPlayer)/*isinst with value type is only supported in some contexts*/).PlayerUID);
				reference = (IClientPlayer)(object)((obj is IClientPlayer) ? obj : null);
			}
			if (base.capi.IsGamePaused)
			{
				return;
			}
			frostAlphaAccum += dt;
			if (frostAlphaAccum > 5f)
			{
				frostAlphaAccum = 0f;
				targetFrostAlpha = getFrostAlpha();
			}
			isSpectator = player != null && (int)((IPlayer)player).WorldData.CurrentGameMode == 3;
			if (isSpectator)
			{
				return;
			}
			if (DisplayChatMessages && messageTextures.Count > 0)
			{
				MessageTexture messageTexture = messageTextures.Last();
				if (((IWorldAccessor)base.capi.World).ElapsedMilliseconds > messageTexture.receivedTime + 3500 + 100 * (messageTexture.message.Length - 10))
				{
					messageTextures.RemoveAt(messageTextures.Count - 1);
					messageTexture.tex.Dispose();
				}
			}
			determineSidewaysSwivel(dt);
		}

		public override void DoRender3DOpaque(float dt, bool isShadowPass)
		{
			if (!isSpectator)
			{
				loadModelMatrix(base.entity, dt, isShadowPass);
				Vec3d cameraPos = ((IPlayer)base.capi.World.Player).Entity.CameraPos;
				OriginPos.Set((float)(base.entity.Pos.X - cameraPos.X), (float)(base.entity.Pos.InternalY - cameraPos.Y), (float)(base.entity.Pos.Z - cameraPos.Z));
				if (isShadowPass)
				{
					((EntityRenderer)this).DoRender3DAfterOIT(dt, true);
				}
				if (DoRenderHeldItem && !base.entity.AnimManager.ActiveAnimationsByAnimCode.ContainsKey("lie") && !isSpectator)
				{
					RenderHeldItem(dt, isShadowPass, right: false);
					RenderHeldItem(dt, isShadowPass, right: true);
				}
			}
		}

		protected virtual IShaderProgram getReadyShader()
		{
			IStandardShaderProgram standardShader = base.capi.Render.StandardShader;
			((IShaderProgram)standardShader).Use();
			return (IShaderProgram)(object)standardShader;
		}

		protected virtual void RenderHeldItem(float dt, bool isShadowPass, bool right)
		{
			object obj2;
			if (!right)
			{
				EntityAgent obj = eagent;
				obj2 = ((obj != null) ? obj.LeftHandItemSlot : null);
			}
			else
			{
				EntityAgent obj3 = eagent;
				obj2 = ((obj3 != null) ? obj3.RightHandItemSlot : null);
			}
			ItemSlot val = (ItemSlot)obj2;
			ItemStack val2 = ((val != null) ? val.Itemstack : null);
			if (val2 != null && !(val is ItemSlotSkill))
			{
				IAnimationManager animManager = base.entity.AnimManager;
				object obj4;
				if (animManager == null)
				{
					obj4 = null;
				}
				else
				{
					IAnimator animator = animManager.Animator;
					obj4 = ((animator != null) ? animator.GetAttachmentPointPose(right ? "RightHand" : "LeftHand") : null);
				}
				AttachmentPointAndPose val3 = (AttachmentPointAndPose)obj4;
				if (val3 != null)
				{
					ItemRenderInfo itemStackRenderInfo = base.capi.Render.GetItemStackRenderInfo(val, (EnumItemRenderTarget)(right ? 2 : 3), dt);
					RenderItem(dt, isShadowPass, val2, val3, itemStackRenderInfo);
				}
			}
		}

		protected virtual void RenderItem(float dt, bool isShadowPass, ItemStack stack, AttachmentPointAndPose apap, ItemRenderInfo renderInfo)
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_015a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Expected O, but got Unknown
			//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e7: Expected O, but got Unknown
			//IL_0307: Unknown result type (might be due to invalid IL or missing references)
			//IL_0311: Expected O, but got Unknown
			//IL_032e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0338: Expected O, but got Unknown
			//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_05ce: Expected O, but got Unknown
			//IL_0437: Unknown result type (might be due to invalid IL or missing references)
			//IL_0441: Expected O, but got Unknown
			//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0602: Unknown result type (might be due to invalid IL or missing references)
			//IL_0612: Unknown result type (might be due to invalid IL or missing references)
			IRenderAPI render = base.capi.Render;
			AttachmentPoint val = apap?.AttachPoint;
			IShaderProgram val2 = null;
			if (renderInfo?.Transform == null || renderInfo.ModelRef == null || val == null)
			{
				return;
			}
			ModelTransform obj = renderInfo.Transform.EnsureDefaultValues();
			FastVec3f origin = ((ModelTransformNoDefaults)obj).Origin;
			FastVec3f translation = ((ModelTransformNoDefaults)obj).Translation;
			FastVec3f rotation = ((ModelTransformNoDefaults)obj).Rotation;
			FastVec3f scaleXYZ = ((ModelTransformNoDefaults)obj).ScaleXYZ;
			ItemModelMat.Set(ModelMat).Mul(apap.AnimModelMatrix).Translate(origin.X, origin.Y, origin.Z)
				.Scale(scaleXYZ.X, scaleXYZ.Y, scaleXYZ.Z)
				.Translate(val.PosX / 16.0 + (double)translation.X, val.PosY / 16.0 + (double)translation.Y, val.PosZ / 16.0 + (double)translation.Z)
				.RotateX((float)(val.RotationX + (double)rotation.X) * ((float)Math.PI / 180f))
				.RotateY((float)(val.RotationY + (double)rotation.Y) * ((float)Math.PI / 180f))
				.RotateZ((float)(val.RotationZ + (double)rotation.Z) * ((float)Math.PI / 180f))
				.Translate(0f - origin.X, 0f - origin.Y, 0f - origin.Z);
			string text = "tex";
			if (isShadowPass)
			{
				text = "tex2d";
				val2 = render.CurrentActiveShader;
				float[] array = Mat4f.Mul(ItemModelMat.Values, base.capi.Render.CurrentModelviewMatrix, ItemModelMat.Values);
				Mat4f.Mul(array, base.capi.Render.CurrentProjectionMatrix, array);
				val2.UniformMatrix("mvpMatrix", array);
				val2.Uniform("origin", new Vec3f());
			}
			else
			{
				val2 = getReadyShader();
				val2.Uniform("dontWarpVertices", 0);
				val2.Uniform("addRenderFlags", 0);
				val2.Uniform("normalShaded", 1);
				IShaderProgram obj2 = val2;
				JsonObject itemAttributes = stack.ItemAttributes;
				obj2.Uniform("tempGlowMode", (itemAttributes != null) ? itemAttributes["tempGlowMode"].AsInt(0) : 0);
				val2.Uniform("rgbaTint", ColorUtil.WhiteArgbVec);
				val2.Uniform("alphaTest", renderInfo.AlphaTest);
				val2.Uniform("damageEffect", renderInfo.DamageEffect);
				val2.Uniform("overlayOpacity", renderInfo.OverlayOpacity);
				if (renderInfo.OverlayTexture != null && renderInfo.OverlayOpacity > 0f)
				{
					val2.BindTexture2D("tex2dOverlay", renderInfo.OverlayTexture.TextureId, 1);
					val2.Uniform("overlayTextureSize", new Vec2f((float)renderInfo.OverlayTexture.Width, (float)renderInfo.OverlayTexture.Height));
					val2.Uniform("baseTextureSize", new Vec2f((float)renderInfo.TextureSize.Width, (float)renderInfo.TextureSize.Height));
					TextureAtlasPosition textureAtlasPosition = render.GetTextureAtlasPosition(stack);
					val2.Uniform("baseUvOrigin", new Vec2f(textureAtlasPosition.x1, textureAtlasPosition.y1));
				}
				int num = (int)stack.Collectible.GetTemperature((IWorldAccessor)(object)base.capi.World, stack);
				float[] incandescenceColorAsColor4f = ColorUtil.GetIncandescenceColorAsColor4f(num);
				int num2 = GameMath.Clamp((num - 500) / 3, 0, 255);
				Item item = stack.Item;
				object obj3 = ((item != null) ? item.FirstTexture : null);
				if (obj3 == null)
				{
					Block block = stack.Block;
					obj3 = ((block != null) ? block.FirstTextureInventory : null);
				}
				BakedCompositeTexture val3 = ((CompositeTexture)(obj3?)).Baked;
				Vec4f val4 = (Vec4f)((val3 != null) ? ((object)ColorUtil.ToRGBAVec4f(((ITextureAtlasAPI)base.capi.BlockTextureAtlas).GetAverageColor(val3.TextureSubId))) : ((object)new Vec4f(1f, 1f, 1f, 1f)));
				val2.Uniform("averageColor", val4);
				val2.Uniform("extraGlow", num2);
				val2.Uniform("rgbaAmbientIn", render.AmbientColor);
				val2.Uniform("rgbaLightIn", lightrgbs);
				val2.Uniform("rgbaGlowIn", new Vec4f(incandescenceColorAsColor4f[0], incandescenceColorAsColor4f[1], incandescenceColorAsColor4f[2], (float)num2 / 255f));
				val2.Uniform("rgbaFogIn", render.FogColor);
				val2.Uniform("fogMinIn", render.FogMin);
				val2.Uniform("fogDensityIn", render.FogDensity);
				val2.Uniform("normalShaded", renderInfo.NormalShaded ? 1 : 0);
				val2.UniformMatrix("projectionMatrix", render.CurrentProjectionMatrix);
				val2.UniformMatrix("viewMatrix", render.CameraMatrixOriginf);
				val2.UniformMatrix("modelMatrix", ItemModelMat.Values);
			}
			if (!renderInfo.CullFaces)
			{
				render.GlDisableCullFace();
			}
			render.RenderMultiTextureMesh(renderInfo.ModelRef, text, 0);
			if (!isShadowPass)
			{
				val2.Uniform("tempGlowMode", 0);
			}
			if (!renderInfo.CullFaces)
			{
				render.GlEnableCullFace();
			}
			if (isShadowPass)
			{
				return;
			}
			val2.Uniform("damageEffect", 0f);
			val2.Stop();
			float num3 = Math.Max(0f, 1f - (float)((IWorldAccessor)base.capi.World).BlockAccessor.GetDistanceToRainFall(base.entity.Pos.AsBlockPos, 4, 1) / 5f);
			AdvancedParticleProperties[] array2 = stack.Collectible?.ParticleProperties;
			if (stack.Collectible == null || base.capi.IsGamePaused)
			{
				return;
			}
			Vec4f val5 = ItemModelMat.TransformVector(new Vec4f(stack.Collectible.TopMiddlePos.X, stack.Collectible.TopMiddlePos.Y, stack.Collectible.TopMiddlePos.Z, 1f));
			if (pMatrixHandFov != null)
			{
				Vec4f val6 = new Matrixf().Set(pMatrixHandFov).Mul(render.CameraMatrixOriginf).TransformVector(val5);
				val5 = new Matrixf(render.CameraMatrixOriginf).Invert().Mul(new Matrixf(pMatrixNormalFov).Invert()).TransformVector(val6);
			}
			EntityPlayer entity = ((IPlayer)base.capi.World.Player).Entity;
			accum += dt;
			if (array2 != null && array2.Length != 0 && accum > 0.05f)
			{
				accum %= 0.025f;
				foreach (AdvancedParticleProperties val7 in array2)
				{
					val7.WindAffectednesAtPos = num3;
					val7.WindAffectednes = num3;
					val7.basePos.X = (double)val5.X + entity.CameraPos.X;
					val7.basePos.Y = (double)val5.Y + entity.CameraPos.Y;
					val7.basePos.Z = (double)val5.Z + entity.CameraPos.Z;
					((Entity)eagent).World.SpawnParticles((IParticlePropertiesProvider)(object)val7, (IPlayer)null);
				}
			}
		}

		public override void RenderToGui(float dt, double posX, double posY, double posZ, float yawDelta, float size)
		{
			loadModelMatrixForGui(base.entity, posX, posY, posZ, yawDelta, size);
			if (meshRefOpaque != null)
			{
				base.capi.Render.CurrentActiveShader.UniformMatrix("projectionMatrix", base.capi.Render.CurrentProjectionMatrix);
				base.capi.Render.CurrentActiveShader.UniformMatrix("modelViewMatrix", GetModelMatrixForGui(dt, posX, posY, posZ, yawDelta, size));
				base.capi.Render.RenderMultiTextureMesh(meshRefOpaque, "tex2d", 0);
			}
			if (!base.entity.ShapeFresh)
			{
				TesselateShape();
			}
		}

		protected virtual float[] GetModelMatrixForGui(float dt, double posX, double posY, double posZ, float yawDelta, float size)
		{
			Mat4f.Mul(ModelMat, base.capi.Render.CurrentModelviewMatrix, ModelMat);
			Mat4f.Translate(ModelMat, ModelMat, new float[3] { 0.5f, 0f, 0.5f });
			Mat4f.Scale(ModelMat, ModelMat, new float[3] { 1f, 1f, -1f });
			Mat4f.Translate(ModelMat, ModelMat, new float[3] { -0.5f, 0f, -0.5f });
			return ModelMat;
		}

		public override void DoRender3DOpaqueBatched(float dt, bool isShadowPass)
		{
			if (!isSpectator && meshRefOpaque != null)
			{
				IShaderProgram currentActiveShader = base.capi.Render.CurrentActiveShader;
				if (isShadowPass)
				{
					Mat4f.Mul(tmpMvMat, base.capi.Render.CurrentModelviewMatrix, ModelMat);
					currentActiveShader.UniformMatrix("modelViewMatrix", tmpMvMat);
				}
				else
				{
					frostAlpha += (targetFrostAlpha - frostAlpha) * dt / 6f;
					float num = (float)Math.Round(GameMath.Clamp(frostAlpha, 0f, 1f), 4);
					currentActiveShader.Uniform("rgbaLightIn", lightrgbs);
					currentActiveShader.Uniform("extraGlow", base.entity.Properties.Client.GlowLevel);
					currentActiveShader.UniformMatrix("modelMatrix", ModelMat);
					currentActiveShader.UniformMatrix("viewMatrix", base.capi.Render.CurrentModelviewMatrix);
					currentActiveShader.Uniform("addRenderFlags", AddRenderFlags);
					currentActiveShader.Uniform("windWaveIntensity", (float)WindWaveIntensity);
					currentActiveShader.Uniform("entityId", (int)base.entity.EntityId);
					currentActiveShader.Uniform("glitchFlicker", glitchFlicker ? 1 : 0);
					currentActiveShader.Uniform("frostAlpha", num);
					currentActiveShader.Uniform("waterWaveCounter", base.capi.Render.ShaderUniforms.WaterWaveCounter);
					color.R = (float)((base.entity.RenderColor >> 16) & 0xFF) / 255f;
					color.G = (float)((base.entity.RenderColor >> 8) & 0xFF) / 255f;
					color.B = (float)(base.entity.RenderColor & 0xFF) / 255f;
					color.A = (float)((base.entity.RenderColor >> 24) & 0xFF) / 255f;
					currentActiveShader.Uniform("renderColor", color);
					double val = ((TreeAttribute)base.entity.WatchedAttributes).GetDouble("temporalStability", 1.0);
					double val2 = ((TreeAttribute)((Entity)((IPlayer)base.capi.World.Player).Entity).WatchedAttributes).GetDouble("temporalStability", 1.0);
					double num2 = Math.Min(val, val2);
					float num3 = (float)(glitchAffected ? Math.Max(0.0, 1.0 - 2.5 * num2) : 0.0);
					currentActiveShader.Uniform("glitchEffectStrength", num3);
				}
				currentActiveShader.UBOs["Animation"].Update((object)base.entity.AnimManager.Animator.Matrices, 0, base.entity.AnimManager.Animator.MaxJointId * 16 * 4);
				if (meshRefOpaque != null)
				{
					base.capi.Render.RenderMultiTextureMesh(meshRefOpaque, "entityTex", 0);
				}
			}
		}

		public override void DoRender2D(float dt)
		{
			if (isSpectator || (debugTagTexture == null && messageTextures == null))
			{
				return;
			}
			Entity entity = base.entity;
			Entity obj = ((entity is EntityPlayer) ? entity : null);
			if (obj != null && ((EntityAgent)obj).ServerControls.Sneak && debugTagTexture == null)
			{
				return;
			}
			IRenderAPI render = base.capi.Render;
			EntityPlayer entity2 = ((IPlayer)base.capi.World.Player).Entity;
			Vec3d val = MatrixToolsd.Project(getAboveHeadPosition(entity2), render.PerspectiveProjectionMat, render.PerspectiveViewMat, render.FrameWidth, render.FrameHeight);
			if (val.Z < 0.0)
			{
				return;
			}
			float val2 = 4f / Math.Max(1f, (float)val.Z);
			float num = Math.Min(1f, val2);
			if (num > 0.75f)
			{
				num = 0.75f + (num - 0.75f) / 2f;
			}
			float num2 = 0f;
			((Entity)entity2).Pos.SquareDistanceTo(base.entity.Pos);
			if (debugTagTexture != null)
			{
				float num3 = (float)val.X - num * (float)debugTagTexture.Width / 2f;
				float num4 = (float)render.FrameHeight - (float)val.Y - (num2 + (float)debugTagTexture.Height) * Math.Max(0f, num);
				render.Render2DTexture(debugTagTexture.TextureId, num3, num4 - num2, num * (float)debugTagTexture.Width, num * (float)debugTagTexture.Height, 20f, (Vec4f)null);
			}
			if (messageTextures == null)
			{
				return;
			}
			num2 += 0f;
			foreach (MessageTexture messageTexture in messageTextures)
			{
				num2 += (float)messageTexture.tex.Height * num + 4f;
				float num5 = (float)val.X - num * (float)messageTexture.tex.Width / 2f;
				float num6 = (float)val.Y + num2;
				render.Render2DTexture(messageTexture.tex.TextureId, num5, (float)render.FrameHeight - num6, num * (float)messageTexture.tex.Width, num * (float)messageTexture.tex.Height, 20f, (Vec4f)null);
			}
		}

		public virtual Vec3d getAboveHeadPosition(EntityPlayer entityPlayer)
		{
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Expected O, but got Unknown
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Expected O, but got Unknown
			Entity entity = base.entity;
			Entity obj = ((entity is EntityAgent) ? entity : null);
			IMountableSeat val = ((obj != null) ? ((EntityAgent)obj).MountedOn : null);
			IMountableSeat mountedOn = ((EntityAgent)entityPlayer).MountedOn;
			Vec3d val3;
			if (((val != null) ? val.MountSupplier : null) != null && val.MountSupplier == ((mountedOn != null) ? mountedOn.MountSupplier : null))
			{
				Vec3d val2 = val.SeatPosition.XYZ - mountedOn.SeatPosition.XYZ;
				val3 = new Vec3d(entityPlayer.CameraPos.X + ((Entity)entityPlayer).LocalEyePos.X, entityPlayer.CameraPos.Y + 0.4 + ((Entity)entityPlayer).LocalEyePos.Y, entityPlayer.CameraPos.Z + ((Entity)entityPlayer).LocalEyePos.Z);
				val3.Add(val2);
			}
			else
			{
				val3 = new Vec3d(base.entity.Pos.X, base.entity.Pos.InternalY + (double)base.entity.SelectionBox.Y2 + 0.2, base.entity.Pos.Z);
			}
			double num = base.entity.SelectionBox.X2 - base.entity.OriginSelectionBox.X2;
			double num2 = base.entity.SelectionBox.Z2 - base.entity.OriginSelectionBox.Z2;
			val3.Add(num, 0.0, num2);
			return val3;
		}

		public void loadModelMatrix(Entity entity, float dt, bool isShadowPass)
		{
			//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02de: Invalid comparison between Unknown and I4
			EntityPlayer entity2 = ((IPlayer)base.capi.World.Player).Entity;
			Mat4f.Identity(ModelMat);
			IMountableSeat seatOfMountedEntity;
			if (ims != null && (seatOfMountedEntity = MountableUtil.GetSeatOfMountedEntity(ims, (Entity)(object)entity2)) != null)
			{
				Vec3d val = seatOfMountedEntity.SeatPosition.XYZ - seatOfMountedEntity.MountSupplier.Position.XYZ;
				ModelMat = Mat4f.Translate(ModelMat, ModelMat, 0f - (float)val.X, 0f - (float)val.Y, 0f - (float)val.Z);
			}
			else
			{
				Entity obj = ((entity is EntityAgent) ? entity : null);
				seatOfMountedEntity = ((obj != null) ? ((EntityAgent)obj).MountedOn : null);
				if (seatOfMountedEntity != null)
				{
					if (((EntityAgent)entity2).MountedOn != null && ((EntityAgent)entity2).MountedOn.Entity == seatOfMountedEntity.Entity)
					{
						EntityPos seatPosition = ((EntityAgent)entity2).MountedOn.SeatPosition;
						Mat4f.Translate(ModelMat, ModelMat, (float)(seatOfMountedEntity.SeatPosition.X - seatPosition.X), (float)(seatOfMountedEntity.SeatPosition.InternalY - seatPosition.Y), (float)(seatOfMountedEntity.SeatPosition.Z - seatPosition.Z));
					}
					else
					{
						Mat4f.Translate(ModelMat, ModelMat, (float)(seatOfMountedEntity.SeatPosition.X - entity2.CameraPos.X), (float)(seatOfMountedEntity.SeatPosition.InternalY - entity2.CameraPos.Y), (float)(seatOfMountedEntity.SeatPosition.Z - entity2.CameraPos.Z));
					}
				}
				else
				{
					Mat4f.Translate(ModelMat, ModelMat, (float)(entity.Pos.X - entity2.CameraPos.X), (float)(entity.Pos.InternalY - entity2.CameraPos.Y), (float)(entity.Pos.Z - entity2.CameraPos.Z));
				}
			}
			float num = entity.Properties.Client.Shape?.rotateX ?? 0f;
			float num2 = entity.Properties.Client.Shape?.rotateY ?? 0f;
			float num3 = entity.Properties.Client.Shape?.rotateZ ?? 0f;
			Mat4f.Translate(ModelMat, ModelMat, 0f, entity.SelectionBox.Y2 / 2f, 0f);
			if (!isShadowPass)
			{
				updateStepPitch(dt);
			}
			double[] array = Quaterniond.Create();
			float num4 = ((entity is EntityPlayer) ? 0f : entity.Pos.Pitch);
			float num5 = entity.Pos.Yaw + (num2 + 90f) * ((float)Math.PI / 180f);
			BlockFacing climbingOnFace = entity.ClimbingOnFace;
			int num6;
			if (entity.Properties.RotateModelOnClimb)
			{
				BlockFacing climbingOnFace2 = entity.ClimbingOnFace;
				num6 = ((climbingOnFace2 != null && (int)climbingOnFace2.Axis == 0) ? 1 : 0);
			}
			else
			{
				num6 = 0;
			}
			bool flag = (byte)num6 != 0;
			float num7 = -1f;
			Quaterniond.RotateX(array, array, (double)(num4 + num * ((float)Math.PI / 180f) + (flag ? (num5 * num7) : 0f)));
			Quaterniond.RotateY(array, array, (double)(flag ? 0f : num5));
			Quaterniond.RotateZ(array, array, (double)entity.Pos.Roll + stepPitch + (double)(num3 * ((float)Math.PI / 180f)) + (double)(flag ? ((float)Math.PI / 2f * (float)((climbingOnFace != BlockFacing.WEST) ? 1 : (-1))) : 0f));
			Quaterniond.RotateX(array, array, (double)xangle);
			Quaterniond.RotateY(array, array, (double)yangle);
			Quaterniond.RotateZ(array, array, (double)zangle);
			float[] array2 = new float[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array2[i] = (float)array[i];
			}
			Mat4f.Mul(ModelMat, ModelMat, Mat4f.FromQuat(Mat4f.Create(), array2));
			if (shouldSwivelFromMotion)
			{
				Mat4f.RotateX(ModelMat, ModelMat, nowSwivelRad);
			}
			float size = entity.Properties.Client.Size;
			Mat4f.Translate(ModelMat, ModelMat, 0f, (0f - entity.SelectionBox.Y2) / 2f, 0f);
			Mat4f.Scale(ModelMat, ModelMat, new float[3] { size, size, size });
			Mat4f.Translate(ModelMat, ModelMat, -0.5f, 0f, -0.5f);
		}

		protected void loadModelMatrixForGui(Entity entity, double posX, double posY, double posZ, double yawDelta, float size)
		{
			Mat4f.Identity(ModelMat);
			Mat4f.Translate(ModelMat, ModelMat, (float)posX, (float)posY, (float)posZ);
			Mat4f.Translate(ModelMat, ModelMat, size, 2f * size, 0f);
			float num = ((entity.Properties.Client.Shape != null) ? entity.Properties.Client.Shape.rotateX : 0f);
			float num2 = ((entity.Properties.Client.Shape != null) ? entity.Properties.Client.Shape.rotateY : 0f);
			float num3 = ((entity.Properties.Client.Shape != null) ? entity.Properties.Client.Shape.rotateZ : 0f);
			Mat4f.RotateX(ModelMat, ModelMat, (float)Math.PI + num * ((float)Math.PI / 180f));
			Mat4f.RotateY(ModelMat, ModelMat, (float)yawDelta + num2 * ((float)Math.PI / 180f));
			Mat4f.RotateZ(ModelMat, ModelMat, num3 * ((float)Math.PI / 180f));
			float num4 = entity.Properties.Client.Size * size;
			Mat4f.Scale(ModelMat, ModelMat, new float[3] { num4, num4, num4 });
			Mat4f.Translate(ModelMat, ModelMat, -0.5f, 0f, -0.5f);
		}

		private void updateStepPitch(float dt)
		{
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Invalid comparison between Unknown and I4
			if (!base.entity.CanStepPitch)
			{
				stepPitch = 0.0;
				return;
			}
			double num = 0.0;
			double num2;
			int num5;
			int num6;
			if (LastJumpMs > 0)
			{
				num = 0.0;
				if (base.capi.InWorldEllapsedMilliseconds - LastJumpMs > 500 && base.entity.OnGround)
				{
					LastJumpMs = -1L;
				}
			}
			else
			{
				prevYAccum += dt;
				if (prevYAccum > 0.20000000298023224)
				{
					prevYAccum = 0.0;
					prevY = base.entity.Pos.Y;
				}
				EntityAgent obj = eagent;
				if (obj != null && !((Entity)obj).Alive)
				{
					stepPitch = Math.Max(0.0, stepPitch - (double)(2f * dt));
				}
				if (eagent == null || base.entity.Properties.CanClimbAnywhere || !((Entity)eagent).Alive || ((TreeAttribute)base.entity.Attributes).GetInt("dmgkb", 0) != 0 || !base.entity.Properties.Client.PitchStep)
				{
					return;
				}
				if ((int)base.entity.Properties.Habitat == 2 || eagent.Controls.IsClimbing)
				{
					stepPitch = GameMath.Clamp(base.entity.Pos.Y - prevY + 0.1, 0.0, 0.3) - GameMath.Clamp(prevY - base.entity.Pos.Y - 0.1, 0.0, 0.3);
					return;
				}
				Vec3d motion = base.entity.ServerPos.Motion;
				if (motion.X != 0.0 && motion.Z != 0.0)
				{
					num2 = base.entity.Pos.Y - prevY;
					if (num2 != 0.0)
					{
						float num3 = (float)Math.PI - base.entity.ServerPos.Yaw;
						float num4 = (float)Math.Atan2(motion.Z, motion.X) + (float)Math.PI / 2f;
						if (Math.Abs(GameMath.AngleRadDistance(num3, num4)) > (float)Math.PI / 2f)
						{
							num2 = 0.0 - num2;
						}
					}
					if (!base.entity.FeetInLiquid)
					{
						num5 = ((!base.entity.Swimming) ? 1 : 0);
						if (num5 != 0)
						{
							num6 = ((num2 > 0.0) ? 1 : 0);
							goto IL_02bb;
						}
					}
					else
					{
						num5 = 0;
					}
					num6 = 0;
					goto IL_02bb;
				}
			}
			goto IL_0357;
			IL_0357:
			stepPitch += (num - stepPitch) * (double)dt * 5.0;
			if (Math.Abs(stepPitch) < 1E-07)
			{
				stepPitch = 0.0;
			}
			return;
			IL_02bb:
			bool flag = (byte)num6 != 0;
			bool num7 = num5 != 0 && num2 < 0.0 && stepingAccum == 0f;
			stepingAccum = Math.Max(0f, stepingAccum - dt);
			fallingAccum = Math.Max(0f, fallingAccum - dt);
			if (flag)
			{
				stepingAccum = 0.2f;
			}
			if (num7)
			{
				fallingAccum = 0.2f;
			}
			if (stepingAccum > fallingAccum)
			{
				num = -0.5;
			}
			else if (fallingAccum > stepingAccum)
			{
				num = 0.5;
			}
			goto IL_0357;
		}

		protected virtual void determineSidewaysSwivel(float dt)
		{
			if (!shouldSwivelFromMotion)
			{
				if (eagent != null)
				{
					eagent.sidewaysSwivelAngle = 0f;
				}
				return;
			}
			if (!base.entity.CanSwivel)
			{
				nowSwivelRad = 0f;
				targetSwivelRad = 0f;
				if (eagent != null)
				{
					eagent.sidewaysSwivelAngle = 0f;
				}
				return;
			}
			swivelaccum += dt;
			if ((double)swivelaccum > 0.1 && base.entity.CanSwivelNow)
			{
				double num = base.entity.Pos.X - prevPosXSwing;
				double num2 = base.entity.Pos.Z - prevPosZSwing;
				double num3 = Math.Atan2(num2, num);
				double num4 = Math.Sqrt(num * num + num2 * num2);
				swivelaccum = 0f;
				float num5 = GameMath.AngleRadDistance((float)num3, (float)prevAngleSwing);
				if (Math.Abs(num5) < (float)Math.PI / 2f)
				{
					float num6 = (float)Math.PI / 180f * maxSwivelAngle;
					targetSwivelRad = GameMath.Clamp((float)num4 * num5 * 3f, 0f - num6, num6);
				}
				else
				{
					targetSwivelRad = 0f;
				}
				prevAngleSwing = num3;
				prevPosXSwing = base.entity.Pos.X;
				prevPosZSwing = base.entity.Pos.Z;
			}
			float num7 = GameMath.AngleRadDistance(nowSwivelRad, targetSwivelRad);
			nowSwivelRad += GameMath.Clamp(num7 * dt * 2f, -0.15f, 0.15f);
			if (eagent != null)
			{
				eagent.sidewaysSwivelAngle = nowSwivelRad;
			}
		}

		public override void Dispose()
		{
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Expected O, but got Unknown
			((IWorldAccessor)base.capi.World).UnregisterGameTickListener(listenerId);
			listenerId = 0L;
			if (meshRefOpaque != null)
			{
				meshRefOpaque.Dispose();
				meshRefOpaque = null;
			}
			if (debugTagTexture != null)
			{
				debugTagTexture.Dispose();
				debugTagTexture = null;
			}
			base.capi.Event.ReloadShapes -= base.entity.MarkShapeModified;
			if (DisplayChatMessages)
			{
				base.capi.Event.ChatMessage -= new ChatLineDelegate(OnChatMessage);
			}
		}
	}
	public class ModSystemFpHands : ModSystem
	{
		public IShaderProgram fpModeItemShader;

		public IShaderProgram fpModeHandShader;

		private ICoreClientAPI capi;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI capi)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Expected O, but got Unknown
			this.capi = capi;
			capi.Event.ReloadShader += new ActionBoolReturn(LoadShaders);
			LoadShaders();
		}

		public bool LoadShaders()
		{
			fpModeItemShader = createProg();
			capi.Shader.RegisterFileShaderProgram("standard", fpModeItemShader);
			fpModeHandShader = createProg();
			capi.Shader.RegisterFileShaderProgram("entityanimated", fpModeHandShader);
			bool flag = fpModeItemShader.Compile() && fpModeHandShader.Compile();
			if (flag)
			{
				foreach (UBORef value in fpModeHandShader.UBOs.Values)
				{
					value.Dispose();
				}
				fpModeHandShader.UBOs.Clear();
				fpModeHandShader.UBOs["Animation"] = capi.Render.CreateUBO(fpModeHandShader, 0, "Animation", GlobalConstants.MaxAnimatedElements * 16 * 4);
			}
			return flag;
		}

		private IShaderProgram createProg()
		{
			IShaderProgram obj = capi.Shader.NewShaderProgram();
			obj.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			obj.VertexShader.PrefixCode = "#define ALLOWDEPTHOFFSET 1\r\n";
			IShader vertexShader = obj.VertexShader;
			vertexShader.PrefixCode = vertexShader.PrefixCode + "#define MAXANIMATEDELEMENTS " + GlobalConstants.MaxAnimatedElements + "\r\n";
			obj.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			obj.FragmentShader.PrefixCode = "#define ALLOWDEPTHOFFSET 1\r\n";
			return obj;
		}
	}
	public abstract class AiTaskButterflyGoto : AiActionBase
	{
		protected Vec3d target;

		private float moveSpeed = 0.03f;

		private float minTurnAnglePerSec;

		private float maxTurnAnglePerSec;

		private float curTurnRadPerSec;

		public AiTaskButterflyGoto(EntityAgent entity)
			: base(entity)
		{
		}

		public override void LoadConfig(JsonObject taskConfig, JsonObject aiConfig)
		{
			base.LoadConfig(taskConfig, aiConfig);
			moveSpeed = taskConfig["movespeed"].AsFloat(0.03f);
			EntityAgent obj = entity;
			if (((obj == null) ? null : ((EntitySidedProperties)(((Entity)obj).Properties?.Server?)).Attributes) != null)
			{
				EntityServerProperties server = ((Entity)entity).Properties.Server;
				minTurnAnglePerSec = ((server != null) ? new float?(((EntitySidedProperties)server).Attributes.GetTreeAttribute("pathfinder").GetFloat("minTurnAnglePerSec", 250f)) : ((float?)null)).Value;
				EntityServerProperties server2 = ((Entity)entity).Properties.Server;
				maxTurnAnglePerSec = ((server2 != null) ? new float?(((EntitySidedProperties)server2).Attributes.GetTreeAttribute("pathfinder").GetFloat("maxTurnAnglePerSec", 450f)) : ((float?)null)).Value;
			}
			else
			{
				minTurnAnglePerSec = 250f;
				maxTurnAnglePerSec = 450f;
			}
		}

		protected override void StartExecute()
		{
			entity.Controls.Forward = true;
			curTurnRadPerSec = minTurnAnglePerSec + (float)((Entity)entity).World.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
			curTurnRadPerSec *= 0.87266463f * moveSpeed;
		}

		protected override bool ContinueExecute(float dt)
		{
			return true;
		}
	}
	public abstract class AiActionBase
	{
		public Random rand;

		public EntityAgent entity;

		public IWorldAccessor world;

		public AnimationMetaData animMeta;

		protected string sound;

		protected float soundRange;

		protected int soundStartMs;

		protected float soundChance = 1.01f;

		protected PathTraverserBase pathTraverser;

		protected double secondsActive;

		public AiActionBase(EntityAgent entity)
		{
			this.entity = entity;
			world = ((Entity)entity).World;
			rand = new Random((int)((Entity)entity).EntityId);
			pathTraverser = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().PathTraverser;
		}

		public virtual void LoadConfig(JsonObject taskConfig, JsonObject aiConfig)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			JsonObject val = taskConfig["animation"];
			if (val.Exists)
			{
				string text = val.AsString((string)null)?.ToLowerInvariant();
				animMeta = new AnimationMetaData
				{
					Code = text,
					Animation = text,
					AnimationSpeed = taskConfig["animationSpeed"].AsFloat(1f)
				}.Init();
			}
			JsonObject val2 = taskConfig["sound"];
			if (val2.Exists)
			{
				sound = val2.AsString((string)null);
				soundRange = taskConfig["soundRange"].AsFloat(16f);
				soundStartMs = taskConfig["soundStartMs"].AsInt(0);
			}
		}

		public virtual bool ShouldExecuteAll()
		{
			soundChance = Math.Min(1.01f, soundChance + 0.002f);
			return ShouldExecute();
		}

		internal abstract bool ShouldExecute();

		protected virtual void StartExecute()
		{
		}

		public virtual void StartExecuteAll()
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Expected O, but got Unknown
			if (animMeta != null)
			{
				((Entity)entity).AnimManager.StartAnimation(animMeta);
			}
			if (sound != null)
			{
				if (((Entity)entity).World.Rand.NextDouble() <= (double)soundChance)
				{
					if (soundStartMs == 0)
					{
						((Entity)entity).World.PlaySoundAt(new AssetLocation("sounds/" + sound), ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, true, soundRange, 1f);
					}
				}
				else
				{
					soundStartMs = 0;
				}
				soundChance = Math.Max(0.025f, soundChance - 0.2f);
			}
			StartExecute();
		}

		public bool ContinueExecuteAll(float dt)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Expected O, but got Unknown
			secondsActive += dt;
			if (soundStartMs > 0 && secondsActive > (double)(soundStartMs * 1000))
			{
				((Entity)entity).World.PlaySoundAt(new AssetLocation("sounds/" + sound), ((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.InternalY, ((Entity)entity).ServerPos.Z, (IPlayer)null, true, soundRange, 1f);
			}
			return ContinueExecute(dt);
		}

		protected abstract bool ContinueExecute(float dt);

		public virtual void FinishExecuteAll(bool cancelled)
		{
			if (animMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(animMeta.Code);
			}
			FinishExecute(cancelled);
		}

		protected virtual void FinishExecute(bool cancelled)
		{
		}
	}
	public static class AiGoalRegistry
	{
		public static Dictionary<string, Type> GoalTypes;

		public static Dictionary<Type, string> GoalCodes;

		public static Dictionary<string, Type> ActionTypes;

		public static Dictionary<Type, string> ActionCodes;

		public static void RegisterGoal<T>(string code) where T : AiGoalBase
		{
			GoalTypes[code] = typeof(T);
			GoalCodes[typeof(T)] = code;
		}

		public static void RegisterAction<T>(string code) where T : AiActionBase
		{
			ActionTypes[code] = typeof(T);
			ActionCodes[typeof(T)] = code;
		}

		static AiGoalRegistry()
		{
			GoalTypes = new Dictionary<string, Type>();
			GoalCodes = new Dictionary<Type, string>();
			ActionTypes = new Dictionary<string, Type>();
			ActionCodes = new Dictionary<Type, string>();
		}
	}
	public class AiGoalManager
	{
		private Entity entity;

		private List<AiGoalBase> Goals = new List<AiGoalBase>();

		private AiGoalBase activeGoal;

		public AiGoalManager(Entity entity)
		{
			this.entity = entity;
		}

		public void AddGoal(AiGoalBase goal)
		{
			Goals.Add(goal);
		}

		public void RemoveGoal(AiGoalBase goal)
		{
			Goals.Remove(goal);
		}

		public void OnGameTick(float dt)
		{
			foreach (AiGoalBase goal in Goals)
			{
				if ((activeGoal == null || goal.Priority > activeGoal.PriorityForCancel) && goal.ShouldExecuteAll())
				{
					activeGoal?.FinishExecuteAll(cancelled: true);
					activeGoal = goal;
					goal.StartExecuteAll();
				}
			}
			if (activeGoal != null && !activeGoal.ContinueExecuteAll(dt))
			{
				activeGoal.FinishExecuteAll(cancelled: false);
				activeGoal = null;
			}
			if (entity.World.EntityDebugMode)
			{
				string text = "";
				if (activeGoal != null)
				{
					text = text + AiTaskRegistry.TaskCodes[activeGoal.GetType()] + "(" + activeGoal.Priority + ")";
				}
				((TreeAttribute)entity.DebugAttributes).SetString("AI Goal", (text.Length > 0) ? text : "-");
			}
		}

		internal void Notify(string key, object data)
		{
			for (int i = 0; i < Goals.Count; i++)
			{
				AiGoalBase aiGoalBase = Goals[i];
				if (aiGoalBase.Notify(key, data) && (aiGoalBase == null || aiGoalBase.Priority > activeGoal.PriorityForCancel))
				{
					activeGoal?.FinishExecuteAll(cancelled: true);
					activeGoal = aiGoalBase;
					aiGoalBase.StartExecuteAll();
				}
			}
		}

		internal void OnStateChanged(EnumEntityState beforeState)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			foreach (IAiTask goal in Goals)
			{
				goal.OnStateChanged(beforeState);
			}
		}
	}
	public class EntityBehaviorGoalAI : EntityBehavior
	{
		public AiGoalManager goalManager;

		public PathTraverserBase PathTraverser;

		public EntityBehaviorGoalAI(Entity entity)
			: base(entity)
		{
			goalManager = new AiGoalManager(entity);
		}

		public override void Initialize(EntityProperties properties, JsonObject aiconfig)
		{
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Expected O, but got Unknown
			if (!(base.entity is EntityAgent))
			{
				base.entity.World.Logger.Error("The goal ai currently only works on entities inheriting from EntityAgent. Will ignore loading goals for entity {0} ", new object[1] { ((RegistryObject)base.entity).Code });
				return;
			}
			ref PathTraverserBase pathTraverser = ref PathTraverser;
			Entity entity = base.entity;
			pathTraverser = new StraightLineTraverser((EntityAgent)(object)((entity is EntityAgent) ? entity : null));
			JsonObject obj = aiconfig["aigoals"];
			JsonObject[] array = ((obj != null) ? obj.AsArray() : null);
			if (array == null)
			{
				return;
			}
			JsonObject[] array2 = array;
			foreach (JsonObject val in array2)
			{
				JsonObject obj2 = val["code"];
				string text = ((obj2 != null) ? obj2.AsString((string)null) : null);
				if (!AiGoalRegistry.GoalTypes.TryGetValue(text, out var value))
				{
					base.entity.World.Logger.Error("Goal with code {0} for entity {1} does not exist. Ignoring.", new object[2]
					{
						text,
						((RegistryObject)base.entity).Code
					});
				}
				else
				{
					AiGoalBase aiGoalBase = (AiGoalBase)Activator.CreateInstance(value, (object)(EntityAgent)base.entity);
					aiGoalBase.LoadConfig(val, aiconfig);
					goalManager.AddGoal(aiGoalBase);
				}
			}
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			if ((int)base.entity.State == 0)
			{
				PathTraverser.OnGameTick(deltaTime);
				goalManager.OnGameTick(deltaTime);
				base.entity.World.FrameProfiler.Mark("entity-ai");
			}
		}

		public override void OnStateChanged(EnumEntityState beforeState, ref EnumHandling handled)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			goalManager.OnStateChanged(beforeState);
		}

		public override void Notify(string key, object data)
		{
			goalManager.Notify(key, data);
		}

		public override string PropertyName()
		{
			return "goalai";
		}
	}
	public class AIGoal
	{
		private IWorldAccessor world;

		private BehaviorGoapAI behavior;

		public AIGoal(BehaviorGoapAI behavior, IWorldAccessor world)
		{
			this.world = world;
			this.behavior = behavior;
		}

		public virtual bool ShouldExecute()
		{
			return false;
		}
	}
	public class AIGoapAction
	{
		private Dictionary<string, GoapCondition> conditions = new Dictionary<string, GoapCondition>();

		private Dictionary<string, GoapCondition> effect = new Dictionary<string, GoapCondition>();

		public virtual float Cost => 1f;
	}
	public class BehaviorGoapAI : EntityBehavior
	{
		private ITreeAttribute goaltree;

		internal float Aggressivness => goaltree.GetFloat("aggressivness", 0f);

		public BehaviorGoapAI(Entity entity)
			: base(entity)
		{
			goaltree = ((TreeAttribute)entity.WatchedAttributes).GetTreeAttribute("goaltree");
		}

		public override string PropertyName()
		{
			return "goaloriented";
		}
	}
	public abstract class AiTaskBaseTargetable : AiTaskBase, IWorldIntersectionSupplier
	{
		protected EntityTagRule[] EntityTags = Array.Empty<EntityTagRule>();

		protected EntityTagRule[] SkipEntityTags = Array.Empty<EntityTagRule>();

		protected bool noTags = true;

		protected bool reverseTagsCheck;

		protected float MinTargetWeight;

		protected float MaxTargetWeight;

		protected string[] targetEntityCodesBeginsWith = Array.Empty<string>();

		protected string[] targetEntityCodesExact;

		protected AssetLocation[] skipEntityCodes;

		protected string targetEntityFirstLetters = "";

		protected EnumCreatureHostility creatureHostility;

		protected bool friendlyTarget;

		public Entity targetEntity;

		protected Entity attackedByEntity;

		protected long attackedByEntityMs;

		protected bool retaliateAttacks = true;

		public string triggerEmotionState;

		protected float tamingGenerations = 10f;

		protected EntityPartitioning partitionUtil;

		protected EntityBehaviorControlledPhysics bhPhysics;

		protected BlockSelection blockSel = new BlockSelection();

		protected EntitySelection entitySel = new EntitySelection();

		protected readonly Vec3d rayTraceFrom = new Vec3d();

		protected readonly Vec3d rayTraceTo = new Vec3d();

		protected readonly Vec3d tmpPos = new Vec3d();

		private Vec3d tmpVec = new Vec3d();

		protected Vec3d collTmpVec = new Vec3d();

		protected float stepHeight;

		public virtual bool AggressiveTargeting => true;

		public Entity TargetEntity => targetEntity;

		protected bool noEntityCodes
		{
			get
			{
				if (targetEntityCodesExact.Length == 0)
				{
					return targetEntityCodesBeginsWith.Length == 0;
				}
				return false;
			}
		}

		protected bool RecentlyAttacked => ((Entity)entity).World.ElapsedMilliseconds - attackedByEntityMs < 30000;

		public Vec3i MapSize => ((Entity)entity).World.BlockAccessor.MapSize;

		public IBlockAccessor blockAccessor => ((Entity)entity).World.BlockAccessor;

		protected AiTaskBaseTargetable(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Expected O, but got Unknown
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Expected O, but got Unknown
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Expected O, but got Unknown
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Expected O, but got Unknown
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Expected O, but got Unknown
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Expected O, but got Unknown
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Expected O, but got Unknown
			partitionUtil = ((Entity)entity).Api.ModLoader.GetModSystem<EntityPartitioning>(true);
			creatureHostility = ((Entity)entity).World.Config.GetString("creatureHostility", (string)null) switch
			{
				"aggressive" => EnumCreatureHostility.Aggressive, 
				"passive" => EnumCreatureHostility.Passive, 
				"off" => EnumCreatureHostility.NeverHostile, 
				_ => EnumCreatureHostility.Aggressive, 
			};
			tamingGenerations = taskConfig["tamingGenerations"].AsFloat(10f);
			friendlyTarget = taskConfig["friendlyTarget"].AsBool(false);
			retaliateAttacks = taskConfig["retaliateAttacks"].AsBool(true);
			triggerEmotionState = taskConfig["triggerEmotionState"].AsString((string)null);
			skipEntityCodes = taskConfig["skipEntityCodes"].AsArray<string>((string[])null, (string)null)?.Select((string str) => AssetLocation.Create(str, ((RegistryObject)entity).Code.Domain)).ToArray();
			InitializeTargetCodes(taskConfig["entityCodes"].AsArray<string>(new string[1] { "player" }, (string)null), ref targetEntityCodesExact, ref targetEntityCodesBeginsWith, ref targetEntityFirstLetters);
			List<List<string>> list = taskConfig["entityTags"].AsObject<List<List<string>>>(new List<List<string>>());
			List<List<string>> list2 = taskConfig["skipEntityTags"].AsObject<List<List<string>>>(new List<List<string>>());
			if (list != null)
			{
				EntityTags = ((IEnumerable<List<string>>)list).Select((Func<List<string>, EntityTagRule>)((List<string> tagList) => new EntityTagRule(((Entity)entity).Api, (IEnumerable<string>)tagList))).ToArray();
			}
			if (list2 != null)
			{
				SkipEntityTags = ((IEnumerable<List<string>>)list2).Select((Func<List<string>, EntityTagRule>)((List<string> tagList) => new EntityTagRule(((Entity)entity).Api, (IEnumerable<string>)tagList))).ToArray();
			}
			reverseTagsCheck = taskConfig["reverseTagsCheck"].AsBool(false);
			noTags = EntityTags.Length == 0 && SkipEntityTags.Length == 0;
			MinTargetWeight = taskConfig["MinTargetWeight"].AsFloat(0f);
			MaxTargetWeight = taskConfig["MaxTargetWeight"].AsFloat(float.MaxValue);
		}

		public static void InitializeTargetCodes(string[] codes, ref string[] targetEntityCodesExact, ref string[] targetEntityCodesBeginsWith, ref string targetEntityFirstLetters)
		{
			List<string> list = new List<string>();
			List<string> list2 = new List<string>();
			foreach (string text in codes)
			{
				if (text.EndsWith('*'))
				{
					list2.Add(text.Substring(0, text.Length - 1));
				}
				else
				{
					list.Add(text);
				}
			}
			targetEntityCodesBeginsWith = list2.ToArray();
			targetEntityCodesExact = new string[list.Count];
			int num = 0;
			foreach (string item in list)
			{
				if (item.Length != 0)
				{
					targetEntityCodesExact[num++] = item;
					char c = item[0];
					if (targetEntityFirstLetters.IndexOf(c) < 0)
					{
						targetEntityFirstLetters += c;
					}
				}
			}
			string[] array = targetEntityCodesBeginsWith;
			foreach (string text2 in array)
			{
				if (text2.Length == 0)
				{
					targetEntityFirstLetters = "";
					break;
				}
				char c2 = text2[0];
				if (targetEntityFirstLetters.IndexOf(c2) < 0)
				{
					targetEntityFirstLetters += c2;
				}
			}
		}

		public override void AfterInitialize()
		{
			bhPhysics = ((Entity)entity).GetBehavior<EntityBehaviorControlledPhysics>();
		}

		public override void StartExecute()
		{
			stepHeight = bhPhysics?.StepHeight ?? 0.6f;
			base.StartExecute();
			if (triggerEmotionState != null)
			{
				((Entity)entity).GetBehavior<EntityBehaviorEmotionStates>()?.TryTriggerState(triggerEmotionState, 1.0, targetEntity?.EntityId ?? 0);
			}
			EntityBehaviorControlledPhysics behavior = ((Entity)entity).GetBehavior<EntityBehaviorControlledPhysics>();
			if (behavior != null)
			{
				stepHeight = behavior.StepHeight;
			}
		}

		protected virtual bool CheckTargetWeight(float weight)
		{
			float num = ((((Entity)entity).Properties.Weight > 0f) ? (weight / ((Entity)entity).Properties.Weight) : float.MaxValue);
			if (MinTargetWeight > 0f && num < MinTargetWeight)
			{
				return false;
			}
			if (MaxTargetWeight > 0f && num > MaxTargetWeight)
			{
				return false;
			}
			return true;
		}

		protected virtual bool CheckTargetTags(EntityTagArray tags)
		{
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (!reverseTagsCheck)
			{
				if (EntityTagRule.IntersectsWithEach(tags, EntityTags))
				{
					if (SkipEntityTags.Length == 0)
					{
						return true;
					}
					if (!reverseTagsCheck)
					{
						if (!EntityTagRule.IntersectsWithEach(tags, SkipEntityTags))
						{
							return true;
						}
					}
					else if (!EntityTagRule.ContainsAllFromAtLeastOne(tags, SkipEntityTags))
					{
						return true;
					}
				}
			}
			else if (EntityTagRule.ContainsAllFromAtLeastOne(tags, EntityTags))
			{
				if (SkipEntityTags.Length == 0)
				{
					return true;
				}
				if (!reverseTagsCheck)
				{
					if (!EntityTagRule.IntersectsWithEach(tags, SkipEntityTags))
					{
						return true;
					}
				}
				else if (!EntityTagRule.ContainsAllFromAtLeastOne(tags, SkipEntityTags))
				{
					return true;
				}
			}
			return false;
		}

		public virtual bool IsTargetableEntityWithTags(Entity e, float range)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			if (CheckTargetTags(e.Tags) && CheckTargetWeight(e.Properties.Weight))
			{
				if (e.Alive)
				{
					return CanSense(e, range);
				}
				return false;
			}
			if (targetEntityFirstLetters.Length == 0 || IsTargetEntity(((RegistryObject)e).Code.Path))
			{
				if (e.Alive)
				{
					return CanSense(e, range);
				}
				return false;
			}
			return false;
		}

		public virtual bool IsTargetableEntityNoTagsNoAll(Entity e, float range)
		{
			if (IsTargetEntity(((RegistryObject)e).Code.Path))
			{
				if (e.Alive)
				{
					return CanSense(e, range);
				}
				return false;
			}
			return false;
		}

		public virtual bool IsTargetableEntityNoTagsAll(Entity e, float range)
		{
			if (e.Alive)
			{
				return CanSense(e, range);
			}
			return false;
		}

		public virtual bool IsTargetableEntity(Entity e, float range, bool ignoreEntityCode = false)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			if (!e.Alive)
			{
				return false;
			}
			if (ignoreEntityCode)
			{
				return CanSense(e, range);
			}
			if (!noTags && CheckTargetTags(e.Tags) && CheckTargetWeight(e.Properties.Weight))
			{
				return CanSense(e, range);
			}
			if (targetEntityFirstLetters.Length == 0 || IsTargetEntity(((RegistryObject)e).Code.Path))
			{
				return CanSense(e, range);
			}
			return false;
		}

		protected bool IsTargetEntity(string testPath)
		{
			if (targetEntityFirstLetters.IndexOf(testPath[0]) < 0)
			{
				return false;
			}
			string[] array = targetEntityCodesExact;
			for (int i = 0; i < array.Length; i++)
			{
				if (testPath == array[i])
				{
					return true;
				}
			}
			array = targetEntityCodesBeginsWith;
			for (int j = 0; j < array.Length; j++)
			{
				if (StringUtil.StartsWithFast(testPath, array[j]))
				{
					return true;
				}
			}
			return false;
		}

		public virtual bool CanSense(Entity e, double range)
		{
			if (e.EntityId == ((Entity)entity).EntityId || !e.IsInteractable)
			{
				return false;
			}
			EntityPlayer val = (EntityPlayer)(object)((e is EntityPlayer) ? e : null);
			if (val != null)
			{
				return CanSensePlayer(val, range);
			}
			if (skipEntityCodes != null)
			{
				for (int i = 0; i < skipEntityCodes.Length; i++)
				{
					if (WildcardUtil.Match(skipEntityCodes[i], ((RegistryObject)e).Code))
					{
						return false;
					}
				}
			}
			return true;
		}

		public virtual bool CanSensePlayer(EntityPlayer eplr, double range)
		{
			if (!friendlyTarget && AggressiveTargeting)
			{
				if (creatureHostility == EnumCreatureHostility.NeverHostile)
				{
					return false;
				}
				if (creatureHostility == EnumCreatureHostility.Passive && (bhEmo == null || (!IsInEmotionState("aggressiveondamage") && !IsInEmotionState("aggressivearoundentities"))))
				{
					return false;
				}
			}
			float num = ((Entity)eplr).Stats.GetBlended("animalSeekingRange");
			IPlayer player = eplr.Player;
			if (((EntityAgent)eplr).Controls.Sneak && ((Entity)eplr).OnGround)
			{
				num *= 0.6f;
			}
			if ((num == 1f || ((Entity)entity).ServerPos.DistanceTo(((Entity)eplr).Pos) < range * (double)num) && targetablePlayerMode(player) && ((Entity)entity).ServerPos.Dimension == ((Entity)eplr).Pos.Dimension)
			{
				return true;
			}
			return false;
		}

		protected virtual bool targetablePlayerMode(IPlayer player)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Invalid comparison between Unknown and I4
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Invalid comparison between Unknown and I4
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Invalid comparison between Unknown and I4
			if (player != null)
			{
				if ((int)player.WorldData.CurrentGameMode != 2 && (int)player.WorldData.CurrentGameMode != 3)
				{
					return (int)((IServerPlayer)((player is IServerPlayer) ? player : null)).ConnectionState == 3;
				}
				return false;
			}
			return true;
		}

		protected virtual bool hasDirectContact(Entity targetEntity, float minDist, float minVerDist)
		{
			if (targetEntity.Pos.Dimension != ((Entity)entity).Pos.Dimension)
			{
				return false;
			}
			Cuboidd obj = targetEntity.SelectionBox.ToDouble().Translate(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
			tmpPos.Set(((Entity)entity).ServerPos).Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			double num = obj.ShortestDistanceFrom((IVec3)(object)tmpPos);
			double num2 = Math.Abs(obj.ShortestVerticalDistanceFrom(tmpPos.Y));
			if (num >= (double)minDist || num2 >= (double)minVerDist)
			{
				return false;
			}
			rayTraceFrom.Set(((Entity)entity).ServerPos);
			Vec3d obj2 = rayTraceFrom;
			obj2.Y += 1.0 / 32.0;
			rayTraceTo.Set(targetEntity.ServerPos);
			Vec3d obj3 = rayTraceTo;
			obj3.Y += 1.0 / 32.0;
			bool flag = false;
			((Entity)entity).World.RayTraceForSelection((IWorldIntersectionSupplier)(object)this, rayTraceFrom, rayTraceTo, ref blockSel, ref entitySel, (BlockFilter)null, (EntityFilter)null);
			flag = blockSel == null;
			if (!flag)
			{
				Vec3d obj4 = rayTraceFrom;
				obj4.Y += (double)(((Entity)entity).SelectionBox.Y2 * 7f / 16f);
				Vec3d obj5 = rayTraceTo;
				obj5.Y += (double)(targetEntity.SelectionBox.Y2 * 7f / 16f);
				((Entity)entity).World.RayTraceForSelection((IWorldIntersectionSupplier)(object)this, rayTraceFrom, rayTraceTo, ref blockSel, ref entitySel, (BlockFilter)null, (EntityFilter)null);
				flag = blockSel == null;
			}
			if (!flag)
			{
				Vec3d obj6 = rayTraceFrom;
				obj6.Y += (double)(((Entity)entity).SelectionBox.Y2 * 7f / 16f);
				Vec3d obj7 = rayTraceTo;
				obj7.Y += (double)(targetEntity.SelectionBox.Y2 * 7f / 16f);
				((Entity)entity).World.RayTraceForSelection((IWorldIntersectionSupplier)(object)this, rayTraceFrom, rayTraceTo, ref blockSel, ref entitySel, (BlockFilter)null, (EntityFilter)null);
				flag = blockSel == null;
			}
			if (!flag)
			{
				return false;
			}
			return true;
		}

		protected void updateTargetPosFleeMode(Vec3d targetPos, float yaw)
		{
			tmpVec = tmpVec.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec.Ahead(0.9, 0f, yaw);
			if (traversable(tmpVec))
			{
				targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw);
				return;
			}
			tmpVec = tmpVec.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec.Ahead(0.9, 0f, yaw - (float)Math.PI / 2f);
			if (traversable(tmpVec))
			{
				targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw - (float)Math.PI / 2f);
				return;
			}
			tmpVec = tmpVec.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec.Ahead(0.9, 0f, yaw + (float)Math.PI / 2f);
			if (traversable(tmpVec))
			{
				targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw + (float)Math.PI / 2f);
				return;
			}
			tmpVec = tmpVec.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec.Ahead(0.9, 0f, yaw + (float)Math.PI);
			targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw + (float)Math.PI);
		}

		protected bool traversable(Vec3d pos)
		{
			if (world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, pos, false))
			{
				return !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, collTmpVec.Set(pos).Add(0.0, (double)Math.Min(1f, stepHeight), 0.0), false);
			}
			return true;
		}

		public Block GetBlock(BlockPos pos)
		{
			return ((Entity)entity).World.BlockAccessor.GetBlock(pos);
		}

		public Cuboidf[] GetBlockIntersectionBoxes(BlockPos pos)
		{
			return ((Entity)entity).World.BlockAccessor.GetBlock(pos).GetCollisionBoxes(((Entity)entity).World.BlockAccessor, pos);
		}

		public bool IsValidPos(BlockPos pos)
		{
			return ((Entity)entity).World.BlockAccessor.IsValidPos(pos);
		}

		public Entity[] GetEntitiesAround(Vec3d position, float horRange, float vertRange, ActionConsumable<Entity> matches = null)
		{
			return Array.Empty<Entity>();
		}

		public Entity GetGuardedEntity()
		{
			string text = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetString("guardedPlayerUid", (string)null);
			if (text != null)
			{
				IPlayer obj = ((Entity)entity).World.PlayerByUid(text);
				if (obj == null)
				{
					return null;
				}
				return (Entity)(object)obj.Entity;
			}
			long num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetLong("guardedEntityId", 0L);
			return ((Entity)entity).World.GetEntityById(num);
		}

		public int GetOwnGeneration()
		{
			int num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetInt("generation", 0);
			JsonObject attributes = ((Entity)entity).Properties.Attributes;
			if (attributes != null && attributes.IsTrue("tamed"))
			{
				num += 10;
			}
			return num;
		}

		protected bool isNonAttackingPlayer(Entity e)
		{
			if (attackedByEntity == null || (attackedByEntity != null && attackedByEntity.EntityId != e.EntityId))
			{
				return e is EntityPlayer;
			}
			return false;
		}

		public override void OnEntityHurt(DamageSource source, float damage)
		{
			attackedByEntity = source.GetCauseEntity();
			attackedByEntityMs = ((Entity)entity).World.ElapsedMilliseconds;
			base.OnEntityHurt(source, damage);
		}

		public void ClearAttacker()
		{
			attackedByEntity = null;
			attackedByEntityMs = -9999L;
		}
	}
	public static class ApiTaskAdditions
	{
		public static void RegisterAiTask<TTask>(this ICoreServerAPI serverAPI, string code) where TTask : IAiTask
		{
			AiTaskRegistry.Register<TTask>(code);
		}
	}
	public static class AiTaskRegistry
	{
		public static readonly Dictionary<string, Type> TaskTypes;

		public static readonly Dictionary<Type, string> TaskCodes;

		public static void Register<TTask>(string code) where TTask : IAiTask
		{
			TaskTypes[code] = typeof(TTask);
			TaskCodes[typeof(TTask)] = code;
		}

		static AiTaskRegistry()
		{
			TaskTypes = new Dictionary<string, Type>();
			TaskCodes = new Dictionary<Type, string>();
			Register<AiTaskWander>("wander");
			Register<AiTaskLookAround>("lookaround");
			Register<AiTaskMeleeAttack>("meleeattack");
			Register<AiTaskSeekEntity>("seekentity");
			Register<AiTaskFleeEntity>("fleeentity");
			Register<AiTaskStayCloseToEntity>("stayclosetoentity");
			Register<AiTaskGetOutOfWater>("getoutofwater");
			Register<AiTaskIdle>("idle");
			Register<AiTaskSeekFoodAndEat>("seekfoodandeat");
			Register<AiTaskSeekBlockAndLay>("seekblockandlay");
			Register<AiTaskUseInventory>("useinventory");
			Register<AiTaskMeleeAttackTargetingEntity>("meleeattacktargetingentity");
			Register<AiTaskSeekTargetingEntity>("seektargetingentity");
			Register<AiTaskStayCloseToGuardedEntity>("stayclosetoguardedentity");
			Register<AiTaskJealousMeleeAttack>("jealousmeleeattack");
			Register<AiTaskJealousSeekEntity>("jealousseekentity");
			Register<AiTaskLookAtEntity>("lookatentity");
			Register<AiTaskGotoEntity>("gotoentity");
			Register<AiTaskWanderR>("wander-r");
			Register<AiTaskBellAlarmR>("bellalarm-r");
			Register<AiTaskComeToOwnerR>("cometoowner-r");
			Register<AiTaskEatHeldItemR>("eathelditem-r");
			Register<AiTaskFleeEntityR>("fleeentity-r");
			Register<AiTaskGetOutOfWaterR>("getoutofwater-r");
			Register<AiTaskIdleR>("idle-r");
			Register<AiTaskLookAroundR>("lookaround-r");
			Register<AiTaskLookAtEntityR>("lookatentity-r");
			Register<AiTaskMeleeAttackR>("meleeattack-r");
			Register<AiTaskSeekFoodAndEatR>("seekfoodandeat-r");
			Register<AiTaskSeekEntityR>("seekentity-r");
			Register<AiTaskShootAtEntityR>("shootatentity-r");
			Register<AiTaskStayCloseToEntityR>("stayclosetoentity-r");
			Register<AiTaskStayInRangeR>("stayinrange-r");
			Register<AiTaskTurretModeR>("turretmode-r");
		}
	}
	public class AiRuntimeConfig : ModSystem
	{
		public static bool RunAiTasks = true;

		public static bool RunAiActivities = true;

		private ICoreServerAPI? serverApi;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			serverApi = api;
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)onTick250ms, 250, 31);
		}

		private void onTick250ms(float obj)
		{
			ICoreServerAPI? obj2 = serverApi;
			RunAiTasks = obj2 == null || ((IWorldAccessor)obj2.World).Config.GetAsBool("runAiTasks", true);
			ICoreServerAPI? obj3 = serverApi;
			RunAiActivities = obj3 == null || ((IWorldAccessor)obj3.World).Config.GetAsBool("runAiActivities", true);
		}
	}
	public sealed class AiTaskManager(Entity entity)
	{
		[CompilerGenerated]
		private ActionBoolReturn<IAiTask>? m_OnShouldExecuteTask;

		public const int ActiveTasksSlotsNumber = 8;

		private readonly Entity entity = entity;

		private readonly List<IAiTask> tasks = new List<IAiTask>();

		private readonly IAiTask?[] activeTasksBySlot = new IAiTask[8];

		private bool wasRunAiTasks;

		public bool Shuffle { get; set; }

		public IAiTask?[] ActiveTasksBySlot => activeTasksBySlot;

		public List<IAiTask> AllTasks => tasks;

		public event Action<IAiTask>? OnTaskStarted;

		public event Action<IAiTask>? OnTaskStopped;

		public event ActionBoolReturn<IAiTask>? OnShouldExecuteTask
		{
			[CompilerGenerated]
			add
			{
				ActionBoolReturn<IAiTask> val = this.m_OnShouldExecuteTask;
				ActionBoolReturn<IAiTask> val2;
				do
				{
					val2 = val;
					ActionBoolReturn<IAiTask> value2 = (ActionBoolReturn<IAiTask>)(object)Delegate.Combine((Delegate?)(object)val2, (Delegate?)(object)value);
					val = Interlocked.CompareExchange(ref this.m_OnShouldExecuteTask, value2, val2);
				}
				while (val != val2);
			}
			[CompilerGenerated]
			remove
			{
				ActionBoolReturn<IAiTask> val = this.m_OnShouldExecuteTask;
				ActionBoolReturn<IAiTask> val2;
				do
				{
					val2 = val;
					ActionBoolReturn<IAiTask> value2 = (ActionBoolReturn<IAiTask>)(object)Delegate.Remove((Delegate?)(object)val2, (Delegate?)(object)value);
					val = Interlocked.CompareExchange(ref this.m_OnShouldExecuteTask, value2, val2);
				}
				while (val != val2);
			}
		}

		public void OnGameTick(float dt)
		{
			if (!AiRuntimeConfig.RunAiTasks)
			{
				if (wasRunAiTasks)
				{
					IAiTask[] array = activeTasksBySlot;
					for (int i = 0; i < array.Length; i++)
					{
						array[i]?.FinishExecute(cancelled: true);
					}
				}
				wasRunAiTasks = false;
			}
			else
			{
				wasRunAiTasks = true;
				if (Shuffle)
				{
					ListExtensions.Shuffle<IAiTask>(tasks, entity.World.Rand);
				}
				StartNewTasks();
				ProcessRunningTasks(dt);
				LogRunningTasks();
			}
		}

		public void AddTask(IAiTask task)
		{
			tasks.Add(task);
			task.ProfilerName = "task-startexecute-" + AiTaskRegistry.TaskCodes[task.GetType()];
		}

		public void RemoveTask(IAiTask task)
		{
			tasks.Remove(task);
		}

		public void AfterInitialize()
		{
			foreach (IAiTask task in tasks)
			{
				task.AfterInitialize();
			}
		}

		public void ExecuteTask(IAiTask task, int slot)
		{
			task.StartExecute();
			activeTasksBySlot[slot] = task;
			if (entity.World.FrameProfiler.Enabled)
			{
				entity.World.FrameProfiler.Mark("task-startexecute-", (object)AiTaskRegistry.TaskCodes[task.GetType()]);
			}
		}

		public void ExecuteTask<TTask>() where TTask : IAiTask
		{
			foreach (TTask item in tasks.OfType<TTask>())
			{
				int slot = item.Slot;
				IAiTask aiTask = activeTasksBySlot[slot];
				if (aiTask != null)
				{
					aiTask.FinishExecute(cancelled: true);
					this.OnTaskStopped?.Invoke(aiTask);
				}
				activeTasksBySlot[slot] = item;
				item.StartExecute();
				this.OnTaskStarted?.Invoke(item);
				entity.World.FrameProfiler.Mark(item.ProfilerName);
			}
		}

		public TTask? GetTask<TTask>() where TTask : IAiTask
		{
			return (TTask)tasks.Find((IAiTask task) => task is TTask);
		}

		public IAiTask? GetTask(string id)
		{
			return tasks.Find((IAiTask task) => task.Id == id);
		}

		public IEnumerable<TTask> GetTasks<TTask>() where TTask : IAiTask
		{
			return tasks.OfType<TTask>();
		}

		public void StopTask(Type taskType)
		{
			IAiTask[] array = activeTasksBySlot;
			foreach (IAiTask aiTask in array)
			{
				if (aiTask?.GetType() == taskType)
				{
					aiTask.FinishExecute(cancelled: true);
					this.OnTaskStopped?.Invoke(aiTask);
					activeTasksBySlot[aiTask.Slot] = null;
				}
			}
			entity.World.FrameProfiler.Mark("finishexecute");
		}

		public void StopTask<TTask>() where TTask : IAiTask
		{
			foreach (TTask item in activeTasksBySlot.OfType<TTask>())
			{
				item.FinishExecute(cancelled: true);
				this.OnTaskStopped?.Invoke(item);
				activeTasksBySlot[item.Slot] = null;
			}
			entity.World.FrameProfiler.Mark("finishexecute");
		}

		public void StopTasks()
		{
			IAiTask[] array = activeTasksBySlot;
			foreach (IAiTask aiTask in array)
			{
				if (aiTask != null)
				{
					aiTask.FinishExecute(cancelled: true);
					this.OnTaskStopped?.Invoke(aiTask);
					activeTasksBySlot[aiTask.Slot] = null;
				}
			}
		}

		public bool IsTaskActive(string id)
		{
			IAiTask[] array = activeTasksBySlot;
			foreach (IAiTask aiTask in array)
			{
				if (aiTask != null && aiTask.Id == id)
				{
					return true;
				}
			}
			return false;
		}

		internal void Notify(string key, object data)
		{
			if (key == "starttask")
			{
				string taskId = (string)data;
				if (activeTasksBySlot.FirstOrDefault((IAiTask aiTask5) => aiTask5?.Id == taskId) != null)
				{
					return;
				}
				IAiTask task = GetTask(taskId);
				if (task != null)
				{
					IAiTask aiTask = activeTasksBySlot[task.Slot];
					if (aiTask != null)
					{
						aiTask.FinishExecute(cancelled: true);
						this.OnTaskStopped?.Invoke(aiTask);
					}
					activeTasksBySlot[task.Slot] = null;
					ExecuteTask(task, task.Slot);
				}
				return;
			}
			if (key == "stoptask")
			{
				string taskId2 = (string)data;
				IAiTask aiTask2 = activeTasksBySlot.FirstOrDefault((IAiTask aiTask5) => aiTask5?.Id == taskId2);
				if (aiTask2 != null)
				{
					aiTask2.FinishExecute(cancelled: true);
					this.OnTaskStopped?.Invoke(aiTask2);
					activeTasksBySlot[aiTask2.Slot] = null;
				}
				return;
			}
			for (int num = 0; num < tasks.Count; num++)
			{
				IAiTask aiTask3 = tasks[num];
				if (!aiTask3.Notify(key, data))
				{
					continue;
				}
				int slot = tasks[num].Slot;
				IAiTask aiTask4 = activeTasksBySlot[slot];
				if (aiTask4 == null || aiTask3.Priority > aiTask4.PriorityForCancel)
				{
					if (aiTask4 != null)
					{
						aiTask4.FinishExecute(cancelled: true);
						this.OnTaskStopped?.Invoke(aiTask4);
					}
					activeTasksBySlot[slot] = aiTask3;
					aiTask3.StartExecute();
					this.OnTaskStarted?.Invoke(aiTask3);
				}
			}
		}

		internal void OnStateChanged(EnumEntityState beforeState)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			foreach (IAiTask task in tasks)
			{
				task.OnStateChanged(beforeState);
			}
		}

		internal void OnEntitySpawn()
		{
			foreach (IAiTask task in tasks)
			{
				task.OnEntitySpawn();
			}
		}

		internal void OnEntityLoaded()
		{
			foreach (IAiTask task in tasks)
			{
				task.OnEntityLoaded();
			}
		}

		internal void OnEntityDespawn(EntityDespawnData reason)
		{
			foreach (IAiTask task in tasks)
			{
				task.OnEntityDespawn(reason);
			}
		}

		internal void OnEntityHurt(DamageSource source, float damage)
		{
			foreach (IAiTask task in tasks)
			{
				task.OnEntityHurt(source, damage);
			}
		}

		private void StartNewTasks()
		{
			foreach (IAiTask task in tasks)
			{
				if (task.Priority < 0f)
				{
					continue;
				}
				int slot = task.Slot;
				IAiTask aiTask = activeTasksBySlot[slot];
				if ((aiTask == null || task.Priority > aiTask.PriorityForCancel) && task.ShouldExecute() && ShouldExecuteTask(task))
				{
					aiTask?.FinishExecute(cancelled: true);
					if (aiTask != null)
					{
						this.OnTaskStopped?.Invoke(aiTask);
					}
					activeTasksBySlot[slot] = task;
					task.StartExecute();
					this.OnTaskStarted?.Invoke(task);
				}
				if (entity.World.FrameProfiler.Enabled)
				{
					entity.World.FrameProfiler.Mark(task.ProfilerName);
				}
			}
		}

		private bool ShouldExecuteTask(IAiTask task)
		{
			if (this.OnShouldExecuteTask == null)
			{
				return true;
			}
			bool flag = true;
			Delegate[] invocationList = ((Delegate)(object)this.OnShouldExecuteTask).GetInvocationList();
			for (int i = 0; i < invocationList.Length; i++)
			{
				ActionBoolReturn<IAiTask> val = (ActionBoolReturn<IAiTask>)(object)invocationList[i];
				flag &= val.Invoke(task);
			}
			return flag;
		}

		private void ProcessRunningTasks(float dt)
		{
			for (int i = 0; i < activeTasksBySlot.Length; i++)
			{
				IAiTask aiTask = activeTasksBySlot[i];
				if (aiTask != null && aiTask.CanContinueExecute())
				{
					if (!aiTask.ContinueExecute(dt))
					{
						aiTask.FinishExecute(cancelled: false);
						this.OnTaskStopped?.Invoke(aiTask);
						activeTasksBySlot[i] = null;
					}
					if (entity.World.FrameProfiler.Enabled)
					{
						entity.World.FrameProfiler.Mark("task-continueexec-", (object)AiTaskRegistry.TaskCodes[aiTask.GetType()]);
					}
				}
			}
		}

		private void LogRunningTasks()
		{
			if (!entity.World.EntityDebugMode)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			for (int i = 0; i < activeTasksBySlot.Length; i++)
			{
				IAiTask aiTask = activeTasksBySlot[i];
				if (aiTask != null)
				{
					if (num++ > 0)
					{
						stringBuilder.Append(", ");
					}
					AiTaskRegistry.TaskCodes.TryGetValue(aiTask.GetType(), out string value);
					StringBuilder stringBuilder2 = stringBuilder;
					StringBuilder.AppendInterpolatedStringHandler handler = new StringBuilder.AppendInterpolatedStringHandler(8, 3, stringBuilder2);
					handler.AppendFormatted(value);
					handler.AppendLiteral("(p");
					handler.AppendFormatted(aiTask.Priority);
					handler.AppendLiteral(", pc ");
					handler.AppendFormatted(aiTask.PriorityForCancel);
					handler.AppendLiteral(")");
					stringBuilder2.Append(ref handler);
				}
			}
			((TreeAttribute)entity.DebugAttributes).SetString("AI Tasks", (stringBuilder.Length > 0) ? stringBuilder.ToString() : "-");
		}
	}
	public class EntityBehaviorTaskAI : EntityBehavior
	{
		public AiTaskManager TaskManager = new AiTaskManager(entity);

		public WaypointsTraverser? PathTraverser;

		public EntityBehaviorTaskAI(Entity entity)
			: base(entity)
		{
		}

		public override string PropertyName()
		{
			return "taskai";
		}

		public override void OnEntitySpawn()
		{
			((EntityBehavior)this).OnEntitySpawn();
			TaskManager.OnEntitySpawn();
		}

		public override void OnEntityLoaded()
		{
			((EntityBehavior)this).OnEntityLoaded();
			TaskManager.OnEntityLoaded();
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			((EntityBehavior)this).OnEntityDespawn(despawn);
			TaskManager.OnEntityDespawn(despawn);
		}

		public override void OnEntityReceiveDamage(DamageSource damageSource, ref float damage)
		{
			((EntityBehavior)this).OnEntityReceiveDamage(damageSource, ref damage);
			TaskManager.OnEntityHurt(damageSource, damage);
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			ILogger logger = base.entity.World.Logger;
			Entity entity = base.entity;
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (val == null)
			{
				logger.Error($"The task ai currently only works on entities inheriting from EntityAgent. Will ignore loading tasks for entity {((RegistryObject)base.entity).Code}.");
				return;
			}
			TaskManager.Shuffle = attributes["shuffle"].AsBool(false);
			string value = attributes["aiCreatureType"].AsString("Default");
			if (!Enum.TryParse<EnumAICreatureType>(value, out EnumAICreatureType result))
			{
				result = (EnumAICreatureType)0;
				logger.Warning($"Entity {((RegistryObject)base.entity).Code} Task AI, invalid aiCreatureType '{value}'. Will default to 'Default'.");
			}
			PathTraverser = new WaypointsTraverser(val, result);
			JsonObject obj = attributes["aitasks"];
			JsonObject[] array = ((obj != null) ? obj.AsArray() : null);
			if (array == null)
			{
				return;
			}
			JsonObject[] array2 = array;
			foreach (JsonObject val2 in array2)
			{
				JsonObject obj2 = val2["enabled"];
				if (obj2 != null && !obj2.AsBool(true))
				{
					continue;
				}
				JsonObject obj3 = val2["code"];
				string text = ((obj3 != null) ? obj3.AsString((string)null) : null);
				if (text == null)
				{
					logger.Error($"Task does not have 'code' specified, for entity '{((RegistryObject)base.entity).Code}', will skip it.");
					continue;
				}
				if (!AiTaskRegistry.TaskTypes.TryGetValue(text, out Type value2))
				{
					logger.Error($"Task with code {text} for entity {((RegistryObject)base.entity).Code} does not exist, will skip it.");
					continue;
				}
				IAiTask aiTask;
				try
				{
					aiTask = (IAiTask)Activator.CreateInstance(value2, val, val2, attributes);
				}
				catch
				{
					logger.Error($"Task with code '{text}' for entity '{((RegistryObject)base.entity).Code}': failed to instantiate task, possible error in task config json.");
					throw;
				}
				if (aiTask != null)
				{
					TaskManager.AddTask(aiTask);
					continue;
				}
				logger.Error($"Task with code {text} for entity {((RegistryObject)base.entity).Code}: failed to instantiate task.");
			}
		}

		public override void AfterInitialized(bool onFirstSpawn)
		{
			TaskManager.AfterInitialize();
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			if ((int)base.entity.State == 0 && base.entity.Alive)
			{
				base.entity.World.FrameProfiler.Mark("ai-init");
				PathTraverser?.OnGameTick(deltaTime);
				base.entity.World.FrameProfiler.Mark("ai-pathfinding");
				base.entity.World.FrameProfiler.Enter("ai-tasks");
				TaskManager.OnGameTick(deltaTime);
				base.entity.World.FrameProfiler.Leave();
			}
		}

		public override void OnStateChanged(EnumEntityState beforeState, ref EnumHandling handling)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			TaskManager.OnStateChanged(beforeState);
		}

		public override void Notify(string key, object data)
		{
			TaskManager.Notify(key, data);
		}
	}
	public class AiTaskFleeEntity : AiTaskBaseTargetable
	{
		private Vec3d targetPos = new Vec3d();

		private float targetYaw;

		private float moveSpeed = 0.02f;

		private float seekingRange = 25f;

		private float executionChance = 0.1f;

		private float fleeingDistance = 31f;

		private float minDayLight = -1f;

		private float fleeDurationMs = 5000f;

		private float instafleeOnDamageChance;

		private bool cancelOnHurt;

		private long fleeStartMs;

		private bool stuck;

		private bool lowStabilityAttracted;

		private bool ignoreDeepDayLight;

		private bool cancelNow;

		private float nowFleeingDistance;

		private bool instafleenow;

		private readonly Vec3d ownPos = new Vec3d();

		private Vec3d tmpTargetPos = new Vec3d();

		public override bool AggressiveTargeting => false;

		public AiTaskFleeEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Expected O, but got Unknown
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Expected O, but got Unknown
			moveSpeed = taskConfig["movespeed"].AsFloat(0.02f);
			seekingRange = taskConfig["seekingRange"].AsFloat(25f);
			executionChance = taskConfig["executionChance"].AsFloat(0.1f);
			minDayLight = taskConfig["minDayLight"].AsFloat(-1f);
			cancelOnHurt = taskConfig["cancelOnHurt"].AsBool(false);
			ignoreDeepDayLight = taskConfig["ignoreDeepDayLight"].AsBool(false);
			fleeingDistance = taskConfig["fleeingDistance"].AsFloat(seekingRange + 15f);
			fleeDurationMs = taskConfig["fleeDurationMs"].AsInt(9000);
			instafleeOnDamageChance = taskConfig["instafleeOnDamageChance"].AsFloat(0f);
			int num;
			if (StringUtil.ToBool(((Entity)entity).World.Config.GetString("temporalStability", (string)null), true))
			{
				JsonObject attributes = ((Entity)entity).Properties.Attributes;
				num = ((attributes != null && attributes["spawnCloserDuringLowStability"].AsBool(false)) ? 1 : 0);
			}
			else
			{
				num = 0;
			}
			lowStabilityAttracted = (byte)num != 0;
		}

		public override bool ShouldExecute()
		{
			soundChance = Math.Min(1.01f, soundChance + 0.002f);
			if (instafleenow)
			{
				return TryInstaFlee();
			}
			if (base.rand.NextDouble() > (double)executionChance)
			{
				return false;
			}
			if (base.noEntityCodes && (attackedByEntity == null || !retaliateAttacks))
			{
				return false;
			}
			if (!PreconditionsSatisifed())
			{
				return false;
			}
			if (minDayLight > 0f)
			{
				if (((TreeAttribute)((Entity)entity).Attributes).GetBool("ignoreDaylightFlee", false))
				{
					return false;
				}
				if (ignoreDeepDayLight && ((Entity)entity).ServerPos.Y < (double)(world.SeaLevel - 2))
				{
					return false;
				}
				if ((float)((Entity)entity).World.BlockAccessor.GetLightLevel((int)((Entity)entity).ServerPos.X, (int)((Entity)entity).ServerPos.Y, (int)((Entity)entity).ServerPos.Z, (EnumLightLevelType)4) / (float)((Entity)entity).World.SunBrightness < minDayLight)
				{
					return false;
				}
			}
			int ownGeneration = GetOwnGeneration();
			float num = ((WhenInEmotionState != null) ? 1f : Math.Max(0f, (tamingGenerations - (float)ownGeneration) / tamingGenerations));
			ownPos.SetWithDimension(((Entity)entity).ServerPos);
			float hereRange = num * seekingRange;
			((Entity)entity).World.FrameProfiler.Mark("task-fleeentity-shouldexecute-init");
			if (lowStabilityAttracted)
			{
				ref Entity reference = ref targetEntity;
				Entity nearestEntity = partitionUtil.GetNearestEntity(ownPos, hereRange, delegate(Entity entity)
				{
					if (!(entity is EntityAgent))
					{
						return false;
					}
					if (!IsTargetableEntity(entity, hereRange))
					{
						return false;
					}
					return !(entity is EntityPlayer) || ((TreeAttribute)entity.WatchedAttributes).GetDouble("temporalStability", 1.0) > 0.25;
				}, EnumEntitySearchType.Creatures);
				reference = ((nearestEntity is EntityAgent) ? nearestEntity : null);
			}
			else if (noTags)
			{
				if (targetEntityFirstLetters.Length == 0)
				{
					ref Entity reference2 = ref targetEntity;
					Entity nearestEntity2 = partitionUtil.GetNearestEntity(ownPos, hereRange, (Entity entity) => IsTargetableEntityNoTagsAll(entity, hereRange) && entity is EntityAgent, EnumEntitySearchType.Creatures);
					reference2 = ((nearestEntity2 is EntityAgent) ? nearestEntity2 : null);
				}
				else
				{
					ref Entity reference3 = ref targetEntity;
					Entity nearestEntity3 = partitionUtil.GetNearestEntity(ownPos, hereRange, (Entity entity) => IsTargetableEntityNoTagsNoAll(entity, hereRange) && entity is EntityAgent, EnumEntitySearchType.Creatures);
					reference3 = ((nearestEntity3 is EntityAgent) ? nearestEntity3 : null);
				}
			}
			else
			{
				ref Entity reference4 = ref targetEntity;
				Entity nearestEntity4 = partitionUtil.GetNearestEntity(ownPos, hereRange, (Entity entity) => IsTargetableEntityWithTags(entity, hereRange) && entity is EntityAgent, EnumEntitySearchType.Creatures);
				reference4 = ((nearestEntity4 is EntityAgent) ? nearestEntity4 : null);
			}
			nowFleeingDistance = fleeingDistance;
			((Entity)entity).World.FrameProfiler.Mark("task-fleeentity-shouldexecute-entitysearch");
			if (targetEntity != null)
			{
				if (entity.ToleratesDamageFrom(targetEntity))
				{
					nowFleeingDistance /= 2f;
				}
				float yaw = (float)Math.Atan2(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X, targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z);
				updateTargetPosFleeMode(targetPos, yaw);
				return true;
			}
			return false;
		}

		private bool TryInstaFlee()
		{
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Expected O, but got Unknown
			if (targetEntity == null || ((Entity)entity).ServerPos.DistanceTo(targetEntity.ServerPos) > (double)seekingRange)
			{
				float num = GameMath.Cos(((Entity)entity).ServerPos.Yaw);
				float num2 = GameMath.Sin(((Entity)entity).ServerPos.Yaw);
				double num3 = 200.0;
				targetPos = new Vec3d(((Entity)entity).ServerPos.X + (double)num2 * num3, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z + (double)num * num3);
				targetYaw = ((Entity)entity).ServerPos.Yaw;
				targetEntity = null;
			}
			else
			{
				nowFleeingDistance = (float)((Entity)entity).ServerPos.DistanceTo(targetEntity.ServerPos) + 15f;
				if (entity.ToleratesDamageFrom(targetEntity))
				{
					nowFleeingDistance /= 2.5f;
				}
				updateTargetPosFleeMode(targetPos, ((Entity)entity).ServerPos.Yaw);
			}
			instafleenow = false;
			return true;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			cancelNow = false;
			soundChance = Math.Max(0.025f, soundChance - 0.2f);
			Entity obj = targetEntity;
			float num = ((obj != null) ? obj.SelectionBox.XSize : 0f);
			pathTraverser.WalkTowards(targetPos, moveSpeed, num + 0.2f, OnGoalReached, OnStuck, (EnumAICreatureType)0);
			fleeStartMs = ((Entity)entity).World.ElapsedMilliseconds;
			stuck = false;
		}

		public override bool ContinueExecute(float dt)
		{
			if (world.Rand.NextDouble() < 0.2)
			{
				float yaw = ((targetEntity == null) ? (0f - targetYaw) : ((float)Math.Atan2(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X, targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z)));
				updateTargetPosFleeMode(tmpTargetPos.Set(targetPos), yaw);
				pathTraverser.CurrentTarget.X = tmpTargetPos.X;
				pathTraverser.CurrentTarget.Y = tmpTargetPos.Y;
				pathTraverser.CurrentTarget.Z = tmpTargetPos.Z;
				pathTraverser.Retarget();
			}
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			if (targetEntity != null && ((Entity)entity).ServerPos.SquareDistanceTo(targetEntity.ServerPos) > nowFleeingDistance * nowFleeingDistance)
			{
				return false;
			}
			if (targetEntity == null && ((Entity)entity).World.ElapsedMilliseconds - fleeStartMs > 5000)
			{
				return false;
			}
			if (world.Rand.NextDouble() < 0.25)
			{
				float num = (float)((Entity)entity).World.BlockAccessor.GetLightLevel((int)((Entity)entity).ServerPos.X, (int)((Entity)entity).ServerPos.Y, (int)((Entity)entity).ServerPos.Z, (EnumLightLevelType)4) / (float)((Entity)entity).World.SunBrightness;
				if (((ignoreDeepDayLight && ((Entity)entity).ServerPos.Y < (double)(world.SeaLevel - 2)) || num < minDayLight) && !((TreeAttribute)((Entity)entity).Attributes).GetBool("ignoreDaylightFlee", false))
				{
					return false;
				}
			}
			if (!stuck && (targetEntity == null || targetEntity.Alive) && (float)(((Entity)entity).World.ElapsedMilliseconds - fleeStartMs) < fleeDurationMs && !cancelNow)
			{
				return pathTraverser.Active;
			}
			return false;
		}

		public override void OnEntityHurt(DamageSource source, float damage)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Invalid comparison between Unknown and I4
			base.OnEntityHurt(source, damage);
			if (cancelOnHurt)
			{
				cancelNow = true;
			}
			if ((int)source.Type != 6 && ((Entity)entity).World.Rand.NextDouble() < (double)instafleeOnDamageChance)
			{
				instafleenow = true;
				targetEntity = source.GetCauseEntity();
			}
		}

		public void InstaFleeFrom(Entity fromEntity)
		{
			instafleenow = true;
			targetEntity = fromEntity;
		}

		public override void FinishExecute(bool cancelled)
		{
			pathTraverser.Stop();
			base.FinishExecute(cancelled);
		}

		private void OnStuck()
		{
			stuck = true;
		}

		private void OnGoalReached()
		{
			pathTraverser.Retarget();
		}

		public override bool CanSense(Entity e, double range)
		{
			if (e.EntityId == ((Entity)entity).EntityId)
			{
				return false;
			}
			EntityPlayer val = (EntityPlayer)(object)((e is EntityPlayer) ? e : null);
			if (val != null)
			{
				return CanSensePlayer(val, range);
			}
			if (skipEntityCodes != null)
			{
				for (int i = 0; i < skipEntityCodes.Length; i++)
				{
					if (WildcardUtil.Match(skipEntityCodes[i], ((RegistryObject)e).Code))
					{
						return false;
					}
				}
			}
			return true;
		}
	}
	public class AiTaskGetOutOfWater : AiTaskBase
	{
		private Vec3d target = new Vec3d();

		private BlockPos pos = new BlockPos();

		private bool done;

		private float moveSpeed = 0.03f;

		private int searchattempts;

		public AiTaskGetOutOfWater(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			moveSpeed = taskConfig["movespeed"].AsFloat(0.06f);
		}

		public override bool ShouldExecute()
		{
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Expected O, but got Unknown
			if (!((Entity)entity).Swimming)
			{
				return false;
			}
			if (base.rand.NextDouble() > 0.03999999910593033)
			{
				return false;
			}
			int num = GameMath.Min(50, 30 + searchattempts * 2);
			target.Y = ((Entity)entity).ServerPos.Y;
			int num2 = 10;
			int num3 = (int)((Entity)entity).ServerPos.X;
			int num4 = (int)((Entity)entity).ServerPos.Z;
			IBlockAccessor blockAccessor = ((Entity)entity).World.BlockAccessor;
			Vec3d val = new Vec3d();
			while (num2-- > 0)
			{
				pos.X = num3 + base.rand.Next(num + 1) - num / 2;
				pos.Z = num4 + base.rand.Next(num + 1) - num / 2;
				pos.Y = blockAccessor.GetTerrainMapheightAt(pos) + 1;
				if (!((CollectibleObject)blockAccessor.GetBlock(pos, 2)).IsLiquid())
				{
					blockAccessor.GetBlock(pos);
					if (!((Entity)entity).World.CollisionTester.IsColliding(blockAccessor, ((Entity)entity).CollisionBox, val.Set((double)pos.X + 0.5, (double)((float)pos.Y + 0.1f), (double)pos.Z + 0.5), true) && ((Entity)entity).World.CollisionTester.IsColliding(blockAccessor, ((Entity)entity).CollisionBox, val.Set((double)pos.X + 0.5, (double)((float)pos.Y - 0.1f), (double)pos.Z + 0.5), true))
					{
						target.Set((double)pos.X + 0.5, (double)(pos.Y + 1), (double)pos.Z + 0.5);
						return true;
					}
				}
			}
			searchattempts++;
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			searchattempts = 0;
			done = false;
			pathTraverser.WalkTowards(target, moveSpeed, 0.5f, OnGoalReached, OnStuck, (EnumAICreatureType)0);
		}

		public override bool ContinueExecute(float dt)
		{
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			if (base.rand.NextDouble() < 0.10000000149011612 && !((Entity)entity).FeetInLiquid)
			{
				return false;
			}
			return !done;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			pathTraverser.Stop();
		}

		private void OnStuck()
		{
			done = true;
		}

		private void OnGoalReached()
		{
			done = true;
		}
	}
	public class AiTaskGotoEntity : AiTaskBase
	{
		public Entity targetEntity;

		public float moveSpeed = 0.02f;

		public float seekingRange = 25f;

		public float maxFollowTime = 60f;

		public float allowedExtraDistance;

		private bool stuck;

		private float currentFollowTime;

		public bool Finished => !pathTraverser.Ready;

		public AiTaskGotoEntity(EntityAgent entity, Entity target)
			: base(entity, JsonObject.FromJson("{}"), JsonObject.FromJson("{}"))
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			targetEntity = target;
			animMeta = new AnimationMetaData
			{
				Code = "walk",
				Animation = "walk",
				AnimationSpeed = 1f
			}.Init();
		}

		public override bool ShouldExecute()
		{
			return false;
		}

		public float MinDistanceToTarget()
		{
			return allowedExtraDistance + Math.Max(0.8f, targetEntity.SelectionBox.XSize / 2f + ((Entity)entity).SelectionBox.XSize / 2f);
		}

		public override void StartExecute()
		{
			base.StartExecute();
			stuck = false;
			pathTraverser.NavigateTo_Async(targetEntity.ServerPos.XYZ, moveSpeed, MinDistanceToTarget(), OnGoalReached, OnStuck, null, 999);
			currentFollowTime = 0f;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		public override bool ContinueExecute(float dt)
		{
			currentFollowTime += dt;
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			pathTraverser.CurrentTarget.X = targetEntity.ServerPos.X;
			pathTraverser.CurrentTarget.Y = targetEntity.ServerPos.Y;
			pathTraverser.CurrentTarget.Z = targetEntity.ServerPos.Z;
			Cuboidd obj = targetEntity.SelectionBox.ToDouble().Translate(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			double num = obj.ShortestDistanceFrom((IVec3)(object)val);
			float num2 = MinDistanceToTarget();
			if (currentFollowTime < maxFollowTime && num < (double)(seekingRange * seekingRange) && num > (double)num2)
			{
				return !stuck;
			}
			return false;
		}

		public bool TargetReached()
		{
			Cuboidd obj = targetEntity.SelectionBox.ToDouble().Translate(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			double num = obj.ShortestDistanceFrom((IVec3)(object)val);
			float num2 = MinDistanceToTarget();
			return num < (double)num2;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			pathTraverser.Stop();
		}

		public override bool Notify(string key, object data)
		{
			return false;
		}

		private void OnStuck()
		{
			stuck = true;
		}

		private void OnGoalReached()
		{
			pathTraverser.Active = true;
		}
	}
	public class DayTimeFrame
	{
		public double FromHour;

		public double ToHour;

		public bool Matches(double hourOfDay)
		{
			if (FromHour <= hourOfDay)
			{
				return ToHour >= hourOfDay;
			}
			return false;
		}
	}
	public class AiTaskIdle : AiTaskBase
	{
		public int minduration;

		public int maxduration;

		public float chance;

		public AssetLocation onBlockBelowCode;

		public long idleUntilMs;

		private bool entityWasInRange;

		private long lastEntityInRangeTestTotalMs;

		private string[] stopOnNearbyEntityCodesExact;

		private string[] stopOnNearbyEntityCodesBeginsWith = Array.Empty<string>();

		private string targetEntityFirstLetters = "";

		private float stopRange;

		private bool stopOnHurt;

		private EntityPartitioning partitionUtil;

		private bool stopNow;

		private float tamingGenerations = 10f;

		public AiTaskIdle(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Expected O, but got Unknown
			partitionUtil = ((Entity)entity).Api.ModLoader.GetModSystem<EntityPartitioning>(true);
			minduration = taskConfig["minduration"].AsInt(2000);
			maxduration = taskConfig["maxduration"].AsInt(4000);
			chance = taskConfig["chance"].AsFloat(1.1f);
			string text = taskConfig["onBlockBelowCode"].AsString((string)null);
			tamingGenerations = taskConfig["tamingGenerations"].AsFloat(10f);
			if (text != null && text.Length > 0)
			{
				onBlockBelowCode = new AssetLocation(text);
			}
			stopRange = taskConfig["stopRange"].AsFloat(0f);
			stopOnHurt = taskConfig["stopOnHurt"].AsBool(false);
			string[] array = taskConfig["stopOnNearbyEntityCodes"].AsArray<string>(new string[1] { "player" }, (string)null);
			List<string> list = new List<string>();
			List<string> list2 = new List<string>();
			foreach (string text2 in array)
			{
				if (text2.EndsWith('*'))
				{
					list2.Add(text2.Substring(0, text2.Length - 1));
				}
				else
				{
					list.Add(text2);
				}
			}
			stopOnNearbyEntityCodesExact = list.ToArray();
			stopOnNearbyEntityCodesBeginsWith = list2.ToArray();
			string[] array2 = stopOnNearbyEntityCodesExact;
			foreach (string text3 in array2)
			{
				if (text3.Length != 0)
				{
					char c = text3[0];
					if (targetEntityFirstLetters.IndexOf(c) < 0)
					{
						targetEntityFirstLetters += c;
					}
				}
			}
			array2 = stopOnNearbyEntityCodesBeginsWith;
			foreach (string text4 in array2)
			{
				if (text4.Length != 0)
				{
					char c2 = text4[0];
					if (targetEntityFirstLetters.IndexOf(c2) < 0)
					{
						targetEntityFirstLetters += c2;
					}
				}
			}
			if (maxduration < 0)
			{
				idleUntilMs = -1L;
			}
			else
			{
				idleUntilMs = ((Entity)entity).World.ElapsedMilliseconds + minduration + ((Entity)entity).World.Rand.Next(maxduration - minduration);
			}
			int num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetInt("generation", 0);
			float num2 = Math.Max(0f, (tamingGenerations - (float)num) / tamingGenerations);
			if (WhenInEmotionState != null)
			{
				num2 = 1f;
			}
			stopRange *= num2;
			lastEntityInRangeTestTotalMs = ((Entity)entity).World.ElapsedMilliseconds - ((Entity)entity).World.Rand.Next(1500);
		}

		public override bool ShouldExecute()
		{
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Invalid comparison between Unknown and I4
			long elapsedMilliseconds = ((Entity)entity).World.ElapsedMilliseconds;
			if (cooldownUntilMs < elapsedMilliseconds && ((Entity)entity).World.Rand.NextDouble() < (double)chance)
			{
				if ((int)((Entity)entity).Properties.Habitat == 1 && ((Entity)entity).FeetInLiquid)
				{
					return false;
				}
				if (!PreconditionsSatisifed())
				{
					return false;
				}
				if (elapsedMilliseconds - lastEntityInRangeTestTotalMs > 2000)
				{
					entityWasInRange = entityInRange();
					lastEntityInRangeTestTotalMs = elapsedMilliseconds;
				}
				if (entityWasInRange)
				{
					return false;
				}
				Block blockRaw = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)((Entity)entity).ServerPos.X, (int)((Entity)entity).ServerPos.InternalY - 1, (int)((Entity)entity).ServerPos.Z, 1);
				if (!((SmallBoolArray)(ref blockRaw.SideSolid))[BlockFacing.UP.Index])
				{
					return false;
				}
				if (onBlockBelowCode == (AssetLocation)null)
				{
					return true;
				}
				Block blockRaw2 = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)((Entity)entity).ServerPos.X, (int)((Entity)entity).ServerPos.InternalY, (int)((Entity)entity).ServerPos.Z, 0);
				if (!((RegistryObject)blockRaw2).WildCardMatch(onBlockBelowCode))
				{
					if (blockRaw2.Replaceable >= 6000)
					{
						return ((RegistryObject)blockRaw).WildCardMatch(onBlockBelowCode);
					}
					return false;
				}
				return true;
			}
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			if (maxduration < 0)
			{
				idleUntilMs = -1L;
			}
			else
			{
				idleUntilMs = ((Entity)entity).World.ElapsedMilliseconds + minduration + ((Entity)entity).World.Rand.Next(maxduration - minduration);
			}
			((Entity)entity).IdleSoundChanceModifier = 0f;
			stopNow = false;
		}

		public override bool ContinueExecute(float dt)
		{
			if (base.rand.NextDouble() < 0.30000001192092896)
			{
				long elapsedMilliseconds = ((Entity)entity).World.ElapsedMilliseconds;
				if (elapsedMilliseconds - lastEntityInRangeTestTotalMs > 1500 && stopOnNearbyEntityCodesExact != null)
				{
					entityWasInRange = entityInRange();
					lastEntityInRangeTestTotalMs = elapsedMilliseconds;
				}
				if (entityWasInRange)
				{
					return false;
				}
				if (!IsInValidDayTimeHours(initialRandomness: false))
				{
					return false;
				}
			}
			if (!stopNow)
			{
				if (idleUntilMs >= 0)
				{
					return ((Entity)entity).World.ElapsedMilliseconds < idleUntilMs;
				}
				return true;
			}
			return false;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			((Entity)entity).IdleSoundChanceModifier = 1f;
		}

		private bool entityInRange()
		{
			if (stopRange <= 0f)
			{
				return false;
			}
			bool found = false;
			partitionUtil.WalkEntities(((Entity)entity).ServerPos.XYZ, stopRange, delegate(Entity e)
			{
				//IL_009a: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a0: Invalid comparison between Unknown and I4
				//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ae: Invalid comparison between Unknown and I4
				if (!e.Alive || e.EntityId == ((Entity)entity).EntityId || !e.IsInteractable)
				{
					return true;
				}
				string path = ((RegistryObject)e).Code.Path;
				if (targetEntityFirstLetters.IndexOf(path[0]) < 0)
				{
					return true;
				}
				for (int i = 0; i < stopOnNearbyEntityCodesExact.Length; i++)
				{
					if (path == stopOnNearbyEntityCodesExact[i])
					{
						EntityPlayer val = (EntityPlayer)(object)((e is EntityPlayer) ? e : null);
						if (val != null)
						{
							IPlayer val2 = ((Entity)entity).World.PlayerByUid(val.PlayerUID);
							if (val2 == null || ((int)val2.WorldData.CurrentGameMode != 2 && (int)val2.WorldData.CurrentGameMode != 3))
							{
								found = true;
								return false;
							}
							return false;
						}
						found = true;
						return false;
					}
				}
				for (int j = 0; j < stopOnNearbyEntityCodesBeginsWith.Length; j++)
				{
					if (StringUtil.StartsWithFast(path, stopOnNearbyEntityCodesBeginsWith[j]))
					{
						found = true;
						return false;
					}
				}
				return true;
			}, EnumEntitySearchType.Creatures);
			return found;
		}

		public override void OnEntityHurt(DamageSource source, float damage)
		{
			if (stopOnHurt)
			{
				stopNow = true;
			}
		}
	}
	public class AiTaskLookAround : AiTaskBase
	{
		public int minduration;

		public int maxduration;

		public float turnSpeedMul = 0.75f;

		public long idleUntilMs;

		public AiTaskLookAround(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			JsonObject obj = taskConfig["minduration"];
			minduration = ((obj != null) ? new int?(obj.AsInt(2000)) : ((int?)null)).Value;
			JsonObject obj2 = taskConfig["maxduration"];
			maxduration = ((obj2 != null) ? new int?(obj2.AsInt(4000)) : ((int?)null)).Value;
			JsonObject obj3 = taskConfig["turnSpeedMul"];
			turnSpeedMul = ((obj3 != null) ? new float?(obj3.AsFloat(0.75f)) : ((float?)null)).Value;
			idleUntilMs = ((Entity)entity).World.ElapsedMilliseconds + minduration + ((Entity)entity).World.Rand.Next(maxduration - minduration);
		}

		public override bool ShouldExecute()
		{
			return cooldownUntilMs < ((Entity)entity).World.ElapsedMilliseconds;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			idleUntilMs = ((Entity)entity).World.ElapsedMilliseconds + minduration + ((Entity)entity).World.Rand.Next(maxduration - minduration);
			((Entity)entity).ServerPos.Yaw = (float)GameMath.Clamp(((Entity)entity).World.Rand.NextDouble() * 6.2831854820251465, (double)(((Entity)entity).ServerPos.Yaw - (float)Math.PI / 4f * GlobalConstants.OverallSpeedMultiplier * turnSpeedMul), (double)(((Entity)entity).ServerPos.Yaw + (float)Math.PI / 4f * GlobalConstants.OverallSpeedMultiplier * turnSpeedMul));
		}

		public override bool ContinueExecute(float dt)
		{
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			return ((Entity)entity).World.ElapsedMilliseconds < idleUntilMs;
		}
	}
	public class AiTaskLookAtEntity : AiTaskBaseTargetable
	{
		public bool manualExecute;

		public float moveSpeed = 0.02f;

		public float seekingRange = 25f;

		public float maxFollowTime = 60f;

		private float minTurnAnglePerSec;

		private float maxTurnAnglePerSec;

		private float curTurnRadPerSec;

		private float maxTurnAngleRad = (float)Math.PI * 2f;

		private float spawnAngleRad;

		public AiTaskLookAtEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			maxTurnAngleRad = taskConfig["maxTurnAngleDeg"].AsFloat(360f) * ((float)Math.PI / 180f);
			spawnAngleRad = ((TreeAttribute)((Entity)entity).Attributes).GetFloat("spawnAngleRad", 0f);
		}

		public override bool ShouldExecute()
		{
			if (!manualExecute)
			{
				targetEntity = partitionUtil.GetNearestEntity(((Entity)entity).ServerPos.XYZ, seekingRange, (Entity e) => IsTargetableEntity(e, seekingRange), EnumEntitySearchType.Creatures);
				return targetEntity != null;
			}
			return false;
		}

		public float MinDistanceToTarget()
		{
			return Math.Max(0.8f, targetEntity.SelectionBox.XSize / 2f + ((Entity)entity).SelectionBox.XSize / 2f);
		}

		public override void StartExecute()
		{
			base.StartExecute();
			EntityAgent obj = entity;
			if (((obj == null) ? null : ((EntitySidedProperties)(((Entity)obj).Properties.Server?)).Attributes) != null)
			{
				minTurnAnglePerSec = ((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetFloat("minTurnAnglePerSec", 250f);
				maxTurnAnglePerSec = ((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetFloat("maxTurnAnglePerSec", 450f);
			}
			else
			{
				minTurnAnglePerSec = 250f;
				maxTurnAnglePerSec = 450f;
			}
			curTurnRadPerSec = minTurnAnglePerSec + (float)((Entity)entity).World.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
			curTurnRadPerSec *= (float)Math.PI / 180f;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Expected O, but got Unknown
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			Vec3f val = new Vec3f();
			val.Set((float)(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X), (float)(targetEntity.ServerPos.Y - ((Entity)entity).ServerPos.Y), (float)(targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z));
			float num = (float)Math.Atan2(val.X, val.Z);
			if (maxTurnAngleRad < (float)Math.PI)
			{
				num = GameMath.Clamp(num, spawnAngleRad - maxTurnAngleRad, spawnAngleRad + maxTurnAngleRad);
			}
			float num2 = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, num);
			EntityPos serverPos = ((Entity)entity).ServerPos;
			serverPos.Yaw += GameMath.Clamp(num2, (0f - curTurnRadPerSec) * dt, curTurnRadPerSec * dt);
			((Entity)entity).ServerPos.Yaw = ((Entity)entity).ServerPos.Yaw % ((float)Math.PI * 2f);
			return (double)Math.Abs(num2) > 0.01;
		}

		public override bool Notify(string key, object data)
		{
			return false;
		}
	}
	public interface IMeleeAttackListener
	{
		void DidAttack(Entity targetEntity);
	}
	public class AiTaskMeleeAttack : AiTaskBaseTargetable
	{
		protected long lastCheckOrAttackMs;

		protected float damage = 2f;

		protected float knockbackStrength = 1f;

		protected float minDist = 1.5f;

		protected float minVerDist = 1f;

		protected float attackAngleRangeDeg = 20f;

		protected bool damageInflicted;

		protected int attackDurationMs = 1500;

		protected int damagePlayerAtMs = 500;

		public EnumDamageType damageType = (EnumDamageType)2;

		public int damageTier;

		protected float attackRange = 3f;

		protected bool turnToTarget = true;

		private float curTurnRadPerSec;

		private bool didStartAnim;

		public AiTaskMeleeAttack(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			damage = taskConfig["damage"].AsFloat(2f);
			knockbackStrength = taskConfig["knockbackStrength"].AsFloat(GameMath.Sqrt(damage / 4f));
			attackAngleRangeDeg = taskConfig["attackAngleRangeDeg"].AsFloat(20f);
			attackDurationMs = taskConfig["attackDurationMs"].AsInt(1500);
			damagePlayerAtMs = taskConfig["damagePlayerAtMs"].AsInt(1000);
			minDist = taskConfig["minDist"].AsFloat(2f);
			minVerDist = taskConfig["minVerDist"].AsFloat(1f);
			string text = taskConfig["damageType"].AsString((string)null);
			if (text != null)
			{
				damageType = (EnumDamageType)Enum.Parse(typeof(EnumDamageType), text, ignoreCase: true);
			}
			damageTier = taskConfig["damageTier"].AsInt(0);
			((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("extraInfoText").SetString("dmgTier", Lang.Get("Damage tier: {0}", new object[1] { damageTier }));
		}

		public override bool ShouldExecute()
		{
			long elapsedMilliseconds = ((Entity)entity).World.ElapsedMilliseconds;
			if (elapsedMilliseconds - lastCheckOrAttackMs < attackDurationMs || cooldownUntilMs > elapsedMilliseconds)
			{
				return false;
			}
			if (!PreconditionsSatisifed())
			{
				return false;
			}
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			int ownGeneration = GetOwnGeneration();
			bool fullyTamed = (float)ownGeneration >= tamingGenerations;
			float num = Math.Max(0f, (tamingGenerations - (float)ownGeneration) / tamingGenerations);
			if (WhenInEmotionState != null)
			{
				num = 1f;
			}
			if (num <= 0f)
			{
				return false;
			}
			if (((Entity)entity).World.ElapsedMilliseconds - attackedByEntityMs > 30000)
			{
				attackedByEntity = null;
			}
			if (retaliateAttacks && attackedByEntity != null && attackedByEntity.Alive && attackedByEntity.IsInteractable && IsTargetableEntity(attackedByEntity, 15f, ignoreEntityCode: true) && hasDirectContact(attackedByEntity, minDist, minVerDist) && !entity.ToleratesDamageFrom(attackedByEntity))
			{
				targetEntity = attackedByEntity;
			}
			else
			{
				targetEntity = ((Entity)entity).World.GetNearestEntity(val, attackRange * num, attackRange * num, (ActionConsumable<Entity>)delegate(Entity e)
				{
					if (fullyTamed && (isNonAttackingPlayer(e) || entity.ToleratesDamageFrom(attackedByEntity)))
					{
						return false;
					}
					return IsTargetableEntity(e, 15f) && hasDirectContact(e, minDist, minVerDist);
				});
			}
			lastCheckOrAttackMs = ((Entity)entity).World.ElapsedMilliseconds;
			damageInflicted = false;
			return targetEntity != null;
		}

		public override void StartExecute()
		{
			didStartAnim = false;
			curTurnRadPerSec = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().PathTraverser.curTurnRadPerSec;
			if (!turnToTarget)
			{
				base.StartExecute();
			}
		}

		public override bool ContinueExecute(float dt)
		{
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			EntityPos serverPos = ((Entity)entity).ServerPos;
			EntityPos serverPos2 = targetEntity.ServerPos;
			if (serverPos.Dimension != serverPos2.Dimension)
			{
				return false;
			}
			bool flag = true;
			if (turnToTarget)
			{
				float num = (float)Math.Atan2(serverPos2.X - serverPos.X, serverPos2.Z - serverPos.Z);
				float num2 = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, num);
				EntityPos serverPos3 = ((Entity)entity).ServerPos;
				serverPos3.Yaw += GameMath.Clamp(num2, (0f - curTurnRadPerSec) * dt * GlobalConstants.OverallSpeedMultiplier, curTurnRadPerSec * dt * GlobalConstants.OverallSpeedMultiplier);
				((Entity)entity).ServerPos.Yaw = ((Entity)entity).ServerPos.Yaw % ((float)Math.PI * 2f);
				flag = Math.Abs(num2) < attackAngleRangeDeg * ((float)Math.PI / 180f);
				if (flag && !didStartAnim)
				{
					didStartAnim = true;
					base.StartExecute();
				}
			}
			if (lastCheckOrAttackMs + damagePlayerAtMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return true;
			}
			if (!damageInflicted && flag)
			{
				attackTarget();
				damageInflicted = true;
			}
			if (lastCheckOrAttackMs + attackDurationMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return true;
			}
			return false;
		}

		protected virtual void attackTarget()
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Expected O, but got Unknown
			if (!hasDirectContact(targetEntity, minDist, minVerDist))
			{
				return;
			}
			bool alive = targetEntity.Alive;
			targetEntity.ReceiveDamage(new DamageSource
			{
				Source = (EnumDamageSource)8,
				SourceEntity = (Entity)(object)entity,
				Type = damageType,
				DamageTier = damageTier,
				KnockbackStrength = knockbackStrength
			}, damage * GlobalConstants.CreatureDamageModifier);
			if (entity is IMeleeAttackListener meleeAttackListener)
			{
				meleeAttackListener.DidAttack(targetEntity);
			}
			if (alive && !targetEntity.Alive)
			{
				if (!(targetEntity is EntityPlayer))
				{
					((TreeAttribute)((Entity)entity).WatchedAttributes).SetDouble("lastMealEatenTotalHours", ((Entity)entity).World.Calendar.TotalHours);
				}
				bhEmo?.TryTriggerState("saturated", targetEntity.EntityId);
			}
		}
	}
	public class AiTaskSeekBlockAndLay : AiTaskBase
	{
		protected POIRegistry porregistry;

		protected IAnimalNest targetPoi;

		protected float moveSpeed = 0.02f;

		protected bool nowStuck;

		protected bool laid;

		protected float sitDays = 1f;

		protected float layTime = 1f;

		protected double incubationDays = 5.0;

		protected string[] chickCodes;

		protected string[] nestTypes;

		protected double onGroundChance = 0.3;

		protected AssetLocation failBlockCode;

		protected float sitTimeNow;

		protected double sitEndDay;

		protected bool sitAnimStarted;

		protected float PortionsEatenForLay;

		protected string requiresNearbyEntityCode;

		protected float requiresNearbyEntityRange = 5f;

		protected AnimationMetaData sitAnimMeta;

		private Dictionary<IAnimalNest, FailedAttempt> failedSeekTargets = new Dictionary<IAnimalNest, FailedAttempt>();

		protected long lastPOISearchTotalMs;

		protected double attemptLayEggTotalHours;

		public AiTaskSeekBlockAndLay(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			//IL_023f: Expected O, but got Unknown
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			porregistry = ((Entity)entity).Api.ModLoader.GetModSystem<POIRegistry>(true);
			((TreeAttribute)((Entity)entity).WatchedAttributes).SetBool("doesSit", true);
			moveSpeed = taskConfig["movespeed"].AsFloat(0.02f);
			sitDays = taskConfig["sitDays"].AsFloat(1f);
			layTime = taskConfig["layTime"].AsFloat(1.5f);
			incubationDays = taskConfig["incubationDays"].AsDouble(5.0);
			if (taskConfig["sitAnimation"].Exists)
			{
				sitAnimMeta = new AnimationMetaData
				{
					Code = taskConfig["sitAnimation"].AsString((string)null)?.ToLowerInvariant(),
					Animation = taskConfig["sitAnimation"].AsString((string)null)?.ToLowerInvariant(),
					AnimationSpeed = taskConfig["sitAnimationSpeed"].AsFloat(1f)
				}.Init();
			}
			chickCodes = taskConfig["chickCodes"].AsArray<string>((string[])null, (string)null);
			if (chickCodes == null)
			{
				chickCodes = new string[1] { taskConfig["chickCode"].AsString((string)null) };
			}
			nestTypes = taskConfig["nestTypes"].AsArray<string>((string[])null, (string)null);
			PortionsEatenForLay = taskConfig["portionsEatenForLay"].AsFloat(3f);
			requiresNearbyEntityCode = taskConfig["requiresNearbyEntityCode"].AsString((string)null);
			requiresNearbyEntityRange = taskConfig["requiresNearbyEntityRange"].AsFloat(5f);
			string text = taskConfig["failBlockCode"].AsString((string)null);
			if (text != null)
			{
				failBlockCode = new AssetLocation(text);
			}
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() > 0.03)
			{
				return false;
			}
			if (lastPOISearchTotalMs + 15000 > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilTotalHours > ((Entity)entity).World.Calendar.TotalHours)
			{
				return false;
			}
			if (!PreconditionsSatisifed())
			{
				return false;
			}
			PortionsEatenForLay = 3f;
			if (!DidConsumeFood(PortionsEatenForLay))
			{
				return false;
			}
			if (attemptLayEggTotalHours <= 0.0)
			{
				attemptLayEggTotalHours = ((Entity)entity).World.Calendar.TotalHours;
			}
			lastPOISearchTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			targetPoi = FindPOI(42) as IAnimalNest;
			if (targetPoi == null)
			{
				LayEggOnGround();
			}
			return targetPoi != null;
		}

		private IPointOfInterest FindPOI(int radius)
		{
			return porregistry.GetWeightedNearestPoi(((Entity)entity).ServerPos.XYZ, radius, delegate(IPointOfInterest poi)
			{
				if (poi.Type != "nest")
				{
					return false;
				}
				if (poi is IAnimalNest animalNest && !animalNest.Occupied((Entity)(object)entity) && animalNest.IsSuitableFor((Entity)(object)entity, nestTypes))
				{
					failedSeekTargets.TryGetValue(animalNest, out var value);
					if (value == null || value.Count < 4 || value.LastTryMs < world.ElapsedMilliseconds - 60000)
					{
						return true;
					}
				}
				return false;
			});
		}

		public float MinDistanceToTarget()
		{
			return 0.01f;
		}

		public override void StartExecute()
		{
			if (animMeta != null)
			{
				animMeta.EaseInSpeed = 1f;
				animMeta.EaseOutSpeed = 1f;
				((Entity)entity).AnimManager.StartAnimation(animMeta);
			}
			nowStuck = false;
			sitTimeNow = 0f;
			laid = false;
			pathTraverser.NavigateTo_Async(targetPoi.Position, moveSpeed, MinDistanceToTarget() - 0.1f, OnGoalReached, OnStuck, null, 1000, 1);
			sitAnimStarted = false;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		protected virtual ItemStack MakeEggItem(string chickCode)
		{
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Expected O, but got Unknown
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Expected O, but got Unknown
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Expected O, but got Unknown
			ICoreAPI api = ((Entity)entity).Api;
			EntityAgent obj = entity;
			object obj2;
			if (obj == null)
			{
				obj2 = null;
			}
			else
			{
				JsonObject attributes = ((Entity)obj).Properties.Attributes;
				obj2 = ((attributes != null) ? attributes["eggTypes"].AsArray<JsonItemStack>((JsonItemStack[])null, (string)null) : null);
			}
			JsonItemStack[] array = (JsonItemStack[])obj2;
			ItemStack val;
			if (array == null)
			{
				string text = "egg-chicken-raw";
				if (entity != null)
				{
					api.Logger.Warning("No egg type specified for entity " + AssetLocation.op_Implicit(((RegistryObject)entity).Code) + ", falling back to " + text);
				}
				val = new ItemStack(api.World.GetItem(AssetLocation.op_Implicit(text)), 1);
			}
			else
			{
				JsonItemStack val2 = array[api.World.Rand.Next(array.Length)];
				if (!val2.Resolve(api.World, (string)null, false))
				{
					api.Logger.Warning("Failed to resolve egg " + ((object)Unsafe.As<EnumItemClass, EnumItemClass>(ref val2.Type)/*cast due to .constrained prefix*/).ToString() + " with code " + AssetLocation.op_Implicit(val2.Code) + " for entity " + AssetLocation.op_Implicit(((RegistryObject)entity).Code));
					return null;
				}
				val = new ItemStack(val2.ResolvedItemstack.Collectible, 1);
			}
			if (chickCode != null)
			{
				TreeAttribute val3 = new TreeAttribute();
				string text2 = chickCode;
				EntityAgent obj3 = entity;
				chickCode = AssetLocation.op_Implicit(AssetLocation.Create(text2, ((obj3 != null) ? ((RegistryObject)obj3).Code.Domain : null) ?? "game"));
				val3.SetString("code", chickCode);
				EntityAgent obj4 = entity;
				val3.SetInt("generation", (obj4 != null) ? (((TreeAttribute)((Entity)obj4).WatchedAttributes).GetInt("generation", 0) + 1) : 0);
				val3.SetDouble("incubationDays", incubationDays);
				EntityAgent val4 = entity;
				if (val4 != null)
				{
					val3.SetLong("herdID", val4.HerdId);
				}
				val.Attributes["chick"] = (IAttribute)(object)val3;
			}
			return val;
		}

		public override bool ContinueExecute(float dt)
		{
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			if (targetPoi.Occupied((Entity)(object)entity))
			{
				onBadTarget();
				return false;
			}
			Vec3d position = targetPoi.Position;
			double num = position.HorizontalSquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Z);
			pathTraverser.CurrentTarget.X = position.X;
			pathTraverser.CurrentTarget.Y = position.Y;
			pathTraverser.CurrentTarget.Z = position.Z;
			float num2 = MinDistanceToTarget();
			if (num <= (double)num2)
			{
				pathTraverser.Stop();
				if (animMeta != null)
				{
					((Entity)entity).AnimManager.StopAnimation(animMeta.Code);
				}
				((Entity)entity).GetBehavior<EntityBehaviorMultiply>();
				if (!targetPoi.IsSuitableFor((Entity)(object)entity, nestTypes))
				{
					onBadTarget();
					return false;
				}
				targetPoi.SetOccupier((Entity)(object)entity);
				if (sitAnimMeta != null && !sitAnimStarted)
				{
					((Entity)entity).AnimManager.StartAnimation(sitAnimMeta);
					sitAnimStarted = true;
					sitEndDay = ((Entity)entity).World.Calendar.TotalDays + (double)sitDays;
				}
				sitTimeNow += dt;
				if (sitTimeNow >= layTime && !laid)
				{
					laid = true;
					string chickCode = null;
					if (GetRequiredEntityNearby() != null && chickCodes.Length != 0)
					{
						chickCode = chickCodes[((Entity)entity).World.Rand.Next(chickCodes.Length)];
					}
					if (targetPoi.TryAddEgg(MakeEggItem(chickCode)))
					{
						ConsumeFood(PortionsEatenForLay);
						attemptLayEggTotalHours = -1.0;
						MakeLaySound();
						failedSeekTargets.Remove(targetPoi);
						return false;
					}
				}
				if (((Entity)entity).World.Calendar.TotalDays >= sitEndDay)
				{
					failedSeekTargets.Remove(targetPoi);
					return false;
				}
			}
			else if (!pathTraverser.Active)
			{
				float num3 = (float)((Entity)entity).World.Rand.NextDouble() * 0.3f - 0.15f;
				float num4 = (float)((Entity)entity).World.Rand.NextDouble() * 0.3f - 0.15f;
				pathTraverser.NavigateTo(targetPoi.Position.AddCopy(num3, 0f, num4), moveSpeed, MinDistanceToTarget() - 0.15f, OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, 500);
			}
			if (nowStuck)
			{
				return false;
			}
			if (attemptLayEggTotalHours > 0.0 && ((Entity)entity).World.Calendar.TotalHours - attemptLayEggTotalHours > 12.0)
			{
				LayEggOnGround();
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			attemptLayEggTotalHours = -1.0;
			pathTraverser.Stop();
			if (sitAnimMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(sitAnimMeta.Code);
			}
			targetPoi?.SetOccupier(null);
			if (cancelled)
			{
				cooldownUntilTotalHours = 0.0;
			}
		}

		private void OnStuck()
		{
			nowStuck = true;
			onBadTarget();
		}

		private void onBadTarget()
		{
			IAnimalNest animalNest = null;
			if (attemptLayEggTotalHours >= 0.0 && ((Entity)entity).World.Calendar.TotalHours - attemptLayEggTotalHours > 12.0)
			{
				LayEggOnGround();
			}
			else if (base.rand.NextDouble() > 0.4)
			{
				animalNest = FindPOI(18) as IAnimalNest;
			}
			failedSeekTargets.TryGetValue(targetPoi, out var value);
			if (value == null)
			{
				value = (failedSeekTargets[targetPoi] = new FailedAttempt());
			}
			value.Count++;
			value.LastTryMs = world.ElapsedMilliseconds;
			if (animalNest != null)
			{
				targetPoi = animalNest;
				nowStuck = false;
				sitTimeNow = 0f;
				laid = false;
				pathTraverser.NavigateTo_Async(targetPoi.Position, moveSpeed, MinDistanceToTarget() - 0.1f, OnGoalReached, OnStuck, null, 1000, 1);
				sitAnimStarted = false;
			}
		}

		private void OnGoalReached()
		{
			pathTraverser.Active = true;
			failedSeekTargets.Remove(targetPoi);
		}

		private bool DidConsumeFood(float portion)
		{
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute == null)
			{
				return false;
			}
			return treeAttribute.GetFloat("saturation", 0f) >= portion;
		}

		private bool ConsumeFood(float portion)
		{
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute == null)
			{
				return false;
			}
			float num = treeAttribute.GetFloat("saturation", 0f);
			if (num >= portion)
			{
				float num2 = ((((Entity)entity).World.Rand.NextDouble() < 0.25) ? portion : 1f);
				treeAttribute.SetFloat("saturation", num - num2);
				return true;
			}
			return false;
		}

		private Entity GetRequiredEntityNearby()
		{
			if (requiresNearbyEntityCode == null)
			{
				return null;
			}
			return ((Entity)entity).World.GetNearestEntity(((Entity)entity).ServerPos.XYZ, requiresNearbyEntityRange, requiresNearbyEntityRange, (ActionConsumable<Entity>)delegate(Entity e)
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Expected O, but got Unknown
				if (((RegistryObject)e).WildCardMatch(new AssetLocation(requiresNearbyEntityCode)))
				{
					ITreeAttribute treeAttribute = ((TreeAttribute)e.WatchedAttributes).GetTreeAttribute("hunger");
					if (!((TreeAttribute)e.WatchedAttributes).GetBool("doesEat", false) || treeAttribute == null)
					{
						return true;
					}
					treeAttribute.SetFloat("saturation", Math.Max(0f, treeAttribute.GetFloat("saturation", 0f) - 1f));
					return true;
				}
				return false;
			});
		}

		private void LayEggOnGround()
		{
			if (!(((Entity)entity).World.Rand.NextDouble() > onGroundChance))
			{
				Block block = ((Entity)entity).World.GetBlock(failBlockCode);
				if (block != null && (TryPlace(block, 0, 0, 0) || TryPlace(block, 1, 0, 0) || TryPlace(block, 0, 0, -1) || TryPlace(block, -1, 0, 0) || TryPlace(block, 0, 0, 1)))
				{
					ConsumeFood(PortionsEatenForLay);
					attemptLayEggTotalHours = -1.0;
				}
			}
		}

		private bool TryPlace(Block block, int dx, int dy, int dz)
		{
			IBlockAccessor blockAccessor = ((Entity)entity).World.BlockAccessor;
			BlockPos val = ((Entity)entity).ServerPos.XYZ.AsBlockPos.Add(dx, dy, dz);
			if (((CollectibleObject)blockAccessor.GetBlock(val, 2)).IsLiquid())
			{
				return false;
			}
			if (!blockAccessor.GetBlock(val).IsReplacableBy(block))
			{
				return false;
			}
			val.Y--;
			if (blockAccessor.GetMostSolidBlock(val).CanAttachBlockAt(blockAccessor, block, val, BlockFacing.UP, (Cuboidi)null))
			{
				val.Y++;
				blockAccessor.SetBlock(block.BlockId, val);
				BlockEntityTransient obj = blockAccessor.GetBlockEntity(val) as BlockEntityTransient;
				obj?.SetPlaceTime(((Entity)entity).World.Calendar.TotalHours);
				if (obj != null && obj.IsDueTransition())
				{
					blockAccessor.SetBlock(0, val);
				}
				return true;
			}
			return false;
		}

		private void MakeLaySound()
		{
			if (sound == (AssetLocation)null)
			{
				return;
			}
			if (soundStartMs > 0)
			{
				((Entity)entity).World.RegisterCallback((Action<float>)delegate
				{
					((Entity)entity).World.PlaySoundAt(sound, (Entity)(object)entity, (IPlayer)null, true, soundRange, 1f);
					lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
				}, soundStartMs);
			}
			else
			{
				((Entity)entity).World.PlaySoundAt(sound, (Entity)(object)entity, (IPlayer)null, true, soundRange, 1f);
				lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			}
		}
	}
	public enum EnumAttackPattern
	{
		DirectAttack,
		CircleTarget
	}
	public class AiTaskSeekEntity : AiTaskBaseTargetable
	{
		protected Vec3d targetPos;

		private readonly Vec3d ownPos = new Vec3d();

		protected float moveSpeed = 0.02f;

		protected float seekingRange = 25f;

		protected float belowTempSeekingRange = 25f;

		protected float belowTempThreshold = -999f;

		protected float maxFollowTime = 60f;

		protected bool stopNow;

		protected bool active;

		protected float currentFollowTime;

		protected bool alarmHerd;

		protected bool leapAtTarget;

		protected float leapHeightMul = 1f;

		protected string leapAnimationCode = "jump";

		protected float leapChance = 1f;

		protected EnumAttackPattern attackPattern;

		protected EnumAICreatureType? creatureType;

		protected long finishedMs;

		protected bool jumpAnimOn;

		protected long lastSearchTotalMs;

		protected long attackModeBeginTotalMs;

		protected long lastHurtByTargetTotalMs;

		protected float extraTargetDistance;

		protected bool lowTempRangeMode;

		protected bool revengeRangeMode;

		protected bool lastPathfindOk;

		protected int searchWaitMs = 4000;

		protected Vec3d lastGoalReachedPos;

		protected Dictionary<long, int> futilityCounters;

		private float executionChance;

		private long jumpedMS;

		private float lastPathUpdateSeconds;

		public float NowSeekRange { get; set; }

		protected bool RecentlyHurt => ((Entity)entity).World.ElapsedMilliseconds - lastHurtByTargetTotalMs < 10000;

		protected bool RemainInOffensiveMode => ((Entity)entity).World.ElapsedMilliseconds - attackModeBeginTotalMs < 20000;

		public AiTaskSeekEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			base.Id = "seekentity";
			tamingGenerations = taskConfig["tamingGenerations"].AsFloat(10f);
			JsonObject val = taskConfig["leapAnimation"];
			leapAnimationCode = ((val.Token == null) ? "jump" : val.AsString((string)null));
			leapChance = taskConfig["leapChance"].AsFloat(1f);
			leapHeightMul = taskConfig["leapHeightMul"].AsFloat(1f);
			moveSpeed = taskConfig["movespeed"].AsFloat(0.02f);
			extraTargetDistance = taskConfig["extraTargetDistance"].AsFloat(0f);
			seekingRange = taskConfig["seekingRange"].AsFloat(25f);
			belowTempSeekingRange = taskConfig["belowTempSeekingRange"].AsFloat(25f);
			belowTempThreshold = taskConfig["belowTempThreshold"].AsFloat(-999f);
			maxFollowTime = taskConfig["maxFollowTime"].AsFloat(60f);
			alarmHerd = taskConfig["alarmHerd"].AsBool(false);
			leapAtTarget = taskConfig["leapAtTarget"].AsBool(false);
			retaliateAttacks = taskConfig["retaliateAttacks"].AsBool(true);
			executionChance = taskConfig["executionChance"].AsFloat(0.1f);
			searchWaitMs = taskConfig["searchWaitMs"].AsInt(4000);
			if (taskConfig["aiCreatureType"].Exists)
			{
				creatureType = (EnumAICreatureType)taskConfig["aiCreatureType"].AsInt(0);
			}
		}

		public override bool ShouldExecute()
		{
			if (base.noEntityCodes && (attackedByEntity == null || !retaliateAttacks))
			{
				return false;
			}
			if (base.rand.NextDouble() > (double)executionChance && (WhenInEmotionState == null || !IsInEmotionState(WhenInEmotionState)) && !base.RecentlyAttacked)
			{
				return false;
			}
			if (!PreconditionsSatisifed())
			{
				return false;
			}
			if (WhenInEmotionState == null && base.rand.NextDouble() > 0.5)
			{
				return false;
			}
			if (lastSearchTotalMs + searchWaitMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (jumpAnimOn && ((Entity)entity).World.ElapsedMilliseconds - finishedMs > 2000)
			{
				((Entity)entity).AnimManager.StopAnimation("jump");
			}
			if (cooldownUntilMs > ((Entity)entity).World.ElapsedMilliseconds && !base.RecentlyAttacked)
			{
				return false;
			}
			lastSearchTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			if (!base.RecentlyAttacked)
			{
				attackedByEntity = null;
				revengeRangeMode = false;
			}
			NowSeekRange = getSeekRange();
			if (retaliateAttacks && attackedByEntity != null && attackedByEntity.Alive && attackedByEntity.IsInteractable && IsTargetableEntity(attackedByEntity, NowSeekRange, ignoreEntityCode: true) && !entity.ToleratesDamageFrom(attackedByEntity))
			{
				targetEntity = attackedByEntity;
				targetPos = targetEntity.ServerPos.XYZ;
				revengeRangeMode = true;
				return true;
			}
			bool fullyTamed = (float)GetOwnGeneration() >= tamingGenerations;
			ownPos.SetWithDimension(((Entity)entity).ServerPos);
			targetEntity = partitionUtil.GetNearestEntity(ownPos, NowSeekRange, (!noTags) ? ((ActionConsumable<Entity>)((Entity e) => (!fullyTamed || (!isNonAttackingPlayer(e) && !entity.ToleratesDamageFrom(attackedByEntity))) && IsTargetableEntityWithTags(e, NowSeekRange))) : ((targetEntityFirstLetters.Length == 0) ? ((ActionConsumable<Entity>)((Entity e) => (!fullyTamed || (!isNonAttackingPlayer(e) && !entity.ToleratesDamageFrom(attackedByEntity))) && IsTargetableEntityNoTagsAll(e, NowSeekRange))) : ((ActionConsumable<Entity>)((Entity e) => (!fullyTamed || (!isNonAttackingPlayer(e) && !entity.ToleratesDamageFrom(attackedByEntity))) && IsTargetableEntityNoTagsNoAll(e, NowSeekRange)))), EnumEntitySearchType.Creatures);
			if (targetEntity != null)
			{
				if (alarmHerd && entity.HerdId > 0)
				{
					((Entity)entity).World.GetNearestEntity(ownPos, NowSeekRange, NowSeekRange, (ActionConsumable<Entity>)delegate(Entity e)
					{
						EntityAgent val = (EntityAgent)(object)((e is EntityAgent) ? e : null);
						if (e.EntityId != ((Entity)entity).EntityId && val != null && ((Entity)val).Alive && val.HerdId == entity.HerdId)
						{
							((Entity)val).Notify("seekEntity", (object)targetEntity);
						}
						return false;
					});
				}
				targetPos = targetEntity.ServerPos.XYZ;
				if (((Entity)entity).ServerPos.SquareDistanceTo(targetPos) <= (double)MinDistanceToTarget())
				{
					return false;
				}
				return true;
			}
			return false;
		}

		protected float getSeekRange()
		{
			float num = seekingRange;
			if (belowTempThreshold > -99f && ((Entity)entity).World.BlockAccessor.GetClimateAt(((Entity)entity).Pos.AsBlockPos, (EnumGetClimateMode)3, ((Entity)entity).World.Calendar.TotalDays).Temperature <= belowTempThreshold)
			{
				num = belowTempSeekingRange;
			}
			if (retaliateAttacks && attackedByEntity != null && attackedByEntity.Alive && attackedByEntity.IsInteractable && IsTargetableEntity(attackedByEntity, NowSeekRange * 1.5f, ignoreEntityCode: true) && !entity.ToleratesDamageFrom(attackedByEntity))
			{
				num *= 1.5f;
			}
			return num;
		}

		public float MinDistanceToTarget()
		{
			return extraTargetDistance + Math.Max(0.1f, targetEntity.SelectionBox.XSize / 2f + ((Entity)entity).SelectionBox.XSize / 2f);
		}

		public override void StartExecute()
		{
			stopNow = false;
			active = true;
			currentFollowTime = 0f;
			attackPattern = EnumAttackPattern.DirectAttack;
			int searchDepth = 3500;
			if (world.Rand.NextDouble() < 0.05)
			{
				searchDepth = 10000;
			}
			pathTraverser.NavigateTo_Async(targetPos.Clone(), moveSpeed, MinDistanceToTarget(), OnGoalReached, OnStuck, OnSeekUnable, searchDepth, 1, creatureType);
		}

		private void OnSeekUnable()
		{
			OnSiegeUnable();
		}

		private void OnSiegeUnable()
		{
			if (targetPos.DistanceTo(((Entity)entity).ServerPos.XYZ) < NowSeekRange && !TryCircleTarget())
			{
				OnCircleTargetUnable();
			}
		}

		public void OnCircleTargetUnable()
		{
			((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().TaskManager.AllTasks.ForEach(delegate(IAiTask t)
			{
				(t as AiTaskFleeEntity)?.InstaFleeFrom(targetEntity);
			});
		}

		private bool TryCircleTarget()
		{
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Expected O, but got Unknown
			//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Expected O, but got Unknown
			//IL_0267: Unknown result type (might be due to invalid IL or missing references)
			//IL_0272: Expected O, but got Unknown
			targetPos.SquareDistanceTo(((Entity)entity).Pos);
			int searchDepth = 3500;
			attackPattern = EnumAttackPattern.CircleTarget;
			lastPathfindOk = false;
			float num = (float)Math.Atan2(((Entity)entity).ServerPos.X - targetPos.X, ((Entity)entity).ServerPos.Z - targetPos.Z);
			for (int i = 0; i < 3; i++)
			{
				double num2 = (double)num + 0.5 + world.Rand.NextDouble() / 2.0;
				double num3 = 4.0 + world.Rand.NextDouble() * 6.0;
				double num4 = GameMath.Sin(num2) * num3;
				double num5 = GameMath.Cos(num2) * num3;
				targetPos.Add(num4, 0.0, num5);
				int num6 = 0;
				bool flag = false;
				BlockPos val = new BlockPos((int)targetPos.X, (int)targetPos.Y, (int)targetPos.Z);
				int num7 = 0;
				while (num6 < 5)
				{
					if (((SmallBoolArray)(ref PosUtil.GetBlockBelow(world.BlockAccessor, val, num7, 0).SideSolid))[BlockFacing.UP.Index] && !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, new Vec3d((double)val.X + 0.5, (double)(val.Y - num7 + 1), (double)val.Z + 0.5), false))
					{
						flag = true;
						Vec3d obj = targetPos;
						obj.Y -= (double)num7;
						Vec3d obj2 = targetPos;
						obj2.Y += 1.0;
						break;
					}
					if (((SmallBoolArray)(ref PosUtil.GetBlockAbove(world.BlockAccessor, val, num7, 0).SideSolid))[BlockFacing.UP.Index] && !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, new Vec3d((double)val.X + 0.5, (double)(val.Y + num7 + 1), (double)val.Z + 0.5), false))
					{
						flag = true;
						Vec3d obj3 = targetPos;
						obj3.Y += (double)num7;
						Vec3d obj4 = targetPos;
						obj4.Y += 1.0;
						break;
					}
					num6++;
					num7++;
				}
				if (flag)
				{
					pathTraverser.NavigateTo_Async(targetPos.Clone(), moveSpeed, MinDistanceToTarget(), OnGoalReached, OnStuck, OnCircleTargetUnable, searchDepth, 1);
					return true;
				}
			}
			return false;
		}

		public override bool CanContinueExecute()
		{
			if (pathTraverser.Ready)
			{
				attackModeBeginTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
				lastPathfindOk = true;
			}
			return pathTraverser.Ready;
		}

		private double getDistanceToTarget()
		{
			if (targetEntity == null)
			{
				return double.MaxValue;
			}
			Cuboidd obj = targetEntity.SelectionBox.ToDouble().Translate(targetEntity.ServerPos.X, targetEntity.ServerPos.InternalY, targetEntity.ServerPos.Z);
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			return obj.ShortestDistanceFrom((IVec3)(object)val);
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_032f: Unknown result type (might be due to invalid IL or missing references)
			//IL_033d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0343: Invalid comparison between Unknown and I4
			//IL_055f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0564: Unknown result type (might be due to invalid IL or missing references)
			//IL_0570: Unknown result type (might be due to invalid IL or missing references)
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			if (currentFollowTime == 0f && (!stopNow || world.Rand.NextDouble() < 0.25))
			{
				base.StartExecute();
			}
			currentFollowTime += dt;
			lastPathUpdateSeconds += dt;
			double distanceToTarget = getDistanceToTarget();
			if (attackPattern == EnumAttackPattern.DirectAttack && lastPathUpdateSeconds >= 0.75f && targetPos.SquareDistanceTo(targetEntity.ServerPos.X, targetEntity.ServerPos.InternalY, targetEntity.ServerPos.Z) >= 9f)
			{
				targetPos.Set(targetEntity.ServerPos.X + targetEntity.ServerPos.Motion.X * 10.0, targetEntity.ServerPos.InternalY, targetEntity.ServerPos.Z + targetEntity.ServerPos.Motion.Z * 10.0);
				pathTraverser.NavigateTo(targetPos, moveSpeed, MinDistanceToTarget(), OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, 2000, 1);
				lastPathUpdateSeconds = 0f;
			}
			if (leapAtTarget && !((Entity)entity).AnimManager.IsAnimationActive(new string[1] { animMeta.Code }))
			{
				RunningAnimation animationState = ((Entity)entity).AnimManager.Animator.GetAnimationState(leapAnimationCode);
				if (animationState == null || !animationState.Active)
				{
					animMeta.EaseInSpeed = 1f;
					animMeta.EaseOutSpeed = 1f;
					((Entity)entity).AnimManager.StartAnimation(animMeta);
				}
			}
			if (jumpAnimOn && ((Entity)entity).World.ElapsedMilliseconds - finishedMs > 2000)
			{
				((Entity)entity).AnimManager.StopAnimation(leapAnimationCode);
				animMeta.EaseInSpeed = 1f;
				animMeta.EaseOutSpeed = 1f;
				((Entity)entity).AnimManager.StartAnimation(animMeta);
			}
			if (attackPattern == EnumAttackPattern.DirectAttack)
			{
				pathTraverser.CurrentTarget.X = targetEntity.ServerPos.X;
				pathTraverser.CurrentTarget.Y = targetEntity.ServerPos.InternalY;
				pathTraverser.CurrentTarget.Z = targetEntity.ServerPos.Z;
			}
			Entity obj = targetEntity;
			Entity obj2 = ((obj is EntityPlayer) ? obj : null);
			int num;
			if (obj2 == null)
			{
				num = 0;
			}
			else
			{
				IPlayer player = ((EntityPlayer)obj2).Player;
				num = (((int)((player != null) ? new EnumGameMode?(player.WorldData.CurrentGameMode) : ((EnumGameMode?)null)).GetValueOrDefault() == 2) ? 1 : 0);
			}
			bool flag = (byte)num != 0;
			if (!flag && leapAtTarget && base.rand.NextDouble() < (double)leapChance)
			{
				bool flag2 = ((Entity)entity).World.ElapsedMilliseconds - jumpedMS < 3000;
				if (distanceToTarget > 0.5 && distanceToTarget < 4.0 && !flag2 && targetEntity.ServerPos.Y + 0.1 >= ((Entity)entity).ServerPos.Y)
				{
					double num2 = (targetEntity.ServerPos.X + targetEntity.ServerPos.Motion.X * 80.0 - ((Entity)entity).ServerPos.X) / 30.0;
					double num3 = (targetEntity.ServerPos.Z + targetEntity.ServerPos.Motion.Z * 80.0 - ((Entity)entity).ServerPos.Z) / 30.0;
					((Entity)entity).ServerPos.Motion.Add(num2, (double)leapHeightMul * GameMath.Max(0.13, (targetEntity.ServerPos.Y - ((Entity)entity).ServerPos.Y) / 30.0), num3);
					float yaw = (float)Math.Atan2(num2, num3);
					((Entity)entity).ServerPos.Yaw = yaw;
					jumpedMS = ((Entity)entity).World.ElapsedMilliseconds;
					finishedMs = ((Entity)entity).World.ElapsedMilliseconds;
					if (leapAnimationCode != null)
					{
						((Entity)entity).AnimManager.StopAnimation("walk");
						((Entity)entity).AnimManager.StopAnimation("run");
						((Entity)entity).AnimManager.StartAnimation(new AnimationMetaData
						{
							Animation = leapAnimationCode,
							Code = leapAnimationCode
						}.Init());
						jumpAnimOn = true;
					}
				}
				if (flag2 && !((Entity)entity).Collided && distanceToTarget < 0.5)
				{
					EntityPos serverPos = ((Entity)entity).ServerPos;
					serverPos.Motion /= 2f;
				}
			}
			float num4 = MinDistanceToTarget();
			if (targetEntity.Alive && !stopNow && !flag && pathTraverser.Active && currentFollowTime < maxFollowTime && distanceToTarget < (double)NowSeekRange)
			{
				if (!(distanceToTarget > (double)num4))
				{
					Entity obj3 = targetEntity;
					EntityAgent val = (EntityAgent)(object)((obj3 is EntityAgent) ? obj3 : null);
					if (val != null)
					{
						return val.ServerControls.TriesToMove;
					}
					return false;
				}
				return true;
			}
			return false;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			finishedMs = ((Entity)entity).World.ElapsedMilliseconds;
			pathTraverser.Stop();
			active = false;
		}

		public override bool Notify(string key, object data)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			if (key == "seekEntity")
			{
				targetEntity = (Entity)data;
				targetPos = targetEntity.ServerPos.XYZ;
				return true;
			}
			return false;
		}

		public override void OnEntityHurt(DamageSource source, float damage)
		{
			base.OnEntityHurt(source, damage);
			if (targetEntity != source.GetCauseEntity() && active)
			{
				return;
			}
			lastHurtByTargetTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			float num = ((source.GetCauseEntity() == null) ? 0f : ((float)source.GetCauseEntity().ServerPos.DistanceTo(((Entity)entity).ServerPos)));
			float seekRange = getSeekRange();
			if (num > seekRange)
			{
				((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().TaskManager.AllTasks.ForEach(delegate(IAiTask t)
				{
					(t as AiTaskFleeEntity)?.InstaFleeFrom(targetEntity);
				});
			}
		}

		private void OnStuck()
		{
			stopNow = true;
		}

		private void OnGoalReached()
		{
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Expected O, but got Unknown
			if (attackPattern != EnumAttackPattern.DirectAttack)
			{
				return;
			}
			if (lastGoalReachedPos != (Vec3d)null && (double)lastGoalReachedPos.SquareDistanceTo(((Entity)entity).Pos) < 0.001)
			{
				if (futilityCounters == null)
				{
					futilityCounters = new Dictionary<long, int>();
				}
				else
				{
					futilityCounters.TryGetValue(targetEntity.EntityId, out var value);
					value++;
					futilityCounters[targetEntity.EntityId] = value;
					if (value > 19)
					{
						return;
					}
				}
			}
			lastGoalReachedPos = new Vec3d(((Entity)entity).Pos);
			pathTraverser.Retarget();
		}

		public override bool CanSense(Entity e, double range)
		{
			bool flag = base.CanSense(e, range);
			if (flag && futilityCounters != null && futilityCounters.TryGetValue(e.EntityId, out var value) && value > 0)
			{
				value -= 2;
				futilityCounters[e.EntityId] = value;
				return false;
			}
			return flag;
		}
	}
	internal class FailedAttempt
	{
		public long LastTryMs;

		public int Count;
	}
	public class AiTaskSeekFoodAndEat : AiTaskBase
	{
		private AssetLocation eatSound;

		private POIRegistry porregistry;

		private IAnimalFoodSource targetPoi;

		private float moveSpeed = 0.02f;

		private long stuckatMs;

		private bool nowStuck;

		private float eatTime = 1f;

		private float eatTimeNow;

		private bool soundPlayed;

		private bool doConsumePortion = true;

		private bool eatAnimStarted;

		private bool eatLooseItems;

		private float quantityEaten;

		private AnimationMetaData eatAnimMeta;

		private AnimationMetaData eatAnimMetaLooseItems;

		private Dictionary<IAnimalFoodSource, FailedAttempt> failedSeekTargets = new Dictionary<IAnimalFoodSource, FailedAttempt>();

		private float extraTargetDist;

		private long lastPOISearchTotalMs;

		public CreatureDiet Diet;

		private EntityBehaviorMultiplyBase bhMultiply;

		private ICoreAPI api;

		public AiTaskSeekFoodAndEat(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_015a: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_0205: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0228: Unknown result type (might be due to invalid IL or missing references)
			api = ((Entity)entity).Api;
			porregistry = api.ModLoader.GetModSystem<POIRegistry>(true);
			((TreeAttribute)((Entity)entity).WatchedAttributes).SetBool("doesEat", true);
			string text = taskConfig["eatSound"].AsString((string)null);
			if (text != null)
			{
				eatSound = new AssetLocation(text).WithPathPrefix("sounds/");
			}
			moveSpeed = taskConfig["movespeed"].AsFloat(0.02f);
			eatTime = taskConfig["eatTime"].AsFloat(1.5f);
			doConsumePortion = taskConfig["doConsumePortion"].AsBool(true);
			eatLooseItems = taskConfig["eatLooseItems"].AsBool(true);
			Diet = ((Entity)entity).Properties.Attributes["creatureDiet"].AsObject<CreatureDiet>((CreatureDiet)null);
			if (Diet == null)
			{
				api.Logger.Warning("Creature " + ((RegistryObject)entity).Code.ToShortString() + " has SeekFoodAndEat task but no Diet specified");
			}
			if (taskConfig["eatAnimation"].Exists)
			{
				eatAnimMeta = new AnimationMetaData
				{
					Code = taskConfig["eatAnimation"].AsString((string)null)?.ToLowerInvariant(),
					Animation = taskConfig["eatAnimation"].AsString((string)null)?.ToLowerInvariant(),
					AnimationSpeed = taskConfig["eatAnimationSpeed"].AsFloat(1f)
				}.Init();
			}
			if (taskConfig["eatAnimationLooseItems"].Exists)
			{
				eatAnimMetaLooseItems = new AnimationMetaData
				{
					Code = taskConfig["eatAnimationLooseItems"].AsString((string)null)?.ToLowerInvariant(),
					Animation = taskConfig["eatAnimationLooseItems"].AsString((string)null)?.ToLowerInvariant(),
					AnimationSpeed = taskConfig["eatAnimationSpeedLooseItems"].AsFloat(1f)
				}.Init();
			}
		}

		public override void AfterInitialize()
		{
			bhMultiply = ((Entity)entity).GetBehavior<EntityBehaviorMultiplyBase>();
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() < 0.005)
			{
				return false;
			}
			if (lastPOISearchTotalMs + 15000 > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilTotalHours > ((Entity)entity).World.Calendar.TotalHours)
			{
				return false;
			}
			if (!PreconditionsSatisifed())
			{
				return false;
			}
			if (bhMultiply != null && !bhMultiply.ShouldEat && ((Entity)entity).World.Rand.NextDouble() < 0.996)
			{
				return false;
			}
			if (Diet == null)
			{
				return false;
			}
			targetPoi = null;
			extraTargetDist = 0f;
			lastPOISearchTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			if (eatLooseItems)
			{
				api.ModLoader.GetModSystem<EntityPartitioning>(true).WalkEntities(((Entity)entity).ServerPos.XYZ, 10.0, delegate(Entity e)
				{
					EntityItem val = (EntityItem)(object)((e is EntityItem) ? e : null);
					if (val != null && suitableFoodSource(val.Itemstack))
					{
						targetPoi = new LooseItemFoodSource(val);
						return false;
					}
					return true;
				}, EnumEntitySearchType.Inanimate);
			}
			if (targetPoi == null)
			{
				targetPoi = porregistry.GetNearestPoi(((Entity)entity).ServerPos.XYZ, 48f, delegate(IPointOfInterest poi)
				{
					if (poi.Type != "food")
					{
						return false;
					}
					IAnimalFoodSource key;
					IAnimalFoodSource animalFoodSource = (key = poi as IAnimalFoodSource);
					if (animalFoodSource != null && animalFoodSource.IsSuitableFor((Entity)(object)entity, Diet))
					{
						failedSeekTargets.TryGetValue(key, out var value);
						if (value == null || value.Count < 4 || value.LastTryMs < world.ElapsedMilliseconds - 60000)
						{
							return true;
						}
					}
					return false;
				}) as IAnimalFoodSource;
			}
			return targetPoi != null;
		}

		private bool suitableFoodSource(ItemStack itemStack)
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			EnumFoodCategory foodSourceCategory = (EnumFoodCategory)(((_003F?)((itemStack == null) ? ((EnumFoodCategory?)null) : itemStack.Collectible?.NutritionProps?.FoodCategory)) ?? (-1));
			object obj;
			if (itemStack == null)
			{
				obj = null;
			}
			else
			{
				JsonObject itemAttributes = itemStack.ItemAttributes;
				obj = ((itemAttributes != null) ? itemAttributes["foodTags"].AsArray<string>((string[])null, (string)null) : null);
			}
			if (obj == null)
			{
				obj = Array.Empty<string>();
			}
			string[] foodSourceTags = (string[])obj;
			return Diet.Matches(foodSourceCategory, foodSourceTags);
		}

		public float MinDistanceToTarget()
		{
			return Math.Max(extraTargetDist + 0.6f, ((Entity)entity).SelectionBox.XSize / 2f + 0.05f);
		}

		public override void StartExecute()
		{
			base.StartExecute();
			stuckatMs = -9999L;
			nowStuck = false;
			soundPlayed = false;
			eatTimeNow = 0f;
			pathTraverser.NavigateTo_Async(targetPoi.Position, moveSpeed, MinDistanceToTarget() - 0.1f, OnGoalReached, OnStuck, null, 1000, 1);
			eatAnimStarted = false;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_0258: Unknown result type (might be due to invalid IL or missing references)
			//IL_025d: Unknown result type (might be due to invalid IL or missing references)
			//IL_025f: Expected O, but got Unknown
			//IL_0264: Expected O, but got Unknown
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			Vec3d position = targetPoi.Position;
			pathTraverser.CurrentTarget.X = position.X;
			pathTraverser.CurrentTarget.Y = position.Y;
			pathTraverser.CurrentTarget.Z = position.Z;
			double num = ((Entity)entity).SelectionBox.ToDouble().Translate(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).ShortestDistanceFrom((IVec3)(object)position);
			float num2 = MinDistanceToTarget();
			if (num <= (double)num2)
			{
				pathTraverser.Stop();
				if (animMeta != null)
				{
					((Entity)entity).AnimManager.StopAnimation(animMeta.Code);
				}
				if (bhMultiply != null && !bhMultiply.ShouldEat)
				{
					return false;
				}
				if (!targetPoi.IsSuitableFor((Entity)(object)entity, Diet))
				{
					return false;
				}
				if (eatAnimMeta != null && !eatAnimStarted)
				{
					((Entity)entity).AnimManager.StartAnimation((targetPoi is LooseItemFoodSource && eatAnimMetaLooseItems != null) ? eatAnimMetaLooseItems : eatAnimMeta);
					eatAnimStarted = true;
				}
				eatTimeNow += dt;
				if (targetPoi is LooseItemFoodSource looseItemFoodSource)
				{
					((Entity)entity).World.SpawnCubeParticles(targetPoi.Position, looseItemFoodSource.ItemStack, 0.25f, 1, 0.25f + 0.5f * (float)((Entity)entity).World.Rand.NextDouble(), (IPlayer)null, (Vec3f)null);
				}
				if (eatTimeNow > eatTime * 0.75f && !soundPlayed)
				{
					soundPlayed = true;
					if (eatSound != (AssetLocation)null)
					{
						((Entity)entity).World.PlaySoundAt(eatSound, (Entity)(object)entity, (IPlayer)null, true, 16f, 1f);
					}
				}
				if (eatTimeNow >= eatTime)
				{
					ITreeAttribute val = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
					if (val == null)
					{
						SyncedTreeAttribute watchedAttributes = ((Entity)entity).WatchedAttributes;
						TreeAttribute val2 = new TreeAttribute();
						val = (ITreeAttribute)val2;
						((TreeAttribute)watchedAttributes)["hunger"] = (IAttribute)val2;
					}
					if (doConsumePortion)
					{
						float num3 = targetPoi.ConsumeOnePortion((Entity)(object)entity);
						quantityEaten += num3;
						val.SetFloat("saturation", num3 + val.GetFloat("saturation", 0f));
						((TreeAttribute)((Entity)entity).WatchedAttributes).SetDouble("lastMealEatenTotalHours", ((Entity)entity).World.Calendar.TotalHours);
						((Entity)entity).WatchedAttributes.MarkPathDirty("hunger");
					}
					else
					{
						quantityEaten = 1f;
					}
					failedSeekTargets.Remove(targetPoi);
					return false;
				}
			}
			else if (!pathTraverser.Active)
			{
				float num4 = (float)((Entity)entity).World.Rand.NextDouble() * 0.3f - 0.15f;
				float num5 = (float)((Entity)entity).World.Rand.NextDouble() * 0.3f - 0.15f;
				if (!pathTraverser.NavigateTo(targetPoi.Position.AddCopy(num4, 0f, num5), moveSpeed, num2 - 0.15f, OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, 500, 1))
				{
					return false;
				}
			}
			if (nowStuck && (float)((Entity)entity).World.ElapsedMilliseconds > (float)stuckatMs + eatTime * 1000f)
			{
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			EntityBehaviorMultiply behavior = ((Entity)entity).GetBehavior<EntityBehaviorMultiply>();
			if (behavior != null && behavior.PortionsLeftToEat > 0f && !behavior.IsPregnant)
			{
				cooldownUntilTotalHours += mincooldownHours + ((Entity)entity).World.Rand.NextDouble() * (maxcooldownHours - mincooldownHours);
			}
			else
			{
				cooldownUntilTotalHours = api.World.Calendar.TotalHours + mincooldownHours + ((Entity)entity).World.Rand.NextDouble() * (maxcooldownHours - mincooldownHours);
			}
			pathTraverser.Stop();
			if (eatAnimMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(eatAnimMeta.Code);
			}
			if (animMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(animMeta.Code);
			}
			if (cancelled)
			{
				cooldownUntilTotalHours = 0.0;
			}
			if (quantityEaten < 1f)
			{
				cooldownUntilTotalHours = 0.0;
			}
			else
			{
				quantityEaten = 0f;
			}
		}

		private void OnStuck()
		{
			stuckatMs = ((Entity)entity).World.ElapsedMilliseconds;
			nowStuck = true;
			failedSeekTargets.TryGetValue(targetPoi, out var value);
			if (value == null)
			{
				value = (failedSeekTargets[targetPoi] = new FailedAttempt());
			}
			value.Count++;
			value.LastTryMs = world.ElapsedMilliseconds;
		}

		private void OnGoalReached()
		{
			pathTraverser.Active = true;
			failedSeekTargets.Remove(targetPoi);
		}
	}
	public class PlayerPoi : IAnimalFoodSource, IPointOfInterest
	{
		private EntityPlayer plr;

		private Vec3d pos = new Vec3d();

		public Vec3d Position
		{
			get
			{
				pos.Set(((Entity)plr).Pos.X, ((Entity)plr).Pos.Y, ((Entity)plr).Pos.Z);
				return pos;
			}
		}

		public string Type => "food";

		public PlayerPoi(EntityPlayer plr)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			this.plr = plr;
		}

		public float ConsumeOnePortion(Entity entity)
		{
			return 0f;
		}

		public bool IsSuitableFor(Entity entity, CreatureDiet diet)
		{
			return false;
		}
	}
	public class LooseItemFoodSource : IAnimalFoodSource, IPointOfInterest
	{
		private EntityItem entity;

		public ItemStack ItemStack => entity.Itemstack;

		public Vec3d Position => ((Entity)entity).ServerPos.XYZ;

		public string Type => "food";

		public LooseItemFoodSource(EntityItem entity)
		{
			this.entity = entity;
		}

		public float ConsumeOnePortion(Entity entity)
		{
			ItemStack itemstack = this.entity.Itemstack;
			int stackSize = itemstack.StackSize;
			itemstack.StackSize = stackSize - 1;
			if (this.entity.Itemstack.StackSize <= 0)
			{
				((Entity)this.entity).Die((EnumDespawnReason)0, (DamageSource)null);
			}
			if (this.entity.Itemstack.StackSize < 0)
			{
				return 0f;
			}
			return 1f;
		}

		public bool IsSuitableFor(Entity entity, CreatureDiet diet)
		{
			return true;
		}
	}
	public class AiTaskStayCloseToEntity : AiTaskBase
	{
		protected Entity targetEntity;

		protected float moveSpeed = 0.03f;

		protected float range = 8f;

		protected float maxDistance = 3f;

		protected string entityCode;

		protected bool stuck;

		protected bool onlyIfLowerId;

		protected bool allowTeleport;

		protected float teleportAfterRange;

		protected int teleportToRange;

		public int TeleportMaxRange;

		public float minSeekSeconds = 3f;

		protected Vec3d targetOffset = new Vec3d();

		protected Vec3d initialTargetPos;

		public int allowTeleportCount;

		private float executingSeconds;

		private int stuckCounter;

		private long cooldownUntilTotalMs;

		public AiTaskStayCloseToEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			moveSpeed = taskConfig["movespeed"].AsFloat(0.03f);
			range = taskConfig["searchRange"].AsFloat(8f);
			maxDistance = taskConfig["maxDistance"].AsFloat(3f);
			minSeekSeconds = taskConfig["minSeekSeconds"].AsFloat(3f);
			onlyIfLowerId = taskConfig["onlyIfLowerId"].AsBool(false);
			entityCode = taskConfig["entityCode"].AsString((string)null);
			allowTeleport = taskConfig["allowTeleport"].AsBool(false);
			teleportAfterRange = taskConfig["teleportAfterRange"].AsFloat(30f);
			teleportToRange = taskConfig["teleportToRange"].AsInt(1);
			TeleportMaxRange = taskConfig["teleportMaxRange"].AsInt(int.MaxValue);
		}

		public override bool ShouldExecute()
		{
			if (base.rand.NextDouble() > 0.009999999776482582)
			{
				return false;
			}
			if (stuckCounter > 3)
			{
				stuckCounter = 0;
				cooldownUntilTotalMs = ((Entity)entity).World.ElapsedMilliseconds + 60000;
			}
			if (((Entity)entity).World.ElapsedMilliseconds < cooldownUntilMs)
			{
				return false;
			}
			if (targetEntity == null || !targetEntity.Alive)
			{
				if (onlyIfLowerId)
				{
					targetEntity = ((Entity)entity).World.GetNearestEntity(((Entity)entity).ServerPos.XYZ, range, 2f, (ActionConsumable<Entity>)((Entity e) => e.EntityId < ((Entity)entity).EntityId && ((RegistryObject)e).Code.Path.Equals(entityCode)));
				}
				else
				{
					targetEntity = ((Entity)entity).World.GetNearestEntity(((Entity)entity).ServerPos.XYZ, range, 2f, (ActionConsumable<Entity>)((Entity e) => ((RegistryObject)e).Code.Path.Equals(entityCode)));
				}
			}
			if (targetEntity != null && (!targetEntity.Alive || targetEntity.ShouldDespawn))
			{
				targetEntity = null;
			}
			if (targetEntity == null)
			{
				return false;
			}
			double x = targetEntity.ServerPos.X;
			double y = targetEntity.ServerPos.Y;
			double z = targetEntity.ServerPos.Z;
			return (double)((Entity)entity).ServerPos.SquareDistanceTo(x, y, z) > (double)(maxDistance * maxDistance);
		}

		public override void StartExecute()
		{
			base.StartExecute();
			executingSeconds = 0f;
			initialTargetPos = targetEntity.ServerPos.XYZ;
			if (targetEntity.ServerPos.DistanceTo(((Entity)entity).ServerPos) > (double)TeleportMaxRange)
			{
				stuck = true;
				return;
			}
			float xSize = targetEntity.SelectionBox.XSize;
			pathTraverser.NavigateTo_Async(targetEntity.ServerPos.XYZ, moveSpeed, xSize + 0.2f, OnGoalReached, OnStuck, OnNoPath, 1000, 1);
			targetOffset.Set(((Entity)entity).World.Rand.NextDouble() * 2.0 - 1.0, 0.0, ((Entity)entity).World.Rand.NextDouble() * 2.0 - 1.0);
			stuck = false;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		public override bool ContinueExecute(float dt)
		{
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			if (initialTargetPos.DistanceTo(targetEntity.ServerPos.XYZ) > 3f)
			{
				initialTargetPos = targetEntity.ServerPos.XYZ;
				pathTraverser.Retarget();
			}
			double num = targetEntity.ServerPos.X + targetOffset.X;
			double y = targetEntity.ServerPos.Y;
			double num2 = targetEntity.ServerPos.Z + targetOffset.Z;
			pathTraverser.CurrentTarget.X = num;
			pathTraverser.CurrentTarget.Y = y;
			pathTraverser.CurrentTarget.Z = num2;
			float num3 = ((Entity)entity).ServerPos.SquareDistanceTo(num, y, num2);
			if (num3 < 9f)
			{
				pathTraverser.Stop();
				return false;
			}
			if ((allowTeleport || allowTeleportCount > 0) && executingSeconds > 4f && (num3 > teleportAfterRange * teleportAfterRange || stuck) && ((Entity)entity).World.Rand.NextDouble() < 0.05)
			{
				tryTeleport();
			}
			executingSeconds += dt;
			if (stuck || !pathTraverser.Active)
			{
				return executingSeconds < minSeekSeconds;
			}
			return true;
		}

		private Vec3d findDecentTeleportPos()
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Expected O, but got Unknown
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Expected O, but got Unknown
			IBlockAccessor blockAccessor = ((Entity)entity).World.BlockAccessor;
			Random random = ((Entity)entity).World.Rand;
			Vec3d val = new Vec3d();
			BlockPos val2 = new BlockPos();
			for (int i = teleportToRange; i < teleportToRange + 30; i++)
			{
				float num = GameMath.Clamp((float)i / 5f, 2f, 4.5f);
				double num2 = random.NextDouble() * 2.0 * (double)num - (double)num;
				double num3 = random.NextDouble() * 2.0 * (double)num - (double)num;
				for (int j = 0; j < 8; j++)
				{
					int num4 = (1 - j % 2 * 2) * (int)Math.Ceiling((float)j / 2f);
					val.Set(targetEntity.ServerPos.X + num2, targetEntity.ServerPos.Y + (double)num4, targetEntity.ServerPos.Z + num3);
					val2.Set((int)val.X, (int)val.Y, (int)val.Z);
					Block block = blockAccessor.GetBlock(val2);
					Cuboidf[] collisionBoxes = block.GetCollisionBoxes(blockAccessor, val2);
					if (collisionBoxes != null && collisionBoxes.Length != 0)
					{
						continue;
					}
					JsonObject attributes = ((CollectibleObject)block).Attributes;
					if (attributes != null && attributes["insideDamage"].AsInt(0) > 0)
					{
						continue;
					}
					val2.Set((int)val.X, (int)val.Y - 1, (int)val.Z);
					Block block2 = blockAccessor.GetBlock(val2);
					collisionBoxes = block2.GetCollisionBoxes(blockAccessor, val2);
					if (collisionBoxes == null || collisionBoxes.Length == 0)
					{
						continue;
					}
					JsonObject attributes2 = ((CollectibleObject)block2).Attributes;
					if (attributes2 == null || attributes2["insideDamage"].AsInt(0) <= 0)
					{
						val.Y = (float)((int)val.Y - 1) + collisionBoxes.Max((Cuboidf c) => c.Y2);
						return val;
					}
				}
			}
			return null;
		}

		protected void tryTeleport()
		{
			if ((!allowTeleport && allowTeleportCount <= 0) || targetEntity == null)
			{
				return;
			}
			Vec3d val = findDecentTeleportPos();
			if (val != (Vec3d)null)
			{
				((Entity)entity).TeleportToDouble(val.X, val.Y, val.Z, (Action)delegate
				{
					initialTargetPos = targetEntity.ServerPos.XYZ;
					pathTraverser.Retarget();
					allowTeleportCount = Math.Max(0, allowTeleportCount - 1);
				});
			}
		}

		public override void FinishExecute(bool cancelled)
		{
			if (stuck)
			{
				stuckCounter++;
			}
			else
			{
				stuckCounter = 0;
			}
			base.FinishExecute(cancelled);
		}

		protected void OnStuck()
		{
			stuck = true;
		}

		public void OnNoPath()
		{
		}

		protected virtual void OnGoalReached()
		{
		}
	}
	public class AiTaskUseInventory : AiTaskBase
	{
		protected AssetLocation useSound;

		protected float useTime = 1f;

		protected float useTimeNow;

		protected bool soundPlayed;

		protected bool doConsumePortion = true;

		protected HashSet<EnumFoodCategory> eatItemCategories = new HashSet<EnumFoodCategory>();

		protected HashSet<AssetLocation> eatItemCodes = new HashSet<AssetLocation>();

		protected bool isEdible;

		public AiTaskUseInventory(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			JsonObject val = taskConfig["useSound"];
			if (val.Exists)
			{
				string text = val.AsString((string)null);
				if (text != null)
				{
					useSound = new AssetLocation(text).WithPathPrefix("sounds/");
				}
			}
			useTime = taskConfig["useTime"].AsFloat(1.5f);
			EnumFoodCategory[] array = taskConfig["eatItemCategories"].AsArray<EnumFoodCategory>(Array.Empty<EnumFoodCategory>(), (string)null);
			foreach (EnumFoodCategory item in array)
			{
				eatItemCategories.Add(item);
			}
			AssetLocation[] array2 = taskConfig["eatItemCodes"].AsArray<AssetLocation>(Array.Empty<AssetLocation>(), (string)null);
			foreach (AssetLocation item2 in array2)
			{
				eatItemCodes.Add(item2);
			}
		}

		public override bool ShouldExecute()
		{
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			if (((Entity)entity).World.Rand.NextDouble() < 0.005)
			{
				return false;
			}
			if (cooldownUntilMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilTotalHours > ((Entity)entity).World.Calendar.TotalHours)
			{
				return false;
			}
			if (!PreconditionsSatisifed())
			{
				return false;
			}
			EntityBehaviorMultiplyBase behavior = ((Entity)entity).GetBehavior<EntityBehaviorMultiplyBase>();
			if (behavior != null && !behavior.ShouldEat && ((Entity)entity).World.Rand.NextDouble() < 0.996)
			{
				return false;
			}
			ItemSlot leftHandItemSlot = entity.LeftHandItemSlot;
			if (leftHandItemSlot.Empty)
			{
				return false;
			}
			isEdible = false;
			EnumFoodCategory? val = leftHandItemSlot.Itemstack.Collectible?.NutritionProps?.FoodCategory;
			if (val.HasValue && eatItemCategories.Contains(val.Value))
			{
				isEdible = true;
				return true;
			}
			ItemStack itemstack = leftHandItemSlot.Itemstack;
			AssetLocation val2 = ((itemstack == null) ? null : ((RegistryObject)(itemstack.Collectible?)).Code);
			if (val2 != (AssetLocation)null && eatItemCodes.Contains(val2))
			{
				isEdible = true;
				return true;
			}
			if (!leftHandItemSlot.Empty)
			{
				((Entity)entity).World.SpawnItemEntity(leftHandItemSlot.TakeOutWhole(), ((Entity)entity).ServerPos.XYZ, (Vec3d)null);
			}
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			soundPlayed = false;
			useTimeNow = 0f;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Expected O, but got Unknown
			//IL_0138: Expected O, but got Unknown
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			useTimeNow += dt;
			if (useTimeNow > useTime * 0.75f && !soundPlayed)
			{
				soundPlayed = true;
				if (useSound != (AssetLocation)null)
				{
					((Entity)entity).World.PlaySoundAt(useSound, (Entity)(object)entity, (IPlayer)null, true, 16f, 1f);
				}
			}
			if (entity.LeftHandItemSlot == null || entity.LeftHandItemSlot.Empty)
			{
				return false;
			}
			((Entity)entity).World.SpawnCubeParticles(((Entity)entity).ServerPos.XYZ, entity.LeftHandItemSlot.Itemstack, 0.25f, 1, 0.25f + 0.5f * (float)((Entity)entity).World.Rand.NextDouble(), (IPlayer)null, (Vec3f)null);
			if (useTimeNow >= useTime)
			{
				if (isEdible)
				{
					ITreeAttribute val = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
					if (val == null)
					{
						SyncedTreeAttribute watchedAttributes = ((Entity)entity).WatchedAttributes;
						TreeAttribute val2 = new TreeAttribute();
						val = (ITreeAttribute)val2;
						((TreeAttribute)watchedAttributes)["hunger"] = (IAttribute)val2;
					}
					if (doConsumePortion)
					{
						float num = 1f;
						val.SetFloat("saturation", num + val.GetFloat("saturation", 0f));
					}
				}
				entity.LeftHandItemSlot.TakeOut(1);
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			if (cancelled)
			{
				cooldownUntilTotalHours = 0.0;
			}
		}
	}
	public class AiTaskWander : AiTaskBase
	{
		public Vec3d MainTarget;

		private bool done;

		private float moveSpeed = 0.03f;

		private float wanderChance = 0.02f;

		private float maxHeight = 7f;

		private float? preferredLightLevel;

		private float targetDistance = 0.12f;

		private NatFloat wanderRangeHorizontal = NatFloat.createStrongerInvexp(3f, 40f);

		private NatFloat wanderRangeVertical = NatFloat.createStrongerInvexp(3f, 10f);

		public bool StayCloseToSpawn;

		public Vec3d SpawnPosition;

		public double MaxDistanceToSpawn;

		private long lastTimeInRangeMs;

		private int failedWanders;

		private bool needsToTele;

		private float tryStartAnimAgain = 0.1f;

		public float WanderRangeMul
		{
			get
			{
				return ((TreeAttribute)((Entity)entity).Attributes).GetFloat("wanderRangeMul", 1f);
			}
			set
			{
				((TreeAttribute)((Entity)entity).Attributes).SetFloat("wanderRangeMul", value);
			}
		}

		public int FailedConsecutivePathfinds
		{
			get
			{
				return ((TreeAttribute)((Entity)entity).Attributes).GetInt("failedConsecutivePathfinds", 0);
			}
			set
			{
				((TreeAttribute)((Entity)entity).Attributes).SetInt("failedConsecutivePathfinds", value);
			}
		}

		public AiTaskWander(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Expected O, but got Unknown
			float num = 3f;
			float num2 = 30f;
			if (taskConfig["maxDistanceToSpawn"].Exists)
			{
				StayCloseToSpawn = true;
				MaxDistanceToSpawn = taskConfig["maxDistanceToSpawn"].AsDouble(10.0);
				SpawnPosition = new Vec3d(((TreeAttribute)((Entity)entity).Attributes).GetDouble("spawnX", 0.0), ((TreeAttribute)((Entity)entity).Attributes).GetDouble("spawnY", 0.0), ((TreeAttribute)((Entity)entity).Attributes).GetDouble("spawnZ", 0.0));
				BlockPos blockPos = TreeAttributeUtil.GetBlockPos((ITreeAttribute)(object)((Entity)entity).WatchedAttributes, "importOffset", (BlockPos)null);
				if (blockPos != (BlockPos)null)
				{
					SpawnPosition.Add(blockPos);
				}
			}
			targetDistance = taskConfig["targetDistance"].AsFloat(0.12f);
			moveSpeed = taskConfig["movespeed"].AsFloat(0.03f);
			wanderChance = taskConfig["wanderChance"].AsFloat(0.02f);
			num = taskConfig["wanderRangeMin"].AsFloat(3f);
			num2 = taskConfig["wanderRangeMax"].AsFloat(30f);
			wanderRangeHorizontal = NatFloat.createInvexp(num, num2);
			maxHeight = taskConfig["maxHeight"].AsFloat(7f);
			preferredLightLevel = taskConfig["preferredLightLevel"].AsFloat(-99f);
			if (preferredLightLevel < 0f)
			{
				preferredLightLevel = null;
			}
		}

		public override void OnEntityLoaded()
		{
			if (StayCloseToSpawn && (SpawnPosition == (Vec3d)null || (SpawnPosition.X == 0.0 && SpawnPosition.Z == 0.0) || !((TreeAttribute)((Entity)entity).Attributes).HasAttribute("spawnX")))
			{
				OnEntitySpawn();
			}
		}

		public override void OnEntitySpawn()
		{
			((TreeAttribute)((Entity)entity).Attributes).SetDouble("spawnX", ((Entity)entity).ServerPos.X);
			((TreeAttribute)((Entity)entity).Attributes).SetDouble("spawnY", ((Entity)entity).ServerPos.Y);
			((TreeAttribute)((Entity)entity).Attributes).SetDouble("spawnZ", ((Entity)entity).ServerPos.Z);
			SpawnPosition = ((Entity)entity).ServerPos.XYZ;
		}

		public Vec3d loadNextWanderTarget()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Expected O, but got Unknown
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Expected O, but got Unknown
			//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e9: Expected I4, but got Unknown
			//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b6: Expected O, but got Unknown
			//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c0: Expected O, but got Unknown
			EnumHabitat habitat = ((Entity)entity).Properties.Habitat;
			int num = 9;
			Vec4d val = null;
			Vec4d val2 = new Vec4d();
			BlockPos val3 = new BlockPos(((Entity)entity).Pos.Dimension);
			if (FailedConsecutivePathfinds > 10)
			{
				WanderRangeMul = Math.Max(0.1f, WanderRangeMul * 0.9f);
			}
			else
			{
				WanderRangeMul = Math.Min(1f, WanderRangeMul * 1.1f);
				if (base.rand.NextDouble() < 0.05)
				{
					WanderRangeMul = Math.Min(1f, WanderRangeMul * 1.5f);
				}
			}
			float num2 = WanderRangeMul;
			if (base.rand.NextDouble() < 0.05)
			{
				num2 *= 3f;
			}
			while (num-- > 0)
			{
				double num3 = wanderRangeHorizontal.nextFloat() * (float)(base.rand.Next(2) * 2 - 1) * num2;
				double num4 = wanderRangeVertical.nextFloat() * (float)(base.rand.Next(2) * 2 - 1) * num2;
				double num5 = wanderRangeHorizontal.nextFloat() * (float)(base.rand.Next(2) * 2 - 1) * num2;
				val2.X = ((Entity)entity).ServerPos.X + num3;
				val2.Y = ((Entity)entity).ServerPos.InternalY + num4;
				val2.Z = ((Entity)entity).ServerPos.Z + num5;
				val2.W = 1.0;
				if (StayCloseToSpawn)
				{
					double num6 = (double)val2.SquareDistanceTo(SpawnPosition) / (MaxDistanceToSpawn * MaxDistanceToSpawn);
					val2.W = 1.0 - num6;
				}
				switch ((int)habitat)
				{
				case 2:
				{
					int rainMapHeightAt = world.BlockAccessor.GetRainMapHeightAt((int)val2.X, (int)val2.Z);
					val2.Y = Math.Min(val2.Y, (float)rainMapHeightAt + maxHeight);
					if (((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)val2.X, (int)val2.Y, (int)val2.Z, 2)).IsLiquid())
					{
						val2.W = 0.0;
					}
					break;
				}
				case 1:
				{
					val2.Y = moveDownToFloor((int)val2.X, val2.Y, (int)val2.Z);
					if (val2.Y < 0.0)
					{
						val2.W = 0.0;
						break;
					}
					if (((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)val2.X, (int)val2.Y, (int)val2.Z, 2)).IsLiquid())
					{
						val2.W /= 2.0;
					}
					bool stop = false;
					bool willFall = false;
					float num7 = (float)Math.Atan2(num3, num5) + (float)Math.PI / 2f;
					Vec3d val4 = val2.XYZ.Ahead(1.0, 0f, num7);
					Vec3d val5 = ((Entity)entity).ServerPos.XYZ.Ahead(1.0, 0f, num7);
					int prevY = (int)val5.Y;
					GameMath.BresenHamPlotLine2d((int)val5.X, (int)val5.Z, (int)val4.X, (int)val4.Z, (PlotDelegate2D)delegate(int x, int z)
					{
						if (!stop)
						{
							double num9 = moveDownToFloor(x, prevY, z);
							if (num9 < 0.0 || (double)prevY - num9 > 4.0)
							{
								willFall = true;
								stop = true;
							}
							if (num9 - (double)prevY > 2.0)
							{
								stop = true;
							}
							prevY = (int)num9;
						}
					});
					if (willFall)
					{
						val2.W = 0.0;
					}
					break;
				}
				case 0:
					if (!((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)val2.X, (int)val2.Y, (int)val2.Z, 2)).IsLiquid())
					{
						val2.W = 0.0;
					}
					break;
				case 3:
					if (!((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)val2.X, (int)val2.Y, (int)val2.Z, 2)).IsLiquid())
					{
						val2.W = 0.0;
					}
					else
					{
						val2.W = 1.0 / (Math.Abs(num4) + 1.0);
					}
					break;
				}
				if (val2.W > 0.0)
				{
					for (int num8 = 0; num8 < BlockFacing.HORIZONTALS.Length; num8++)
					{
						BlockFacing val6 = BlockFacing.HORIZONTALS[num8];
						if (((Entity)entity).World.BlockAccessor.IsSideSolid((int)val2.X + val6.Normali.X, (int)val2.Y, (int)val2.Z + val6.Normali.Z, val6.Opposite))
						{
							val2.W *= 0.5;
						}
					}
				}
				if (preferredLightLevel.HasValue && val2.W != 0.0)
				{
					val3.Set((int)val2.X, (int)val2.Y, (int)val2.Z);
					int val7 = Math.Abs((int)preferredLightLevel.Value - ((Entity)entity).World.BlockAccessor.GetLightLevel(val3, (EnumLightLevelType)2));
					val2.W /= (double)Math.Max(1, val7);
				}
				if (val == null || val2.W > val.W)
				{
					val = new Vec4d(val2.X, val2.Y, val2.Z, val2.W);
					if (val2.W >= 1.0)
					{
						break;
					}
				}
			}
			if (val.W > 0.0)
			{
				FailedConsecutivePathfinds = Math.Max(FailedConsecutivePathfinds - 3, 0);
				return val.XYZ;
			}
			FailedConsecutivePathfinds++;
			return null;
		}

		private double moveDownToFloor(int x, double y, int z)
		{
			int num = 5;
			while (num-- > 0)
			{
				if (world.BlockAccessor.IsSideSolid(x, (int)y, z, BlockFacing.UP))
				{
					return y + 1.0;
				}
				y -= 1.0;
			}
			return -1.0;
		}

		public override bool ShouldExecute()
		{
			if (base.rand.NextDouble() > (double)((failedWanders > 0) ? (1f - wanderChance * 4f * (float)failedWanders) : wanderChance))
			{
				failedWanders = 0;
				return false;
			}
			needsToTele = false;
			if (StayCloseToSpawn)
			{
				double num = ((Entity)entity).ServerPos.XYZ.SquareDistanceTo(SpawnPosition);
				long elapsedMilliseconds = ((Entity)entity).World.ElapsedMilliseconds;
				if (num > MaxDistanceToSpawn * MaxDistanceToSpawn)
				{
					if (elapsedMilliseconds - lastTimeInRangeMs > 120000 && ((Entity)entity).World.GetNearestEntity(((Entity)entity).ServerPos.XYZ, 15f, 15f, (ActionConsumable<Entity>)((Entity e) => e is EntityPlayer)) == null)
					{
						needsToTele = true;
					}
					MainTarget = SpawnPosition.Clone();
					return true;
				}
				lastTimeInRangeMs = elapsedMilliseconds;
			}
			MainTarget = loadNextWanderTarget();
			return MainTarget != (Vec3d)null;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			if (needsToTele && StayCloseToSpawn)
			{
				((Entity)entity).TeleportTo(SpawnPosition);
				done = true;
			}
			else
			{
				done = false;
				pathTraverser.WalkTowards(MainTarget, moveSpeed, targetDistance, OnGoalReached, OnStuck, (EnumAICreatureType)0);
				tryStartAnimAgain = 0.1f;
			}
		}

		public override bool ContinueExecute(float dt)
		{
			base.ContinueExecute(dt);
			if (!IsInValidDayTimeHours(initialRandomness: false))
			{
				return false;
			}
			if (animMeta != null && tryStartAnimAgain > 0f && (tryStartAnimAgain -= dt) <= 0f)
			{
				((Entity)entity).AnimManager.StartAnimation(animMeta);
			}
			if (entity.Controls.IsClimbing && ((Entity)entity).Properties.CanClimbAnywhere && ((Entity)entity).ClimbingIntoFace != null)
			{
				BlockFacing climbingIntoFace = ((Entity)entity).ClimbingIntoFace;
				if (Math.Sign(climbingIntoFace.Normali.X) == Math.Sign(pathTraverser.CurrentTarget.X - ((Entity)entity).ServerPos.X))
				{
					pathTraverser.CurrentTarget.X = ((Entity)entity).ServerPos.X;
				}
				if (Math.Sign(climbingIntoFace.Normali.Y) == Math.Sign(pathTraverser.CurrentTarget.Y - ((Entity)entity).ServerPos.Y))
				{
					pathTraverser.CurrentTarget.Y = ((Entity)entity).ServerPos.Y;
				}
				if (Math.Sign(climbingIntoFace.Normali.Z) == Math.Sign(pathTraverser.CurrentTarget.Z - ((Entity)entity).ServerPos.Z))
				{
					pathTraverser.CurrentTarget.Z = ((Entity)entity).ServerPos.Z;
				}
			}
			if ((double)MainTarget.HorizontalSquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Z) < 0.5)
			{
				pathTraverser.Stop();
				return false;
			}
			return !done;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			if (cancelled)
			{
				pathTraverser.Stop();
			}
		}

		private void OnStuck()
		{
			done = true;
			failedWanders++;
		}

		private void OnGoalReached()
		{
			done = true;
			failedWanders = 0;
		}
	}
	public class AiTaskJealousMeleeAttack : AiTaskMeleeAttack
	{
		private Entity guardedEntity;

		public AiTaskJealousMeleeAttack(EntityAgent entit, JsonObject taskConfig, JsonObject aiConfig)
			: base(entit, taskConfig, aiConfig)
		{
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() < 0.1)
			{
				guardedEntity = GetGuardedEntity();
			}
			if (guardedEntity == null)
			{
				return false;
			}
			return base.ShouldExecute();
		}

		public override bool IsTargetableEntity(Entity e, float range, bool ignoreEntityCode = false)
		{
			if (!base.IsTargetableEntity(e, range, ignoreEntityCode))
			{
				return false;
			}
			return e.GetBehavior<EntityBehaviorTaskAI>()?.TaskManager.AllTasks?.FirstOrDefault((IAiTask task) => task is AiTaskStayCloseToGuardedEntity aiTaskStayCloseToGuardedEntity && aiTaskStayCloseToGuardedEntity.guardedEntity == guardedEntity) != null;
		}
	}
	public class AiTaskJealousSeekEntity : AiTaskSeekEntity
	{
		private Entity guardedEntity;

		public AiTaskJealousSeekEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() < 0.1)
			{
				guardedEntity = GetGuardedEntity();
			}
			if (guardedEntity == null)
			{
				return false;
			}
			return base.ShouldExecute();
		}

		public override bool IsTargetableEntity(Entity e, float range, bool ignoreEntityCode = false)
		{
			if (!base.IsTargetableEntity(e, range, ignoreEntityCode))
			{
				return false;
			}
			return e.GetBehavior<EntityBehaviorTaskAI>()?.TaskManager.AllTasks?.FirstOrDefault((IAiTask task) => task is AiTaskStayCloseToGuardedEntity aiTaskStayCloseToGuardedEntity && aiTaskStayCloseToGuardedEntity.guardedEntity == guardedEntity) != null;
		}
	}
	public class AiTaskMeleeAttackTargetingEntity : AiTaskMeleeAttack
	{
		private Entity guardedEntity;

		private Entity lastattackingEntity;

		private long lastattackingEntityFoundMs;

		public AiTaskMeleeAttackTargetingEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() < 0.1)
			{
				guardedEntity = GetGuardedEntity();
			}
			if (guardedEntity == null)
			{
				return false;
			}
			if (((Entity)entity).World.ElapsedMilliseconds - lastattackingEntityFoundMs > 30000)
			{
				lastattackingEntity = null;
			}
			if (attackedByEntity == guardedEntity)
			{
				attackedByEntity = null;
			}
			return base.ShouldExecute();
		}

		public override void StartExecute()
		{
			base.StartExecute();
			lastattackingEntityFoundMs = ((Entity)entity).World.ElapsedMilliseconds;
			lastattackingEntity = targetEntity;
		}

		public override bool IsTargetableEntity(Entity e, float range, bool ignoreEntityCode = false)
		{
			if (!base.IsTargetableEntity(e, range, ignoreEntityCode))
			{
				return false;
			}
			if (e == guardedEntity)
			{
				return false;
			}
			IAiTask[] array = e.GetBehavior<EntityBehaviorTaskAI>()?.TaskManager.ActiveTasksBySlot;
			if (e != lastattackingEntity || !e.Alive)
			{
				return array?.FirstOrDefault((IAiTask task) => task is AiTaskBaseTargetable aiTaskBaseTargetable && aiTaskBaseTargetable.TargetEntity == guardedEntity && aiTaskBaseTargetable.AggressiveTargeting) != null;
			}
			return true;
		}
	}
	public class AiTaskSeekTargetingEntity : AiTaskSeekEntity
	{
		private Entity guardedEntity;

		private Entity lastattackingEntity;

		private long lastattackingEntityFoundMs;

		public AiTaskSeekTargetingEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			searchWaitMs = 1000;
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() < 0.1)
			{
				string text = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetString("guardedPlayerUid", (string)null);
				if (text != null)
				{
					IPlayer obj = ((Entity)entity).World.PlayerByUid(text);
					guardedEntity = (Entity)(object)((obj != null) ? obj.Entity : null);
				}
				else
				{
					long num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetLong("guardedEntityId", 0L);
					guardedEntity = ((Entity)entity).World.GetEntityById(num);
				}
			}
			if (guardedEntity == null)
			{
				return false;
			}
			if (((TreeAttribute)((Entity)entity).WatchedAttributes).GetBool("commandSit", false))
			{
				return false;
			}
			if (((Entity)entity).World.ElapsedMilliseconds - lastattackingEntityFoundMs > 30000)
			{
				lastattackingEntity = null;
			}
			return base.ShouldExecute();
		}

		public override void StartExecute()
		{
			base.StartExecute();
			lastattackingEntityFoundMs = ((Entity)entity).World.ElapsedMilliseconds;
			lastattackingEntity = targetEntity;
		}

		public override bool IsTargetableEntity(Entity e, float range, bool ignoreEntityCode = false)
		{
			if (!base.IsTargetableEntity(e, range, ignoreEntityCode))
			{
				return false;
			}
			IAiTask[] array = e.GetBehavior<EntityBehaviorTaskAI>()?.TaskManager.ActiveTasksBySlot;
			if (e != lastattackingEntity || !e.Alive)
			{
				return array?.FirstOrDefault((IAiTask task) => task is AiTaskBaseTargetable aiTaskBaseTargetable && aiTaskBaseTargetable.TargetEntity == guardedEntity && aiTaskBaseTargetable.AggressiveTargeting) != null;
			}
			return true;
		}
	}
	public class AiTaskStayCloseToGuardedEntity : AiTaskStayCloseToEntity
	{
		public Entity guardedEntity;

		public AiTaskStayCloseToGuardedEntity(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() < 0.1)
			{
				guardedEntity = GetGuardedEntity();
			}
			if (guardedEntity == null)
			{
				return false;
			}
			if (base.rand.NextDouble() > 0.10000000149011612)
			{
				return false;
			}
			if (((TreeAttribute)((Entity)entity).WatchedAttributes).GetBool("commandSit", false))
			{
				return false;
			}
			targetEntity = guardedEntity;
			double x = guardedEntity.ServerPos.X;
			double y = guardedEntity.ServerPos.Y;
			double z = guardedEntity.ServerPos.Z;
			return (double)((Entity)entity).ServerPos.SquareDistanceTo(x, y, z) > (double)(maxDistance * maxDistance);
		}

		public override void StartExecute()
		{
			base.StartExecute();
			float xSize = targetEntity.SelectionBox.XSize;
			pathTraverser.NavigateTo_Async(targetEntity.ServerPos.XYZ, moveSpeed, xSize + 0.2f, OnGoalReached, base.OnStuck, base.tryTeleport, 1000, 1);
			targetOffset.Set(((Entity)entity).World.Rand.NextDouble() * 2.0 - 1.0, 0.0, ((Entity)entity).World.Rand.NextDouble() * 2.0 - 1.0);
			stuck = false;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		public Entity GetGuardedEntity()
		{
			string text = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetString("guardedPlayerUid", (string)null);
			if (text != null)
			{
				IPlayer obj = ((Entity)entity).World.PlayerByUid(text);
				if (obj == null)
				{
					return null;
				}
				return (Entity)(object)obj.Entity;
			}
			long num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetLong("guardedEntityId", 0L);
			return ((Entity)entity).World.GetEntityById(num);
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskBaseTargetableConfig : AiTaskBaseConfig
	{
		[JsonProperty]
		public EnumEntitySearchType SearchType;

		[JsonProperty]
		public float SeekingRange = 25f;

		[JsonProperty]
		public float MinTargetWeight;

		[JsonProperty]
		public float MaxTargetWeight;

		[JsonProperty]
		private List<List<string>>? entityTags = new List<List<string>>();

		[JsonProperty]
		private List<List<string>>? skipEntityTags = new List<List<string>>();

		[JsonProperty]
		public bool ReverseTagsCheck;

		[JsonProperty]
		public bool ReverseSkipTagsCheck;

		[JsonProperty]
		private string[]? entityCodes = Array.Empty<string>();

		[JsonProperty]
		public AssetLocation[] SkipEntityCodes = Array.Empty<AssetLocation>();

		[JsonProperty]
		public float TamingGenerations = 10f;

		[JsonProperty]
		public bool UseFearReductionFactor;

		[JsonProperty]
		public bool SeekingRangeAffectedByPlayerStat = true;

		[JsonProperty]
		public float SneakRangeReduction = 1f;

		[JsonProperty]
		public string? TriggerEmotionState;

		[JsonProperty]
		public EnumCreatureHostility CreatureHostility;

		[JsonProperty]
		public bool IgnoreDeadEntities = true;

		[JsonProperty]
		public bool FriendlyTarget;

		[JsonProperty]
		public bool RetaliateAttacks = true;

		[JsonProperty]
		public bool TargetEntitiesWithSameHerdId;

		[JsonProperty]
		public bool TargetEntitiesWithDifferentHerdId;

		[JsonProperty]
		public bool TargetOnlyInteractableEntities = true;

		[JsonProperty]
		public int[] TargetLightLevels = new int[4] { 0, 0, 32, 32 };

		[JsonProperty]
		public EnumLightLevelType TargetLightLevelType = (EnumLightLevelType)3;

		[JsonProperty]
		public int TargetSearchCooldownMs = 2000;

		[JsonProperty]
		public bool TargetPlayerInAllGameModes;

		public EntityTagRule[] EntityTags = Array.Empty<EntityTagRule>();

		public EntityTagRule[] SkipEntityTags = Array.Empty<EntityTagRule>();

		public string[] TargetEntityCodesBeginsWith = Array.Empty<string>();

		public string[] TargetEntityCodesExact = Array.Empty<string>();

		public string TargetEntityFirstLetters = "";

		public bool NoEntityCodes
		{
			get
			{
				if (TargetEntityCodesExact.Length == 0)
				{
					return TargetEntityCodesBeginsWith.Length == 0;
				}
				return false;
			}
		}

		public bool NoTags
		{
			get
			{
				if (EntityTags.Length == 0)
				{
					return SkipEntityTags.Length == 0;
				}
				return false;
			}
		}

		public bool TargetEverything
		{
			get
			{
				if (NoEntityCodes && NoTags)
				{
					return NoEntityWeight;
				}
				return false;
			}
		}

		public bool NoEntityWeight
		{
			get
			{
				if (MaxTargetWeight <= 0f)
				{
					return MinTargetWeight <= 0f;
				}
				return false;
			}
		}

		public bool IgnoreTargetLightLevel
		{
			get
			{
				if (TargetLightLevels[0] == 0 && TargetLightLevels[1] == 0 && TargetLightLevels[2] == 32)
				{
					return TargetLightLevels[3] == 32;
				}
				return false;
			}
		}

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (entityTags != null)
			{
				EntityTags = ((IEnumerable<List<string>>)entityTags).Select((Func<List<string>, EntityTagRule>)((List<string> tagList) => new EntityTagRule(((Entity)entity).Api, (IEnumerable<string>)tagList))).ToArray();
				entityTags = null;
			}
			if (skipEntityTags != null)
			{
				SkipEntityTags = ((IEnumerable<List<string>>)skipEntityTags).Select((Func<List<string>, EntityTagRule>)((List<string> tagList) => new EntityTagRule(((Entity)entity).Api, (IEnumerable<string>)tagList))).ToArray();
				skipEntityTags = null;
			}
			if (entityCodes != null)
			{
				InitializeTargetCodes(entityCodes, out TargetEntityCodesExact, out TargetEntityCodesBeginsWith, out TargetEntityFirstLetters);
				entityCodes = null;
			}
			if (TargetLightLevels.Length != 4)
			{
				((Entity)entity).Api.Logger.Error($"Invalid 'targetLightLevels' value (array length: {TargetLightLevels.Length}, should be 4) in AI task '{Code}' for entity '{((RegistryObject)entity).Code}'");
				throw new ArgumentException($"Invalid 'targetLightLevels' value (array length: {TargetLightLevels.Length}, should be 4) in AI task '{Code}' for entity '{((RegistryObject)entity).Code}'");
			}
			if (TargetLightLevels[0] > TargetLightLevels[1] || TargetLightLevels[1] > TargetLightLevels[2] || TargetLightLevels[2] > TargetLightLevels[3])
			{
				((Entity)entity).Api.Logger.Error($"Invalid 'targetLightLevels' value: [{TargetLightLevels[0]},{TargetLightLevels[1]},{TargetLightLevels[2]},{TargetLightLevels[3]}], in AI task '{Code}' for entity '{((RegistryObject)entity).Code}'");
				throw new ArgumentException($"Invalid 'targetLightLevels' value: [{TargetLightLevels[0]},{TargetLightLevels[1]},{TargetLightLevels[2]},{TargetLightLevels[3]}], in AI task '{Code}' for entity '{((RegistryObject)entity).Code}'");
			}
		}

		protected static void InitializeTargetCodes(string[] codes, out string[] targetEntityCodesExact, out string[] targetEntityCodesBeginsWith, out string targetEntityFirstLetters)
		{
			List<string> list = new List<string>();
			List<string> list2 = new List<string>();
			targetEntityFirstLetters = "";
			foreach (string text in codes)
			{
				if (text.EndsWith('*'))
				{
					string text2 = text;
					list2.Add(text2.Substring(0, text2.Length - 1));
				}
				else
				{
					list.Add(text);
				}
			}
			targetEntityCodesBeginsWith = list2.ToArray();
			targetEntityCodesExact = new string[list.Count];
			int num = 0;
			foreach (string item in list)
			{
				if (item.Length != 0)
				{
					targetEntityCodesExact[num++] = item;
					char c = item[0];
					if (targetEntityFirstLetters.IndexOf(c) < 0)
					{
						targetEntityFirstLetters += c;
					}
				}
			}
			string[] array = targetEntityCodesBeginsWith;
			foreach (string text3 in array)
			{
				if (text3.Length == 0)
				{
					targetEntityFirstLetters = "";
					break;
				}
				char c2 = text3[0];
				if (targetEntityFirstLetters.IndexOf(c2) < 0)
				{
					targetEntityFirstLetters += c2;
				}
			}
		}
	}
	public abstract class AiTaskBaseTargetableR : AiTaskBaseR, IWorldIntersectionSupplier
	{
		protected Entity? targetEntity;

		protected long lastTargetSearchMs;

		private BlockSelection blockSel = new BlockSelection();

		private EntitySelection entitySel = new EntitySelection();

		private readonly Vec3d rayTraceFrom = new Vec3d();

		private readonly Vec3d rayTraceTo = new Vec3d();

		private readonly Vec3d tmpPos = new Vec3d();

		protected EntityBehaviorControlledPhysics? physicsBehavior;

		protected float stepHeight;

		public Entity? TargetEntity => targetEntity;

		public virtual bool AggressiveTargeting => true;

		public Vec3i MapSize => ((Entity)entity).World.BlockAccessor.MapSize;

		public IBlockAccessor blockAccessor => ((Entity)entity).World.BlockAccessor;

		protected bool RecentlySearchedForTarget => ((Entity)entity).World.ElapsedMilliseconds - lastTargetSearchMs < Config.TargetSearchCooldownMs;

		protected virtual string[] HostileEmotionStates => new string[2] { "aggressiveondamage", "aggressivearoundentities" };

		private AiTaskBaseTargetableConfig Config => GetConfig<AiTaskBaseTargetableConfig>();

		public Block GetBlock(BlockPos pos)
		{
			return ((Entity)entity).World.BlockAccessor.GetBlock(pos);
		}

		public Cuboidf[] GetBlockIntersectionBoxes(BlockPos pos)
		{
			return ((Entity)entity).World.BlockAccessor.GetBlock(pos).GetCollisionBoxes(((Entity)entity).World.BlockAccessor, pos);
		}

		public bool IsValidPos(BlockPos pos)
		{
			return ((Entity)entity).World.BlockAccessor.IsValidPos(pos);
		}

		public Entity[] GetEntitiesAround(Vec3d position, float horRange, float vertRange, ActionConsumable<Entity>? matches = null)
		{
			return Array.Empty<Entity>();
		}

		protected AiTaskBaseTargetableR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskBaseTargetableConfig>(entity, taskConfig, aiConfig);
			lastTargetSearchMs = ((Entity)entity).World.ElapsedMilliseconds - base.Rand.Next(Config.TargetSearchCooldownMs);
		}

		protected AiTaskBaseTargetableR(EntityAgent entity)
			: base(entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			partitionUtil = ((Entity)entity).Api.ModLoader.GetModSystem<EntityPartitioning>(true) ?? throw new ArgumentException("EntityPartitioning mod system is not found");
			AiTaskRegistry.TaskCodes.TryGetValue(GetType(), out string value);
			baseConfig = new AiTaskBaseTargetableConfig();
			baseConfig.Code = ((baseConfig.Code == "") ? (value ?? "") : baseConfig.Code);
			baseConfig.Init(entity);
		}

		public override void AfterInitialize()
		{
			base.AfterInitialize();
			physicsBehavior = ((Entity)entity).GetBehavior<EntityBehaviorControlledPhysics>();
		}

		public override void StartExecute()
		{
			stepHeight = physicsBehavior?.StepHeight ?? 0.6f;
			base.StartExecute();
			if (Config.TriggerEmotionState != null)
			{
				((Entity)entity).GetBehavior<EntityBehaviorEmotionStates>()?.TryTriggerState(Config.TriggerEmotionState, 1.0, targetEntity?.EntityId ?? 0);
			}
		}

		public virtual void ClearAttacker()
		{
			attackedByEntity = null;
			attackedByEntityMs = -2 * Config.RecentlyAttackedTimeoutMs;
		}

		protected virtual bool IsTargetableEntity(Entity target, float range)
		{
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			if (!target.Alive && Config.IgnoreDeadEntities)
			{
				return false;
			}
			if (!CheckTargetHerdId(target))
			{
				return false;
			}
			if (Config.TargetEverything)
			{
				return CanSense(target, range);
			}
			if (CheckTargetWeight(target.Properties.Weight) && CheckTargetTags(target.Tags))
			{
				return CanSense(target, range);
			}
			if (CheckTargetCodes(((RegistryObject)target).Code.Path))
			{
				return CanSense(target, range);
			}
			return false;
		}

		protected virtual bool CheckTargetHerdId(Entity target)
		{
			if (Config.TargetEntitiesWithSameHerdId)
			{
				EntityAgent val = entity;
				if (val != null)
				{
					EntityAgent val2 = (EntityAgent)(object)((target is EntityAgent) ? target : null);
					if (val2 != null && val.HerdId != 0L && val.HerdId != val2.HerdId)
					{
						return false;
					}
				}
			}
			if (Config.TargetEntitiesWithDifferentHerdId)
			{
				EntityAgent val3 = entity;
				if (val3 != null)
				{
					EntityAgent val4 = (EntityAgent)(object)((target is EntityAgent) ? target : null);
					if (val4 != null && val3.HerdId != 0L && val3.HerdId == val4.HerdId)
					{
						return false;
					}
				}
			}
			return true;
		}

		protected virtual bool CheckTargetWeight(float weight)
		{
			float num = ((((Entity)entity).Properties.Weight > 0f) ? (weight / ((Entity)entity).Properties.Weight) : float.MaxValue);
			if (Config.MinTargetWeight > 0f && num < Config.MinTargetWeight)
			{
				return false;
			}
			if (Config.MaxTargetWeight > 0f && num > Config.MaxTargetWeight)
			{
				return false;
			}
			return true;
		}

		protected virtual bool CheckTargetTags(EntityTagArray tags)
		{
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			if (Config.NoTags)
			{
				return false;
			}
			if (!Config.ReverseTagsCheck)
			{
				if (EntityTagRule.IntersectsWithEach(tags, Config.EntityTags))
				{
					if (Config.SkipEntityTags.Length == 0)
					{
						return true;
					}
					if (!Config.ReverseSkipTagsCheck)
					{
						if (!EntityTagRule.IntersectsWithEach(tags, Config.SkipEntityTags))
						{
							return true;
						}
					}
					else if (!EntityTagRule.ContainsAllFromAtLeastOne(tags, Config.SkipEntityTags))
					{
						return true;
					}
				}
			}
			else if (EntityTagRule.ContainsAllFromAtLeastOne(tags, Config.EntityTags))
			{
				if (Config.SkipEntityTags.Length == 0)
				{
					return true;
				}
				if (!Config.ReverseSkipTagsCheck)
				{
					if (!EntityTagRule.IntersectsWithEach(tags, Config.SkipEntityTags))
					{
						return true;
					}
				}
				else if (!EntityTagRule.ContainsAllFromAtLeastOne(tags, Config.SkipEntityTags))
				{
					return true;
				}
			}
			return false;
		}

		protected virtual bool CheckTargetCodes(string testPath)
		{
			if (Config.TargetEntityFirstLetters.Length == 0)
			{
				return false;
			}
			if (Config.TargetEntityFirstLetters.IndexOf(testPath[0]) < 0)
			{
				return false;
			}
			for (int i = 0; i < Config.TargetEntityCodesExact.Length; i++)
			{
				if (testPath == Config.TargetEntityCodesExact[i])
				{
					return true;
				}
			}
			for (int j = 0; j < Config.TargetEntityCodesBeginsWith.Length; j++)
			{
				if (StringUtil.StartsWithFast(testPath, Config.TargetEntityCodesBeginsWith[j]))
				{
					return true;
				}
			}
			return false;
		}

		protected virtual float GetTargetLightLevelRangeMultiplier(Entity target)
		{
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			if (Config.IgnoreTargetLightLevel)
			{
				return 1f;
			}
			int lightLevel = ((Entity)entity).World.BlockAccessor.GetLightLevel(target.Pos.AsBlockPos, Config.TargetLightLevelType);
			if (lightLevel <= Config.TargetLightLevels[0] || lightLevel >= Config.TargetLightLevels[3])
			{
				return 0f;
			}
			if (lightLevel >= Config.TargetLightLevels[1] && lightLevel <= Config.TargetLightLevels[2])
			{
				return 1f;
			}
			if (lightLevel <= Config.TargetLightLevels[1] && Config.TargetLightLevels[0] != Config.TargetLightLevels[1])
			{
				return (float)(lightLevel - Config.TargetLightLevels[0]) / (float)(Config.TargetLightLevels[1] - Config.TargetLightLevels[0]);
			}
			if (lightLevel >= Config.TargetLightLevels[2] && Config.TargetLightLevels[2] != Config.TargetLightLevels[3])
			{
				return 1f - (float)((lightLevel - Config.TargetLightLevels[2]) / (Config.TargetLightLevels[3] - Config.TargetLightLevels[2]));
			}
			return 1f;
		}

		protected virtual bool CanSense(Entity target, double range)
		{
			if (!target.Alive && Config.IgnoreDeadEntities)
			{
				return false;
			}
			if (target.EntityId == ((Entity)entity).EntityId || (!target.IsInteractable && Config.TargetOnlyInteractableEntities))
			{
				return false;
			}
			if (Config.SkipEntityCodes.Length != 0)
			{
				for (int i = 0; i < Config.SkipEntityCodes.Length; i++)
				{
					if (WildcardUtil.Match(Config.SkipEntityCodes[i], ((RegistryObject)target).Code))
					{
						return false;
					}
				}
			}
			EntityPlayer val = (EntityPlayer)(object)((target is EntityPlayer) ? target : null);
			if (val != null && !CanSensePlayer(val, range))
			{
				return false;
			}
			if (!CheckDetectionRange(target, range))
			{
				return false;
			}
			return true;
		}

		protected virtual bool CanSensePlayer(EntityPlayer target, double range)
		{
			if (!CheckEntityHostility(target))
			{
				return false;
			}
			if (!TargetablePlayerMode(target))
			{
				return false;
			}
			return true;
		}

		protected virtual bool CheckEntityHostility(EntityPlayer target)
		{
			if (!Config.FriendlyTarget && AggressiveTargeting)
			{
				return Config.CreatureHostility switch
				{
					EnumCreatureHostility.Aggressive => true, 
					EnumCreatureHostility.Passive => emotionStatesBehavior == null || !IsInEmotionState(HostileEmotionStates), 
					EnumCreatureHostility.NeverHostile => false, 
					_ => false, 
				};
			}
			return true;
		}

		protected virtual bool CheckDetectionRange(Entity target, double range)
		{
			if (((Entity)entity).ServerPos.Dimension != target.Pos.Dimension)
			{
				return false;
			}
			float detectionRangeMultiplier = GetDetectionRangeMultiplier(target);
			if (detectionRangeMultiplier <= 0f)
			{
				return false;
			}
			if (detectionRangeMultiplier != 1f && ((Entity)entity).ServerPos.DistanceTo(target.Pos) > range * (double)detectionRangeMultiplier)
			{
				return false;
			}
			return true;
		}

		protected virtual float GetDetectionRangeMultiplier(Entity target)
		{
			float num = 1f;
			if (!Config.IgnoreTargetLightLevel)
			{
				num *= GetTargetLightLevelRangeMultiplier(target);
			}
			EntityAgent val = (EntityAgent)(object)((target is EntityAgent) ? target : null);
			if (val != null && val.Controls.Sneak && target.OnGround && target.OnGround)
			{
				num *= Config.SneakRangeReduction;
			}
			if (Config.SeekingRangeAffectedByPlayerStat && target is EntityPlayer)
			{
				num *= target.Stats.GetBlended("animalSeekingRange");
			}
			return num;
		}

		protected virtual bool TargetablePlayerMode(EntityPlayer target)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Invalid comparison between Unknown and I4
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Invalid comparison between Unknown and I4
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Invalid comparison between Unknown and I4
			if (Config.TargetPlayerInAllGameModes)
			{
				return true;
			}
			IPlayer player = target.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			if (val != null)
			{
				if ((int)((IPlayer)val).WorldData.CurrentGameMode != 2 && (int)((IPlayer)val).WorldData.CurrentGameMode != 3)
				{
					if (val != null)
					{
						return (int)val.ConnectionState == 3;
					}
					return false;
				}
				return false;
			}
			return true;
		}

		protected virtual Entity? GetGuardedEntity()
		{
			string text = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetString("guardedPlayerUid", (string)null);
			if (text != null)
			{
				IPlayer obj = ((Entity)entity).World.PlayerByUid(text);
				if (obj == null)
				{
					return null;
				}
				return (Entity?)(object)obj.Entity;
			}
			long num = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetLong("guardedEntityId", 0L);
			if (num != 0L)
			{
				((Entity)entity).World.GetEntityById(num);
			}
			return null;
		}

		protected virtual bool IsNonAttackingPlayer(Entity target)
		{
			if (attackedByEntity == null || attackedByEntity.EntityId != target.EntityId)
			{
				return target is EntityPlayer;
			}
			return false;
		}

		protected virtual bool HasDirectContact(Entity targetEntity, float maxDistance, float maxVerticalDistance)
		{
			if (targetEntity.Pos.Dimension != ((Entity)entity).Pos.Dimension)
			{
				return false;
			}
			Cuboidd obj = targetEntity.SelectionBox.ToDouble().Translate(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
			tmpPos.Set(((Entity)entity).ServerPos).Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			double num = obj.ShortestDistanceFrom((IVec3)(object)tmpPos);
			double num2 = Math.Abs(obj.ShortestVerticalDistanceFrom(tmpPos.Y));
			if (num >= (double)maxDistance || num2 >= (double)maxVerticalDistance)
			{
				return false;
			}
			rayTraceFrom.Set(((Entity)entity).ServerPos);
			Vec3d obj2 = rayTraceFrom;
			obj2.Y += 1.0 / 32.0;
			rayTraceTo.Set(targetEntity.ServerPos);
			Vec3d obj3 = rayTraceTo;
			obj3.Y += 1.0 / 32.0;
			bool flag = false;
			((Entity)entity).World.RayTraceForSelection((IWorldIntersectionSupplier)(object)this, rayTraceFrom, rayTraceTo, ref blockSel, ref entitySel, (BlockFilter)null, (EntityFilter)null);
			flag = blockSel == null;
			if (!flag)
			{
				Vec3d obj4 = rayTraceFrom;
				obj4.Y += (double)(((Entity)entity).SelectionBox.Y2 * 7f / 16f);
				Vec3d obj5 = rayTraceTo;
				obj5.Y += (double)(targetEntity.SelectionBox.Y2 * 7f / 16f);
				((Entity)entity).World.RayTraceForSelection((IWorldIntersectionSupplier)(object)this, rayTraceFrom, rayTraceTo, ref blockSel, ref entitySel, (BlockFilter)null, (EntityFilter)null);
				flag = blockSel == null;
			}
			if (!flag)
			{
				Vec3d obj6 = rayTraceFrom;
				obj6.Y += (double)(((Entity)entity).SelectionBox.Y2 * 7f / 16f);
				Vec3d obj7 = rayTraceTo;
				obj7.Y += (double)(targetEntity.SelectionBox.Y2 * 7f / 16f);
				((Entity)entity).World.RayTraceForSelection((IWorldIntersectionSupplier)(object)this, rayTraceFrom, rayTraceTo, ref blockSel, ref entitySel, (BlockFilter)null, (EntityFilter)null);
				flag = blockSel == null;
			}
			if (!flag)
			{
				return false;
			}
			return true;
		}

		protected virtual float GetFearReductionFactor()
		{
			if (!Config.UseFearReductionFactor)
			{
				return 1f;
			}
			return Math.Max(0f, (Config.TamingGenerations - (float)GetOwnGeneration()) / Config.TamingGenerations);
		}

		protected virtual bool SearchForTarget()
		{
			float seekingRange = GetSeekingRange();
			targetEntity = partitionUtil.GetNearestEntity(((Entity)entity).ServerPos.XYZ, seekingRange, (Entity entity) => IsTargetableEntity(entity, seekingRange), Config.SearchType);
			return targetEntity != null;
		}

		protected virtual float GetSeekingRange()
		{
			float fearReductionFactor = GetFearReductionFactor();
			return Config.SeekingRange * fearReductionFactor;
		}

		protected virtual float GetAverageSize(Entity target)
		{
			return target.SelectionBox.XSize / 2f + ((Entity)entity).SelectionBox.XSize / 2f;
		}

		protected virtual bool CheckAndResetSearchCooldown()
		{
			if (RecentlySearchedForTarget)
			{
				return false;
			}
			lastTargetSearchMs = ((Entity)entity).World.ElapsedMilliseconds;
			return true;
		}

		protected virtual bool ShouldRetaliate()
		{
			if (Config.RetaliateAttacks && attackedByEntity != null && attackedByEntity.Alive && attackedByEntity.IsInteractable && CanSense(attackedByEntity, Config.SeekingRange))
			{
				return !entity.ToleratesDamageFrom(attackedByEntity);
			}
			return false;
		}

		protected virtual float MinDistanceToTarget(float extraDistance = 0f)
		{
			float num = ((Entity)entity).SelectionBox.XSize / 2f;
			Entity? obj = targetEntity;
			return num + ((obj != null) ? obj.SelectionBox.XSize : 0f) / 2f + extraDistance;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskBellAlarmConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public int SpawnRange = 12;

		[JsonProperty]
		public int SpawnIntervalMinMs = 1000;

		[JsonProperty]
		public int SpawnIntervalMaxMs = 5000;

		[JsonProperty]
		public int SpawnMaxQuantity = 6;

		[JsonProperty]
		public float PlayerScalingFactor = 1f;

		[JsonProperty]
		public float PlayerSpawnScaleRange = 15f;

		[JsonProperty]
		private AssetLocation[]? entitiesToSpawn = Array.Empty<AssetLocation>();

		[JsonProperty]
		public AssetLocation? RepeatSound;

		[JsonProperty]
		public string ListenAiTaskId = "listen";

		[JsonProperty]
		public float NotListeningRangeReduction = 0.5f;

		[JsonProperty]
		public float SilentSoundRangeReduction = 0.25f;

		[JsonProperty]
		public float QuietSoundRangeReduction = 0.5f;

		[JsonProperty]
		public float MaxDistanceToTarget = 20f;

		[JsonProperty]
		public string Origin = "bellalarm";

		public EntityProperties[] EntitiesToSpawn = Array.Empty<EntityProperties>();

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (entitiesToSpawn != null)
			{
				List<EntityProperties> list = new List<EntityProperties>();
				AssetLocation[] array = entitiesToSpawn;
				foreach (AssetLocation val in array)
				{
					EntityProperties entityType = ((Entity)entity).World.GetEntityType(val);
					if (entityType == null)
					{
						((Entity)entity).World.Logger.Warning($"AiTaskBellAlarm specified '{val}' in 'EntitiesToSpawn', but no such entity type found, will ignore.");
					}
					else
					{
						list.Add(entityType);
					}
				}
				EntitiesToSpawn = list.ToArray();
				entitiesToSpawn = null;
			}
			if (RepeatSound != (AssetLocation)null)
			{
				RepeatSound = RepeatSound.WithPathPrefixOnce("sounds/");
			}
		}
	}
	public class AiTaskBellAlarmR : AiTaskBaseTargetableR
	{
		protected int nextSpawnIntervalMs;

		protected List<Entity> spawnedEntities = new List<Entity>();

		protected float timeSinceLastSpawnSec;

		protected CollisionTester collisionTester = new CollisionTester();

		private AiTaskBellAlarmConfig Config => GetConfig<AiTaskBellAlarmConfig>();

		public AiTaskBellAlarmR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskBellAlarmConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			return SearchForTarget();
		}

		public override void StartExecute()
		{
			if (Config.RepeatSound != (AssetLocation)null)
			{
				ICoreAPI api = ((Entity)entity).Api;
				ICoreAPI obj = ((api is ICoreServerAPI) ? api : null);
				if (obj != null)
				{
					((ICoreServerAPI)obj).Network.BroadcastEntityPacket(((Entity)entity).EntityId, 1025, SerializerUtil.Serialize<AssetLocation>(Config.RepeatSound));
				}
			}
			nextSpawnIntervalMs = Config.SpawnIntervalMinMs + ((Entity)entity).World.Rand.Next(Config.SpawnIntervalMaxMs - Config.SpawnIntervalMinMs);
			base.StartExecute();
		}

		public override bool ContinueExecute(float dt)
		{
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (targetEntity == null)
			{
				return false;
			}
			timeSinceLastSpawnSec += dt;
			if (timeSinceLastSpawnSec * 1000f > (float)nextSpawnIntervalMs)
			{
				ICoreAPI api = ((Entity)entity).Api;
				ICoreServerAPI val = (ICoreServerAPI)(object)((api is ICoreServerAPI) ? api : null);
				if (val == null)
				{
					return false;
				}
				int num = ((Entity)entity).World.GetPlayersAround(((Entity)entity).ServerPos.XYZ, Config.PlayerSpawnScaleRange, Config.PlayerSpawnScaleRange, (ActionConsumable<IPlayer>)((IPlayer player) => ((Entity)player.Entity).Alive)).Length;
				float num2 = 1f + (float)(num - 1) * val.Server.Config.SpawnCapPlayerScaling * Config.PlayerScalingFactor;
				TrySpawnCreatures(GameMath.RoundRandom(base.Rand, (float)Config.SpawnMaxQuantity * num2 - 1f) + 1, Config.SpawnRange);
				nextSpawnIntervalMs = Config.SpawnIntervalMinMs + ((Entity)entity).World.Rand.Next(Config.SpawnIntervalMaxMs - Config.SpawnIntervalMinMs);
				timeSinceLastSpawnSec = 0f;
			}
			if (targetEntity.Pos.SquareDistanceTo(((Entity)entity).Pos) > Config.MaxDistanceToTarget * Config.MaxDistanceToTarget)
			{
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			ICoreAPI api = ((Entity)entity).Api;
			ICoreAPI obj = ((api is ICoreServerAPI) ? api : null);
			if (obj != null)
			{
				((ICoreServerAPI)obj).Network.BroadcastEntityPacket(((Entity)entity).EntityId, 1026, (byte[])null);
			}
			base.FinishExecute(cancelled);
		}

		public override void OnEntityDespawn(EntityDespawnData reason)
		{
			ICoreAPI api = ((Entity)entity).Api;
			ICoreAPI obj = ((api is ICoreServerAPI) ? api : null);
			if (obj != null)
			{
				((ICoreServerAPI)obj).Network.BroadcastEntityPacket(((Entity)entity).EntityId, 1026, (byte[])null);
			}
			base.OnEntityDespawn(reason);
		}

		protected virtual void TrySpawnCreatures(int maxQuantity, int range)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Expected O, but got Unknown
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Expected O, but got Unknown
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Expected O, but got Unknown
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			ICoreAPI api = ((Entity)entity).Api;
			ICoreServerAPI val = (ICoreServerAPI)(object)((api is ICoreServerAPI) ? api : null);
			if (val == null)
			{
				return;
			}
			FastVec3d val2 = default(FastVec3d);
			((FastVec3d)(ref val2))._002Ector(((Entity)entity).Pos.X, ((Entity)entity).Pos.Y, ((Entity)entity).Pos.Z);
			Vec3d val3 = new Vec3d();
			BlockPos val4 = new BlockPos(0);
			BlockPos val5 = new BlockPos(0);
			for (int i = 0; i < spawnedEntities.Count; i++)
			{
				if (spawnedEntities[i] == null || !spawnedEntities[i].Alive)
				{
					spawnedEntities.RemoveAt(i);
					i--;
				}
			}
			if (Config.EntitiesToSpawn.Length == 0 || spawnedEntities.Count > maxQuantity)
			{
				return;
			}
			int num = 50;
			int num2 = 0;
			while (num-- > 0 && num2 < 1)
			{
				int num3 = base.Rand.Next(Config.EntitiesToSpawn.Length);
				EntityProperties val6 = Config.EntitiesToSpawn[num3];
				int num4 = ((IWorldAccessor)val.World).Rand.Next(2 * range) - range;
				int num5 = ((IWorldAccessor)val.World).Rand.Next(2 * range) - range;
				int num6 = ((IWorldAccessor)val.World).Rand.Next(2 * range) - range;
				val3.Set((double)((int)val2.X + num4) + 0.5, (double)((int)val2.Y + num5) + 0.001, (double)((int)val2.Z + num6) + 0.5);
				val4.Set((int)val3.X, (int)val3.Y, (int)val3.Z);
				while (((CollectibleObject)PosUtil.GetBlockBelow(((IWorldAccessor)val.World).BlockAccessor, val4, 1, 0)).Id == 0 && val3.Y > 0.0)
				{
					val4.Y--;
					val3.Y -= 1.0;
				}
				val5.Set((int)val3.X, (int)val3.Y, (int)val3.Z);
				if (((IWorldAccessor)val.World).BlockAccessor.IsValidPos(val5))
				{
					Cuboidf val7 = val6.SpawnCollisionBox.OmniNotDownGrowBy(0.1f);
					if (!collisionTester.IsColliding(((IWorldAccessor)val.World).BlockAccessor, val7, val3, false))
					{
						DoSpawn(val6, val3, entity.HerdId);
						num2++;
					}
				}
			}
		}

		protected virtual void DoSpawn(EntityProperties entityType, Vec3d spawnPosition, long herdId)
		{
			Entity val = ((Entity)entity).Api.ClassRegistry.CreateEntity(entityType);
			EntityAgent val2 = (EntityAgent)(object)((val is EntityAgent) ? val : null);
			if (val2 != null)
			{
				val2.HerdId = herdId;
			}
			val.ServerPos.SetPosWithDimension(spawnPosition);
			val.ServerPos.SetYaw((float)base.Rand.NextDouble() * ((float)Math.PI * 2f));
			val.Pos.SetFrom(val.ServerPos);
			val.PositionBeforeFalling.Set(val.ServerPos.X, val.ServerPos.Y, val.ServerPos.Z);
			((TreeAttribute)val.Attributes).SetString("origin", Config.Origin);
			((Entity)entity).World.SpawnEntity(val);
			spawnedEntities.Add(val);
		}

		protected override bool CheckDetectionRange(Entity target, double range)
		{
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Invalid comparison between Unknown and I4
			if (!base.CheckDetectionRange(target, range))
			{
				return false;
			}
			EntityPlayer val = (EntityPlayer)(object)((target is EntityPlayer) ? target : null);
			if (val == null)
			{
				return true;
			}
			double num = target.Pos.DistanceTo(((Entity)entity).Pos.XYZ);
			bool flag = ((EntityAgent)val).ServerControls.LeftMouseDown || ((EntityAgent)val).ServerControls.RightMouseDown || (int)((EntityAgent)val).ServerControls.HandUse > 0;
			bool flag2 = ((EntityAgent)val).ServerControls.TriesToMove || ((EntityAgent)val).ServerControls.Jump || !((Entity)val).OnGround;
			bool num2 = !flag && !flag2;
			bool flag3 = ((EntityAgent)val).ServerControls.Sneak && !((EntityAgent)val).ServerControls.Jump && ((Entity)val).OnGround && !flag;
			if (num2)
			{
				range *= (double)Config.SilentSoundRangeReduction;
			}
			else if (flag3)
			{
				range *= (double)Config.QuietSoundRangeReduction;
			}
			return num <= range;
		}

		protected override float GetSeekingRange()
		{
			float num = base.GetSeekingRange();
			if (!((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().TaskManager.IsTaskActive(Config.ListenAiTaskId))
			{
				num *= Config.NotListeningRangeReduction;
			}
			return num;
		}
	}
	public class AiTaskComeToOwnerR : AiTaskStayCloseToEntityR
	{
		public Entity? TargetOwner
		{
			get
			{
				return targetEntity;
			}
			set
			{
				targetEntity = value;
			}
		}

		public AiTaskComeToOwnerR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("ownedby");
			if (treeAttribute == null)
			{
				return false;
			}
			string text = treeAttribute.GetString("uid", (string)null);
			if (text == null)
			{
				return false;
			}
			IPlayer obj = ((Entity)entity).World.PlayerByUid(text);
			targetEntity = (Entity?)(object)((obj != null) ? obj.Entity : null);
			if (targetEntity == null)
			{
				return false;
			}
			return CanSense(targetEntity, GetSeekingRange());
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskEatHeldItemConfig : AiTaskBaseConfig
	{
		[JsonProperty]
		public float DurationSec = 1.5f;

		[JsonProperty]
		public float ChanceToUseFoodWithoutEating = 0.004f;

		[JsonProperty]
		public CreatureDiet? Diet;

		[JsonProperty]
		public bool ConsumePortion = true;

		[JsonProperty]
		public float SaturationPerPortion = 1f;

		[JsonProperty]
		public EnumHand HandToEatFrom;

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (Diet == null)
			{
				Diet = ((Entity)entity).Properties.Attributes["creatureDiet"].AsObject<CreatureDiet>((CreatureDiet)null);
			}
			if (Diet == null)
			{
				((Entity)entity).Api.Logger.Warning("Creature '" + ((RegistryObject)entity).Code.ToShortString() + "' has AiTaskUseInventory task but no Diet specified.");
			}
		}
	}
	public class AiTaskEatHeldItemR : AiTaskBaseR
	{
		protected float currentUseTime;

		protected bool soundPlayed;

		protected bool isEdible;

		protected EntityBehaviorMultiplyBase? multiplyBehavior;

		private AiTaskEatHeldItemConfig Config => GetConfig<AiTaskEatHeldItemConfig>();

		public AiTaskEatHeldItemR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskEatHeldItemConfig>(entity, taskConfig, aiConfig);
		}

		public override void AfterInitialize()
		{
			base.AfterInitialize();
			multiplyBehavior = ((Entity)entity).GetBehavior<EntityBehaviorMultiplyBase>();
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			if (multiplyBehavior != null && !multiplyBehavior.ShouldEat && ((Entity)entity).World.Rand.NextDouble() >= (double)Config.ChanceToUseFoodWithoutEating)
			{
				return false;
			}
			ItemSlot slot = GetSlot();
			if (slot == null || slot.Empty)
			{
				return false;
			}
			ItemStack itemstack = slot.Itemstack;
			if (itemstack == null)
			{
				return false;
			}
			if (!SuitableFoodSource(itemstack))
			{
				if (!slot.Empty)
				{
					((Entity)entity).World.SpawnItemEntity(slot.TakeOutWhole(), ((Entity)entity).ServerPos.XYZ, (Vec3d)null);
				}
				return false;
			}
			isEdible = true;
			return true;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			soundPlayed = false;
			currentUseTime = 0f;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Expected O, but got Unknown
			//IL_00d7: Expected O, but got Unknown
			base.ContinueExecute(dt);
			currentUseTime += dt;
			ItemSlot slot = GetSlot();
			if (slot == null || slot.Empty)
			{
				return false;
			}
			((Entity)entity).World.SpawnCubeParticles(((Entity)entity).ServerPos.XYZ, slot.Itemstack, 0.25f, 1, 0.25f + 0.5f * (float)((Entity)entity).World.Rand.NextDouble(), (IPlayer)null, (Vec3f)null);
			if (currentUseTime >= Config.DurationSec)
			{
				if (isEdible && Config.ConsumePortion)
				{
					ITreeAttribute val = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
					if (val == null)
					{
						SyncedTreeAttribute watchedAttributes = ((Entity)entity).WatchedAttributes;
						TreeAttribute val2 = new TreeAttribute();
						val = (ITreeAttribute)val2;
						((TreeAttribute)watchedAttributes)["hunger"] = (IAttribute)val2;
					}
					val.SetFloat("saturation", Config.SaturationPerPortion + val.GetFloat("saturation", 0f));
				}
				slot.TakeOut(1);
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			if (cancelled)
			{
				cooldownUntilTotalHours = 0.0;
			}
		}

		protected virtual bool SuitableFoodSource(ItemStack itemStack)
		{
			return Config.Diet?.Matches(itemStack) ?? true;
		}

		protected virtual ItemSlot? GetSlot()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			EnumHand handToEatFrom = Config.HandToEatFrom;
			if ((int)handToEatFrom != 0)
			{
				if ((int)handToEatFrom == 1)
				{
					return entity.RightHandItemSlot;
				}
				return null;
			}
			return entity.LeftHandItemSlot;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskFleeEntityConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public float MoveSpeed = 0.02f;

		[JsonProperty]
		public bool IgnoreDeepDayLight;

		[JsonProperty]
		public float FleeingDistance;

		[JsonProperty]
		public int FleeDurationMs = 9000;

		[JsonProperty]
		public int FleeDurationWhenTargetLost = 5000;

		[JsonProperty]
		public float InstaFleeOnDamageChance;

		[JsonProperty]
		public bool SpawnCloserDuringLowStability;

		[JsonProperty]
		public float FleeDistanceReductionIfToleratesDamage = 0.5f;

		[JsonProperty]
		public float ChanceToAdjustDirection = 0.2f;

		[JsonProperty]
		public float ChanceToCheckLightLevel = 0.25f;

		[JsonProperty]
		public float SoundChanceRestoreRate = 0.002f;

		[JsonProperty]
		public float SoundChanceDecreaseRate = 0.2f;

		[JsonProperty]
		public float SoundChanceMinimum = 0.25f;

		[JsonProperty]
		public float RequiredTemporalStability = 0.25f;

		[JsonProperty]
		public float DeepDayLightLevelOffset = -2f;

		public bool LowStabilityAttracted;

		public float FleeSeekRangeDifference = 15f;

		public float MaxSoundChance;

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (FleeingDistance <= 0f)
			{
				FleeingDistance = SeekingRange + FleeSeekRangeDifference;
			}
			MaxSoundChance = SoundChance;
			FleeSeekRangeDifference = FleeingDistance - SeekingRange;
			int lowStabilityAttracted;
			if (StringUtil.ToBool(((Entity)entity).World.Config.GetString("temporalStability", (string)null), true))
			{
				JsonObject attributes = ((Entity)entity).Properties.Attributes;
				if (attributes != null)
				{
					JsonObject obj = attributes["spawnCloserDuringLowStability"];
					if (((obj != null) ? new bool?(obj.AsBool(false)) : ((bool?)null)) == true)
					{
						lowStabilityAttracted = 1;
						goto IL_00b1;
					}
				}
				lowStabilityAttracted = (SpawnCloserDuringLowStability ? 1 : 0);
			}
			else
			{
				lowStabilityAttracted = 0;
			}
			goto IL_00b1;
			IL_00b1:
			LowStabilityAttracted = (byte)lowStabilityAttracted != 0;
		}
	}
	public class AiTaskFleeEntityR : AiTaskBaseTargetableR
	{
		protected Vec3d targetPos = new Vec3d();

		protected Vec3d ownPos = new Vec3d();

		protected float targetYaw;

		protected long fleeStartMs;

		protected bool stuck;

		protected float currentFleeingDistance;

		protected bool instaFleeNow;

		protected const float minimumPathTraversalTolerance = 0.5f;

		private readonly Vec3d tmpVec3 = new Vec3d();

		private readonly Vec3d tmpVec2 = new Vec3d();

		private readonly Vec3d tmpVec1 = new Vec3d();

		public override bool AggressiveTargeting => false;

		private AiTaskFleeEntityConfig Config => GetConfig<AiTaskFleeEntityConfig>();

		public AiTaskFleeEntityR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskFleeEntityConfig>(entity, taskConfig, aiConfig);
		}

		public virtual void InstaFleeFrom(Entity fromEntity)
		{
			instaFleeNow = true;
			targetEntity = fromEntity;
		}

		public override bool ShouldExecute()
		{
			Config.SoundChance = Math.Min(Config.MaxSoundChance, Config.SoundChance + Config.SoundChanceRestoreRate);
			if (instaFleeNow)
			{
				return TryInstaFlee();
			}
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			ownPos.SetWithDimension(((Entity)entity).ServerPos);
			float adjustedRange = ((Config.WhenInEmotionState != null) ? 1f : GetFearReductionFactor()) * Config.SeekingRange;
			((Entity)entity).World.FrameProfiler.Mark("task-fleeentity-shouldexecute-init");
			if (Config.LowStabilityAttracted)
			{
				ref Entity? reference = ref targetEntity;
				Entity nearestEntity = partitionUtil.GetNearestEntity(ownPos, adjustedRange, delegate(Entity entity)
				{
					if (!(entity is EntityAgent))
					{
						return false;
					}
					if (!IsTargetableEntity(entity, adjustedRange))
					{
						return false;
					}
					return !(entity is EntityPlayer) || ((TreeAttribute)entity.WatchedAttributes).GetDouble("temporalStability", 1.0) > (double)Config.RequiredTemporalStability;
				}, Config.SearchType);
				reference = ((nearestEntity is EntityAgent) ? nearestEntity : null);
			}
			else
			{
				targetEntity = partitionUtil.GetNearestEntity(ownPos, adjustedRange, (Entity entity) => IsTargetableEntity(entity, adjustedRange), Config.SearchType);
			}
			currentFleeingDistance = Config.FleeingDistance;
			((Entity)entity).World.FrameProfiler.Mark("task-fleeentity-shouldexecute-entitysearch");
			if (targetEntity != null)
			{
				if (entity.ToleratesDamageFrom(targetEntity))
				{
					currentFleeingDistance *= Config.FleeDistanceReductionIfToleratesDamage;
				}
				currentFleeingDistance += (((Entity)entity).SelectionBox.XSize + targetEntity.SelectionBox.XSize) / 2f;
				float yaw = (float)Math.Atan2(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X, targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z);
				UpdateTargetPosFleeMode(targetPos, yaw);
				return true;
			}
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			Config.SoundChance = Math.Max(Config.SoundChanceMinimum, Config.SoundChance - Config.SoundChanceDecreaseRate);
			float targetDistance = Math.Max(0.5f, ((Entity)entity).SelectionBox.XSize / 2f);
			pathTraverser.WalkTowards(targetPos, Config.MoveSpeed, targetDistance, OnGoalReached, OnStuck, (EnumAICreatureType)0);
			fleeStartMs = ((Entity)entity).World.ElapsedMilliseconds;
			stuck = false;
		}

		public override bool ContinueExecute(float dt)
		{
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (world.Rand.NextDouble() <= (double)Config.ChanceToAdjustDirection)
			{
				float yaw = ((targetEntity == null) ? (0f - targetYaw) : ((float)Math.Atan2(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X, targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z)));
				tmpVec3.Set(targetPos);
				UpdateTargetPosFleeMode(tmpVec3, yaw);
				pathTraverser.CurrentTarget.X = tmpVec3.X;
				pathTraverser.CurrentTarget.Y = tmpVec3.Y;
				pathTraverser.CurrentTarget.Z = tmpVec3.Z;
				pathTraverser.Retarget();
			}
			if (targetEntity != null && ((Entity)entity).ServerPos.SquareDistanceTo(targetEntity.ServerPos) > currentFleeingDistance * currentFleeingDistance)
			{
				return false;
			}
			if (targetEntity == null && ((Entity)entity).World.ElapsedMilliseconds - fleeStartMs > Config.FleeDurationWhenTargetLost)
			{
				return false;
			}
			if (world.Rand.NextDouble() < (double)Config.ChanceToCheckLightLevel)
			{
				return CheckEntityLightLevel();
			}
			if (!stuck && (targetEntity == null || targetEntity.Alive) && ((Entity)entity).World.ElapsedMilliseconds - fleeStartMs < Config.FleeDurationMs)
			{
				return pathTraverser.Active;
			}
			return false;
		}

		public override void FinishExecute(bool cancelled)
		{
			pathTraverser.Stop();
			base.FinishExecute(cancelled);
		}

		public override void OnEntityHurt(DamageSource source, float damage)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Invalid comparison between Unknown and I4
			base.OnEntityHurt(source, damage);
			if ((int)source.Type != 6 && ((Entity)entity).World.Rand.NextDouble() < (double)Config.InstaFleeOnDamageChance)
			{
				instaFleeNow = true;
				targetEntity = source.GetCauseEntity();
			}
		}

		protected override bool CheckEntityLightLevel()
		{
			if (((TreeAttribute)((Entity)entity).Attributes).GetBool("ignoreDaylightFlee", false))
			{
				return false;
			}
			if (Config.IgnoreDeepDayLight && ((Entity)entity).ServerPos.Y < (double)((float)world.SeaLevel + Config.DeepDayLightLevelOffset))
			{
				return false;
			}
			return base.CheckEntityLightLevel();
		}

		protected virtual bool TryInstaFlee()
		{
			if (targetEntity == null || ((Entity)entity).ServerPos.DistanceTo(targetEntity.ServerPos) > (double)Config.SeekingRange)
			{
				float num = GameMath.Cos(((Entity)entity).ServerPos.Yaw);
				float num2 = GameMath.Sin(((Entity)entity).ServerPos.Yaw);
				double num3 = 200.0;
				targetPos.Set(((Entity)entity).ServerPos.X + (double)num2 * num3, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z + (double)num * num3);
				targetYaw = ((Entity)entity).ServerPos.Yaw;
				targetEntity = null;
			}
			else
			{
				currentFleeingDistance = (float)((Entity)entity).ServerPos.DistanceTo(targetEntity.ServerPos) + Config.FleeSeekRangeDifference;
				if (entity.ToleratesDamageFrom(targetEntity))
				{
					currentFleeingDistance /= Config.FleeDistanceReductionIfToleratesDamage;
				}
				UpdateTargetPosFleeMode(targetPos, ((Entity)entity).ServerPos.Yaw);
			}
			instaFleeNow = false;
			return true;
		}

		protected virtual void OnStuck()
		{
			stuck = true;
		}

		protected virtual void OnGoalReached()
		{
			pathTraverser.Retarget();
		}

		protected void UpdateTargetPosFleeMode(Vec3d targetPos, float yaw)
		{
			tmpVec1.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec1.Ahead(0.9, 0f, yaw);
			if (Traversable(tmpVec1))
			{
				targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw);
				return;
			}
			tmpVec1.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec1.Ahead(0.9, 0f, yaw - (float)Math.PI / 2f);
			if (Traversable(tmpVec1))
			{
				targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw - (float)Math.PI / 2f);
				return;
			}
			tmpVec1.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec1.Ahead(0.9, 0f, yaw + (float)Math.PI / 2f);
			if (Traversable(tmpVec1))
			{
				targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw + (float)Math.PI / 2f);
				return;
			}
			tmpVec1.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z);
			tmpVec1.Ahead(0.9, 0f, yaw + (float)Math.PI);
			targetPos.Set(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(10.0, 0f, yaw + (float)Math.PI);
		}

		protected bool Traversable(Vec3d pos)
		{
			if (world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, pos, false))
			{
				return !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, tmpVec2.Set(pos).Add(0.0, (double)Math.Min(1f, stepHeight), 0.0), false);
			}
			return true;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskGetOutOfWaterConfig : AiTaskBaseConfig
	{
		[JsonProperty]
		public float MoveSpeed = 0.06f;

		[JsonProperty]
		public int MinimumRangeToSeekLand = 50;

		[JsonProperty]
		public float RangeSearchAttemptsFactor = 2f;

		[JsonProperty]
		public float ChanceToStopTask = 0.1f;
	}
	public class AiTaskGetOutOfWaterR : AiTaskBaseR
	{
		protected Vec3d target = new Vec3d();

		protected bool done;

		protected int searchAttempts;

		protected const float minimumRangeOffset = 0.6f;

		protected const int triesPerAttempt = 10;

		private readonly Vec3d tmpPos = new Vec3d();

		private readonly BlockPos pos = new BlockPos(0);

		private AiTaskGetOutOfWaterConfig Config => GetConfig<AiTaskGetOutOfWaterConfig>();

		public AiTaskGetOutOfWaterR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskGetOutOfWaterConfig>(entity, taskConfig, aiConfig);
			Config.WhenSwimming = true;
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			int num = GameMath.Min(Config.MinimumRangeToSeekLand, (int)((float)Config.MinimumRangeToSeekLand * 0.6f + (float)searchAttempts * Config.RangeSearchAttemptsFactor));
			target.Y = ((Entity)entity).ServerPos.Y;
			int num2 = 10;
			int num3 = (int)((Entity)entity).ServerPos.X;
			int num4 = (int)((Entity)entity).ServerPos.Z;
			IBlockAccessor blockAccessor = ((Entity)entity).World.BlockAccessor;
			while (num2-- > 0)
			{
				pos.X = num3 + base.Rand.Next(num + 1) - num / 2;
				pos.Z = num4 + base.Rand.Next(num + 1) - num / 2;
				pos.Y = blockAccessor.GetTerrainMapheightAt(pos) + 1;
				if (!((CollectibleObject)blockAccessor.GetBlock(pos, 2)).IsLiquid() && !((Entity)entity).World.CollisionTester.IsColliding(blockAccessor, ((Entity)entity).CollisionBox, tmpPos.Set((double)pos.X + 0.5, (double)((float)pos.Y + 0.1f), (double)pos.Z + 0.5), true) && ((Entity)entity).World.CollisionTester.IsColliding(blockAccessor, ((Entity)entity).CollisionBox, tmpPos.Set((double)pos.X + 0.5, (double)((float)pos.Y - 0.1f), (double)pos.Z + 0.5), true))
				{
					target.Set((double)pos.X + 0.5, (double)(pos.Y + 1), (double)pos.Z + 0.5);
					return true;
				}
			}
			searchAttempts++;
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			searchAttempts = 0;
			done = false;
			pathTraverser.WalkTowards(target, Config.MoveSpeed, 0.5f, OnGoalReached, OnStuck, (EnumAICreatureType)0);
		}

		public override bool ContinueExecute(float dt)
		{
			if (base.Rand.NextDouble() < (double)Config.ChanceToStopTask && !((Entity)entity).FeetInLiquid)
			{
				return false;
			}
			return !done;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			pathTraverser.Stop();
		}

		protected virtual void OnStuck()
		{
			done = true;
		}

		protected virtual void OnGoalReached()
		{
			done = true;
		}
	}
	public class AiTaskGotoEntityConversable : AiTaskBaseR
	{
		protected bool stuck;

		protected float currentFollowTime;

		protected string animationCode = "walk";

		public Entity TargetEntity { get; }

		public float MoveSpeed { get; set; } = 0.02f;

		public float SeekingRange { get; set; } = 25f;

		public float MaxFollowTime { get; set; } = 60f;

		public float AllowedExtraDistance { get; set; }

		public bool Finished => !pathTraverser.Ready;

		public AiTaskGotoEntityConversable(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			world.Logger.Error("This AI task 'AiTaskGotoEntityConversable' can only be created from code.");
			throw new InvalidOperationException("This AI task can only be created from code.");
		}

		public AiTaskGotoEntityConversable(EntityAgent entity, Entity target)
			: base(entity)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			TargetEntity = target;
			baseConfig.AnimationMeta = new AnimationMetaData
			{
				Code = animationCode,
				Animation = animationCode,
				AnimationSpeed = 1f
			}.Init();
		}

		public override bool ShouldExecute()
		{
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			stuck = false;
			pathTraverser.NavigateTo_Async(TargetEntity.ServerPos.XYZ, MoveSpeed, MinDistanceToTarget(), OnGoalReached, OnStuck, null, 999);
			currentFollowTime = 0f;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		public override bool ContinueExecute(float dt)
		{
			currentFollowTime += dt;
			pathTraverser.CurrentTarget.X = TargetEntity.ServerPos.X;
			pathTraverser.CurrentTarget.Y = TargetEntity.ServerPos.Y;
			pathTraverser.CurrentTarget.Z = TargetEntity.ServerPos.Z;
			Cuboidd obj = TargetEntity.SelectionBox.ToDouble().Translate(TargetEntity.ServerPos.X, TargetEntity.ServerPos.Y, TargetEntity.ServerPos.Z);
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			double num = obj.ShortestDistanceFrom((IVec3)(object)val);
			float num2 = MinDistanceToTarget();
			if (currentFollowTime < MaxFollowTime && num < (double)(SeekingRange * SeekingRange) && num > (double)num2)
			{
				return !stuck;
			}
			return false;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			pathTraverser.Stop();
		}

		public virtual bool TargetReached()
		{
			Cuboidd obj = TargetEntity.SelectionBox.ToDouble().Translate(TargetEntity.ServerPos.X, TargetEntity.ServerPos.Y, TargetEntity.ServerPos.Z);
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			double num = obj.ShortestDistanceFrom((IVec3)(object)val);
			float num2 = MinDistanceToTarget();
			return num < (double)num2;
		}

		protected virtual void OnStuck()
		{
			stuck = true;
		}

		protected virtual void OnGoalReached()
		{
			pathTraverser.Active = true;
		}

		protected virtual float MinDistanceToTarget()
		{
			return AllowedExtraDistance + Math.Max(0.8f, TargetEntity.SelectionBox.XSize / 2f + ((Entity)entity).SelectionBox.XSize / 2f);
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskIdleConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public bool StopWhenTargetDetected;

		[JsonProperty]
		private string[]? allowedBlockBelowTags = Array.Empty<string>();

		[JsonProperty]
		private string[]? skipBlockBelowTags = Array.Empty<string>();

		[JsonProperty]
		public AssetLocation? AllowedBlockBelowCode;

		[JsonProperty]
		public bool CheckForSolidUpSide = true;

		[JsonProperty]
		public int MinBlockInsideReplaceable = 6000;

		[JsonProperty]
		public float ChanceToCheckTarget = 0.3f;

		public BlockTagRule AllowedBlockBelowTags;

		public BlockTagRule SkipBlockBelowTags;

		public bool IgnoreBlockCodeAndTags
		{
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				if (AllowedBlockBelowTags == BlockTagRule.Empty && SkipBlockBelowTags == BlockTagRule.Empty)
				{
					return AllowedBlockBelowCode == (AssetLocation)null;
				}
				return false;
			}
		}

		public override void Init(EntityAgent entity)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			base.Init(entity);
			if (allowedBlockBelowTags != null)
			{
				AllowedBlockBelowTags = new BlockTagRule(((Entity)entity).Api, (IEnumerable<string>)allowedBlockBelowTags);
				allowedBlockBelowTags = null;
			}
			if (skipBlockBelowTags != null)
			{
				SkipBlockBelowTags = new BlockTagRule(((Entity)entity).Api, (IEnumerable<string>)skipBlockBelowTags);
				skipBlockBelowTags = null;
			}
		}
	}
	public class AiTaskIdleR : AiTaskBaseTargetableR
	{
		private AiTaskIdleConfig Config => GetConfig<AiTaskIdleConfig>();

		public AiTaskIdleR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskIdleConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			if (CheckForTargetToStop())
			{
				return false;
			}
			if (!CheckForBlockBelow())
			{
				return false;
			}
			return true;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			((Entity)entity).IdleSoundChanceModifier = 0f;
		}

		public override bool ContinueExecute(float dt)
		{
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (base.Rand.NextDouble() <= (double)Config.ChanceToCheckTarget && CheckForTargetToStop())
			{
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			((Entity)entity).IdleSoundChanceModifier = 1f;
		}

		protected virtual bool CheckForTargetToStop()
		{
			if (!Config.StopWhenTargetDetected)
			{
				return false;
			}
			if (!CheckAndResetSearchCooldown())
			{
				return false;
			}
			return SearchForTarget();
		}

		protected virtual bool CheckForBlockBelow()
		{
			Block blockRaw = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)((Entity)entity).ServerPos.X, (int)((Entity)entity).ServerPos.InternalY - 1, (int)((Entity)entity).ServerPos.Z, 1);
			if (Config.CheckForSolidUpSide && !((SmallBoolArray)(ref blockRaw.SideSolid))[BlockFacing.UP.Index])
			{
				return false;
			}
			if (Config.IgnoreBlockCodeAndTags)
			{
				return true;
			}
			Block blockRaw2 = ((Entity)entity).World.BlockAccessor.GetBlockRaw((int)((Entity)entity).ServerPos.X, (int)((Entity)entity).ServerPos.InternalY, (int)((Entity)entity).ServerPos.Z, 0);
			if (blockRaw2.Replaceable >= Config.MinBlockInsideReplaceable)
			{
				return CheckForBlock(blockRaw);
			}
			return CheckForBlock(blockRaw2);
		}

		protected virtual bool CheckForBlock(Block block)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			if (Config.IgnoreBlockCodeAndTags)
			{
				return true;
			}
			if (Config.AllowedBlockBelowTags != BlockTagRule.Empty && !((BlockTagRule)(ref Config.AllowedBlockBelowTags)).Intersects(block.Tags))
			{
				return false;
			}
			if (Config.SkipBlockBelowTags != BlockTagRule.Empty && ((BlockTagRule)(ref Config.SkipBlockBelowTags)).Intersects(block.Tags))
			{
				return false;
			}
			if (Config.AllowedBlockBelowCode != (AssetLocation)null && !((RegistryObject)block).WildCardMatch(Config.AllowedBlockBelowCode))
			{
				return false;
			}
			return true;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskLookAroundConfig : AiTaskBaseConfig
	{
		[JsonProperty]
		public float TurnAngleFactor = 0.75f;
	}
	public class AiTaskLookAroundR : AiTaskBaseR
	{
		private AiTaskLookAroundConfig Config => GetConfig<AiTaskLookAroundConfig>();

		public AiTaskLookAroundR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskLookAroundConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			return PreconditionsSatisficed();
		}

		public override void StartExecute()
		{
			base.StartExecute();
			((Entity)entity).ServerPos.Yaw = (float)GameMath.Clamp(((Entity)entity).World.Rand.NextDouble() * 6.2831854820251465, (double)(((Entity)entity).ServerPos.Yaw - (float)Math.PI / 4f * GlobalConstants.OverallSpeedMultiplier * Config.TurnAngleFactor), (double)(((Entity)entity).ServerPos.Yaw + (float)Math.PI / 4f * GlobalConstants.OverallSpeedMultiplier * Config.TurnAngleFactor));
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskLookAtEntityConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public float MaxTurnAngleDeg = 360f;

		[JsonProperty]
		public float SpawnAngleDeg;

		[JsonProperty]
		public float DefaultMinTurnAngleDegPerSec = 250f;

		[JsonProperty]
		public float DefaultMaxTurnAngleDegPerSec = 450f;

		public float MaxTurnAngleRad => MaxTurnAngleDeg * ((float)Math.PI / 180f);

		public float SpawnAngleRad => SpawnAngleDeg * ((float)Math.PI / 180f);
	}
	public class AiTaskLookAtEntityR : AiTaskBaseTargetableR
	{
		protected float minTurnAnglePerSec;

		protected float maxTurnAnglePerSec;

		protected float currentTurnRadPerSec;

		protected const float yawChangeRateToStop = 0.01f;

		private AiTaskLookAtEntityConfig Config => GetConfig<AiTaskLookAtEntityConfig>();

		public AiTaskLookAtEntityR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskLookAtEntityConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			return SearchForTarget();
		}

		public override void StartExecute()
		{
			base.StartExecute();
			EntityAgent obj = entity;
			object obj2;
			if (obj == null)
			{
				obj2 = null;
			}
			else
			{
				EntityServerProperties server = ((Entity)obj).Properties.Server;
				if (server == null)
				{
					obj2 = null;
				}
				else
				{
					ITreeAttribute attributes = ((EntitySidedProperties)server).Attributes;
					obj2 = ((attributes != null) ? attributes.GetTreeAttribute("pathfinder") : null);
				}
			}
			ITreeAttribute val = (ITreeAttribute)obj2;
			if (val != null)
			{
				minTurnAnglePerSec = val.GetFloat("minTurnAnglePerSec", Config.DefaultMinTurnAngleDegPerSec);
				maxTurnAnglePerSec = val.GetFloat("maxTurnAnglePerSec", Config.DefaultMaxTurnAngleDegPerSec);
			}
			else
			{
				minTurnAnglePerSec = Config.DefaultMinTurnAngleDegPerSec;
				maxTurnAnglePerSec = Config.DefaultMaxTurnAngleDegPerSec;
			}
			currentTurnRadPerSec = minTurnAnglePerSec + (float)base.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
			currentTurnRadPerSec *= (float)Math.PI / 180f;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (targetEntity == null)
			{
				return false;
			}
			FastVec3f val = default(FastVec3f);
			((FastVec3f)(ref val)).Set((float)(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X), (float)(targetEntity.ServerPos.Y - ((Entity)entity).ServerPos.Y), (float)(targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z));
			float num = (float)Math.Atan2(val.X, val.Z);
			if (Config.MaxTurnAngleRad < (float)Math.PI)
			{
				num = GameMath.Clamp(num, Config.SpawnAngleRad - Config.MaxTurnAngleRad, Config.SpawnAngleRad + Config.MaxTurnAngleRad);
			}
			float num2 = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, num);
			EntityPos serverPos = ((Entity)entity).ServerPos;
			serverPos.Yaw += GameMath.Clamp(num2, (0f - currentTurnRadPerSec) * dt * GlobalConstants.OverallSpeedMultiplier, currentTurnRadPerSec * dt * GlobalConstants.OverallSpeedMultiplier);
			EntityPos serverPos2 = ((Entity)entity).ServerPos;
			serverPos2.Yaw %= (float)Math.PI * 2f;
			return Math.Abs(num2) > 0.01f;
		}
	}
	public sealed class AiTaskLookAtEntityConversable : AiTaskBaseR
	{
		private float minTurnAnglePerSec;

		private float maxTurnAnglePerSec;

		private float curTurnRadPerSec;

		private readonly Entity target;

		public AiTaskLookAtEntityConversable(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			world.Logger.Error("This AI task 'AiTaskLookAtEntityConversable' can only be created from code.");
			throw new InvalidOperationException("This AI task can only be created from code.");
		}

		public AiTaskLookAtEntityConversable(EntityAgent entity, Entity target)
			: base(entity)
		{
			this.target = target;
		}

		public override bool ShouldExecute()
		{
			return false;
		}

		public override void StartExecute()
		{
			if (((EntitySidedProperties)(((Entity)entity).Properties.Server?)).Attributes != null)
			{
				minTurnAnglePerSec = ((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetFloat("minTurnAnglePerSec", 250f);
				maxTurnAnglePerSec = ((EntitySidedProperties)((Entity)entity).Properties.Server).Attributes.GetTreeAttribute("pathfinder").GetFloat("maxTurnAnglePerSec", 450f);
			}
			else
			{
				minTurnAnglePerSec = 250f;
				maxTurnAnglePerSec = 450f;
			}
			curTurnRadPerSec = minTurnAnglePerSec + (float)base.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
			curTurnRadPerSec *= (float)Math.PI / 180f;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			FastVec3f val = default(FastVec3f);
			((FastVec3f)(ref val)).Set((float)(target.ServerPos.X - ((Entity)entity).ServerPos.X), (float)(target.ServerPos.Y - ((Entity)entity).ServerPos.Y), (float)(target.ServerPos.Z - ((Entity)entity).ServerPos.Z));
			float num = (float)Math.Atan2(val.X, val.Z);
			float num2 = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, num);
			EntityPos serverPos = ((Entity)entity).ServerPos;
			serverPos.Yaw += GameMath.Clamp(num2, (0f - curTurnRadPerSec) * dt, curTurnRadPerSec * dt);
			EntityPos serverPos2 = ((Entity)entity).ServerPos;
			serverPos2.Yaw %= (float)Math.PI * 2f;
			return (double)Math.Abs(num2) > 0.01;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskMeleeAttackConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public float Damage;

		[JsonProperty]
		public float KnockbackStrength = float.MinValue;

		[JsonProperty]
		public EnumDamageType DamageType = (EnumDamageType)2;

		[JsonProperty]
		public int DamageTier;

		[JsonProperty]
		public float MaxAttackDistance = 2f;

		[JsonProperty]
		public float MaxAttackVerticalDistance = 1f;

		[JsonProperty]
		public float AttackAngleRangeDeg = 20f;

		[JsonProperty]
		public int AttackDurationMs = 1000;

		[JsonProperty]
		public int[] DamageWindowMs = new int[2] { 0, 2147483647 };

		[JsonProperty]
		public bool TurnToTarget = true;

		[JsonProperty]
		public bool EatAfterKill = true;

		[JsonProperty]
		public bool PlayerIsMeal;

		[JsonProperty]
		public bool IgnoreInvFrames = true;

		[JsonProperty]
		public bool AffectedByGlobalDamageMultiplier = true;

		[JsonProperty]
		public bool RetaliateUnconditionally;

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (KnockbackStrength <= float.MinValue)
			{
				KnockbackStrength = ((Damage >= 0f) ? GameMath.Sqrt(Damage / 4f) : GameMath.Sqrt((0f - Damage) / 4f));
			}
			int num = MaxCooldownMs - MinCooldownMs;
			MinCooldownMs = Math.Max(MinCooldownMs, AttackDurationMs);
			MaxCooldownMs = Math.Max(Math.Max(MaxCooldownMs, MinCooldownMs + num), AttackDurationMs);
		}
	}
	public class AiTaskMeleeAttackR : AiTaskBaseTargetableR
	{
		protected bool damageInflicted;

		protected float currentTurnRadPerSec;

		protected bool didStartAnimation;

		protected bool fullyTamed;

		public static bool ShowExtraDamageInfo { get; set; } = true;

		private AiTaskMeleeAttackConfig Config => GetConfig<AiTaskMeleeAttackConfig>();

		public AiTaskMeleeAttackR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskMeleeAttackConfig>(entity, taskConfig, aiConfig);
			if (Config.DamageWindowMs.Length != 2)
			{
				string text = $"Error loading AI task config for task '{Config.Code}' and entity '{((RegistryObject)entity).Code}': damageWindow should be an array of two integers.";
				((Entity)entity).Api.Logger.Error(text);
				throw new ArgumentException(text);
			}
			int ownGeneration = GetOwnGeneration();
			fullyTamed = (float)ownGeneration >= Config.TamingGenerations;
			SetExtraInfoText();
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed() && (!Config.RetaliateUnconditionally || !base.RecentlyAttacked))
			{
				return false;
			}
			float fearReductionFactor = GetFearReductionFactor();
			if (fearReductionFactor <= 0f)
			{
				return false;
			}
			if (!base.RecentlyAttacked)
			{
				ClearAttacker();
			}
			if (ShouldRetaliate())
			{
				targetEntity = attackedByEntity;
			}
			else
			{
				Vec3d position = ((Entity)entity).ServerPos.XYZ.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
				targetEntity = partitionUtil.GetNearestEntity(position, Config.SeekingRange * fearReductionFactor, (Entity entity) => IsTargetableEntity(entity, Config.SeekingRange * fearReductionFactor), Config.SearchType);
			}
			return targetEntity != null;
		}

		public override void StartExecute()
		{
			didStartAnimation = false;
			damageInflicted = false;
			currentTurnRadPerSec = pathTraverser.curTurnRadPerSec;
			if (!Config.TurnToTarget)
			{
				base.StartExecute();
			}
		}

		public override bool ContinueExecute(float dt)
		{
			if (targetEntity == null)
			{
				return false;
			}
			EntityPos serverPos = ((Entity)entity).ServerPos;
			EntityPos serverPos2 = targetEntity.ServerPos;
			if (serverPos.Dimension != serverPos2.Dimension)
			{
				return false;
			}
			bool flag = true;
			if (Config.TurnToTarget)
			{
				float num = (float)Math.Atan2(serverPos2.X - serverPos.X, serverPos2.Z - serverPos.Z);
				float num2 = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, num);
				EntityPos serverPos3 = ((Entity)entity).ServerPos;
				serverPos3.Yaw += GameMath.Clamp(num2, (0f - currentTurnRadPerSec) * dt * GlobalConstants.OverallSpeedMultiplier, currentTurnRadPerSec * dt * GlobalConstants.OverallSpeedMultiplier);
				EntityPos serverPos4 = ((Entity)entity).ServerPos;
				serverPos4.Yaw %= (float)Math.PI * 2f;
				flag = Math.Abs(num2) < Config.AttackAngleRangeDeg * ((float)Math.PI / 180f);
				if (flag && !didStartAnimation)
				{
					didStartAnimation = true;
					base.StartExecute();
				}
			}
			if (executionStartTimeMs + Config.DamageWindowMs[0] > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return true;
			}
			if (executionStartTimeMs + Config.DamageWindowMs[0] <= ((Entity)entity).World.ElapsedMilliseconds && executionStartTimeMs + Config.DamageWindowMs[1] >= ((Entity)entity).World.ElapsedMilliseconds && !damageInflicted && flag)
			{
				damageInflicted = AttackTarget();
			}
			if (executionStartTimeMs + Config.AttackDurationMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return true;
			}
			return false;
		}

		protected virtual bool AttackTarget()
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Expected O, but got Unknown
			if (targetEntity == null)
			{
				return false;
			}
			if (!HasDirectContact(targetEntity, Config.MaxAttackDistance, Config.MaxAttackVerticalDistance))
			{
				return false;
			}
			bool alive = targetEntity.Alive;
			targetEntity.ReceiveDamage(new DamageSource
			{
				Source = (EnumDamageSource)8,
				SourceEntity = (Entity)(object)entity,
				Type = Config.DamageType,
				DamageTier = Config.DamageTier,
				KnockbackStrength = Config.KnockbackStrength,
				IgnoreInvFrames = Config.IgnoreInvFrames
			}, Config.Damage * (Config.AffectedByGlobalDamageMultiplier ? GlobalConstants.CreatureDamageModifier : 1f));
			if (entity is IMeleeAttackListener meleeAttackListener)
			{
				meleeAttackListener.DidAttack(targetEntity);
			}
			if (alive && !targetEntity.Alive && Config.EatAfterKill)
			{
				if (Config.PlayerIsMeal || !(targetEntity is EntityPlayer))
				{
					((TreeAttribute)((Entity)entity).WatchedAttributes).SetDouble("lastMealEatenTotalHours", ((Entity)entity).World.Calendar.TotalHours);
				}
				emotionStatesBehavior?.TryTriggerState("saturated", targetEntity.EntityId);
			}
			return true;
		}

		protected override bool IsTargetableEntity(Entity target, float range)
		{
			if (fullyTamed && (IsNonAttackingPlayer(target) || entity.ToleratesDamageFrom(target)))
			{
				return false;
			}
			if (!base.IsTargetableEntity(target, range))
			{
				return false;
			}
			return HasDirectContact(target, Config.MaxAttackDistance, Config.MaxAttackVerticalDistance);
		}

		protected override bool ShouldRetaliate()
		{
			if (attackedByEntity != null && base.ShouldRetaliate())
			{
				return HasDirectContact(attackedByEntity, Config.MaxAttackDistance, Config.MaxAttackVerticalDistance);
			}
			return false;
		}

		protected void SetExtraInfoText()
		{
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("extraInfoText");
			treeAttribute.SetString("dmgTier", Lang.Get("Damage tier: {0}", new object[1] { Config.DamageTier }));
			if (ShowExtraDamageInfo)
			{
				treeAttribute.SetString("dmgDamage", Lang.Get("Damage: {0}", new object[1] { Config.Damage }));
				treeAttribute.SetString("dmgType", Lang.Get("Damage type: {0}", new object[1] { Lang.Get($"{Config.DamageType}", Array.Empty<object>()) }));
			}
		}
	}
	public class AiTaskSeekBlockAndLayConfig
	{
	}
	public class AiTaskSeekBlockAndLayR : AiTaskBaseR
	{
		protected class FailedAttempt
		{
			public long LastTryMs;

			public int Count;
		}

		protected POIRegistry porregistry;

		protected IAnimalNest targetPoi;

		protected float moveSpeed = 0.02f;

		protected bool nowStuck;

		protected bool laid;

		protected float sitDays = 1f;

		protected float layTime = 1f;

		protected double incubationDays = 5.0;

		protected string[] chickCodes;

		protected string[] nestTypes;

		protected double onGroundChance = 0.3;

		protected AssetLocation failBlockCode;

		protected float sitTimeNow;

		protected double sitEndDay;

		protected bool sitAnimStarted;

		protected float PortionsEatenForLay;

		protected string requiresNearbyEntityCode;

		protected float requiresNearbyEntityRange = 5f;

		protected AnimationMetaData sitAnimMeta;

		private Dictionary<IAnimalNest, FailedAttempt> failedSeekTargets = new Dictionary<IAnimalNest, FailedAttempt>();

		protected long lastPOISearchTotalMs;

		protected double attemptLayEggTotalHours;

		public AiTaskSeekBlockAndLayR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0235: Unknown result type (might be due to invalid IL or missing references)
			//IL_023f: Expected O, but got Unknown
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			porregistry = ((Entity)entity).Api.ModLoader.GetModSystem<POIRegistry>(true);
			((TreeAttribute)((Entity)entity).WatchedAttributes).SetBool("doesSit", true);
			moveSpeed = taskConfig["movespeed"].AsFloat(0.02f);
			sitDays = taskConfig["sitDays"].AsFloat(1f);
			layTime = taskConfig["layTime"].AsFloat(1.5f);
			incubationDays = taskConfig["incubationDays"].AsDouble(5.0);
			if (taskConfig["sitAnimation"].Exists)
			{
				sitAnimMeta = new AnimationMetaData
				{
					Code = taskConfig["sitAnimation"].AsString((string)null)?.ToLowerInvariant(),
					Animation = taskConfig["sitAnimation"].AsString((string)null)?.ToLowerInvariant(),
					AnimationSpeed = taskConfig["sitAnimationSpeed"].AsFloat(1f)
				}.Init();
			}
			chickCodes = taskConfig["chickCodes"].AsArray<string>((string[])null, (string)null);
			if (chickCodes == null)
			{
				chickCodes = new string[1] { taskConfig["chickCode"].AsString((string)null) };
			}
			nestTypes = taskConfig["nestTypes"].AsArray<string>((string[])null, (string)null);
			PortionsEatenForLay = taskConfig["portionsEatenForLay"].AsFloat(3f);
			requiresNearbyEntityCode = taskConfig["requiresNearbyEntityCode"].AsString((string)null);
			requiresNearbyEntityRange = taskConfig["requiresNearbyEntityRange"].AsFloat(5f);
			string text = taskConfig["failBlockCode"].AsString((string)null);
			if (text != null)
			{
				failBlockCode = new AssetLocation(text);
			}
		}

		public override bool ShouldExecute()
		{
			if (((Entity)entity).World.Rand.NextDouble() > 0.03)
			{
				return false;
			}
			if (lastPOISearchTotalMs + 15000 > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilMs > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (cooldownUntilTotalHours > ((Entity)entity).World.Calendar.TotalHours)
			{
				return false;
			}
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			PortionsEatenForLay = 3f;
			if (!DidConsumeFood(PortionsEatenForLay))
			{
				return false;
			}
			if (attemptLayEggTotalHours <= 0.0)
			{
				attemptLayEggTotalHours = ((Entity)entity).World.Calendar.TotalHours;
			}
			lastPOISearchTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			targetPoi = FindPOI(42) as IAnimalNest;
			if (targetPoi == null)
			{
				LayEggOnGround();
			}
			return targetPoi != null;
		}

		protected IPointOfInterest FindPOI(int radius)
		{
			return porregistry.GetWeightedNearestPoi(((Entity)entity).ServerPos.XYZ, radius, delegate(IPointOfInterest poi)
			{
				if (poi.Type != "nest")
				{
					return false;
				}
				if (poi is IAnimalNest animalNest && !animalNest.Occupied((Entity)(object)entity) && animalNest.IsSuitableFor((Entity)(object)entity, nestTypes))
				{
					failedSeekTargets.TryGetValue(animalNest, out var value);
					if (value == null || value.Count < 4 || value.LastTryMs < world.ElapsedMilliseconds - 60000)
					{
						return true;
					}
				}
				return false;
			});
		}

		public float MinDistanceToTarget()
		{
			return 0.01f;
		}

		public override void StartExecute()
		{
			if (baseConfig.AnimationMeta != null)
			{
				baseConfig.AnimationMeta.EaseInSpeed = 1f;
				baseConfig.AnimationMeta.EaseOutSpeed = 1f;
				((Entity)entity).AnimManager.StartAnimation(baseConfig.AnimationMeta);
			}
			nowStuck = false;
			sitTimeNow = 0f;
			laid = false;
			pathTraverser.NavigateTo_Async(targetPoi.Position, moveSpeed, MinDistanceToTarget() - 0.1f, OnGoalReached, OnStuck, null, 1000, 1);
			sitAnimStarted = false;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		protected virtual ItemStack MakeEggItem(string chickCode)
		{
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Expected O, but got Unknown
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Expected O, but got Unknown
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Expected O, but got Unknown
			ICoreAPI api = ((Entity)entity).Api;
			EntityAgent obj = entity;
			object obj2;
			if (obj == null)
			{
				obj2 = null;
			}
			else
			{
				JsonObject attributes = ((Entity)obj).Properties.Attributes;
				obj2 = ((attributes != null) ? attributes["eggTypes"].AsArray<JsonItemStack>((JsonItemStack[])null, (string)null) : null);
			}
			JsonItemStack[] array = (JsonItemStack[])obj2;
			ItemStack val;
			if (array == null)
			{
				string text = "egg-chicken-raw";
				if (entity != null)
				{
					api.Logger.Warning("No egg type specified for entity " + AssetLocation.op_Implicit(((RegistryObject)entity).Code) + ", falling back to " + text);
				}
				val = new ItemStack(api.World.GetItem(AssetLocation.op_Implicit(text)), 1);
			}
			else
			{
				JsonItemStack val2 = array[api.World.Rand.Next(array.Length)];
				if (!val2.Resolve(api.World, (string)null, false))
				{
					api.Logger.Warning("Failed to resolve egg " + ((object)Unsafe.As<EnumItemClass, EnumItemClass>(ref val2.Type)/*cast due to .constrained prefix*/).ToString() + " with code " + AssetLocation.op_Implicit(val2.Code) + " for entity " + AssetLocation.op_Implicit(((RegistryObject)entity).Code));
					return null;
				}
				val = new ItemStack(val2.ResolvedItemstack.Collectible, 1);
			}
			if (chickCode != null)
			{
				TreeAttribute val3 = new TreeAttribute();
				string text2 = chickCode;
				EntityAgent obj3 = entity;
				chickCode = AssetLocation.op_Implicit(AssetLocation.Create(text2, ((obj3 != null) ? ((RegistryObject)obj3).Code.Domain : null) ?? "game"));
				val3.SetString("code", chickCode);
				EntityAgent obj4 = entity;
				val3.SetInt("generation", (obj4 != null) ? (((TreeAttribute)((Entity)obj4).WatchedAttributes).GetInt("generation", 0) + 1) : 0);
				val3.SetDouble("incubationDays", incubationDays);
				EntityAgent val4 = entity;
				if (val4 != null)
				{
					val3.SetLong("herdID", val4.HerdId);
				}
				val.Attributes["chick"] = (IAttribute)(object)val3;
			}
			return val;
		}

		public override bool ContinueExecute(float dt)
		{
			if (targetPoi.Occupied((Entity)(object)entity))
			{
				onBadTarget();
				return false;
			}
			Vec3d position = targetPoi.Position;
			double num = position.HorizontalSquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Z);
			pathTraverser.CurrentTarget.X = position.X;
			pathTraverser.CurrentTarget.Y = position.Y;
			pathTraverser.CurrentTarget.Z = position.Z;
			float num2 = MinDistanceToTarget();
			if (num <= (double)num2)
			{
				pathTraverser.Stop();
				if (baseConfig.AnimationMeta != null)
				{
					((Entity)entity).AnimManager.StopAnimation(baseConfig.AnimationMeta.Code);
				}
				((Entity)entity).GetBehavior<EntityBehaviorMultiply>();
				if (!targetPoi.IsSuitableFor((Entity)(object)entity, nestTypes))
				{
					onBadTarget();
					return false;
				}
				targetPoi.SetOccupier((Entity)(object)entity);
				if (sitAnimMeta != null && !sitAnimStarted)
				{
					((Entity)entity).AnimManager.StartAnimation(sitAnimMeta);
					sitAnimStarted = true;
					sitEndDay = ((Entity)entity).World.Calendar.TotalDays + (double)sitDays;
				}
				sitTimeNow += dt;
				if (sitTimeNow >= layTime && !laid)
				{
					laid = true;
					string chickCode = null;
					if (GetRequiredEntityNearby() != null && chickCodes.Length != 0)
					{
						chickCode = chickCodes[((Entity)entity).World.Rand.Next(chickCodes.Length)];
					}
					if (targetPoi.TryAddEgg(MakeEggItem(chickCode)))
					{
						ConsumeFood(PortionsEatenForLay);
						attemptLayEggTotalHours = -1.0;
						MakeLaySound();
						failedSeekTargets.Remove(targetPoi);
						return false;
					}
				}
				if (((Entity)entity).World.Calendar.TotalDays >= sitEndDay)
				{
					failedSeekTargets.Remove(targetPoi);
					return false;
				}
			}
			else if (!pathTraverser.Active)
			{
				float num3 = (float)((Entity)entity).World.Rand.NextDouble() * 0.3f - 0.15f;
				float num4 = (float)((Entity)entity).World.Rand.NextDouble() * 0.3f - 0.15f;
				pathTraverser.NavigateTo(targetPoi.Position.AddCopy(num3, 0f, num4), moveSpeed, MinDistanceToTarget() - 0.15f, OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, 500);
			}
			if (nowStuck)
			{
				return false;
			}
			if (attemptLayEggTotalHours > 0.0 && ((Entity)entity).World.Calendar.TotalHours - attemptLayEggTotalHours > 12.0)
			{
				LayEggOnGround();
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			attemptLayEggTotalHours = -1.0;
			pathTraverser.Stop();
			if (sitAnimMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(sitAnimMeta.Code);
			}
			targetPoi?.SetOccupier(null);
			if (cancelled)
			{
				cooldownUntilTotalHours = 0.0;
			}
		}

		protected void OnStuck()
		{
			nowStuck = true;
			onBadTarget();
		}

		protected void onBadTarget()
		{
			IAnimalNest animalNest = null;
			if (attemptLayEggTotalHours >= 0.0 && ((Entity)entity).World.Calendar.TotalHours - attemptLayEggTotalHours > 12.0)
			{
				LayEggOnGround();
			}
			else if (base.Rand.NextDouble() > 0.4)
			{
				animalNest = FindPOI(18) as IAnimalNest;
			}
			failedSeekTargets.TryGetValue(targetPoi, out var value);
			if (value == null)
			{
				value = (failedSeekTargets[targetPoi] = new FailedAttempt());
			}
			value.Count++;
			value.LastTryMs = world.ElapsedMilliseconds;
			if (animalNest != null)
			{
				targetPoi = animalNest;
				nowStuck = false;
				sitTimeNow = 0f;
				laid = false;
				pathTraverser.NavigateTo_Async(targetPoi.Position, moveSpeed, MinDistanceToTarget() - 0.1f, OnGoalReached, OnStuck, null, 1000, 1);
				sitAnimStarted = false;
			}
		}

		protected void OnGoalReached()
		{
			pathTraverser.Active = true;
			failedSeekTargets.Remove(targetPoi);
		}

		protected bool DidConsumeFood(float portion)
		{
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute == null)
			{
				return false;
			}
			return treeAttribute.GetFloat("saturation", 0f) >= portion;
		}

		protected bool ConsumeFood(float portion)
		{
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute == null)
			{
				return false;
			}
			float num = treeAttribute.GetFloat("saturation", 0f);
			if (num >= portion)
			{
				float num2 = ((((Entity)entity).World.Rand.NextDouble() < 0.25) ? portion : 1f);
				treeAttribute.SetFloat("saturation", num - num2);
				return true;
			}
			return false;
		}

		protected Entity GetRequiredEntityNearby()
		{
			if (requiresNearbyEntityCode == null)
			{
				return null;
			}
			return ((Entity)entity).World.GetNearestEntity(((Entity)entity).ServerPos.XYZ, requiresNearbyEntityRange, requiresNearbyEntityRange, (ActionConsumable<Entity>)delegate(Entity e)
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Expected O, but got Unknown
				if (((RegistryObject)e).WildCardMatch(new AssetLocation(requiresNearbyEntityCode)))
				{
					ITreeAttribute treeAttribute = ((TreeAttribute)e.WatchedAttributes).GetTreeAttribute("hunger");
					if (!((TreeAttribute)e.WatchedAttributes).GetBool("doesEat", false) || treeAttribute == null)
					{
						return true;
					}
					treeAttribute.SetFloat("saturation", Math.Max(0f, treeAttribute.GetFloat("saturation", 0f) - 1f));
					return true;
				}
				return false;
			});
		}

		protected void LayEggOnGround()
		{
			if (!(((Entity)entity).World.Rand.NextDouble() > onGroundChance))
			{
				Block block = ((Entity)entity).World.GetBlock(failBlockCode);
				if (block != null && (TryPlace(block, 0, 0, 0) || TryPlace(block, 1, 0, 0) || TryPlace(block, 0, 0, -1) || TryPlace(block, -1, 0, 0) || TryPlace(block, 0, 0, 1)))
				{
					ConsumeFood(PortionsEatenForLay);
					attemptLayEggTotalHours = -1.0;
				}
			}
		}

		protected bool TryPlace(Block block, int dx, int dy, int dz)
		{
			IBlockAccessor blockAccessor = ((Entity)entity).World.BlockAccessor;
			BlockPos val = ((Entity)entity).ServerPos.XYZ.AsBlockPos.Add(dx, dy, dz);
			if (((CollectibleObject)blockAccessor.GetBlock(val, 2)).IsLiquid())
			{
				return false;
			}
			if (!blockAccessor.GetBlock(val).IsReplacableBy(block))
			{
				return false;
			}
			val.Y--;
			if (blockAccessor.GetMostSolidBlock(val).CanAttachBlockAt(blockAccessor, block, val, BlockFacing.UP, (Cuboidi)null))
			{
				val.Y++;
				blockAccessor.SetBlock(block.BlockId, val);
				BlockEntityTransient obj = blockAccessor.GetBlockEntity(val) as BlockEntityTransient;
				obj?.SetPlaceTime(((Entity)entity).World.Calendar.TotalHours);
				if (obj != null && obj.IsDueTransition())
				{
					blockAccessor.SetBlock(0, val);
				}
				return true;
			}
			return false;
		}

		protected void MakeLaySound()
		{
			if (baseConfig.Sound == (AssetLocation)null)
			{
				return;
			}
			if (baseConfig.SoundStartMs > 0)
			{
				((Entity)entity).World.RegisterCallback((Action<float>)delegate
				{
					((Entity)entity).World.PlaySoundAt(baseConfig.Sound, (Entity)(object)entity, (IPlayer)null, true, baseConfig.SoundRange, 1f);
					lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
				}, baseConfig.SoundStartMs);
			}
			else
			{
				((Entity)entity).World.PlaySoundAt(baseConfig.Sound, (Entity)(object)entity, (IPlayer)null, true, baseConfig.SoundRange, 1f);
				lastSoundTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			}
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskSeekEntityConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public float MoveSpeed = 0.02f;

		[JsonProperty]
		public string? JumpAnimationCode = "jump";

		[JsonProperty]
		public float JumpChance = 1f;

		[JsonProperty]
		public float JumpHeightFactor = 1f;

		[JsonProperty]
		public bool JumpAtTarget;

		[JsonProperty]
		public float ExtraTargetDistance;

		[JsonProperty]
		public float BelowTemperatureSeekingRange = 25f;

		[JsonProperty]
		public float BelowTemperatureThreshold = -99f;

		[JsonProperty]
		public float MaxFollowTimeSec = 60f;

		[JsonProperty]
		public bool AlarmHerd;

		[JsonProperty]
		public float HerdAlarmRange;

		[JsonProperty]
		public EnumAICreatureType? AiCreatureType;

		[JsonProperty]
		public bool StopWhenAttackedByTargetOutsideOfSeekingRange = true;

		[JsonProperty]
		public bool FleeWhenAttackedByTargetOutsideOfSeekingRange = true;

		[JsonProperty]
		public bool RetaliateUnconditionally = true;

		[JsonProperty]
		public float RetaliationSeekingRangeFactor = 1.5f;

		[JsonProperty]
		public float PathUpdateCooldownSec = 0.75f;

		[JsonProperty]
		public float MinDistanceToUpdatePath = 3f;

		[JsonProperty]
		public float MotionAnticipationFactor = 10f;

		[JsonProperty]
		public int JumpAnimationTimeoutMs = 2000;

		[JsonProperty]
		public float[] DistanceToTargetToJump = new float[2] { 0.5f, 4f };

		[JsonProperty]
		public float MaxHeightDifferenceToJump = 0.1f;

		[JsonProperty]
		public int JumpCooldownMs = 3000;

		[JsonProperty]
		public string[] AnimationToStopForJump = new string[2] { "walk", "run" };

		[JsonProperty]
		public float JumpMotionAnticipationFactor = 80f;

		[JsonProperty]
		public float JumpSpeedFactor = 1f;

		[JsonProperty]
		public float AfterJumpSpeedReduction = 0.5f;

		[JsonProperty]
		public bool FleeIfCantReach = true;

		[JsonProperty]
		public bool IgnorePlayerIfFullyTamed;

		[JsonProperty]
		public float MaxVerticalJumpSpeed = 0.13f;

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (HerdAlarmRange <= 0f)
			{
				HerdAlarmRange = SeekingRange;
			}
		}
	}
	public class AiTaskSeekEntityR : AiTaskBaseTargetableR
	{
		protected int pathSearchDepth = 3500;

		protected int pathDeepSearchDepth = 10000;

		protected float chanceOfDeepSearch = 0.05f;

		protected int updatePathDepth = 2000;

		protected int circlePathSearchDepth = 3500;

		protected float currentSeekingRange;

		protected float currentFollowTimeSec;

		protected float lastPathUpdateSecondsSec;

		protected EnumAttackPattern attackPattern;

		protected long finishedMs;

		protected bool jumpAnimationOn;

		protected long jumpedMs;

		protected readonly Dictionary<long, int> futilityCounters = new Dictionary<long, int>();

		protected readonly Vec3d targetPosition = new Vec3d();

		protected readonly Vec3d previousPosition = new Vec3d();

		protected bool updatedPathAfterLanding = true;

		protected Vec3d jumpHorizontalVelocity = new Vec3d();

		private readonly Vec3d posBuffer = new Vec3d();

		public override string Id => "seekentity";

		private AiTaskSeekEntityConfig Config => GetConfig<AiTaskSeekEntityConfig>();

		public AiTaskSeekEntityR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Expected O, but got Unknown
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Expected O, but got Unknown
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Expected O, but got Unknown
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskSeekEntityConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			if (jumpAnimationOn && ((Entity)entity).World.ElapsedMilliseconds - finishedMs > Config.JumpAnimationTimeoutMs)
			{
				((Entity)entity).AnimManager.StopAnimation("jump");
				jumpAnimationOn = false;
			}
			if (!PreconditionsSatisficed() && (!Config.RetaliateUnconditionally || !base.RecentlyAttacked))
			{
				return false;
			}
			SetSeekingRange();
			if (!base.RecentlyAttacked)
			{
				ClearAttacker();
			}
			if (ShouldRetaliate() && attackedByEntity != null)
			{
				targetEntity = attackedByEntity;
				targetPosition.SetWithDimension(attackedByEntity.ServerPos);
				AlarmHerd();
				return true;
			}
			if (!CheckAndResetSearchCooldown())
			{
				return false;
			}
			SearchForTarget();
			if (targetEntity == null)
			{
				return false;
			}
			AlarmHerd();
			targetPosition.SetWithDimension(targetEntity.ServerPos);
			if (((Entity)entity).ServerPos.SquareDistanceTo(targetPosition) <= (double)MinDistanceToTarget(Config.ExtraTargetDistance))
			{
				return false;
			}
			return true;
		}

		public override void StartExecute()
		{
			if (targetEntity != null)
			{
				base.StartExecute();
				currentFollowTimeSec = 0f;
				attackPattern = EnumAttackPattern.DirectAttack;
				int searchDepth = pathSearchDepth;
				if (world.Rand.NextDouble() < (double)chanceOfDeepSearch)
				{
					searchDepth = pathDeepSearchDepth;
				}
				pathTraverser.NavigateTo_Async(targetEntity.Pos.XYZ, Config.MoveSpeed, MinDistanceToTarget(Config.ExtraTargetDistance), OnGoalReached, OnStuck, OnSeekUnable, searchDepth, 1, Config.AiCreatureType);
				previousPosition.SetWithDimension(((Entity)entity).Pos);
			}
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_0227: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Invalid comparison between Unknown and I4
			if (targetEntity == null)
			{
				return false;
			}
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			currentFollowTimeSec += dt;
			lastPathUpdateSecondsSec += dt;
			if (Config.JumpAtTarget && !updatedPathAfterLanding && ((Entity)entity).OnGround && ((Entity)entity).Collided)
			{
				pathTraverser.NavigateTo(targetPosition, Config.MoveSpeed, MinDistanceToTarget(Config.ExtraTargetDistance), OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, updatePathDepth, 1, Config.AiCreatureType);
				lastPathUpdateSecondsSec = 0f;
				updatedPathAfterLanding = true;
			}
			if (!Config.JumpAtTarget || ((Entity)entity).OnGround || updatedPathAfterLanding)
			{
				UpdatePath();
			}
			if (Config.JumpAtTarget && !updatedPathAfterLanding && !((Entity)entity).OnGround)
			{
				((Entity)entity).ServerPos.Motion.X = jumpHorizontalVelocity.X;
				((Entity)entity).ServerPos.Motion.Z = jumpHorizontalVelocity.Z;
			}
			RestoreMainAnimation();
			if (attackPattern == EnumAttackPattern.DirectAttack)
			{
				pathTraverser.CurrentTarget.X = targetEntity.ServerPos.X;
				pathTraverser.CurrentTarget.Y = targetEntity.ServerPos.InternalY;
				pathTraverser.CurrentTarget.Z = targetEntity.ServerPos.Z;
			}
			if (PerformJump())
			{
				updatedPathAfterLanding = false;
				pathTraverser.Stop();
			}
			double distanceToTarget = GetDistanceToTarget();
			Entity? obj = targetEntity;
			Entity? obj2 = ((obj is EntityPlayer) ? obj : null);
			int num;
			if (obj2 != null)
			{
				IPlayer player = ((EntityPlayer)obj2).Player;
				if ((int)((player != null) ? new EnumGameMode?(player.WorldData.CurrentGameMode) : ((EnumGameMode?)null)).GetValueOrDefault() == 2)
				{
					num = ((!Config.TargetPlayerInAllGameModes) ? 1 : 0);
					goto IL_0242;
				}
			}
			num = 0;
			goto IL_0242;
			IL_0242:
			bool flag = (byte)num != 0;
			float num2 = MinDistanceToTarget(Config.ExtraTargetDistance);
			bool flag2 = pathTraverser.Active || !updatedPathAfterLanding;
			if (targetEntity.Alive && !flag && flag2 && currentFollowTimeSec < Config.MaxFollowTimeSec && distanceToTarget < (double)currentSeekingRange)
			{
				if (!(distanceToTarget > (double)num2))
				{
					Entity? obj3 = targetEntity;
					EntityAgent val = (EntityAgent)(object)((obj3 is EntityAgent) ? obj3 : null);
					if (val != null)
					{
						return val.ServerControls.TriesToMove;
					}
					return false;
				}
				return true;
			}
			return false;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			finishedMs = ((Entity)entity).World.ElapsedMilliseconds;
			pathTraverser.Stop();
			active = false;
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		public override bool Notify(string key, object data)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			if (key == "seekEntity")
			{
				targetEntity = (Entity)data;
				targetPosition.SetWithDimension(targetEntity.ServerPos);
				return true;
			}
			return false;
		}

		public override void OnEntityHurt(DamageSource source, float damage)
		{
			base.OnEntityHurt(source, damage);
			if (!active || targetEntity != source.GetCauseEntity() || targetEntity == null || targetEntity.ServerPos.DistanceTo(((Entity)entity).ServerPos) <= (double)currentSeekingRange)
			{
				return;
			}
			if (Config.StopWhenAttackedByTargetOutsideOfSeekingRange)
			{
				stopTask = true;
			}
			if (Config.FleeWhenAttackedByTargetOutsideOfSeekingRange)
			{
				((Entity)entity).GetBehavior<EntityBehaviorTaskAI>().TaskManager.AllTasks.ForEach(delegate(IAiTask t)
				{
					(t as AiTaskFleeEntity)?.InstaFleeFrom(targetEntity);
				});
			}
		}

		protected override bool CanSense(Entity target, double range)
		{
			if (!base.CanSense(target, range))
			{
				return false;
			}
			if (futilityCounters != null && futilityCounters.TryGetValue(target.EntityId, out var value) && value > 0)
			{
				value -= 2;
				futilityCounters[target.EntityId] = value;
				return false;
			}
			return true;
		}

		protected override bool SearchForTarget()
		{
			bool fullyTamed = (float)GetOwnGeneration() >= Config.TamingGenerations;
			posBuffer.SetWithDimension(((Entity)entity).ServerPos);
			targetEntity = partitionUtil.GetNearestEntity(posBuffer, currentSeekingRange, (Entity potentialTarget) => (!(Config.IgnorePlayerIfFullyTamed && fullyTamed) || (!IsNonAttackingPlayer(potentialTarget) && !entity.ToleratesDamageFrom(attackedByEntity))) && IsTargetableEntity(potentialTarget, currentSeekingRange), Config.SearchType);
			return targetEntity != null;
		}

		protected virtual void OnSeekUnable()
		{
			if (targetPosition.DistanceTo(((Entity)entity).ServerPos.XYZ) < currentSeekingRange && !TryCircleTarget())
			{
				OnCircleTargetUnable();
			}
		}

		protected virtual void OnCircleTargetUnable()
		{
			if (targetEntity != null && Config.FleeIfCantReach)
			{
				EnumerableExtensions.Foreach<AiTaskFleeEntity>(taskAiBehavior.TaskManager.GetTasks<AiTaskFleeEntity>(), (Action<AiTaskFleeEntity>)delegate(AiTaskFleeEntity task)
				{
					task.InstaFleeFrom(targetEntity);
				});
			}
		}

		protected virtual bool TryCircleTarget()
		{
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Expected O, but got Unknown
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0187: Expected O, but got Unknown
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Expected O, but got Unknown
			attackPattern = EnumAttackPattern.CircleTarget;
			float num = (float)Math.Atan2(((Entity)entity).ServerPos.X - targetPosition.X, ((Entity)entity).ServerPos.Z - targetPosition.Z);
			for (int i = 0; i < 3; i++)
			{
				double num2 = (double)num + 0.5 + world.Rand.NextDouble() / 2.0;
				double num3 = 4.0 + world.Rand.NextDouble() * 6.0;
				double num4 = GameMath.Sin(num2) * num3;
				double num5 = GameMath.Cos(num2) * num3;
				targetPosition.Add(num4, 0.0, num5);
				int num6 = 0;
				bool flag = false;
				BlockPos val = new BlockPos((int)targetPosition.X, (int)targetPosition.Y, (int)targetPosition.Z);
				int num7 = 0;
				while (num6 < 5)
				{
					if (((SmallBoolArray)(ref PosUtil.GetBlockBelow(world.BlockAccessor, val, num7, 0).SideSolid))[BlockFacing.UP.Index] && !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, new Vec3d((double)val.X + 0.5, (double)(val.Y - num7 + 1), (double)val.Z + 0.5), false))
					{
						flag = true;
						Vec3d obj = targetPosition;
						obj.Y -= (double)num7;
						Vec3d obj2 = targetPosition;
						obj2.Y += 1.0;
						break;
					}
					if (((SmallBoolArray)(ref PosUtil.GetBlockAbove(world.BlockAccessor, val, num7, 0).SideSolid))[BlockFacing.UP.Index] && !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, new Vec3d((double)val.X + 0.5, (double)(val.Y + num7 + 1), (double)val.Z + 0.5), false))
					{
						flag = true;
						Vec3d obj3 = targetPosition;
						obj3.Y += (double)num7;
						Vec3d obj4 = targetPosition;
						obj4.Y += 1.0;
						break;
					}
					num6++;
					num7++;
				}
				if (flag)
				{
					pathTraverser.NavigateTo_Async(targetPosition.Clone(), Config.MoveSpeed, MinDistanceToTarget(Config.ExtraTargetDistance), OnGoalReached, OnStuck, OnCircleTargetUnable, circlePathSearchDepth, 1, Config.AiCreatureType);
					return true;
				}
			}
			return false;
		}

		protected virtual double GetDistanceToTarget()
		{
			if (targetEntity == null)
			{
				return double.MaxValue;
			}
			Cuboidd obj = targetEntity.SelectionBox.ToDouble().Translate(targetEntity.ServerPos.X, targetEntity.ServerPos.InternalY, targetEntity.ServerPos.Z);
			posBuffer.SetWithDimension(((Entity)entity).ServerPos);
			posBuffer.Add(0.0, (double)(((Entity)entity).SelectionBox.Y2 / 2f), 0.0).Ahead((double)(((Entity)entity).SelectionBox.XSize / 2f), 0f, ((Entity)entity).ServerPos.Yaw);
			return obj.ShortestDistanceFrom((IVec3)(object)posBuffer);
		}

		protected virtual void UpdatePath()
		{
			if (targetEntity != null && attackPattern == EnumAttackPattern.DirectAttack && lastPathUpdateSecondsSec >= Config.PathUpdateCooldownSec && targetPosition.SquareDistanceTo(targetEntity.ServerPos.X, targetEntity.ServerPos.InternalY, targetEntity.ServerPos.Z) >= Config.MinDistanceToUpdatePath * Config.MinDistanceToUpdatePath)
			{
				targetPosition.Set(targetEntity.ServerPos.X + targetEntity.ServerPos.Motion.X * (double)Config.MotionAnticipationFactor, targetEntity.ServerPos.InternalY, targetEntity.ServerPos.Z + targetEntity.ServerPos.Motion.Z * (double)Config.MotionAnticipationFactor);
				pathTraverser.NavigateTo(targetPosition, Config.MoveSpeed, MinDistanceToTarget(Config.ExtraTargetDistance), OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, updatePathDepth, 1, Config.AiCreatureType);
				lastPathUpdateSecondsSec = 0f;
			}
		}

		protected virtual void RestoreMainAnimation()
		{
			if (Config.AnimationMeta == null)
			{
				return;
			}
			if (Config.JumpAtTarget && !((Entity)entity).AnimManager.IsAnimationActive(new string[1] { Config.AnimationMeta.Code }))
			{
				RunningAnimation animationState = ((Entity)entity).AnimManager.Animator.GetAnimationState(Config.JumpAnimationCode);
				if (animationState == null || !animationState.Active)
				{
					Config.AnimationMeta.EaseInSpeed = 1f;
					Config.AnimationMeta.EaseOutSpeed = 1f;
					((Entity)entity).AnimManager.StartAnimation(Config.AnimationMeta);
				}
			}
			if (jumpAnimationOn && ((Entity)entity).World.ElapsedMilliseconds - finishedMs > Config.JumpAnimationTimeoutMs)
			{
				((Entity)entity).AnimManager.StopAnimation(Config.JumpAnimationCode);
				Config.AnimationMeta.EaseInSpeed = 1f;
				Config.AnimationMeta.EaseOutSpeed = 1f;
				((Entity)entity).AnimManager.StartAnimation(Config.AnimationMeta);
			}
		}

		protected virtual void PlayJumpAnimation()
		{
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			if (Config.JumpAnimationCode != null)
			{
				string[] animationToStopForJump = Config.AnimationToStopForJump;
				foreach (string text in animationToStopForJump)
				{
					((Entity)entity).AnimManager.StopAnimation(text);
					((Entity)entity).AnimManager.StopAnimation(text);
				}
				((Entity)entity).AnimManager.StartAnimation(new AnimationMetaData
				{
					Animation = Config.JumpAnimationCode,
					Code = Config.JumpAnimationCode
				}.Init());
				jumpAnimationOn = true;
			}
		}

		protected virtual bool PerformJump()
		{
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Invalid comparison between Unknown and I4
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Expected O, but got Unknown
			if (targetEntity == null)
			{
				return false;
			}
			double distanceToTarget = GetDistanceToTarget();
			Entity? obj = targetEntity;
			Entity? obj2 = ((obj is EntityPlayer) ? obj : null);
			if (obj2 != null)
			{
				IPlayer player = ((EntityPlayer)obj2).Player;
				if ((int)((player != null) ? new EnumGameMode?(player.WorldData.CurrentGameMode) : ((EnumGameMode?)null)).GetValueOrDefault() == 2 && !Config.TargetPlayerInAllGameModes)
				{
					goto IL_008c;
				}
			}
			if (Config.JumpAtTarget && !(base.Rand.NextDouble() > (double)Config.JumpChance))
			{
				bool flag = ((Entity)entity).World.ElapsedMilliseconds - jumpedMs < Config.JumpCooldownMs;
				bool result = false;
				if (distanceToTarget >= (double)Config.DistanceToTargetToJump[0] && distanceToTarget <= (double)Config.DistanceToTargetToJump[1] && !flag && (double)Config.MaxHeightDifferenceToJump >= ((Entity)entity).ServerPos.Y - targetEntity.ServerPos.Y)
				{
					Vec3d val = new Vec3d(((Entity)entity).ServerPos.Motion.X, 0.0, ((Entity)entity).ServerPos.Motion.Z);
					double num = val.Length();
					double num2 = (targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X + targetEntity.ServerPos.Motion.X * (double)Config.JumpMotionAnticipationFactor) * (double)Config.JumpSpeedFactor * 0.032999999821186066 * 0.5;
					double num3 = (targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z + targetEntity.ServerPos.Motion.Z * (double)Config.JumpMotionAnticipationFactor) * (double)Config.JumpSpeedFactor * 0.032999999821186066 * 0.5;
					double num4 = (double)Config.JumpHeightFactor * GameMath.Max((double)Config.MaxVerticalJumpSpeed, (targetEntity.ServerPos.Y - ((Entity)entity).ServerPos.Y) * 0.032999999821186066);
					val.Set(num2, 0.0, num3).Normalize().Mul(num);
					jumpHorizontalVelocity.Set(num2 + ((Entity)entity).ServerPos.Motion.X, 0.0, num3 + ((Entity)entity).ServerPos.Motion.Z);
					((Entity)entity).ServerPos.Motion.X = val.X;
					((Entity)entity).ServerPos.Motion.Z = val.Z;
					((Entity)entity).ServerPos.Motion.Add(num2, num4, num3);
					float yaw = (float)Math.Atan2(num2, num3);
					((Entity)entity).ServerPos.Yaw = yaw;
					PlayJumpAnimation();
					jumpedMs = ((Entity)entity).World.ElapsedMilliseconds;
					finishedMs = ((Entity)entity).World.ElapsedMilliseconds;
					result = true;
				}
				if (flag && !((Entity)entity).Collided && distanceToTarget < (double)Config.DistanceToTargetToJump[0])
				{
					EntityPos serverPos = ((Entity)entity).ServerPos;
					serverPos.Motion *= Config.AfterJumpSpeedReduction;
				}
				return result;
			}
			goto IL_008c;
			IL_008c:
			return false;
		}

		protected virtual void AlarmHerd()
		{
			if (!Config.AlarmHerd || entity.HerdId == 0L)
			{
				return;
			}
			posBuffer.SetWithDimension(((Entity)entity).ServerPos);
			((Entity)entity).World.GetNearestEntity(posBuffer, Config.HerdAlarmRange, Config.HerdAlarmRange, (ActionConsumable<Entity>)delegate(Entity target)
			{
				if (target.EntityId != ((Entity)entity).EntityId)
				{
					EntityAgent val = (EntityAgent)(object)((target is EntityAgent) ? target : null);
					if (val != null && ((Entity)val).Alive && val.HerdId == entity.HerdId)
					{
						((Entity)val).Notify("seekEntity", (object)targetEntity);
					}
				}
				return false;
			});
		}

		protected virtual void OnStuck()
		{
			stopTask = true;
		}

		protected virtual void OnGoalReached()
		{
			if (targetEntity == null || attackPattern != EnumAttackPattern.DirectAttack)
			{
				return;
			}
			if ((double)previousPosition.SquareDistanceTo(((Entity)entity).Pos) < 0.001)
			{
				futilityCounters.TryGetValue(targetEntity.EntityId, out var value);
				value++;
				futilityCounters[targetEntity.EntityId] = value;
				if (value > 19)
				{
					return;
				}
			}
			previousPosition.SetWithDimension(((Entity)entity).Pos);
			pathTraverser.Retarget();
		}

		protected virtual float SetSeekingRange()
		{
			currentSeekingRange = Config.SeekingRange;
			if (Config.BelowTemperatureThreshold > -99f && ((Entity)entity).World.BlockAccessor.GetClimateAt(((Entity)entity).Pos.AsBlockPos, (EnumGetClimateMode)3, ((Entity)entity).World.Calendar.TotalDays).Temperature <= Config.BelowTemperatureThreshold)
			{
				currentSeekingRange = Config.BelowTemperatureSeekingRange;
			}
			if (Config.RetaliationSeekingRangeFactor != 1f && Config.RetaliateAttacks && attackedByEntity != null && attackedByEntity.Alive && attackedByEntity.IsInteractable && CanSense(attackedByEntity, currentSeekingRange * Config.RetaliationSeekingRangeFactor) && !entity.ToleratesDamageFrom(attackedByEntity))
			{
				currentSeekingRange *= Config.RetaliationSeekingRangeFactor;
			}
			currentSeekingRange *= GetFearReductionFactor();
			return currentSeekingRange;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskSeekFoodAndEatConfig : AiTaskBaseConfig
	{
		[JsonProperty]
		public float MoveSpeed = 0.02f;

		[JsonProperty]
		public float ExtraTargetDistance = 0.6f;

		[JsonProperty]
		public int PoiSearchCooldown = 15000;

		[JsonProperty]
		public float ChanceToSeekFoodWithoutEating = 0.004f;

		[JsonProperty]
		public bool EatLooseItems = true;

		[JsonProperty]
		public bool EatFoodSources = true;

		[JsonProperty]
		public AssetLocation? EatSound;

		[JsonProperty]
		public float EatTimeSoundSec = 1.125f;

		[JsonProperty]
		public float EatTimeSec = 1.5f;

		[JsonProperty]
		public float EatSoundRange = 16f;

		[JsonProperty]
		public float EatSoundVolume = 1f;

		[JsonProperty]
		public float LooseItemsSearchRange = 10f;

		[JsonProperty]
		public float PoiSearchRange = 48f;

		[JsonProperty]
		public string PoiType = "food";

		[JsonProperty]
		public int SeekPoiRetryCooldown = 60000;

		[JsonProperty]
		public int SeekPoiMaxAttempts = 4;

		[JsonProperty]
		public EnumAICreatureType? AiCreatureType = (EnumAICreatureType)0;

		[JsonProperty]
		private string? eatAnimation;

		[JsonProperty]
		private float eatAnimationSpeed = 1f;

		[JsonProperty]
		private string? eatAnimationLooseItems;

		[JsonProperty]
		private float eatAnimationSpeedLooseItems = 1f;

		[JsonProperty]
		public bool DoConsumePortion = true;

		[JsonProperty]
		public CreatureDiet? Diet;

		[JsonProperty]
		public float SaturationPerPortion = 1f;

		public AnimationMetaData? EatAnimationMeta;

		public AnimationMetaData? EatAnimationMetaLooseItems;

		public override void Init(EntityAgent entity)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			base.Init(entity);
			if (eatAnimation != null)
			{
				EatAnimationMeta = new AnimationMetaData
				{
					Code = eatAnimation.ToLowerInvariant(),
					Animation = eatAnimation.ToLowerInvariant(),
					AnimationSpeed = eatAnimationSpeed
				}.Init();
			}
			if (eatAnimationLooseItems != null)
			{
				EatAnimationMetaLooseItems = new AnimationMetaData
				{
					Code = eatAnimationLooseItems.ToLowerInvariant(),
					Animation = eatAnimationLooseItems.ToLowerInvariant(),
					AnimationSpeed = eatAnimationSpeedLooseItems
				}.Init();
			}
			AssetLocation? sound = Sound;
			Sound = ((sound != null) ? sound.WithPathPrefix("sounds/") : null);
			if (Diet == null)
			{
				Diet = ((Entity)entity).Properties.Attributes["creatureDiet"].AsObject<CreatureDiet>((CreatureDiet)null);
			}
			if (Diet == null)
			{
				((Entity)entity).Api.Logger.Warning("Creature '" + ((RegistryObject)entity).Code.ToShortString() + "' has SeekFoodAndEat task but no Diet specified.");
			}
			if (EatSound != (AssetLocation)null)
			{
				EatSound = EatSound.WithPathPrefixOnce("sounds/");
			}
		}
	}
	public class AiTaskSeekFoodAndEatR : AiTaskBaseR
	{
		protected struct FailedAttempt
		{
			public long LastTryMs;

			public int Count;
		}

		protected long lastPOISearchTotalMs;

		protected long stuckAtMs;

		protected bool stuck;

		protected float currentEatTime;

		protected Dictionary<IAnimalFoodSource, FailedAttempt> failedSeekTargets = new Dictionary<IAnimalFoodSource, FailedAttempt>();

		protected bool soundPlayed;

		protected bool eatAnimationStarted;

		protected float quantityEaten;

		protected POIRegistry poiRegistry;

		protected IAnimalFoodSource? targetPoi;

		protected EntityBehaviorMultiplyBase? multiplyBaseBehavior;

		private readonly Cuboidd cuboidBuffer = new Cuboidd();

		private AiTaskSeekFoodAndEatConfig Config => GetConfig<AiTaskSeekFoodAndEatConfig>();

		public AiTaskSeekFoodAndEatR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			poiRegistry = ((Entity)entity).Api.ModLoader.GetModSystem<POIRegistry>(true) ?? throw new ArgumentException("Could not find POIRegistry modsystem");
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskSeekFoodAndEatConfig>(entity, taskConfig, aiConfig);
			((TreeAttribute)((Entity)entity).WatchedAttributes).SetBool("doesEat", true);
		}

		public override void AfterInitialize()
		{
			base.AfterInitialize();
			multiplyBaseBehavior = ((Entity)entity).GetBehavior<EntityBehaviorMultiplyBase>();
		}

		public override bool ShouldExecute()
		{
			if (lastPOISearchTotalMs + Config.PoiSearchCooldown > ((Entity)entity).World.ElapsedMilliseconds)
			{
				return false;
			}
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			if (multiplyBaseBehavior != null && !multiplyBaseBehavior.ShouldEat && ((Entity)entity).World.Rand.NextDouble() >= (double)Config.ChanceToSeekFoodWithoutEating)
			{
				return false;
			}
			targetPoi = null;
			lastPOISearchTotalMs = ((Entity)entity).World.ElapsedMilliseconds;
			if (Config.EatLooseItems)
			{
				partitionUtil.WalkEntities(((Entity)entity).ServerPos.XYZ, Config.LooseItemsSearchRange, delegate(Entity target)
				{
					EntityItem val = (EntityItem)(object)((target is EntityItem) ? target : null);
					if (val != null && SuitableFoodSource(val.Itemstack))
					{
						targetPoi = new LooseItemFoodSource(val);
						return false;
					}
					return true;
				}, EnumEntitySearchType.Inanimate);
			}
			if (targetPoi == null && Config.EatFoodSources)
			{
				targetPoi = poiRegistry.GetNearestPoi(((Entity)entity).ServerPos.XYZ, Config.PoiSearchRange, delegate(IPointOfInterest poi)
				{
					if (poi.Type != Config.PoiType)
					{
						return false;
					}
					FailedAttempt value;
					return (poi is IAnimalFoodSource animalFoodSource && animalFoodSource.IsSuitableFor((Entity)(object)entity, Config.Diet) && (!failedSeekTargets.TryGetValue(animalFoodSource, out value) || value.Count < Config.SeekPoiMaxAttempts || value.LastTryMs < world.ElapsedMilliseconds - Config.SeekPoiRetryCooldown)) ? true : false;
				}) as IAnimalFoodSource;
			}
			return targetPoi != null;
		}

		public override void StartExecute()
		{
			if (targetPoi == null)
			{
				stopTask = true;
				return;
			}
			base.StartExecute();
			stuckAtMs = long.MinValue;
			stuck = false;
			soundPlayed = false;
			currentEatTime = 0f;
			pathTraverser.NavigateTo_Async(targetPoi.Position, Config.MoveSpeed, MinDistanceToTarget() - 0.1f, OnGoalReached, OnStuck, null, 1000, 1, Config.AiCreatureType);
			eatAnimationStarted = false;
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (targetPoi == null)
			{
				return false;
			}
			FastVec3d val = default(FastVec3d);
			FastVec3d val2 = ((FastVec3d)(ref val)).Set(targetPoi.Position);
			pathTraverser.CurrentTarget.X = val2.X;
			pathTraverser.CurrentTarget.Y = val2.Y;
			pathTraverser.CurrentTarget.Z = val2.Z;
			cuboidBuffer.Set(((Entity)entity).SelectionBox.ToDouble().Translate(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z));
			double num = cuboidBuffer.ShortestDistanceFrom(val2.X, val2.Y, val2.Z);
			float num2 = MinDistanceToTarget();
			if (num <= (double)num2)
			{
				if (!EatTheTarget(dt))
				{
					return false;
				}
			}
			else if (!pathTraverser.Active)
			{
				float num3 = (float)base.Rand.NextDouble() * 0.3f - 0.15f;
				float num4 = (float)base.Rand.NextDouble() * 0.3f - 0.15f;
				if (!pathTraverser.NavigateTo(targetPoi.Position.AddCopy(num3, 0f, num4), Config.MoveSpeed, num2 - 0.15f, OnGoalReached, OnStuck, null, giveUpWhenNoPath: false, 500, 1, Config.AiCreatureType))
				{
					return false;
				}
			}
			if (stuck && (float)((Entity)entity).World.ElapsedMilliseconds > (float)stuckAtMs + Config.EatTimeSec * 1000f)
			{
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			double num = cooldownUntilTotalHours;
			base.FinishExecute(cancelled);
			EntityBehaviorMultiply behavior = ((Entity)entity).GetBehavior<EntityBehaviorMultiply>();
			if (behavior != null && behavior.PortionsLeftToEat > 0f && !behavior.IsPregnant)
			{
				cooldownUntilTotalHours = num + Config.MinCooldownHours + ((Entity)entity).World.Rand.NextDouble() * (Config.MaxCooldownHours - Config.MinCooldownHours);
			}
			else
			{
				cooldownUntilTotalHours = ((Entity)entity).Api.World.Calendar.TotalHours + Config.MinCooldownHours + ((Entity)entity).World.Rand.NextDouble() * (Config.MaxCooldownHours - Config.MinCooldownHours);
			}
			pathTraverser.Stop();
			if (Config.EatAnimationMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(Config.EatAnimationMeta.Code);
			}
			if (cancelled)
			{
				cooldownUntilTotalHours = 0.0;
			}
			if (quantityEaten < 1f)
			{
				cooldownUntilTotalHours = 0.0;
			}
			else
			{
				quantityEaten = 0f;
			}
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		protected virtual float MinDistanceToTarget()
		{
			return Math.Max(Config.ExtraTargetDistance, ((Entity)entity).SelectionBox.XSize / 2f + 0.05f);
		}

		protected virtual bool SuitableFoodSource(ItemStack itemStack)
		{
			return Config.Diet?.Matches(itemStack) ?? true;
		}

		protected virtual void OnStuck()
		{
			if (targetPoi != null)
			{
				stuckAtMs = ((Entity)entity).World.ElapsedMilliseconds;
				stuck = true;
				failedSeekTargets.TryGetValue(targetPoi, out var value);
				value.Count++;
				value.LastTryMs = world.ElapsedMilliseconds;
				failedSeekTargets[targetPoi] = value;
			}
		}

		protected virtual void OnGoalReached()
		{
			if (targetPoi != null)
			{
				pathTraverser.Active = true;
				failedSeekTargets.Remove(targetPoi);
			}
		}

		protected virtual bool EatTheTarget(float dt)
		{
			//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Expected O, but got Unknown
			//IL_01f9: Expected O, but got Unknown
			if (targetPoi == null)
			{
				return false;
			}
			pathTraverser.Stop();
			if (Config.AnimationMeta != null)
			{
				((Entity)entity).AnimManager.StopAnimation(Config.AnimationMeta.Code);
			}
			if (multiplyBaseBehavior != null && !multiplyBaseBehavior.ShouldEat)
			{
				return false;
			}
			if (!targetPoi.IsSuitableFor((Entity)(object)entity, Config.Diet))
			{
				return false;
			}
			if (Config.EatAnimationMeta != null && !eatAnimationStarted)
			{
				((Entity)entity).AnimManager.StartAnimation((targetPoi is LooseItemFoodSource && Config.EatAnimationMetaLooseItems != null) ? Config.EatAnimationMetaLooseItems : Config.EatAnimationMeta);
				eatAnimationStarted = true;
			}
			currentEatTime += dt;
			if (targetPoi is LooseItemFoodSource looseItemFoodSource)
			{
				((Entity)entity).World.SpawnCubeParticles(targetPoi.Position, looseItemFoodSource.ItemStack, 0.25f, 1, 0.25f + 0.5f * (float)((Entity)entity).World.Rand.NextDouble(), (IPlayer)null, (Vec3f)null);
			}
			if (currentEatTime > Config.EatTimeSoundSec && !soundPlayed)
			{
				soundPlayed = true;
				if (Config.EatSound != (AssetLocation)null)
				{
					((Entity)entity).World.PlaySoundAt(Config.EatSound, (Entity)(object)entity, (IPlayer)null, true, Config.EatSoundRange, Config.EatSoundVolume);
				}
			}
			if (currentEatTime >= Config.EatTimeSec)
			{
				ITreeAttribute val = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("hunger");
				if (val == null)
				{
					SyncedTreeAttribute watchedAttributes = ((Entity)entity).WatchedAttributes;
					TreeAttribute val2 = new TreeAttribute();
					val = (ITreeAttribute)val2;
					((TreeAttribute)watchedAttributes)["hunger"] = (IAttribute)val2;
				}
				if (Config.DoConsumePortion)
				{
					float num = targetPoi.ConsumeOnePortion((Entity)(object)entity);
					float num2 = num * Config.SaturationPerPortion;
					quantityEaten += num;
					val.SetFloat("saturation", num2 + val.GetFloat("saturation", 0f));
					((TreeAttribute)((Entity)entity).WatchedAttributes).SetDouble("lastMealEatenTotalHours", ((Entity)entity).World.Calendar.TotalHours);
					((Entity)entity).WatchedAttributes.MarkPathDirty("hunger");
				}
				else
				{
					quantityEaten = 1f;
				}
				failedSeekTargets.Remove(targetPoi);
				return false;
			}
			return true;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskShootAtEntityConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public bool Immobile;

		[JsonProperty]
		public float MaxThrowingAngleDeg;

		[JsonProperty]
		public bool RetaliateUnconditionally = true;

		[JsonProperty]
		public float MaxTurnAngleDeg = 360f;

		[JsonProperty]
		public float SpawnAngleDeg;

		[JsonProperty]
		public float DefaultMinTurnAngleDegPerSec = 250f;

		[JsonProperty]
		public float DefaultMaxTurnAngleDegPerSec = 450f;

		[JsonProperty]
		public int ThrowAtMs = 1000;

		[JsonProperty]
		public float VerticalRangeFactor = 0.5f;

		[JsonProperty]
		public AssetLocation ProjectileCode = new AssetLocation("thrownstone-{rock}");

		[JsonProperty]
		public AssetLocation ProjectileItem = new AssetLocation("stone-{rock}");

		[JsonProperty]
		public bool NonCollectible = true;

		[JsonProperty]
		public float ProjectileDamage = 1f;

		[JsonProperty]
		public int ProjectileDamageTier;

		[JsonProperty]
		public EnumDamageType ProjectileDamageType = (EnumDamageType)2;

		[JsonProperty]
		public bool IgnoreInvFrames = true;

		[JsonProperty]
		public float YawDispersionDeg;

		[JsonProperty]
		public float PitchDispersionDeg;

		[JsonProperty]
		public EnumDistribution DispersionDistribution = (EnumDistribution)2;

		[JsonProperty]
		public float MaxYawDispersionDeg;

		[JsonProperty]
		public float MaxPitchDispersionDeg;

		[JsonProperty]
		public float DispersionReductionSpeedDeg;

		[JsonProperty]
		public bool ReplaceRockVariant = true;

		[JsonProperty]
		public float DropOnImpactChance = 1f;

		[JsonProperty]
		public bool DamageStackOnImpact;

		[JsonProperty]
		public AssetLocation? ShootSound;

		[JsonProperty]
		public double ProjectileSpeed = 10.0;

		[JsonProperty]
		public double ProjectileGravityFactor = 1.0;

		public float MaxTurnAngleRad => MaxTurnAngleDeg * ((float)Math.PI / 180f);

		public float SpawnAngleRad => SpawnAngleDeg * ((float)Math.PI / 180f);

		public float MaxThrowingAngleRad => MaxThrowingAngleDeg * ((float)Math.PI / 180f);

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (ShootSound != (AssetLocation)null)
			{
				ShootSound = ShootSound.WithPathPrefixOnce("sounds/");
			}
		}
	}
	public class AiTaskShootAtEntityR : AiTaskBaseTargetableR
	{
		protected float minTurnAnglePerSec;

		protected float maxTurnAnglePerSec;

		protected float currentTurnRadPerSec;

		protected bool alreadyThrown;

		protected long previousTargetId;

		protected float currentYawDispersion;

		protected float currentPitchDispersion;

		protected const string defaultRockType = "granite";

		protected readonly NatFloat randomFloat;

		private AiTaskShootAtEntityConfig Config => GetConfig<AiTaskShootAtEntityConfig>();

		public AiTaskShootAtEntityR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskShootAtEntityConfig>(entity, taskConfig, aiConfig);
			randomFloat = new NatFloat(0f, 1f, Config.DispersionDistribution);
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed() && (!Config.RetaliateUnconditionally || !base.RecentlyAttacked))
			{
				return false;
			}
			if (!CheckAndResetSearchCooldown())
			{
				return false;
			}
			return SearchForTarget();
		}

		public override void StartExecute()
		{
			if (targetEntity != null)
			{
				base.StartExecute();
				EntityServerProperties server = ((Entity)entity).Properties.Server;
				object obj;
				if (server == null)
				{
					obj = null;
				}
				else
				{
					ITreeAttribute attributes = ((EntitySidedProperties)server).Attributes;
					obj = ((attributes != null) ? attributes.GetTreeAttribute("pathfinder") : null);
				}
				ITreeAttribute val = (ITreeAttribute)obj;
				if (val != null)
				{
					minTurnAnglePerSec = val.GetFloat("minTurnAnglePerSec", Config.DefaultMinTurnAngleDegPerSec);
					maxTurnAnglePerSec = val.GetFloat("maxTurnAnglePerSec", Config.DefaultMaxTurnAngleDegPerSec);
				}
				else
				{
					minTurnAnglePerSec = Config.DefaultMinTurnAngleDegPerSec;
					maxTurnAnglePerSec = Config.DefaultMaxTurnAngleDegPerSec;
				}
				currentTurnRadPerSec = minTurnAnglePerSec + (float)base.Rand.NextDouble() * (maxTurnAnglePerSec - minTurnAnglePerSec);
				currentTurnRadPerSec *= (float)Math.PI / 180f;
				alreadyThrown = false;
			}
		}

		public override bool ContinueExecute(float dt)
		{
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (targetEntity == null)
			{
				return false;
			}
			AdjustYaw(dt);
			if (((Entity)entity).World.ElapsedMilliseconds - executionStartTimeMs > Config.ThrowAtMs && !alreadyThrown)
			{
				SetOrAdjustDispersion();
				ShootProjectile();
				alreadyThrown = true;
			}
			return true;
		}

		protected override bool IsTargetableEntity(Entity target, float range)
		{
			if (!base.IsTargetableEntity(target, range))
			{
				return false;
			}
			if (!HasDirectContact(target, range, range * Config.VerticalRangeFactor))
			{
				return false;
			}
			if (!CanAimAt(target))
			{
				return false;
			}
			return true;
		}

		protected virtual float GetAimYaw(Entity targetEntity)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			FastVec3f val = default(FastVec3f);
			((FastVec3f)(ref val)).Set((float)(targetEntity.ServerPos.X - ((Entity)entity).ServerPos.X), (float)(targetEntity.ServerPos.Y - ((Entity)entity).ServerPos.Y), (float)(targetEntity.ServerPos.Z - ((Entity)entity).ServerPos.Z));
			return MathF.Atan2(val.X, val.Z);
		}

		protected virtual bool CanAimAt(Entity target)
		{
			if (!Config.Immobile)
			{
				return true;
			}
			float aimYaw = GetAimYaw(target);
			if (aimYaw > Config.SpawnAngleRad - Config.MaxTurnAngleRad - Config.MaxThrowingAngleRad)
			{
				return aimYaw < Config.SpawnAngleRad + Config.MaxTurnAngleRad + Config.MaxThrowingAngleRad;
			}
			return false;
		}

		protected virtual AssetLocation ReplaceRockType(AssetLocation code)
		{
			if (!Config.ReplaceRockVariant)
			{
				return code;
			}
			AssetLocation obj = code.Clone();
			string newValue = "granite";
			IMapChunk mapChunkAtBlockPos = ((Entity)entity).World.BlockAccessor.GetMapChunkAtBlockPos(((Entity)entity).Pos.AsBlockPos);
			if (mapChunkAtBlockPos != null)
			{
				int num = (int)((Entity)entity).Pos.Z % 32;
				int num2 = (int)((Entity)entity).Pos.X % 32;
				newValue = ((RegistryObject)((Entity)entity).World.Blocks[mapChunkAtBlockPos.TopRockIdMap[num * 32 + num2]]).Variant["rock"] ?? "granite";
			}
			obj.Path = obj.Path.Replace("{rock}", newValue);
			return obj;
		}

		protected virtual void SetOrAdjustDispersion()
		{
			if (targetEntity != null)
			{
				if (targetEntity.EntityId == previousTargetId)
				{
					currentYawDispersion = MathF.Max(Config.YawDispersionDeg, currentYawDispersion - Config.DispersionReductionSpeedDeg);
					currentPitchDispersion = MathF.Max(Config.PitchDispersionDeg, currentPitchDispersion - Config.DispersionReductionSpeedDeg);
				}
				else
				{
					currentYawDispersion = MathF.Max(Config.MaxYawDispersionDeg, Config.YawDispersionDeg);
					currentPitchDispersion = MathF.Max(Config.MaxPitchDispersionDeg, Config.PitchDispersionDeg);
					previousTargetId = targetEntity.EntityId;
				}
			}
		}

		protected virtual void AdjustYaw(float dt)
		{
			if (targetEntity != null)
			{
				float aimYaw = GetAimYaw(targetEntity);
				aimYaw = GameMath.Clamp(aimYaw, Config.SpawnAngleRad - Config.MaxTurnAngleRad, Config.SpawnAngleRad + Config.MaxTurnAngleRad);
				float num = GameMath.AngleRadDistance(((Entity)entity).ServerPos.Yaw, aimYaw);
				EntityPos serverPos = ((Entity)entity).ServerPos;
				serverPos.Yaw += GameMath.Clamp(num, (0f - currentTurnRadPerSec) * dt, currentTurnRadPerSec * dt);
				EntityPos serverPos2 = ((Entity)entity).ServerPos;
				serverPos2.Yaw %= (float)Math.PI * 2f;
			}
		}

		protected virtual void ShootProjectile()
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Expected O, but got Unknown
			if (targetEntity != null)
			{
				CreateProjectile(out Entity projectileEntity, out IProjectile projectile, out Item projectileItem);
				projectile.FiredBy = (Entity)(object)entity;
				projectile.Damage = Config.ProjectileDamage;
				projectile.DamageTier = Config.ProjectileDamageTier;
				projectile.DamageType = Config.ProjectileDamageType;
				projectile.IgnoreInvFrames = Config.IgnoreInvFrames;
				projectile.ProjectileStack = new ItemStack(projectileItem, 1);
				projectile.NonCollectible = Config.NonCollectible;
				projectile.DropOnImpactChance = Config.DropOnImpactChance;
				projectile.DamageStackOnImpact = Config.DamageStackOnImpact;
				SetProjectilePositionAndVelocity(projectileEntity, projectile, Config.ProjectileGravityFactor, Config.ProjectileSpeed);
				((Entity)entity).World.SpawnPriorityEntity(projectileEntity);
				if (Config.ShootSound != (AssetLocation)null)
				{
					((Entity)entity).World.PlaySoundAt(Config.ShootSound, (Entity)(object)entity, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
				}
			}
		}

		protected virtual void CreateProjectile(out Entity projectileEntity, out IProjectile projectile, out Item projectileItem)
		{
			AssetLocation val = ReplaceRockType(Config.ProjectileCode);
			AssetLocation val2 = ReplaceRockType(Config.ProjectileItem);
			EntityProperties entityType = ((Entity)entity).World.GetEntityType(val);
			if (entityType == null)
			{
				throw new ArgumentException($"Error while running '{Config.Code}' AI task for entity '{((RegistryObject)entity).Code}': projectile entity with code '{val}' does not exist");
			}
			Entity val3 = ((Entity)entity).World.ClassRegistry.CreateEntity(entityType);
			if (val3 == null)
			{
				throw new ArgumentException($"Error while running '{Config.Code}' AI task for entity '{((RegistryObject)entity).Code}': unable to create entity with code '{val}'.");
			}
			IProjectile val4 = (IProjectile)(object)((val3 is IProjectile) ? val3 : null);
			if (val4 == null)
			{
				throw new ArgumentException($"Error while running '{Config.Code}' AI task for entity '{((RegistryObject)entity).Code}': projectile entity '{val}' should have 'IProjectile' interface.");
			}
			projectile = val4;
			Item item = ((Entity)entity).World.GetItem(val2);
			if (item == null)
			{
				throw new ArgumentException($"Error while running '{Config.Code}' AI task for entity '{((RegistryObject)entity).Code}': projectile item '{val2}' does not exist.");
			}
			projectileItem = item;
			projectileEntity = val3;
		}

		protected virtual void SetProjectilePositionAndVelocity(Entity projectileEntity, IProjectile projectile, double gravityFactor, double speed)
		{
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01db: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			if (targetEntity == null)
			{
				return;
			}
			Vec3d val = ((Entity)entity).ServerPos.XYZ.Add(0.0, ((Entity)entity).LocalEyePos.Y, 0.0);
			Vec3d val2 = targetEntity.ServerPos.XYZ.Add(0.0, targetEntity.LocalEyePos.Y, 0.0);
			float num = 1f / 60f;
			speed *= (double)num;
			double acceleration = gravityFactor * (double)GlobalConstants.GravityPerSecond * (double)num;
			double num2 = (val2 - val).Length() / speed;
			val2 += targetEntity.ServerPos.Motion * num2;
			FastVec3d start = default(FastVec3d);
			((FastVec3d)(ref start))._002Ector(val.X, val.Y, val.Z);
			FastVec3d target = default(FastVec3d);
			((FastVec3d)(ref target))._002Ector(val2.X, val2.Y, val2.Z);
			FastVec3d velocity = default(FastVec3d);
			((FastVec3d)(ref velocity))._002Ector(0.0, 0.0, 0.0);
			bool flag = false;
			for (int i = 0; i < 30; i++)
			{
				flag = SolveBallisticArc(out velocity, start, target, speed, acceleration);
				if (flag)
				{
					break;
				}
				speed *= 1.100000023841858;
			}
			if (!flag)
			{
				FallBackVelocity(out velocity, start, target);
			}
			velocity = ApplyDispersionToVelocity(velocity, currentYawDispersion, currentPitchDispersion);
			projectileEntity.ServerPos.SetPosWithDimension(((Entity)entity).ServerPos.BehindCopy(0.21).XYZ.Add(0.0, ((Entity)entity).LocalEyePos.Y, 0.0));
			projectileEntity.ServerPos.Motion.Set(velocity.X, velocity.Y, velocity.Z);
			projectileEntity.Pos.SetFrom(projectileEntity.ServerPos);
			projectileEntity.World = ((Entity)entity).World;
			projectile.PreInitialize();
		}

		protected virtual bool SolveBallisticArc(out FastVec3d velocity, FastVec3d start, FastVec3d target, double speed, double acceleration)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			Vector3d start2 = default(Vector3d);
			((Vector3d)(ref start2))._002Ector(start.X, start.Y, start.Z);
			Vector3d target2 = default(Vector3d);
			((Vector3d)(ref target2))._002Ector(target.X, target.Y, target.Z);
			Vector3d velocity2;
			bool result = SolveBallisticArc(out velocity2, start2, target2, speed, acceleration);
			velocity = new FastVec3d(velocity2.X, velocity2.Y, velocity2.Z);
			return result;
		}

		protected virtual bool SolveBallisticArc(out Vector3d velocity, Vector3d start, Vector3d target, double speed, double acceleration)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			velocity = Vector3d.Zero;
			Vector3d val = target - start;
			Vector2d val2 = default(Vector2d);
			((Vector2d)(ref val2))._002Ector(val.X, val.Z);
			double length = ((Vector2d)(ref val2)).Length;
			double y = val.Y;
			double num = speed * speed;
			double num2 = num * num - acceleration * (acceleration * length * length + 2.0 * y * num);
			if (num2 < 0.0)
			{
				return false;
			}
			double num3 = Math.Sqrt(num2);
			double num4 = Math.Atan2(num - num3, acceleration * length);
			double num5 = speed * Math.Sin(num4);
			double num6 = speed * Math.Cos(num4);
			Vector2d val3 = Vector2d.Normalize(val2);
			double num7 = val3.X * num6;
			double num8 = val3.Y * num6;
			velocity = new Vector3d(num7, num5, num8);
			return true;
		}

		protected virtual void FallBackVelocity(out FastVec3d velocity, FastVec3d start, FastVec3d target)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Expected O, but got Unknown
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Expected O, but got Unknown
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (targetEntity == null)
			{
				velocity = new FastVec3d(0.0, 0.0, 0.0);
				return;
			}
			Vec3d val = new Vec3d(start.X, start.Y, start.Z);
			Vec3d val2 = new Vec3d(target.X, target.Y, target.Z);
			double num = Math.Pow(val.SquareDistanceTo(val2), 0.1);
			Vec3d val3 = (val2 - val).Normalize() * GameMath.Clamp(num - 1.0, 0.10000000149011612, 1.0);
			velocity = new FastVec3d(val3.X, val3.Y, val3.Z);
		}

		protected virtual FastVec3d ApplyDispersionToVelocity(FastVec3d velocity, float yawDispersionDeg, float pitchDispersionDeg)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			Vector3d direction = Vector3d.Normalize(new Vector3d(velocity.X, velocity.Y, velocity.Z));
			Vector2 dispersionDeg = default(Vector2);
			((Vector2)(ref dispersionDeg))._002Ector(yawDispersionDeg, pitchDispersionDeg);
			Vector3d directionWithDispersion = GetDirectionWithDispersion(direction, dispersionDeg);
			double num = ((FastVec3d)(ref velocity)).Length();
			return new FastVec3d(directionWithDispersion.X * num, directionWithDispersion.Y * num, directionWithDispersion.Z * num);
		}

		protected virtual Vector3d GetDirectionWithDispersion(Vector3d direction, Vector2 dispersionDeg)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			float num = randomFloat.nextFloat() * dispersionDeg.Y * ((float)Math.PI / 180f);
			float num2 = randomFloat.nextFloat() * dispersionDeg.X * ((float)Math.PI / 180f);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))._002Ector(0f, 0f, 1f);
			Vector3d val2 = Vector3.op_Implicit(val) - direction;
			if (!(((Vector3d)(ref val2)).Length < 1000000000.0))
			{
				val2 = Vector3.op_Implicit(val) + direction;
				if (!(((Vector3d)(ref val2)).Length < 1000000000.0))
				{
					goto IL_00a3;
				}
			}
			((Vector3)(ref val))._002Ector(0f, 1f, 0f);
			goto IL_00a3;
			IL_00a3:
			Vector3d val3 = Vector3d.Normalize(direction);
			Vector3d val4 = Vector3d.Normalize(Vector3d.Cross(val3, Vector3.op_Implicit(val)));
			Vector3d val5 = Vector3d.Normalize(Vector3d.Cross(val4, val3));
			Vector3d val6 = val4 * Math.Tan(num2);
			Vector3d val7 = val5 * Math.Tan(num);
			return Vector3d.Normalize(val3 + val6 + val7);
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskStayCloseToEntityConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public float MoveSpeed = 0.03f;

		[JsonProperty]
		public float TeleportMaxRange = float.MaxValue;

		[JsonProperty]
		public float MinTimeBeforeGiveUpSec = 3f;

		[JsonProperty]
		public float ExtraMinDistanceToTarget = 1f;

		[JsonProperty]
		public EnumAICreatureType? AiCreatureType = (EnumAICreatureType)1;

		[JsonProperty]
		public float RandomTargetOffset = 2f;

		[JsonProperty]
		public float MinDistanceToRetarget = 3f;

		[JsonProperty]
		public bool AllowTeleport;

		[JsonProperty]
		public float TeleportAfterRange = 30f;

		[JsonProperty]
		public float TeleportDelaySec = 4f;

		[JsonProperty]
		public float TeleportChance = 0.05f;

		[JsonProperty]
		public float MinTeleportDistanceToTarget = 2f;

		[JsonProperty]
		public float MaxTeleportDistanceToTarget = 4.5f;

		[JsonProperty]
		public float MinRangeToTrigger = float.MinValue;

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (MinRangeToTrigger <= float.MinValue)
			{
				MinRangeToTrigger = ExtraMinDistanceToTarget;
			}
		}
	}
	public class AiTaskStayCloseToEntityR : AiTaskBaseTargetableR
	{
		protected bool stuck;

		protected FastVec3d targetOffset;

		protected FastVec3d initialTargetPos;

		protected float executingTimeSec;

		protected int stuckCounter;

		private readonly BlockPos blockPosBuffer = new BlockPos(0);

		public virtual float TeleportMaxRange => Config.TeleportMaxRange;

		public virtual int AllowTeleportCount { get; set; }

		private AiTaskStayCloseToEntityConfig Config => GetConfig<AiTaskStayCloseToEntityConfig>();

		public AiTaskStayCloseToEntityR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskStayCloseToEntityConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			if (stuckCounter > 3)
			{
				stuckCounter = 0;
				cooldownUntilMs = ((Entity)entity).World.ElapsedMilliseconds + 60000;
			}
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			if (!SearchForTarget())
			{
				return false;
			}
			if (targetEntity != null)
			{
				float num = ((Entity)entity).ServerPos.SquareDistanceTo(targetEntity.ServerPos);
				float num2 = MinDistanceToTarget(Config.MinRangeToTrigger);
				if (num <= num2 * num2)
				{
					return false;
				}
			}
			return true;
		}

		public override void StartExecute()
		{
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			if (targetEntity != null)
			{
				base.StartExecute();
				executingTimeSec = 0f;
				((FastVec3d)(ref initialTargetPos)).Set(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
				pathTraverser.NavigateTo_Async(targetEntity.ServerPos.XYZ, Config.MoveSpeed, MinDistanceToTarget(Config.ExtraMinDistanceToTarget), OnGoalReached, OnStuck, OnNoPath, 1000, 1, Config.AiCreatureType);
				((FastVec3d)(ref targetOffset)).Set(((Entity)entity).World.Rand.NextDouble() * (double)Config.RandomTargetOffset - (double)(Config.RandomTargetOffset / 2f), 0.0, ((Entity)entity).World.Rand.NextDouble() * (double)Config.RandomTargetOffset - (double)(Config.RandomTargetOffset / 2f));
				stuck = false;
			}
		}

		public override bool ContinueExecute(float dt)
		{
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (targetEntity == null)
			{
				return false;
			}
			if (((FastVec3d)(ref initialTargetPos)).Distance(targetEntity.ServerPos.XYZ) > (double)Config.MinDistanceToRetarget)
			{
				((FastVec3d)(ref initialTargetPos)).Set(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
				pathTraverser.Retarget();
			}
			double num = targetEntity.ServerPos.X + targetOffset.X;
			double y = targetEntity.ServerPos.Y;
			double num2 = targetEntity.ServerPos.Z + targetOffset.Z;
			pathTraverser.CurrentTarget.X = num;
			pathTraverser.CurrentTarget.Y = y;
			pathTraverser.CurrentTarget.Z = num2;
			float num3 = ((Entity)entity).ServerPos.SquareDistanceTo(num, y, num2);
			float num4 = MinDistanceToTarget();
			if (num3 < num4 * num4)
			{
				pathTraverser.Stop();
				return false;
			}
			if ((Config.AllowTeleport || AllowTeleportCount > 0) && executingTimeSec > Config.TeleportDelaySec && (num3 > Config.TeleportAfterRange * Config.TeleportAfterRange || stuck) && num3 < Config.TeleportMaxRange * Config.TeleportMaxRange && base.Rand.NextDouble() < (double)Config.TeleportChance)
			{
				TryTeleport();
			}
			executingTimeSec += dt;
			if (stuck || !pathTraverser.Active)
			{
				return executingTimeSec < Config.MinTimeBeforeGiveUpSec;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			if (stuck)
			{
				stuckCounter++;
			}
			else
			{
				stuckCounter = 0;
			}
			base.FinishExecute(cancelled);
		}

		public override bool CanContinueExecute()
		{
			return pathTraverser.Ready;
		}

		protected virtual bool FindDecentTeleportPos(out FastVec3d teleportPosition)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			teleportPosition = default(FastVec3d);
			if (targetEntity == null)
			{
				return false;
			}
			IBlockAccessor val = ((Entity)entity).World.BlockAccessor;
			for (int i = (int)Config.MinTeleportDistanceToTarget * 5; i < (int)(Config.MaxTeleportDistanceToTarget + 1f) * 5; i++)
			{
				float num = GameMath.Clamp((float)i / 5f, Config.MinTeleportDistanceToTarget, Config.MaxTeleportDistanceToTarget);
				double num2 = base.Rand.NextDouble() * 2.0 * (double)num - (double)num;
				double num3 = base.Rand.NextDouble() * 2.0 * (double)num - (double)num;
				for (int j = 0; j < 8; j++)
				{
					int num4 = (1 - j % 2 * 2) * (int)Math.Ceiling((float)j / 2f);
					((FastVec3d)(ref teleportPosition)).Set(targetEntity.ServerPos.X + num2, targetEntity.ServerPos.Y + (double)num4, targetEntity.ServerPos.Z + num3);
					blockPosBuffer.Set((int)teleportPosition.X, (int)teleportPosition.Y, (int)teleportPosition.Z);
					Block block = val.GetBlock(blockPosBuffer);
					Cuboidf[] collisionBoxes = block.GetCollisionBoxes(val, blockPosBuffer);
					if (collisionBoxes != null && collisionBoxes.Length != 0)
					{
						continue;
					}
					JsonObject attributes = ((CollectibleObject)block).Attributes;
					if (attributes != null && attributes["insideDamage"].AsInt(0) > 0)
					{
						continue;
					}
					blockPosBuffer.Set((int)teleportPosition.X, (int)teleportPosition.Y - 1, (int)teleportPosition.Z);
					Block block2 = val.GetBlock(blockPosBuffer);
					collisionBoxes = block2.GetCollisionBoxes(val, blockPosBuffer);
					if (collisionBoxes == null || collisionBoxes.Length == 0)
					{
						continue;
					}
					JsonObject attributes2 = ((CollectibleObject)block2).Attributes;
					if (attributes2 == null || attributes2["insideDamage"].AsInt(0) <= 0)
					{
						teleportPosition.Y = (float)((int)teleportPosition.Y - 1) + collisionBoxes.Max((Cuboidf cuboid) => cuboid.Y2);
						return true;
					}
				}
			}
			return false;
		}

		protected virtual void TryTeleport()
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			if ((Config.AllowTeleport || AllowTeleportCount > 0) && targetEntity != null && FindDecentTeleportPos(out var teleportPosition))
			{
				((Entity)entity).TeleportToDouble(teleportPosition.X, teleportPosition.Y, teleportPosition.Z, (Action)delegate
				{
					//IL_0036: Unknown result type (might be due to invalid IL or missing references)
					((FastVec3d)(ref initialTargetPos)).Set(targetEntity.ServerPos.X, targetEntity.ServerPos.Y, targetEntity.ServerPos.Z);
					pathTraverser.Retarget();
					AllowTeleportCount = Math.Max(0, AllowTeleportCount - 1);
				});
			}
		}

		protected virtual void OnStuck()
		{
			stuck = true;
		}

		protected virtual void OnNoPath()
		{
		}

		protected virtual void OnGoalReached()
		{
			stopTask = true;
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskStayInRangeConfig : AiTaskBaseTargetableConfig
	{
		[JsonProperty]
		public bool RetaliateUnconditionally;

		[JsonProperty]
		public float TargetRangeMin = 15f;

		[JsonProperty]
		public float TargetRangeMax = 25f;

		[JsonProperty]
		public float MoveSpeed = 0.02f;

		[JsonProperty]
		public EnumAICreatureType AiCreatureType;

		[JsonProperty]
		public bool CanStepInLiquid;
	}
	public class AiTaskStayInRangeR : AiTaskBaseTargetableR
	{
		private AiTaskStayInRangeConfig Config => GetConfig<AiTaskStayInRangeConfig>();

		public new Entity? TargetEntity
		{
			get
			{
				return targetEntity;
			}
			set
			{
				targetEntity = value;
			}
		}

		public AiTaskStayInRangeR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskStayInRangeConfig>(entity, taskConfig, aiConfig);
		}

		public override bool ShouldExecute()
		{
			if (targetEntity != null)
			{
				return CheckIfOutOfRange();
			}
			if (!PreconditionsSatisficed() && (!Config.RetaliateUnconditionally || !base.RecentlyAttacked))
			{
				return false;
			}
			if (!base.RecentlyAttacked)
			{
				attackedByEntity = null;
			}
			if (!CheckAndResetSearchCooldown())
			{
				return false;
			}
			if (Config.RetaliateAttacks && attackedByEntity != null && attackedByEntity.Alive && attackedByEntity.IsInteractable && CanSense(attackedByEntity, GetSeekingRange()) && !entity.ToleratesDamageFrom(attackedByEntity))
			{
				targetEntity = attackedByEntity;
				return true;
			}
			SearchForTarget();
			if (targetEntity != null)
			{
				return CheckIfOutOfRange();
			}
			return false;
		}

		public override bool ContinueExecute(float dt)
		{
			if (!ContinueExecuteChecks(dt))
			{
				return false;
			}
			if (pathTraverser.Active)
			{
				return true;
			}
			CheckIfOutOfRange(out var tooFar, out var tooNear);
			bool flag = false;
			if (tooFar)
			{
				flag = WalkTowards(-1);
			}
			else if (tooNear)
			{
				flag = WalkTowards(1);
			}
			if (flag)
			{
				return tooFar || tooNear;
			}
			return false;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			targetEntity = null;
		}

		protected virtual bool CheckIfOutOfRange()
		{
			bool tooFar;
			bool tooNear;
			return CheckIfOutOfRange(out tooFar, out tooNear);
		}

		protected virtual bool CheckIfOutOfRange(out bool tooFar, out bool tooNear)
		{
			tooFar = false;
			tooNear = false;
			if (targetEntity == null)
			{
				return false;
			}
			double num = ((Entity)entity).ServerPos.SquareDistanceTo(targetEntity.ServerPos.XYZ);
			tooFar = num >= (double)(Config.TargetRangeMin * Config.TargetRangeMin);
			tooNear = num <= (double)(Config.TargetRangeMax * Config.TargetRangeMax);
			return tooNear | tooFar;
		}

		protected virtual bool WalkTowards(int sign)
		{
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Expected O, but got Unknown
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Expected O, but got Unknown
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01de: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e4: Expected O, but got Unknown
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			_ = ((Entity)entity).World.BlockAccessor;
			Vec3d xYZ = ((Entity)entity).ServerPos.XYZ;
			Vec3d val = xYZ.SubCopy(targetEntity.ServerPos.X, xYZ.Y, targetEntity.ServerPos.Z).Normalize();
			Vec3d val2 = xYZ + (float)sign * val;
			Vec3d val3 = new Vec3d((double)(int)val2.X + 0.5, (double)(int)val2.Y, (double)(int)val2.Z + 0.5);
			if (CanStepTowards(val2))
			{
				pathTraverser.WalkTowards(val2, Config.MoveSpeed, 0.3f, OnGoalReached, OnStuck, Config.AiCreatureType);
				return true;
			}
			int num = 1 - ((Entity)entity).World.Rand.Next(2) * 2;
			Vec3d val4 = val.RotatedCopy((float)num * ((float)Math.PI / 2f));
			val2 = xYZ + val4;
			val3 = new Vec3d((double)(int)val2.X + 0.5, (double)(int)val2.Y, (double)(int)val2.Z + 0.5);
			if (CanStepTowards(val3))
			{
				pathTraverser.WalkTowards(val2, Config.MoveSpeed, 0.3f, OnGoalReached, OnStuck, Config.AiCreatureType);
				return true;
			}
			Vec3d val5 = val.RotatedCopy((float)(-num) * ((float)Math.PI / 2f));
			val2 = xYZ + val5;
			val3 = new Vec3d((double)(int)val2.X + 0.5, (double)(int)val2.Y, (double)(int)val2.Z + 0.5);
			if (CanStepTowards(val3))
			{
				pathTraverser.WalkTowards(val2, Config.MoveSpeed, 0.3f, OnGoalReached, OnStuck, Config.AiCreatureType);
				return true;
			}
			return false;
		}

		protected virtual bool CanStepTowards(Vec3d nextPos)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			if (targetEntity == null)
			{
				return false;
			}
			Vec3d val = new Vec3d();
			bool flag = world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, nextPos, false);
			if (flag && !world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, val.Set(nextPos).Add(0.0, (double)Math.Min(1f, stepHeight), 0.0), false))
			{
				return true;
			}
			if (flag)
			{
				return false;
			}
			if (IsLiquidAt(nextPos) && !Config.CanStepInLiquid)
			{
				return false;
			}
			if (world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, val.Set(nextPos).Add(0.0, -1.1, 0.0), false))
			{
				nextPos.Y -= 1.0;
				return true;
			}
			if (IsLiquidAt(val) && !Config.CanStepInLiquid)
			{
				return false;
			}
			bool flag2 = world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, val.Set(nextPos).Add(0.0, -2.1, 0.0), false);
			if (flag2 && ((Entity)entity).ServerPos.Y - targetEntity.ServerPos.Y >= 1.0)
			{
				nextPos.Y -= 2.0;
				return true;
			}
			if (IsLiquidAt(val) && !Config.CanStepInLiquid)
			{
				return false;
			}
			bool flag3 = world.CollisionTester.IsColliding(world.BlockAccessor, ((Entity)entity).SelectionBox, val.Set(nextPos).Add(0.0, -3.1, 0.0), false);
			if (!flag2 && flag3 && ((Entity)entity).ServerPos.Y - targetEntity.ServerPos.Y >= 2.0)
			{
				nextPos.Y -= 3.0;
				return true;
			}
			return false;
		}

		protected virtual bool IsLiquidAt(Vec3d pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Expected O, but got Unknown
			BlockPos val = new BlockPos(0);
			val.SetAndCorrectDimension(pos);
			return ((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlock(val)).IsLiquid();
		}

		protected virtual void OnStuck()
		{
		}

		protected virtual void OnGoalReached()
		{
		}
	}
	public enum EnumTurretState
	{
		Idle,
		TurretMode,
		TurretModeLoad,
		TurretModeHold,
		TurretModeFired,
		TurretModeReload,
		TurretModeUnload,
		Stop
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskTurretModeConfig : AiTaskShootAtEntityConfig
	{
		[JsonProperty]
		public float AbortRange = 14f;

		[JsonProperty]
		public float FiringRangeMin = 14f;

		[JsonProperty]
		public float FiringRangeMax = 26f;

		[JsonProperty]
		public float FinishedAnimationProgress = 0.95f;

		[JsonProperty]
		public string LoadAnimation = "load";

		[JsonProperty]
		public string TurretAnimation = "turret";

		[JsonProperty]
		public string LoadFromTurretAnimation = "load-fromturretpose";

		[JsonProperty]
		public string HoldAnimation = "hold";

		[JsonProperty]
		public string FireAnimation = "fire";

		[JsonProperty]
		public string UnloadAnimation = "unload";

		[JsonProperty]
		public string ReloadAnimation = "reload";

		[JsonProperty]
		public AssetLocation? DrawSound;

		[JsonProperty]
		public AssetLocation? ReloadSound;

		public override void Init(EntityAgent entity)
		{
			base.Init(entity);
			if (DrawSound != (AssetLocation)null)
			{
				DrawSound = DrawSound.WithPathPrefixOnce("sounds/");
			}
			if (ReloadSound != (AssetLocation)null)
			{
				ReloadSound = ReloadSound.WithPathPrefixOnce("sounds/");
			}
		}
	}
	public class AiTaskTurretModeR : AiTaskShootAtEntityR
	{
		protected int searchWaitMs = 2000;

		protected EnumTurretState currentState;

		protected IProjectile? prevProjectile;

		protected float currentStateTime;

		private AiTaskTurretModeConfig Config => GetConfig<AiTaskTurretModeConfig>();

		protected virtual bool inFiringRange
		{
			get
			{
				Entity? obj = targetEntity;
				double num = ((obj != null) ? obj.ServerPos.DistanceTo(((Entity)entity).ServerPos) : double.MaxValue);
				if (num >= (double)Config.FiringRangeMin)
				{
					return num <= (double)Config.FiringRangeMax;
				}
				return false;
			}
		}

		protected virtual bool inSensingRange
		{
			get
			{
				Entity? obj = targetEntity;
				return ((obj != null) ? obj.ServerPos.DistanceTo(((Entity)entity).ServerPos) : 3.4028234663852886E+38) <= (double)GetSeekingRange();
			}
		}

		protected virtual bool inAbortRange
		{
			get
			{
				Entity? obj = targetEntity;
				return ((obj != null) ? obj.ServerPos.DistanceTo(((Entity)entity).ServerPos) : 3.4028234663852886E+38) <= (double)Config.AbortRange;
			}
		}

		public AiTaskTurretModeR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskTurretModeConfig>(entity, taskConfig, aiConfig);
		}

		public override void AfterInitialize()
		{
			base.AfterInitialize();
			((Entity)entity).AnimManager.OnAnimationStopped += AnimManager_OnAnimationStopped;
		}

		public override bool ShouldExecute()
		{
			if (base.ShouldExecute())
			{
				return !inAbortRange;
			}
			return false;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			currentState = EnumTurretState.Idle;
			currentStateTime = 0f;
		}

		public override bool ContinueExecute(float dt)
		{
			if (!base.ContinueExecuteChecks(dt))
			{
				return false;
			}
			if (targetEntity == null)
			{
				return false;
			}
			currentStateTime += dt;
			UpdateState();
			AdjustYaw(dt);
			return currentState != EnumTurretState.Stop;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			((Entity)entity).StopAnimation(Config.TurretAnimation);
			((Entity)entity).StopAnimation(Config.HoldAnimation);
			prevProjectile = null;
		}

		protected virtual void UpdateState()
		{
			currentState = currentState switch
			{
				EnumTurretState.Idle => Idle(currentState), 
				EnumTurretState.TurretMode => TurretMode(currentState), 
				EnumTurretState.TurretModeLoad => TurretModeLoad(currentState), 
				EnumTurretState.TurretModeHold => TurretModeHold(currentState), 
				EnumTurretState.TurretModeFired => TurretModeFired(currentState), 
				EnumTurretState.TurretModeReload => TurretModeReload(currentState), 
				EnumTurretState.TurretModeUnload => TurretModeUnload(currentState), 
				EnumTurretState.Stop => currentState, 
				_ => currentState, 
			};
		}

		protected virtual EnumTurretState Idle(EnumTurretState state)
		{
			if (inFiringRange)
			{
				((Entity)entity).StartAnimation(Config.LoadAnimation);
				currentStateTime = 0f;
				return EnumTurretState.TurretMode;
			}
			if (inSensingRange)
			{
				((Entity)entity).StartAnimation(Config.TurretAnimation);
				currentStateTime = 0f;
				return EnumTurretState.TurretMode;
			}
			return state;
		}

		protected virtual EnumTurretState TurretMode(EnumTurretState state)
		{
			if (!IsAnimationFinished(Config.TurretAnimation))
			{
				return state;
			}
			if (inAbortRange)
			{
				Abort();
				return state;
			}
			if (inFiringRange)
			{
				((Entity)entity).StopAnimation(Config.TurretAnimation);
				((Entity)entity).StartAnimation(Config.LoadFromTurretAnimation);
				if (Config.DrawSound != (AssetLocation)null)
				{
					((Entity)entity).World.PlaySoundAt(Config.DrawSound, (Entity)(object)entity, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
				}
				currentStateTime = 0f;
				return EnumTurretState.TurretModeLoad;
			}
			if (currentStateTime > 5f)
			{
				((Entity)entity).StopAnimation(Config.TurretAnimation);
				return EnumTurretState.Stop;
			}
			return state;
		}

		protected virtual EnumTurretState TurretModeLoad(EnumTurretState state)
		{
			if (!IsAnimationFinished(Config.LoadAnimation))
			{
				return state;
			}
			((Entity)entity).StartAnimation(Config.HoldAnimation);
			currentStateTime = 0f;
			return EnumTurretState.TurretModeHold;
		}

		protected virtual EnumTurretState TurretModeHold(EnumTurretState state)
		{
			if (inFiringRange || inAbortRange)
			{
				if ((double)currentStateTime > 1.25)
				{
					SetOrAdjustDispersion();
					ShootProjectile();
					((Entity)entity).StopAnimation(Config.HoldAnimation);
					((Entity)entity).StartAnimation(Config.FireAnimation);
					return EnumTurretState.TurretModeFired;
				}
				return state;
			}
			if (currentStateTime > 2f)
			{
				((Entity)entity).StopAnimation(Config.HoldAnimation);
				((Entity)entity).StartAnimation(Config.UnloadAnimation);
				return EnumTurretState.TurretModeUnload;
			}
			return state;
		}

		protected virtual EnumTurretState TurretModeFired(EnumTurretState state)
		{
			if (targetEntity == null)
			{
				stopTask = true;
				return EnumTurretState.Stop;
			}
			float seekingRange = Config.SeekingRange;
			if (!inAbortRange && targetEntity.Alive)
			{
				Entity? obj = targetEntity;
				EntityPlayer val = (EntityPlayer)(object)((obj is EntityPlayer) ? obj : null);
				if ((val == null || TargetablePlayerMode(val)) && HasDirectContact(targetEntity, seekingRange, seekingRange / 2f))
				{
					if (inSensingRange)
					{
						((Entity)entity).StartAnimation(Config.ReloadAnimation);
						if (Config.ReloadSound != (AssetLocation)null)
						{
							((Entity)entity).World.PlaySoundAt(Config.ReloadSound, (Entity)(object)entity, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
						}
						return EnumTurretState.TurretModeReload;
					}
					return state;
				}
			}
			Abort();
			return state;
		}

		protected virtual EnumTurretState TurretModeReload(EnumTurretState state)
		{
			if (!IsAnimationFinished(Config.ReloadAnimation))
			{
				return state;
			}
			if (inAbortRange)
			{
				Abort();
				return state;
			}
			if (Config.DrawSound != (AssetLocation)null)
			{
				((Entity)entity).World.PlaySoundAt(Config.DrawSound, (Entity)(object)entity, (IPlayer)null, Config.RandomizePitch, Config.SoundRange, Config.SoundVolume);
			}
			return EnumTurretState.TurretModeLoad;
		}

		protected virtual EnumTurretState TurretModeUnload(EnumTurretState state)
		{
			if (!IsAnimationFinished(Config.UnloadAnimation))
			{
				return state;
			}
			return EnumTurretState.Stop;
		}

		protected virtual void Abort()
		{
			currentState = EnumTurretState.Stop;
			((Entity)entity).StopAnimation(Config.HoldAnimation);
			((Entity)entity).StopAnimation(Config.TurretAnimation);
			AiTaskManager aiTaskManager = ((Entity)entity).GetBehavior<EntityBehaviorTaskAI>()?.TaskManager ?? throw new InvalidOperationException("Failed to get task manager");
			AiTaskStayInRangeR task = aiTaskManager.GetTask<AiTaskStayInRangeR>();
			if (task != null && targetEntity != null)
			{
				task.TargetEntity = targetEntity;
				aiTaskManager.ExecuteTask<AiTaskStayInRangeR>();
			}
		}

		protected virtual bool IsAnimationFinished(string animationCode)
		{
			RunningAnimation animationState = ((Entity)entity).AnimManager.GetAnimationState(animationCode);
			if (animationState == null)
			{
				return false;
			}
			if (animationState.Running)
			{
				return animationState.AnimProgress >= Config.FinishedAnimationProgress;
			}
			return true;
		}

		protected virtual void AnimManager_OnAnimationStopped(string anim)
		{
			if (active && targetEntity != null)
			{
				UpdateState();
			}
		}
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class AiTaskWanderConfig : AiTaskBaseConfig
	{
		[JsonProperty]
		public double MaxDistanceToSpawn;

		[JsonProperty]
		public int TeleportToSpawnTimeout = 120000;

		[JsonProperty]
		public float NoPlayersRange = 15f;

		[JsonProperty]
		public float MoveSpeed = 0.03f;

		[JsonProperty]
		public float MinDistanceToTarget = 0.12f;

		[JsonProperty]
		public float MaxHeight = 7f;

		[JsonProperty]
		public int PreferredLightLevel = -1;

		[JsonProperty]
		public EnumLightLevelType PreferredLightLevelType = (EnumLightLevelType)3;

		[JsonProperty]
		private float wanderRangeMin = 3f;

		[JsonProperty]
		private float wanderRangeMax = 30f;

		[JsonProperty]
		private float wanderVerticalRangeMin = 3f;

		[JsonProperty]
		private float wanderVerticalRangeMax = 10f;

		[JsonProperty]
		public bool DoRandomWanderRangeChanges;

		[JsonProperty]
		public int MaxBlocksChecked = 9;

		public NatFloat WanderRangeHorizontal = new NatFloat(0f, 0f, (EnumDistribution)0);

		public NatFloat WanderRangeVertical = new NatFloat(0f, 0f, (EnumDistribution)0);

		public bool IgnoreLightLevel;

		public bool StayCloseToSpawn;

		public override void Init(EntityAgent entity)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			base.Init(entity);
			WanderRangeHorizontal = new NatFloat(wanderRangeMin, wanderRangeMax, (EnumDistribution)6);
			WanderRangeVertical = new NatFloat(wanderVerticalRangeMin, wanderVerticalRangeMax, (EnumDistribution)6);
			StayCloseToSpawn = MaxDistanceToSpawn > 0.0;
			IgnoreLightLevel = PreferredLightLevel < 0;
		}
	}
	public class AiTaskWanderR : AiTaskBaseR
	{
		protected int failedWanders;

		protected long lastTimeInRangeMs;

		protected bool spawnPositionSet;

		protected Vec3d mainTarget = new Vec3d();

		protected Vec3d spawnPosition = new Vec3d();

		protected bool needsToTeleport;

		private readonly Vec4d bestTarget = new Vec4d();

		private readonly Vec4d currentTarget = new Vec4d();

		private readonly BlockPos blockPosBuffer = new BlockPos(0);

		private AiTaskWanderConfig Config => GetConfig<AiTaskWanderConfig>();

		protected float WanderRangeMul
		{
			get
			{
				return ((TreeAttribute)((Entity)entity).Attributes).GetFloat("wanderRangeMul", 1f);
			}
			set
			{
				((TreeAttribute)((Entity)entity).Attributes).SetFloat("wanderRangeMul", value);
			}
		}

		protected int FailedConsecutivePathfinds
		{
			get
			{
				return ((TreeAttribute)((Entity)entity).Attributes).GetInt("failedConsecutivePathfinds", 0);
			}
			set
			{
				((TreeAttribute)((Entity)entity).Attributes).SetInt("failedConsecutivePathfinds", value);
			}
		}

		public AiTaskWanderR(EntityAgent entity, JsonObject taskConfig, JsonObject aiConfig)
			: base(entity, taskConfig, aiConfig)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Expected O, but got Unknown
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Expected O, but got Unknown
			baseConfig = AiTaskBaseR.LoadConfig<AiTaskWanderConfig>(entity, taskConfig, aiConfig);
			spawnPosition = new Vec3d(((TreeAttribute)((Entity)entity).Attributes).GetDouble("spawnX", 0.0), ((TreeAttribute)((Entity)entity).Attributes).GetDouble("spawnY", 0.0), ((TreeAttribute)((Entity)entity).Attributes).GetDouble("spawnZ", 0.0));
		}

		public override bool ShouldExecute()
		{
			if (!PreconditionsSatisficed())
			{
				return false;
			}
			failedWanders = 0;
			needsToTeleport = false;
			if (!Config.StayCloseToSpawn)
			{
				return LoadNextWanderTarget();
			}
			long elapsedMilliseconds = ((Entity)entity).World.ElapsedMilliseconds;
			if ((double)((Entity)entity).ServerPos.XYZ.SquareDistanceTo(spawnPosition.X, spawnPosition.Y, spawnPosition.Z) <= Config.MaxDistanceToSpawn * Config.MaxDistanceToSpawn)
			{
				lastTimeInRangeMs = elapsedMilliseconds;
				return false;
			}
			if (elapsedMilliseconds - lastTimeInRangeMs > Config.TeleportToSpawnTimeout && ((Entity)entity).World.GetNearestEntity(((Entity)entity).ServerPos.XYZ, Config.NoPlayersRange, Config.NoPlayersRange, (ActionConsumable<Entity>)((Entity target) => target is EntityPlayer)) == null)
			{
				needsToTeleport = true;
			}
			mainTarget = spawnPosition;
			return true;
		}

		public override void StartExecute()
		{
			base.StartExecute();
			if (needsToTeleport)
			{
				((Entity)entity).TeleportTo((int)spawnPosition.X, (int)spawnPosition.Y, (int)spawnPosition.Z);
				stopTask = true;
			}
			else
			{
				pathTraverser.WalkTowards(mainTarget, Config.MoveSpeed, Config.MinDistanceToTarget, OnGoalReached, OnStuck, (EnumAICreatureType)0);
			}
		}

		public override bool ContinueExecute(float dt)
		{
			if (!base.ContinueExecute(dt))
			{
				return false;
			}
			if (entity.Controls.IsClimbing && ((Entity)entity).Properties.CanClimbAnywhere && ((Entity)entity).ClimbingIntoFace != null)
			{
				BlockFacing climbingIntoFace = ((Entity)entity).ClimbingIntoFace;
				if (Math.Sign(climbingIntoFace.Normali.X) == Math.Sign(pathTraverser.CurrentTarget.X - ((Entity)entity).ServerPos.X))
				{
					pathTraverser.CurrentTarget.X = ((Entity)entity).ServerPos.X;
				}
				if (Math.Sign(climbingIntoFace.Normali.Y) == Math.Sign(pathTraverser.CurrentTarget.Y - ((Entity)entity).ServerPos.Y))
				{
					pathTraverser.CurrentTarget.Y = ((Entity)entity).ServerPos.Y;
				}
				if (Math.Sign(climbingIntoFace.Normali.Z) == Math.Sign(pathTraverser.CurrentTarget.Z - ((Entity)entity).ServerPos.Z))
				{
					pathTraverser.CurrentTarget.Z = ((Entity)entity).ServerPos.Z;
				}
			}
			if ((double)mainTarget.HorizontalSquareDistanceTo(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Z) < 0.5)
			{
				pathTraverser.Stop();
				return false;
			}
			return true;
		}

		public override void FinishExecute(bool cancelled)
		{
			base.FinishExecute(cancelled);
			if (cancelled)
			{
				pathTraverser.Stop();
			}
		}

		public override void OnEntityLoaded()
		{
			if (!((TreeAttribute)((Entity)entity).Attributes).HasAttribute("spawnX"))
			{
				OnEntitySpawn();
			}
		}

		public override void OnEntitySpawn()
		{
			((TreeAttribute)((Entity)entity).Attributes).SetDouble("spawnX", ((Entity)entity).ServerPos.X);
			((TreeAttribute)((Entity)entity).Attributes).SetDouble("spawnY", ((Entity)entity).ServerPos.Y);
			((TreeAttribute)((Entity)entity).Attributes).SetDouble("spawnZ", ((Entity)entity).ServerPos.Z);
			spawnPosition.Set(((Entity)entity).ServerPos.XYZ);
		}

		protected override bool CheckExecutionChance()
		{
			return base.Rand.NextDouble() <= (double)((failedWanders > 0) ? (1f - Config.ExecutionChance * 4f * (float)failedWanders) : Config.ExecutionChance);
		}

		protected virtual bool LoadNextWanderTarget()
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0217: Expected I4, but got Unknown
			//IL_03de: Unknown result type (might be due to invalid IL or missing references)
			//IL_042a: Unknown result type (might be due to invalid IL or missing references)
			//IL_047d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0487: Expected O, but got Unknown
			//IL_06c1: Unknown result type (might be due to invalid IL or missing references)
			EnumHabitat habitat = ((Entity)entity).Properties.Habitat;
			bool flag = false;
			if (FailedConsecutivePathfinds > 10)
			{
				WanderRangeMul = Math.Max(0.1f, WanderRangeMul * 0.9f);
			}
			else
			{
				WanderRangeMul = Math.Min(1f, WanderRangeMul * 1.1f);
				if (Config.DoRandomWanderRangeChanges && base.Rand.NextDouble() < 0.05)
				{
					WanderRangeMul = Math.Min(1f, WanderRangeMul * 1.5f);
				}
			}
			float num = WanderRangeMul;
			if (Config.DoRandomWanderRangeChanges && base.Rand.NextDouble() < 0.05)
			{
				num *= 3f;
			}
			for (int i = 0; i < Config.MaxBlocksChecked; i++)
			{
				double num2 = Config.WanderRangeHorizontal.nextFloat() * (float)(base.Rand.Next(2) * 2 - 1) * num;
				double num3 = Config.WanderRangeVertical.nextFloat() * (float)(base.Rand.Next(2) * 2 - 1) * num;
				double num4 = Config.WanderRangeHorizontal.nextFloat() * (float)(base.Rand.Next(2) * 2 - 1) * num;
				currentTarget.X = ((Entity)entity).ServerPos.X + num2;
				currentTarget.Y = ((Entity)entity).ServerPos.InternalY + num3;
				currentTarget.Z = ((Entity)entity).ServerPos.Z + num4;
				currentTarget.W = 1.0;
				if (Config.StayCloseToSpawn)
				{
					double num5 = (double)currentTarget.SquareDistanceTo(spawnPosition) / (Config.MaxDistanceToSpawn * Config.MaxDistanceToSpawn);
					currentTarget.W = 1.0 - num5;
				}
				switch ((int)habitat)
				{
				case 2:
				{
					int rainMapHeightAt = world.BlockAccessor.GetRainMapHeightAt((int)currentTarget.X, (int)currentTarget.Z);
					currentTarget.Y = Math.Min(currentTarget.Y, (float)rainMapHeightAt + Config.MaxHeight);
					if (((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)currentTarget.X, (int)currentTarget.Y, (int)currentTarget.Z, 2)).IsLiquid())
					{
						currentTarget.W = 0.0;
					}
					break;
				}
				case 1:
				{
					currentTarget.Y = MoveDownToFloor((int)currentTarget.X, currentTarget.Y, (int)currentTarget.Z);
					if (currentTarget.Y < 0.0)
					{
						currentTarget.W = 0.0;
						break;
					}
					if (((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)currentTarget.X, (int)currentTarget.Y, (int)currentTarget.Z, 2)).IsLiquid())
					{
						Vec4d obj = currentTarget;
						obj.W /= 2.0;
					}
					bool stop = false;
					bool willFall = false;
					float num6 = (float)Math.Atan2(num2, num4) + (float)Math.PI / 2f;
					Vec3d val = new Vec3d(currentTarget.X, currentTarget.Y, currentTarget.Z).Ahead(1.0, 0f, num6);
					Vec3d val2 = new Vec3d(((Entity)entity).ServerPos.X, ((Entity)entity).ServerPos.Y, ((Entity)entity).ServerPos.Z).Ahead(1.0, 0f, num6);
					int prevY = (int)val2.Y;
					GameMath.BresenHamPlotLine2d((int)val2.X, (int)val2.Z, (int)val.X, (int)val.Z, (PlotDelegate2D)delegate(int x, int z)
					{
						if (!stop)
						{
							double num8 = MoveDownToFloor(x, prevY, z);
							if (num8 < 0.0 || (double)prevY - num8 > 4.0)
							{
								willFall = true;
								stop = true;
							}
							if (num8 - (double)prevY > 2.0)
							{
								stop = true;
							}
							prevY = (int)num8;
						}
					});
					if (willFall)
					{
						currentTarget.W = 0.0;
					}
					break;
				}
				case 0:
					if (!((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)currentTarget.X, (int)currentTarget.Y, (int)currentTarget.Z, 2)).IsLiquid())
					{
						currentTarget.W = 0.0;
					}
					break;
				case 3:
					if (!((CollectibleObject)((Entity)entity).World.BlockAccessor.GetBlockRaw((int)currentTarget.X, (int)currentTarget.Y, (int)currentTarget.Z, 2)).IsLiquid())
					{
						currentTarget.W = 0.0;
					}
					else
					{
						currentTarget.W = 1.0 / (Math.Abs(num3) + 1.0);
					}
					break;
				}
				if (currentTarget.W > 0.0)
				{
					for (int num7 = 0; num7 < BlockFacing.HORIZONTALS.Length; num7++)
					{
						if (((Entity)entity).World.BlockAccessor.IsSideSolid((int)currentTarget.X + BlockFacing.HORIZONTALS[num7].Normali.X, (int)currentTarget.Y, (int)currentTarget.Z + BlockFacing.HORIZONTALS[num7].Normali.Z, BlockFacing.HORIZONTALS[num7].Opposite))
						{
							Vec4d obj2 = currentTarget;
							obj2.W *= 0.5;
						}
					}
				}
				if (!Config.IgnoreLightLevel && currentTarget.W != 0.0)
				{
					blockPosBuffer.Set((int)currentTarget.X, (int)currentTarget.Y, (int)currentTarget.Z);
					int val3 = Math.Abs(Config.PreferredLightLevel - ((Entity)entity).World.BlockAccessor.GetLightLevel(blockPosBuffer, Config.PreferredLightLevelType));
					Vec4d obj3 = currentTarget;
					obj3.W /= (double)Math.Max(1, val3);
				}
				if (!flag || currentTarget.W > bestTarget.W)
				{
					flag = true;
					bestTarget.Set(currentTarget.X, currentTarget.Y, currentTarget.Z, currentTarget.W);
					if (currentTarget.W >= 1.0)
					{
						break;
					}
				}
			}
			if (bestTarget.W > 0.0)
			{
				FailedConsecutivePathfinds = Math.Max(FailedConsecutivePathfinds - 3, 0);
				mainTarget.Set(bestTarget.X, bestTarget.Y, bestTarget.Z);
				return true;
			}
			FailedConsecutivePathfinds++;
			return false;
		}

		protected virtual double MoveDownToFloor(int x, double y, int z)
		{
			int num = 5;
			while (num-- > 0)
			{
				if (world.BlockAccessor.IsSideSolid(x, (int)y, z, BlockFacing.UP))
				{
					return y + 1.0;
				}
				y -= 1.0;
			}
			return -1.0;
		}

		protected virtual void OnStuck()
		{
			stopTask = true;
			failedWanders++;
		}

		protected virtual void OnGoalReached()
		{
			stopTask = true;
			failedWanders = 0;
		}
	}
	public class EntityBehaviorAimingAccuracy : EntityBehavior
	{
		public Random Rand;

		public bool IsAiming;

		private List<AccuracyModifier> modifiers = new List<AccuracyModifier>();

		public EntityBehaviorAimingAccuracy(Entity entity)
			: base(entity)
		{
			EntityAgent entity2 = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			modifiers.Add(new BaseAimingAccuracy(entity2));
			modifiers.Add(new MovingAimingAccuracy(entity2));
			modifiers.Add(new SprintAimingAccuracy(entity2));
			modifiers.Add(new OnHurtAimingAccuracy(entity2));
			entity.Attributes.RegisterModifiedListener("aiming", (Action)OnAimingChanged);
			Rand = new Random((int)(entity.EntityId + entity.World.ElapsedMilliseconds));
		}

		private void OnAimingChanged()
		{
			bool isAiming = IsAiming;
			IsAiming = ((TreeAttribute)base.entity.Attributes).GetInt("aiming", 0) > 0;
			if (isAiming == IsAiming)
			{
				return;
			}
			if (IsAiming && base.entity.World is IServerWorldAccessor)
			{
				double num = Rand.NextDouble() - 0.5;
				double num2 = Rand.NextDouble() - 0.5;
				((TreeAttribute)base.entity.WatchedAttributes).SetDouble("aimingRandPitch", num);
				((TreeAttribute)base.entity.WatchedAttributes).SetDouble("aimingRandYaw", num2);
			}
			for (int i = 0; i < modifiers.Count; i++)
			{
				if (IsAiming)
				{
					modifiers[i].BeginAim();
				}
				else
				{
					modifiers[i].EndAim();
				}
			}
		}

		public override void OnGameTick(float deltaTime)
		{
			if (IsAiming)
			{
				if (!base.entity.Alive)
				{
					((TreeAttribute)base.entity.Attributes).SetInt("aiming", 0);
				}
				float accuracy = 0f;
				for (int i = 0; i < modifiers.Count; i++)
				{
					modifiers[i].Update(deltaTime, ref accuracy);
				}
				((TreeAttribute)base.entity.Attributes).SetFloat("aimingAccuracy", accuracy);
			}
		}

		public override void OnEntityReceiveDamage(DamageSource damageSource, ref float damage)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Invalid comparison between Unknown and I4
			((EntityBehavior)this).OnEntityReceiveDamage(damageSource, ref damage);
			if ((int)damageSource.Type != 6)
			{
				for (int i = 0; i < modifiers.Count; i++)
				{
					modifiers[i].OnHurt(damage);
				}
			}
		}

		public override string PropertyName()
		{
			return "aimingaccuracy";
		}
	}
	public class AccuracyModifier
	{
		internal EntityAgent entity;

		internal long aimStartMs;

		public float SecondsSinceAimStart => (float)(((Entity)entity).World.ElapsedMilliseconds - aimStartMs) / 1000f;

		public AccuracyModifier(EntityAgent entity)
		{
			this.entity = entity;
		}

		public virtual void BeginAim()
		{
			aimStartMs = ((Entity)entity).World.ElapsedMilliseconds;
		}

		public virtual void EndAim()
		{
		}

		public virtual void OnHurt(float damage)
		{
		}

		public virtual void Update(float dt, ref float accuracy)
		{
		}
	}
	public class BaseAimingAccuracy : AccuracyModifier
	{
		public BaseAimingAccuracy(EntityAgent entity)
			: base(entity)
		{
		}

		public override void Update(float dt, ref float accuracy)
		{
			float blended = ((Entity)entity).Stats.GetBlended("rangedWeaponsAcc");
			float blended2 = ((Entity)entity).Stats.GetBlended("rangedWeaponsSpeed");
			float num = Math.Min(1f - 0.075f / blended, 1f);
			accuracy = GameMath.Clamp(base.SecondsSinceAimStart * blended2 * 1.7f, 0f, num);
			if (base.SecondsSinceAimStart >= 0.75f)
			{
				accuracy += GameMath.Sin(base.SecondsSinceAimStart * 8f) / 80f / Math.Max(1f, blended);
			}
		}
	}
	public class MovingAimingAccuracy : AccuracyModifier
	{
		private float accuracyPenalty;

		public MovingAimingAccuracy(EntityAgent entity)
			: base(entity)
		{
		}

		public override void Update(float dt, ref float accuracy)
		{
			float blended = ((Entity)entity).Stats.GetBlended("rangedWeaponsAcc");
			if (entity.Controls.TriesToMove)
			{
				accuracyPenalty = GameMath.Clamp(accuracyPenalty + dt / 0.75f, 0f, 0.2f);
			}
			else
			{
				accuracyPenalty = GameMath.Clamp(accuracyPenalty - dt / 2f, 0f, 0.2f);
			}
			accuracy -= accuracyPenalty / Math.Max(1f, blended);
		}
	}
	public class SprintAimingAccuracy : AccuracyModifier
	{
		private float accuracyPenalty;

		public SprintAimingAccuracy(EntityAgent entity)
			: base(entity)
		{
		}

		public override void Update(float dt, ref float accuracy)
		{
			float blended = ((Entity)entity).Stats.GetBlended("rangedWeaponsAcc");
			if (entity.Controls.TriesToMove && entity.Controls.Sprint)
			{
				accuracyPenalty = GameMath.Clamp(accuracyPenalty + dt / 0.75f, 0f, 0.3f);
			}
			else
			{
				accuracyPenalty = GameMath.Clamp(accuracyPenalty - dt / 2f, 0f, 0.3f);
			}
			accuracy -= accuracyPenalty / Math.Max(1f, blended);
		}
	}
	public class OnHurtAimingAccuracy : AccuracyModifier
	{
		private float accuracyPenalty;

		public OnHurtAimingAccuracy(EntityAgent entity)
			: base(entity)
		{
		}

		public override void Update(float dt, ref float accuracy)
		{
			accuracyPenalty = GameMath.Clamp(accuracyPenalty - dt / 3f, 0f, 0.4f);
		}

		public override void OnHurt(float damage)
		{
			if (damage > 3f)
			{
				float blended = ((Entity)entity).Stats.GetBlended("rangedWeaponsAcc");
				accuracyPenalty = -0.4f / Math.Max(1f, blended);
			}
		}
	}
	public class EntityBehaviorBreathe : EntityBehavior
	{
		private ITreeAttribute oxygenTree;

		private float oxygenCached = -1f;

		private float maxOxygen;

		private Cuboidd tmp = new Cuboidd();

		private float breathAccum;

		private float padding = 0.1f;

		private Block suffocationSourceBlock;

		private float damageAccum;

		public float Oxygen
		{
			get
			{
				return oxygenCached = oxygenTree.GetFloat("currentoxygen", 0f);
			}
			set
			{
				if (value != oxygenCached)
				{
					oxygenCached = value;
					oxygenTree.SetFloat("currentoxygen", value);
					base.entity.WatchedAttributes.MarkPathDirty("oxygen");
				}
			}
		}

		public float MaxOxygen
		{
			get
			{
				return maxOxygen;
			}
			set
			{
				maxOxygen = value;
				oxygenTree.SetFloat("maxoxygen", value);
				base.entity.WatchedAttributes.MarkPathDirty("oxygen");
			}
		}

		public bool HasAir
		{
			get
			{
				return oxygenTree.GetBool("hasair", false);
			}
			set
			{
				if (oxygenTree.GetBool("hasair", false) != value)
				{
					oxygenTree.SetBool("hasair", value);
					base.entity.WatchedAttributes.MarkPathDirty("oxygen");
				}
			}
		}

		public EntityBehaviorBreathe(Entity entity)
			: base(entity)
		{
		}//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown


		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Expected O, but got Unknown
			//IL_004b: Expected O, but got Unknown
			((EntityBehavior)this).Initialize(properties, typeAttributes);
			oxygenTree = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("oxygen");
			if (oxygenTree == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				ITreeAttribute val2 = (ITreeAttribute)val;
				oxygenTree = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("oxygen", (IAttribute)(object)val2);
				float num = 40000f;
				if (base.entity is EntityPlayer)
				{
					num = base.entity.World.Config.GetAsInt("lungCapacity", 40000);
				}
				MaxOxygen = typeAttributes["maxoxygen"].AsFloat(num);
				Oxygen = typeAttributes["currentoxygen"].AsFloat(MaxOxygen);
				HasAir = true;
			}
			else
			{
				maxOxygen = oxygenTree.GetFloat("maxoxygen", 0f);
			}
			breathAccum = (float)base.entity.World.Rand.NextDouble();
		}

		public override void OnEntityRevive()
		{
			Oxygen = MaxOxygen;
		}

		public void Check()
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Invalid comparison between Unknown and I4
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Expected O, but got Unknown
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Invalid comparison between Unknown and I4
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Invalid comparison between Unknown and I4
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Expected O, but got Unknown
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Expected O, but got Unknown
			maxOxygen = oxygenTree.GetFloat("maxoxygen", 0f);
			if ((int)base.entity.World.Side == 2)
			{
				return;
			}
			bool hasAir = true;
			if (base.entity is EntityPlayer)
			{
				EntityPlayer val = (EntityPlayer)base.entity;
				EnumGameMode currentGameMode = base.entity.World.PlayerByUid(val.PlayerUID).WorldData.CurrentGameMode;
				if ((int)currentGameMode == 2 || (int)currentGameMode == 3)
				{
					HasAir = true;
					return;
				}
			}
			EntityPos sidedPos = base.entity.SidedPos;
			double num = (base.entity.Swimming ? base.entity.Properties.SwimmingEyeHeight : base.entity.Properties.EyeHeight);
			double num2 = (sidedPos.Y + num) % 1.0;
			BlockPos val2 = new BlockPos((int)(sidedPos.X + base.entity.LocalEyePos.X), (int)(sidedPos.Y + num), (int)(sidedPos.Z + base.entity.LocalEyePos.Z), sidedPos.Dimension);
			Block block = base.entity.World.BlockAccessor.GetBlock(val2, 3);
			JsonObject attributes = ((CollectibleObject)block).Attributes;
			if (attributes == null || attributes["asphyxiating"].AsBool(true))
			{
				Cuboidf[] collisionBoxes = block.GetCollisionBoxes(base.entity.World.BlockAccessor, val2);
				Cuboidf val3 = new Cuboidf();
				if (collisionBoxes != null)
				{
					for (int i = 0; i < collisionBoxes.Length; i++)
					{
						val3.Set(collisionBoxes[i]);
						val3.OmniGrowBy(0f - padding);
						tmp.Set((double)((float)val2.X + val3.X1), (double)((float)val2.Y + val3.Y1), (double)((float)val2.Z + val3.Z1), (double)((float)val2.X + val3.X2), (double)((float)val2.Y + val3.Y2), (double)((float)val2.Z + val3.Z2));
						val3.OmniGrowBy(padding);
						if (tmp.Contains(sidedPos.X + base.entity.LocalEyePos.X, sidedPos.Y + base.entity.LocalEyePos.Y, sidedPos.Z + base.entity.LocalEyePos.Z))
						{
							Cuboidd val4 = base.entity.SelectionBox.ToDouble();
							if (tmp.Intersects(val4))
							{
								hasAir = false;
								suffocationSourceBlock = block;
								break;
							}
						}
					}
				}
			}
			if (((CollectibleObject)block).IsLiquid() && (double)((float)block.LiquidLevel / 7f) > num2)
			{
				hasAir = false;
			}
			HasAir = hasAir;
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Invalid comparison between Unknown and I4
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Expected O, but got Unknown
			if ((int)base.entity.State == 1)
			{
				return;
			}
			if (!HasAir)
			{
				float num = (Oxygen = Math.Max(0f, Oxygen - deltaTime * 1000f));
				if (num <= 0f && (int)base.entity.World.Side == 1)
				{
					damageAccum += deltaTime;
					if ((double)damageAccum > 0.75)
					{
						damageAccum = 0f;
						DamageSource val = new DamageSource
						{
							Source = (EnumDamageSource)0,
							SourceBlock = suffocationSourceBlock,
							Type = (EnumDamageType)5
						};
						base.entity.ReceiveDamage(val, 0.5f);
					}
				}
			}
			else if (Oxygen < maxOxygen)
			{
				Oxygen = Math.Min(maxOxygen, Oxygen + deltaTime * 10000f);
			}
			((EntityBehavior)this).OnGameTick(deltaTime);
			breathAccum += deltaTime;
			if (breathAccum > 1f)
			{
				breathAccum = 0f;
				Check();
			}
		}

		public override string PropertyName()
		{
			return "breathe";
		}
	}
	public class EntityBehaviorCollectEntities : EntityBehavior
	{
		private int waitTicks;

		private int lastCollectedEntityIndex;

		private Vec3d tmp = new Vec3d();

		private float itemsPerSecond = 23f;

		private float unconsumedDeltaTime;

		public EntityBehaviorCollectEntities(Entity entity)
			: base(entity)
		{
		}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown


		public override void OnGameTick(float deltaTime)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Invalid comparison between Unknown and I4
			if ((int)base.entity.State != 0 || !base.entity.Alive)
			{
				return;
			}
			Entity entity = base.entity;
			Entity obj = ((entity is EntityPlayer) ? entity : null);
			IPlayer val = ((obj != null) ? ((EntityPlayer)obj).Player : null);
			IPlayer obj2 = ((val is IServerPlayer) ? val : null);
			if (obj2 != null && ((IServerPlayer)obj2).ItemCollectMode == 1)
			{
				Entity entity2 = base.entity;
				Entity obj3 = ((entity2 is EntityAgent) ? entity2 : null);
				if (obj3 != null && !((EntityAgent)obj3).Controls.Sneak)
				{
					return;
				}
			}
			if (base.entity.IsActivityRunning("invulnerable"))
			{
				waitTicks = 3;
			}
			else
			{
				if (waitTicks-- > 0 || (val != null && (int)val.WorldData.CurrentGameMode == 3))
				{
					return;
				}
				tmp.Set(base.entity.ServerPos.X, base.entity.ServerPos.InternalY + (double)base.entity.SelectionBox.Y1 + (double)(base.entity.SelectionBox.Y2 / 2f), base.entity.ServerPos.Z);
				Entity[] entitiesAround = base.entity.World.GetEntitiesAround(tmp, 1.5f, 1.5f, (ActionConsumable<Entity>)entityMatcher);
				if (entitiesAround.Length == 0)
				{
					unconsumedDeltaTime = 0f;
					return;
				}
				deltaTime = Math.Min(1f, deltaTime + unconsumedDeltaTime);
				while (deltaTime - 1f / itemsPerSecond > 0f)
				{
					Entity val2 = null;
					int i;
					for (i = 0; i < entitiesAround.Length; i++)
					{
						if (entitiesAround[i] != null && i >= lastCollectedEntityIndex)
						{
							val2 = entitiesAround[i];
							break;
						}
					}
					if (val2 == null)
					{
						val2 = entitiesAround[0];
						i = 0;
					}
					if (val2 == null)
					{
						return;
					}
					if (!OnFoundCollectible(val2))
					{
						lastCollectedEntityIndex = (lastCollectedEntityIndex + 1) % entitiesAround.Length;
					}
					else
					{
						entitiesAround[i] = null;
					}
					deltaTime -= 1f / itemsPerSecond;
				}
				unconsumedDeltaTime = deltaTime;
			}
		}

		public virtual bool OnFoundCollectible(Entity foundEntity)
		{
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Expected O, but got Unknown
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Expected O, but got Unknown
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Expected O, but got Unknown
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Expected O, but got Unknown
			ItemStack val = foundEntity.OnCollected(base.entity);
			bool flag = false;
			ItemStack val2 = val.Clone();
			if (val != null && val.StackSize > 0)
			{
				flag = base.entity.TryGiveItemStack(val);
			}
			if (val != null && val.StackSize <= 0)
			{
				foundEntity.Die((EnumDespawnReason)3, (DamageSource)null);
			}
			if (flag)
			{
				val.Collectible.OnCollected(val, base.entity);
				TreeAttribute val3 = new TreeAttribute();
				val3["itemstack"] = (IAttribute)new ItemstackAttribute(val2.Clone());
				val3["byentityid"] = (IAttribute)new LongAttribute(base.entity.EntityId);
				base.entity.World.Api.Event.PushEvent("onitemcollected", (IAttribute)(object)val3);
				base.entity.World.PlaySoundAt(new AssetLocation("sounds/player/collect"), base.entity, (IPlayer)null, true, 32f, 1f);
				return true;
			}
			return false;
		}

		private bool entityMatcher(Entity foundEntity)
		{
			return foundEntity.CanCollect(base.entity);
		}

		public override string PropertyName()
		{
			return "collectitems";
		}
	}
	public class StepParentElementTo : ModelTransform
	{
		[JsonProperty]
		public string ElementName;
	}
	public interface IAttachableToEntity
	{
		int RequiresBehindSlots { get; set; }

		bool IsAttachable(Entity toEntity, ItemStack itemStack);

		void CollectTextures(ItemStack stack, Shape shape, string texturePrefixCode, Dictionary<string, CompositeTexture> intoDict);

		string GetCategoryCode(ItemStack stack);

		CompositeShape GetAttachedShape(ItemStack stack, string slotCode);

		string[] GetDisableElements(ItemStack stack);

		string[] GetKeepElements(ItemStack stack);

		string GetTexturePrefixCode(ItemStack stack);

		static IAttachableToEntity FromCollectible(CollectibleObject cobj)
		{
			IAttachableToEntity collectibleInterface = cobj.GetCollectibleInterface<IAttachableToEntity>();
			if (collectibleInterface != null)
			{
				return collectibleInterface;
			}
			return FromAttributes(cobj);
		}

		static IAttachableToEntity FromAttributes(CollectibleObject cobj)
		{
			JsonObject attributes = cobj.Attributes;
			AttributeAttachableToEntity attributeAttachableToEntity = ((attributes != null) ? attributes["attachableToEntity"].AsObject<AttributeAttachableToEntity>((AttributeAttachableToEntity)null, ((RegistryObject)cobj).Code.Domain) : null);
			if (attributeAttachableToEntity == null)
			{
				JsonObject attributes2 = cobj.Attributes;
				if (attributes2 != null && attributes2["wearableAttachment"].Exists)
				{
					AttributeAttachableToEntity attributeAttachableToEntity2 = new AttributeAttachableToEntity();
					object obj = cobj.Attributes["clothescategory"].AsString((string)null);
					if (obj == null)
					{
						JsonObject attributes3 = cobj.Attributes;
						obj = ((attributes3 != null) ? attributes3["attachableToEntity"]["categoryCode"].AsString((string)null) : null);
					}
					attributeAttachableToEntity2.CategoryCode = (string)obj;
					attributeAttachableToEntity2.KeepElements = cobj.Attributes["keepElements"].AsArray<string>((string[])null, (string)null);
					attributeAttachableToEntity2.DisableElements = cobj.Attributes["disableElements"].AsArray<string>((string[])null, (string)null);
					return attributeAttachableToEntity2;
				}
			}
			return attributeAttachableToEntity;
		}

		static void CollectTexturesFromCollectible(ItemStack stack, string texturePrefixCode, Shape gearShape, Dictionary<string, CompositeTexture> intoDict)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			if (gearShape.Textures == null)
			{
				gearShape.Textures = new Dictionary<string, AssetLocation>();
			}
			IDictionary<string, CompositeTexture> dictionary;
			if ((int)stack.Class != 0)
			{
				IDictionary<string, CompositeTexture> textures = stack.Item.Textures;
				dictionary = textures;
			}
			else
			{
				dictionary = stack.Block.Textures;
			}
			IDictionary<string, CompositeTexture> dictionary2 = dictionary;
			if (dictionary2 == null)
			{
				return;
			}
			foreach (KeyValuePair<string, CompositeTexture> item in dictionary2)
			{
				gearShape.Textures[item.Key] = item.Value.Base;
			}
		}
	}
	public class AttributeAttachableToEntity : IAttachableToEntity
	{
		public string CategoryCode { get; set; }

		public CompositeShape AttachedShape { get; set; }

		public string[] DisableElements { get; set; }

		public string[] KeepElements { get; set; }

		public string TexturePrefixCode { get; set; }

		public OrderedDictionary<string, CompositeShape> AttachedShapeBySlotCode { get; set; }

		public int RequiresBehindSlots { get; set; }

		public string GetTexturePrefixCode(ItemStack stack)
		{
			return TexturePrefixCode;
		}

		public void CollectTextures(ItemStack stack, Shape gearShape, string texturePrefixCode, Dictionary<string, CompositeTexture> intoDict)
		{
			IAttachableToEntity.CollectTexturesFromCollectible(stack, texturePrefixCode, gearShape, intoDict);
		}

		public CompositeShape GetAttachedShape(ItemStack stack, string slotCode)
		{
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Invalid comparison between Unknown and I4
			if (AttachedShape != null)
			{
				return AttachedShape;
			}
			if (AttachedShapeBySlotCode != null)
			{
				foreach (KeyValuePair<string, CompositeShape> item in AttachedShapeBySlotCode)
				{
					if (WildcardUtil.Match(item.Key, slotCode))
					{
						return item.Value;
					}
				}
			}
			if ((int)stack.Class != 1)
			{
				return stack.Block.Shape;
			}
			return stack.Item.Shape;
		}

		public string GetCategoryCode(ItemStack stack)
		{
			return CategoryCode;
		}

		public string[] GetDisableElements(ItemStack stack)
		{
			return DisableElements;
		}

		public string[] GetKeepElements(ItemStack stack)
		{
			return KeepElements;
		}

		public bool IsAttachable(Entity toEntity, ItemStack itemStack)
		{
			return true;
		}
	}
	public abstract class EntityBehaviorContainer : EntityBehavior
	{
		protected ICoreAPI Api;

		private InWorldContainer container;

		public bool hideClothing;

		private bool eventRegistered;

		private bool dropContentsOnDeath;

		public abstract InventoryBase Inventory { get; }

		public abstract string InventoryClassName { get; }

		protected EntityBehaviorContainer(Entity entity)
			: base(entity)
		{
			container = new InWorldContainer(() => Inventory, InventoryClassName);
		}

		public override bool TryEarlyLoadCollectibleMappings(IWorldAccessor worldForCollectibleResolve, Dictionary<int, AssetLocation> oldBlockIdMapping, Dictionary<int, AssetLocation> oldItemIdMapping, bool resolveImports, EntityProperties entityProperties, JsonObject behaviorConfig)
		{
			((EntityBehavior)this).OnLoadCollectibleMappings(worldForCollectibleResolve, oldBlockIdMapping, oldItemIdMapping, resolveImports);
			return true;
		}

		public override bool ShouldEarlyLoadCollectibleMappings()
		{
			return true;
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Invalid comparison between Unknown and I4
			Api = base.entity.World.Api;
			container.Init(Api, () => base.entity.Pos.AsBlockPos, delegate
			{
				base.entity.WatchedAttributes.MarkPathDirty(InventoryClassName);
			});
			if ((int)Api.Side == 2)
			{
				base.entity.WatchedAttributes.RegisterModifiedListener(InventoryClassName, (Action)inventoryModified);
			}
			dropContentsOnDeath = attributes != null && attributes.IsTrue("dropContentsOnDeath");
		}

		private void inventoryModified()
		{
			loadInv();
			base.entity.MarkShapeModified();
		}

		public override void OnGameTick(float deltaTime)
		{
			if (!eventRegistered && Inventory != null)
			{
				eventRegistered = true;
				Inventory.SlotModified += Inventory_SlotModified;
			}
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			if (Inventory != null)
			{
				Inventory.SlotModified -= Inventory_SlotModified;
			}
		}

		protected void Inventory_SlotModifiedBackpack(int slotid)
		{
			Entity entity = base.entity;
			EntityPlayer val = (EntityPlayer)(object)((entity is EntityPlayer) ? entity : null);
			if (val != null && val.Player.InventoryManager.GetOwnInventory("backpack")[slotid] is ItemSlotBackpack)
			{
				base.entity.MarkShapeModified();
			}
		}

		protected virtual void Inventory_SlotModified(int slotid)
		{
			base.entity.MarkShapeModified();
		}

		public override void OnTesselation(ref Shape entityShape, string shapePathForLogging, ref bool shapeIsCloned, ref string[] willDeleteElements)
		{
			try
			{
				addGearToShape(ref entityShape, shapePathForLogging, ref shapeIsCloned, ref willDeleteElements);
			}
			catch (Exception innerException)
			{
				throw new Exception("Error tesselating entity " + AssetLocation.op_Implicit(((RegistryObject)base.entity).Code) + " at " + (object)base.entity.Pos.AsBlockPos, innerException);
			}
			((EntityBehavior)this).OnTesselation(ref entityShape, shapePathForLogging, ref shapeIsCloned, ref willDeleteElements);
			if (Inventory != null)
			{
				ItemSlot val = ((IEnumerable<ItemSlot>)Inventory).MaxBy((ItemSlot slot) => (!slot.Empty) ? ((ThreeBytes)(ref slot.Itemstack.Collectible.LightHsv))[2] : 0);
				if (!val.Empty)
				{
					base.entity.LightHsv = val.Itemstack.Collectible.GetLightHsv(base.entity.World.BlockAccessor, (BlockPos)null, val.Itemstack);
				}
				else
				{
					base.entity.LightHsv = null;
				}
			}
		}

		protected Shape addGearToShape(ref Shape entityShape, string shapePathForLogging, ref bool shapeIsCloned, ref string[] willDeleteElements)
		{
			IInventory inventory = (IInventory)(object)Inventory;
			if (inventory == null || (!(base.entity is EntityPlayer) && inventory.Empty))
			{
				return entityShape;
			}
			foreach (ItemSlot item in (IEnumerable<ItemSlot>)inventory)
			{
				if (!item.Empty && !hideClothing && ShouldAddGearToShape(item))
				{
					entityShape = addGearToShape(entityShape, item, "default", shapePathForLogging, ref shapeIsCloned, ref willDeleteElements);
				}
			}
			if (shapeIsCloned)
			{
				ICoreAPI api = Api;
				ICoreClientAPI val = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
				if (val != null)
				{
					EntityProperties entityType = Api.World.GetEntityType(((RegistryObject)base.entity).Code);
					if (entityType != null)
					{
						int textureSubId = default(int);
						TextureAtlasPosition val2 = default(TextureAtlasPosition);
						foreach (KeyValuePair<string, CompositeTexture> texture in entityType.Client.Textures)
						{
							CompositeTexture value = texture.Value;
							value.Bake(Api.Assets);
							val.EntityTextureAtlas.GetOrInsertTexture(value.Baked.TextureFilenames[0], ref textureSubId, ref val2, (CreateTextureDelegate)null, 0f);
							value.Baked.TextureSubId = textureSubId;
							base.entity.Properties.Client.Textures[texture.Key] = texture.Value;
						}
					}
				}
			}
			return entityShape;
		}

		protected virtual bool ShouldAddGearToShape(ItemSlot slot)
		{
			return true;
		}

		protected virtual Shape addGearToShape(Shape entityShape, ItemSlot gearslot, string slotCode, string shapePathForLogging, ref bool shapeIsCloned, ref string[] willDeleteElements, Dictionary<string, StepParentElementTo> overrideStepParent = null)
		{
			if (gearslot.Empty || entityShape == null)
			{
				return entityShape;
			}
			IAttachableToEntity attachableToEntity = IAttachableToEntity.FromCollectible(gearslot.Itemstack.Collectible);
			if (attachableToEntity == null || !attachableToEntity.IsAttachable(base.entity, gearslot.Itemstack))
			{
				return entityShape;
			}
			if (!shapeIsCloned)
			{
				entityShape = entityShape.Clone();
				shapeIsCloned = true;
			}
			return addGearToShape(entityShape, gearslot.Itemstack, attachableToEntity, slotCode, shapePathForLogging, ref willDeleteElements, overrideStepParent);
		}

		protected virtual Shape addGearToShape(Shape entityShape, ItemStack stack, IAttachableToEntity iatta, string slotCode, string shapePathForLogging, ref string[] willDeleteElements, Dictionary<string, StepParentElementTo> overrideStepParent = null)
		{
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_021a: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
			if (stack == null || iatta == null)
			{
				return entityShape;
			}
			float num = 0f;
			JsonObject itemAttributes = stack.ItemAttributes;
			if (itemAttributes != null && itemAttributes["visibleDamageEffect"].AsBool(false))
			{
				num = Math.Max(0f, 1f - (float)stack.Collectible.GetRemainingDurability(stack) / (float)stack.Collectible.GetMaxDurability(stack) * 1.1f);
			}
			entityShape.RemoveElements(iatta.GetDisableElements(stack));
			string[] keepElements = iatta.GetKeepElements(stack);
			if (keepElements != null && willDeleteElements != null)
			{
				string[] array = keepElements;
				foreach (string text in array)
				{
					willDeleteElements = ArrayExtensions.Remove<string>(willDeleteElements, text);
				}
			}
			IDictionary<string, CompositeTexture> textures = base.entity.Properties.Client.Textures;
			string texturePrefixCode = iatta.GetTexturePrefixCode(stack);
			Shape val = null;
			AssetLocation val2 = null;
			CompositeShape val3 = null;
			CollectibleObject collectible = stack.Collectible;
			IWearableShapeSupplier val4 = (IWearableShapeSupplier)(object)((collectible is IWearableShapeSupplier) ? collectible : null);
			if (val4 != null)
			{
				val = val4.GetShape(stack, base.entity, texturePrefixCode);
			}
			if (val == null)
			{
				val3 = iatta.GetAttachedShape(stack, slotCode);
				val2 = val3.Base.CopyWithPathPrefixAndAppendixOnce("shapes/", ".json");
				val = Shape.TryGet(Api, val2);
				if (val == null)
				{
					Api.World.Logger.Warning("Entity attachable shape {0} defined in {1} {2} not found or errored, was supposed to be at {3}. Shape will be invisible.", new object[4]
					{
						val3.Base,
						stack.Class,
						((RegistryObject)stack.Collectible).Code,
						val2
					});
					return entityShape;
				}
				val.SubclassForStepParenting(texturePrefixCode, num);
				val.ResolveReferences(base.entity.World.Logger, AssetLocation.op_Implicit(val2));
			}
			ICoreClientAPI capi = default(ICoreClientAPI);
			ref ICoreClientAPI reference = ref capi;
			ICoreAPI api = Api;
			reference = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			Dictionary<string, CompositeTexture> dictionary = null;
			if (capi != null)
			{
				dictionary = new Dictionary<string, CompositeTexture>();
				iatta.CollectTextures(stack, val, texturePrefixCode, dictionary);
			}
			applyStepParentOverrides(overrideStepParent, val);
			entityShape.StepParentShape(val, (((object)val3?.Base).ToString() ?? "Custom texture from ItemWearableShapeSupplier") + $" defined in {stack.Class} {((RegistryObject)stack.Collectible).Code}", shapePathForLogging, Api.World.Logger, (Action<string, AssetLocation>)delegate(string texcode, AssetLocation tloc)
			{
				addTexture(texcode, tloc, textures, texturePrefixCode, capi);
			});
			if (val3?.Overlays != null)
			{
				CompositeShape[] overlays = val3.Overlays;
				foreach (CompositeShape val5 in overlays)
				{
					Shape val6 = Shape.TryGet(Api, val5.Base.CopyWithPathPrefixAndAppendixOnce("shapes/", ".json"));
					if (val6 == null)
					{
						Api.World.Logger.Warning("Entity attachable shape {0} overlay {4} defined in {1} {2} not found or errored, was supposed to be at {3}. Shape will be invisible.", new object[5]
						{
							val3.Base,
							stack.Class,
							((RegistryObject)stack.Collectible).Code,
							val2,
							val5.Base
						});
						continue;
					}
					val6.SubclassForStepParenting(texturePrefixCode, num);
					if (capi != null)
					{
						iatta.CollectTextures(stack, val6, texturePrefixCode, dictionary);
					}
					applyStepParentOverrides(overrideStepParent, val6);
					entityShape.StepParentShape(val6, val5.Base.ToShortString(), shapePathForLogging, Api.Logger, (Action<string, AssetLocation>)delegate(string texcode, AssetLocation tloc)
					{
						addTexture(texcode, tloc, textures, texturePrefixCode, capi);
					});
				}
			}
			if (capi != null)
			{
				int textureSubId = default(int);
				TextureAtlasPosition val10 = default(TextureAtlasPosition);
				foreach (KeyValuePair<string, CompositeTexture> item in dictionary)
				{
					CompositeTexture val7 = (textures[item.Key] = item.Value.Clone());
					CompositeTexture val9 = val7;
					capi.EntityTextureAtlas.GetOrInsertTexture(val9, ref textureSubId, ref val10, 0f);
					val9.Baked.TextureSubId = textureSubId;
				}
			}
			return entityShape;
		}

		private static void applyStepParentOverrides(Dictionary<string, StepParentElementTo> overrideStepParent, Shape gearShape)
		{
			if (overrideStepParent == null)
			{
				return;
			}
			overrideStepParent.TryGetValue("", out var value);
			ShapeElement[] elements = gearShape.Elements;
			foreach (ShapeElement val in elements)
			{
				StepParentElementTo value2;
				if (val.StepParentName == null || val.StepParentName.Length == 0)
				{
					val.StepParentName = value.ElementName;
				}
				else if (overrideStepParent.TryGetValue(val.StepParentName, out value2))
				{
					val.StepParentName = value2.ElementName;
				}
			}
		}

		private void addTexture(string texcode, AssetLocation tloc, IDictionary<string, CompositeTexture> textures, string texturePrefixCode, ICoreClientAPI capi)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Expected O, but got Unknown
			//IL_001a: Expected O, but got Unknown
			if (capi != null)
			{
				string key = texturePrefixCode + texcode;
				CompositeTexture val = new CompositeTexture(tloc);
				CompositeTexture val2 = val;
				textures[key] = val;
				CompositeTexture val3 = val2;
				val3.Bake(Api.Assets);
				int textureSubId = default(int);
				TextureAtlasPosition val4 = default(TextureAtlasPosition);
				capi.EntityTextureAtlas.GetOrInsertTexture(val3.Baked.TextureFilenames[0], ref textureSubId, ref val4, (CreateTextureDelegate)null, 0f);
				val3.Baked.TextureSubId = textureSubId;
			}
		}

		public override void OnLoadCollectibleMappings(IWorldAccessor worldForNewMappings, Dictionary<int, AssetLocation> oldBlockIdMapping, Dictionary<int, AssetLocation> oldItemIdMapping, bool resolveImports)
		{
			container.OnLoadCollectibleMappings(worldForNewMappings, oldBlockIdMapping, oldItemIdMapping, 0, resolveImports);
		}

		public override void OnStoreCollectibleMappings(Dictionary<int, AssetLocation> blockIdMapping, Dictionary<int, AssetLocation> itemIdMapping)
		{
			container.OnStoreCollectibleMappings(blockIdMapping, itemIdMapping);
		}

		public override void FromBytes(bool isSync)
		{
			loadInv();
		}

		protected virtual void loadInv()
		{
			if (Inventory != null)
			{
				container.FromTreeAttributes((ITreeAttribute)(object)base.entity.WatchedAttributes, base.entity.World);
				base.entity.MarkShapeModified();
			}
		}

		public override void ToBytes(bool forClient)
		{
			storeInv();
		}

		public virtual void storeInv()
		{
			container.ToTreeAttributes((ITreeAttribute)(object)base.entity.WatchedAttributes);
			base.entity.WatchedAttributes.MarkPathDirty(InventoryClassName);
			IWorldChunk chunkAtBlockPos = base.entity.World.BlockAccessor.GetChunkAtBlockPos(base.entity.ServerPos.AsBlockPos);
			if (chunkAtBlockPos != null)
			{
				chunkAtBlockPos.MarkModified();
			}
		}

		public override bool TryGiveItemStack(ItemStack itemstack, ref EnumHandling handling)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Expected O, but got Unknown
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Expected O, but got Unknown
			ItemSlot val = (ItemSlot)new DummySlot((ItemStack)null);
			val.Itemstack = itemstack.Clone();
			ItemStackMoveOperation val2 = new ItemStackMoveOperation(base.entity.World, (EnumMouseButton)0, (EnumModifierKey)0, (EnumMergePriority)0, itemstack.StackSize);
			if (Inventory != null)
			{
				WeightedSlot bestSuitedSlot = Inventory.GetBestSuitedSlot(val, (ItemStackMoveOperation)null, new List<ItemSlot>());
				if (bestSuitedSlot.weight > 0f)
				{
					val.TryPutInto(bestSuitedSlot.slot, ref val2);
					itemstack.StackSize -= val2.MovedQuantity;
					base.entity.WatchedAttributes.MarkAllDirty();
					return val2.MovedQuantity > 0;
				}
			}
			Entity entity = base.entity;
			Entity obj = ((entity is EntityAgent) ? entity : null);
			object obj2;
			if (obj == null)
			{
				obj2 = null;
			}
			else
			{
				ItemSlot leftHandItemSlot = ((EntityAgent)obj).LeftHandItemSlot;
				obj2 = ((leftHandItemSlot != null) ? leftHandItemSlot.Inventory : null);
			}
			if (obj2 != null)
			{
				Entity entity2 = base.entity;
				Entity obj3 = ((entity2 is EntityAgent) ? entity2 : null);
				WeightedSlot val3 = ((obj3 != null) ? ((EntityAgent)obj3).LeftHandItemSlot.Inventory.GetBestSuitedSlot(val, (ItemStackMoveOperation)null, new List<ItemSlot>()) : null);
				if (val3.weight > 0f)
				{
					val.TryPutInto(val3.slot, ref val2);
					itemstack.StackSize -= val2.MovedQuantity;
					base.entity.WatchedAttributes.MarkAllDirty();
					return val2.MovedQuantity > 0;
				}
			}
			return false;
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			((EntityBehavior)this).OnEntityDeath(damageSourceForDeath);
			if (dropContentsOnDeath)
			{
				Inventory.DropAll(base.entity.ServerPos.XYZ, 0);
			}
		}
	}
	public class EntityBehaviorControlledPhysics : PhysicsBehaviorBase, IPhysicsTickable, IRemotePhysics
	{
		protected const double collisionboxReductionForInsideBlocksCheck = 0.009;

		protected bool smoothStepping;

		protected readonly List<PModule> physicsModules = new List<PModule>();

		protected readonly List<PModule> customModules = new List<PModule>();

		protected Vec3d newPos = new Vec3d();

		protected readonly Vec3d prevPos = new Vec3d();

		protected readonly BlockPos tmpPos = new BlockPos();

		protected readonly Cuboidd entityBox = new Cuboidd();

		protected readonly List<FastVec3i> traversed = new List<FastVec3i>(4);

		protected readonly List<Block> traversedBlocks = new List<Block>(4);

		protected readonly IComparer<FastVec3i> fastVec3IComparer = (IComparer<FastVec3i>)new FastVec3iComparer();

		protected readonly Vec3d moveDelta = new Vec3d();

		protected double prevYMotion;

		protected bool onGroundBefore;

		protected bool feetInLiquidBefore;

		protected bool swimmingBefore;

		protected float knockBackCounter;

		protected Cuboidf sneakTestCollisionbox = new Cuboidf();

		protected readonly Cuboidd steppingCollisionBox = new Cuboidd();

		protected readonly Vec3d steppingTestVec = new Vec3d();

		protected readonly Vec3d steppingTestMotion = new Vec3d();

		public Matrixf tmpModelMat = new Matrixf();

		public float StepHeight = 0.6f;

		public float stepUpSpeed = 0.07f;

		public float climbUpSpeed = 0.07f;

		public float climbDownSpeed = 0.035f;

		public Entity Entity => ((EntityBehavior)this).entity;

		public bool Ticking { get; set; }

		public override bool ThreadSafe => true;

		public void SetState(EntityPos pos, float dt)
		{
			float dtFac = dt * 60f;
			Entity entity = ((EntityBehavior)this).entity;
			prevPos.Set(pos);
			prevYMotion = pos.Motion.Y;
			onGroundBefore = entity.OnGround;
			feetInLiquidBefore = entity.FeetInLiquid;
			swimmingBefore = entity.Swimming;
			traversed.Clear();
			traversedBlocks.Clear();
			if (entity.AdjustCollisionBoxToAnimation)
			{
				AdjustCollisionBoxToAnimation(dtFac);
			}
		}

		public EntityBehaviorControlledPhysics(Entity entity)
			: base(entity)
		{
		}//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Expected O, but got Unknown
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Expected O, but got Unknown
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Expected O, but got Unknown
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Expected O, but got Unknown
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Expected O, but got Unknown
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Expected O, but got Unknown
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Expected O, but got Unknown
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Expected O, but got Unknown


		public virtual void SetModules()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Expected O, but got Unknown
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Expected O, but got Unknown
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Expected O, but got Unknown
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Expected O, but got Unknown
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Expected O, but got Unknown
			physicsModules.Add((PModule)new PModuleWind());
			physicsModules.Add((PModule)new PModuleOnGround());
			physicsModules.Add((PModule)new PModuleInLiquid());
			physicsModules.Add((PModule)new PModuleInAir());
			physicsModules.Add((PModule)new PModuleGravity());
			physicsModules.Add((PModule)new PModuleMotionDrag());
			physicsModules.Add((PModule)new PModuleKnockback());
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Invalid comparison between Unknown and I4
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			((PhysicsBehaviorBase)this).Init();
			SetProperties(properties, attributes);
			ICoreAPI api = ((EntityBehavior)this).entity.Api;
			ICoreServerAPI val = (ICoreServerAPI)(object)((api is ICoreServerAPI) ? api : null);
			if (val != null)
			{
				val.Server.AddPhysicsTickable((IPhysicsTickable)(object)this);
			}
			PhysicsTickDelegate physicsUpdateWatcher = ((EntityBehavior)this).entity.PhysicsUpdateWatcher;
			if (physicsUpdateWatcher != null)
			{
				physicsUpdateWatcher.Invoke(0f, ((EntityBehavior)this).entity.SidedPos.XYZ);
			}
			if ((int)((EntityBehavior)this).entity.Api.Side != 2)
			{
				return;
			}
			EnumHandling val2 = (EnumHandling)1;
			((EntityBehavior)this).OnReceivedServerPos(true, ref val2);
			((EntityBehavior)this).entity.Attributes.RegisterModifiedListener("dmgkb", (Action)delegate
			{
				if (((TreeAttribute)((EntityBehavior)this).entity.Attributes).GetInt("dmgkb", 0) == 1)
				{
					knockBackCounter = 2f;
				}
			});
		}

		public override void AfterInitialized(bool onFirstSpawn)
		{
			((PhysicsBehaviorBase)this).AfterInitialized(onFirstSpawn);
		}

		public override void OnGameTick(float deltaTime)
		{
			if (((EntityBehavior)this).entity.World is IServerWorldAccessor)
			{
				IMountable mountableSupplier = base.mountableSupplier;
				Entity obj = ((mountableSupplier != null) ? mountableSupplier.Controller : null);
				EntityPlayer val = (EntityPlayer)(object)((obj is EntityPlayer) ? obj : null);
				if (val != null && ((Entity)val).Alive)
				{
					callOnEntityInside();
					((EntityBehavior)this).entity.AfterPhysicsTick?.Invoke();
				}
			}
			else
			{
				((EntityBehavior)this).entity.AfterPhysicsTick?.Invoke();
			}
		}

		public void SetProperties(EntityProperties properties, JsonObject attributes)
		{
			StepHeight = attributes["stepHeight"].AsFloat(0.6f);
			stepUpSpeed = attributes["stepUpSpeed"].AsFloat(0.07f);
			climbUpSpeed = attributes["climbUpSpeed"].AsFloat(0.07f);
			climbDownSpeed = attributes["climbDownSpeed"].AsFloat(0.035f);
			sneakTestCollisionbox = ((EntityBehavior)this).entity.CollisionBox.Clone().OmniNotDownGrowBy(-0.1f);
			Cuboidf obj = sneakTestCollisionbox;
			obj.Y2 /= 2f;
			SetModules();
			object obj2;
			if (properties == null)
			{
				obj2 = null;
			}
			else
			{
				JsonObject attributes2 = properties.Attributes;
				obj2 = ((attributes2 != null) ? attributes2["physics"] : null);
			}
			JsonObject val = (JsonObject)obj2;
			for (int i = 0; i < physicsModules.Count; i++)
			{
				physicsModules[i].Initialize(val, ((EntityBehavior)this).entity);
			}
		}

		public override void OnReceivedServerPos(bool isTeleport, ref EnumHandling handled)
		{
		}

		public void OnReceivedClientPos(int version)
		{
			if (version > base.previousVersion)
			{
				base.previousVersion = version;
				HandleRemotePhysics(1f / 15f, isTeleport: true);
			}
			else
			{
				HandleRemotePhysics(1f / 15f, isTeleport: false);
			}
		}

		public void HandleRemotePhysics(float dt, bool isTeleport)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
			if (base.nPos == (Vec3d)null)
			{
				base.nPos = new Vec3d();
				base.nPos.Set(((EntityBehavior)this).entity.ServerPos);
			}
			float num = dt * 60f;
			base.lPos.SetFrom(base.nPos);
			base.nPos.Set(((EntityBehavior)this).entity.ServerPos);
			if (isTeleport)
			{
				base.lPos.SetFrom(base.nPos);
			}
			base.lPos.Dimension = ((EntityBehavior)this).entity.Pos.Dimension;
			tmpPos.dimension = base.lPos.Dimension;
			base.lPos.Motion.X = (base.nPos.X - base.lPos.X) / (double)num;
			base.lPos.Motion.Y = (base.nPos.Y - base.lPos.Y) / (double)num;
			base.lPos.Motion.Z = (base.nPos.Z - base.lPos.Z) / (double)num;
			if (base.lPos.Motion.Length() > 20.0)
			{
				base.lPos.Motion.Set(0.0, 0.0, 0.0);
			}
			((EntityBehavior)this).entity.Pos.Motion.Set(base.lPos.Motion);
			((EntityBehavior)this).entity.ServerPos.Motion.Set(base.lPos.Motion);
			PhysicsBehaviorBase.collisionTester.NewTick(base.lPos);
			Entity entity = ((EntityBehavior)this).entity;
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (((val != null) ? val.MountedOn : null) != null)
			{
				((EntityBehavior)this).entity.Swimming = false;
				((EntityBehavior)this).entity.OnGround = false;
				if (base.capi != null)
				{
					((EntityBehavior)this).entity.Pos.SetPos(val.MountedOn.SeatPosition);
				}
				((EntityBehavior)this).entity.ServerPos.Motion.X = 0.0;
				((EntityBehavior)this).entity.ServerPos.Motion.Y = 0.0;
				((EntityBehavior)this).entity.ServerPos.Motion.Z = 0.0;
			}
			else
			{
				((EntityBehavior)this).entity.Pos.SetFrom(((EntityBehavior)this).entity.ServerPos);
				SetState(base.lPos, dt);
				RemoteMotionAndCollision(base.lPos, num);
				ApplyTests(base.lPos, ((EntityAgent)((EntityBehavior)this).entity).Controls, dt, remote: true);
				if (knockBackCounter > 0f)
				{
					knockBackCounter -= dt;
					return;
				}
				knockBackCounter = 0f;
				((TreeAttribute)((EntityBehavior)this).entity.Attributes).SetInt("dmgkb", 0);
			}
		}

		public void RemoteMotionAndCollision(EntityPos pos, float dtFactor)
		{
			double num = (double)(1f / 60f * dtFactor) + Math.Max(0.0, -0.014999999664723873 * pos.Motion.Y * (double)dtFactor);
			Vec3d motion = pos.Motion;
			motion.Y -= num;
			((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(((EntityBehavior)this).entity, pos, dtFactor, ref newPos, 0f, 0f);
			bool flag = base.lPos.Motion.Y < 0.0;
			((EntityBehavior)this).entity.OnGround = ((EntityBehavior)this).entity.CollidedVertically && flag;
			Vec3d motion2 = pos.Motion;
			motion2.Y += num;
			pos.SetPos(base.nPos);
		}

		public void MotionAndCollision(EntityPos pos, EntityControls controls, float dt)
		{
			Entity entity = ((EntityBehavior)this).entity;
			foreach (PModule physicsModule in physicsModules)
			{
				if (physicsModule.Applicable(entity, pos, controls))
				{
					physicsModule.DoApply(dt, entity, pos, controls);
				}
			}
			foreach (PModule customModule in customModules)
			{
				if (customModule.Applicable(entity, pos, controls))
				{
					customModule.DoApply(dt, entity, pos, controls);
				}
			}
		}

		public void ApplyTests(EntityPos pos, EntityControls controls, float dt, bool remote)
		{
			//IL_0444: Unknown result type (might be due to invalid IL or missing references)
			//IL_044a: Invalid comparison between Unknown and I4
			//IL_09bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_09dd: Unknown result type (might be due to invalid IL or missing references)
			Entity entity = ((EntityBehavior)this).entity;
			EntityProperties properties = entity.Properties;
			IBlockAccessor blockAccessor = entity.World.BlockAccessor;
			float num = dt * 60f;
			BlockPos val = tmpPos;
			Cuboidd val2 = entityBox;
			Vec3d motion = pos.Motion;
			Vec3d val3 = newPos;
			controls.IsClimbing = false;
			entity.ClimbingOnFace = null;
			entity.ClimbingIntoFace = null;
			if (properties.CanClimb)
			{
				bool flag = properties.CanClimbAnywhere && entity.Alive;
				int num2 = ((!flag) ? 1 : 0);
				int num3 = (int)Math.Ceiling(entity.CollisionBox.Y2);
				val2.SetAndTranslate(entity.CollisionBox, pos.X, pos.Y, pos.Z);
				val.Set((int)pos.X, 0, (int)pos.Z);
				for (int i = 0; i < num3; i++)
				{
					val.Y = (int)pos.Y + i;
					Block block = blockAccessor.GetBlock(val, num2);
					if (!block.IsClimbable(val) && !flag)
					{
						continue;
					}
					Cuboidf[] collisionBoxes = block.GetCollisionBoxes(blockAccessor, val);
					if (collisionBoxes == null)
					{
						continue;
					}
					for (int j = 0; j < collisionBoxes.Length; j++)
					{
						double num4 = val2.ShortestDistanceFrom(collisionBoxes[j], val);
						controls.IsClimbing |= num4 < (double)properties.ClimbTouchDistance;
						if (controls.IsClimbing)
						{
							entity.ClimbingOnFace = null;
							break;
						}
					}
				}
				if (flag && controls.WalkVector.LengthSq() > 1E-05)
				{
					BlockFacing val4 = BlockFacing.FromVector(controls.WalkVector.X, controls.WalkVector.Y, controls.WalkVector.Z);
					if (val4 != null)
					{
						val.Set((int)pos.X + val4.Normali.X, (int)pos.Y + val4.Normali.Y, (int)pos.Z + val4.Normali.Z);
						Cuboidf[] collisionBoxes2 = blockAccessor.GetBlock(val, 0).GetCollisionBoxes(blockAccessor, val);
						entity.ClimbingIntoFace = ((collisionBoxes2 != null && collisionBoxes2.Length != 0) ? val4 : null);
					}
				}
				if (!controls.IsClimbing)
				{
					float climbTouchDistance = properties.ClimbTouchDistance;
					int num5 = (int)pos.Y;
					for (int k = 0; k < 4; k++)
					{
						val.IterateHorizontalOffsets(k);
						Cuboidf[] collisionBoxes3;
						int num6;
						for (int l = 0; l < num3; l++)
						{
							val.Y = num5 + l;
							Block block2 = blockAccessor.GetBlock(val, num2);
							if (!block2.IsClimbable(val) && !flag)
							{
								continue;
							}
							collisionBoxes3 = block2.GetCollisionBoxes(blockAccessor, val);
							if (collisionBoxes3 == null)
							{
								continue;
							}
							num6 = 0;
							while (num6 < collisionBoxes3.Length)
							{
								if (!(val2.ShortestDistanceFrom(collisionBoxes3[num6], val) < (double)climbTouchDistance))
								{
									num6++;
									continue;
								}
								goto IL_02a1;
							}
						}
						continue;
						IL_02a1:
						controls.IsClimbing = true;
						entity.ClimbingOnFace = BlockFacing.HORIZONTALS[k];
						entity.ClimbingOnCollBox = collisionBoxes3[num6];
						break;
					}
				}
			}
			if (!remote)
			{
				if (controls.IsClimbing && controls.WalkVector.Y == 0.0)
				{
					motion.Y = (controls.Sneak ? Math.Max(0f - climbUpSpeed, motion.Y - (double)climbUpSpeed) : motion.Y);
					if (controls.Jump)
					{
						motion.Y = climbDownSpeed * dt * 60f;
					}
				}
				double num7 = motion.X * (double)num + pos.X;
				double num8 = motion.Y * (double)num + pos.Y;
				double num9 = motion.Z * (double)num + pos.Z;
				moveDelta.Set(motion.X * (double)num, prevYMotion * (double)num, motion.Z * (double)num);
				((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(entity, pos, num, ref val3, 0f, base.CollisionYExtra);
				if (!properties.CanClimbAnywhere)
				{
					controls.IsStepping = HandleSteppingOnBlocks(pos, moveDelta, num, controls);
				}
				HandleSneaking(pos, controls, dt);
				int num10 = (int)pos.X;
				int num11 = (int)pos.Y;
				int num12 = (int)pos.Z;
				if (entity.CollidedHorizontally && !controls.IsClimbing && !controls.IsStepping && (int)properties.Habitat != 3)
				{
					if (blockAccessor.GetBlockRaw(num10, (int)(pos.InternalY + 0.5), num12, 2).LiquidLevel >= 7 || blockAccessor.GetBlockRaw(num10, (int)pos.InternalY, num12, 2).LiquidLevel >= 7 || blockAccessor.GetBlockRaw(num10, (int)(pos.InternalY - 0.05), num12, 2).LiquidLevel >= 7)
					{
						motion.Y += 0.2 * (double)dt;
						controls.IsStepping = true;
					}
					else
					{
						double num13 = Math.Abs(motion.X);
						double num14 = Math.Abs(motion.Z);
						if (num13 > num14)
						{
							if (num14 < 0.001)
							{
								motion.Z += ((motion.Z < 0.0) ? (-0.0025) : 0.0025);
							}
						}
						else if (num13 < 0.001)
						{
							motion.X += ((motion.X < 0.0) ? (-0.0025) : 0.0025);
						}
					}
				}
				float num15 = entity.CollisionBox.Width / 2f;
				if (blockAccessor.IsNotTraversable((double)(int)(num7 + (double)(num15 * (float)Math.Sign(motion.X))), (double)num11, (double)num12, pos.Dimension))
				{
					val3.X = pos.X;
				}
				if (blockAccessor.IsNotTraversable((double)num10, (double)(int)num8, (double)num12, pos.Dimension))
				{
					val3.Y = pos.Y;
				}
				if (blockAccessor.IsNotTraversable((double)num10, (double)num11, (double)(int)(num9 + (double)(num15 * (float)Math.Sign(motion.Z))), pos.Dimension))
				{
					val3.Z = pos.Z;
				}
				pos.SetPos(val3);
				if ((num7 < val3.X && motion.X < 0.0) || (num7 > val3.X && motion.X > 0.0))
				{
					motion.X = 0.0;
				}
				if ((num8 < val3.Y && motion.Y < 0.0) || (num8 > val3.Y && motion.Y > 0.0))
				{
					motion.Y = 0.0;
				}
				if ((num9 < val3.Z && motion.Z < 0.0) || (num9 > val3.Z && motion.Z > 0.0))
				{
					motion.Z = 0.0;
				}
			}
			bool flag2 = prevYMotion <= 0.0;
			entity.OnGround = entity.CollidedVertically && flag2;
			float num16 = entity.CollisionBox.X2 - entity.OriginCollisionBox.X2;
			float num17 = entity.CollisionBox.Z2 - entity.OriginCollisionBox.Z2;
			int num18 = (int)(pos.X + (double)num16);
			int num19 = (int)pos.InternalY;
			int num20 = (int)(pos.Z + (double)num17);
			int num21 = (int)(pos.InternalY + entity.SwimmingOffsetY);
			Block blockRaw = blockAccessor.GetBlockRaw(num18, num19, num20, 2);
			Block val5 = ((num21 == num19) ? blockRaw : blockAccessor.GetBlockRaw(num18, num21, num20, 2));
			entity.Swimming = ((CollectibleObject)val5).IsLiquid();
			entity.OnGround = (entity.CollidedVertically && flag2 && !controls.IsClimbing) || controls.IsStepping;
			if (((CollectibleObject)blockRaw).IsLiquid())
			{
				Block blockRaw2 = blockAccessor.GetBlockRaw(num18, num19 + 1, num20, 2);
				entity.FeetInLiquid = (double)((float)(blockRaw.LiquidLevel + ((blockRaw2.LiquidLevel > 0) ? 1 : 0)) / 8f) >= pos.Y - (double)(int)pos.Y;
				entity.InLava = blockRaw.LiquidCode == "lava";
				if (!feetInLiquidBefore && entity.FeetInLiquid && (!entity.IsFirstTick() || prevPos.LengthSq() != 0.0))
				{
					entity.OnCollideWithLiquid();
				}
			}
			else
			{
				entity.FeetInLiquid = false;
				entity.InLava = false;
			}
			if (!onGroundBefore && entity.OnGround)
			{
				entity.OnFallToGround(prevYMotion);
			}
			if ((swimmingBefore || feetInLiquidBefore) && !entity.Swimming && !entity.FeetInLiquid)
			{
				entity.OnExitedLiquid();
			}
			if (!flag2 || entity.OnGround || controls.IsClimbing)
			{
				entity.PositionBeforeFalling.Set(pos);
			}
			Cuboidd obj = ((CollisionTester)PhysicsBehaviorBase.collisionTester).entityBox;
			int num22 = (int)(obj.X2 - 0.009);
			int num23 = (int)(obj.Y2 - 0.009);
			int num24 = (int)(obj.Z2 - 0.009);
			int num25 = (int)(obj.X1 + 0.009);
			int num26 = (int)(obj.Z1 + 0.009);
			FastVec3i item = default(FastVec3i);
			for (int m = (int)(obj.Y1 + 0.009); m <= num23; m++)
			{
				for (int n = num25; n <= num22; n++)
				{
					for (int num27 = num26; num27 <= num24; num27++)
					{
						val.Set(n, m, num27);
						Block block3 = blockAccessor.GetBlock(val);
						if (((CollectibleObject)block3).Id != 0)
						{
							((FastVec3i)(ref item))._002Ector(n, m, num27);
							int num28 = traversed.BinarySearch(item, fastVec3IComparer);
							if (num28 < 0)
							{
								num28 = ~num28;
							}
							traversed.Insert(num28, item);
							traversedBlocks.Insert(num28, block3);
						}
					}
				}
			}
			PhysicsTickDelegate physicsUpdateWatcher = entity.PhysicsUpdateWatcher;
			if (physicsUpdateWatcher != null)
			{
				physicsUpdateWatcher.Invoke(0f, prevPos);
			}
		}

		public virtual void OnPhysicsTick(float dt)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Invalid comparison between Unknown and I4
			Entity entity = ((EntityBehavior)this).entity;
			if ((int)entity.State != 0)
			{
				return;
			}
			EntityPos sidedPos = entity.SidedPos;
			PhysicsBehaviorBase.collisionTester.AssignToEntity((PhysicsBehaviorBase)(object)this, sidedPos.Dimension);
			EntityControls controls = ((EntityAgent)entity).Controls;
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (((val != null) ? val.MountedOn : null) != null)
			{
				AdjustMountedPositionFor(val);
				return;
			}
			SetState(sidedPos, dt);
			MotionAndCollision(sidedPos, controls, dt);
			ApplyTests(sidedPos, controls, dt, remote: false);
			if ((int)entity.World.Side == 1)
			{
				entity.Pos.SetFrom(entity.ServerPos);
			}
			IMountable mountableSupplier = base.mountableSupplier;
			if (mountableSupplier == null)
			{
				return;
			}
			IMountableSeat[] seats = mountableSupplier.Seats;
			foreach (IMountableSeat obj in seats)
			{
				Entity obj2 = ((obj != null) ? obj.Passenger : null);
				EntityAgent val2 = (EntityAgent)(object)((obj2 is EntityAgent) ? obj2 : null);
				if (val2 != null && val2.MountedOn != null)
				{
					AdjustMountedPositionFor(val2);
				}
			}
		}

		private void AdjustMountedPositionFor(EntityAgent entity)
		{
			((Entity)entity).Swimming = false;
			((Entity)entity).OnGround = false;
			EntityPos sidedPos = ((Entity)entity).SidedPos;
			if (!(entity is EntityPlayer))
			{
				sidedPos.SetFrom(entity.MountedOn.SeatPosition);
			}
			else
			{
				sidedPos.SetPos(entity.MountedOn.SeatPosition);
			}
			sidedPos.Motion.X = 0.0;
			sidedPos.Motion.Y = 0.0;
			sidedPos.Motion.Z = 0.0;
		}

		public virtual void AfterPhysicsTick(float dt)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			Entity entity = ((EntityBehavior)this).entity;
			if ((int)entity.State == 0 && (base.mountableSupplier == null || base.capi != null || !MountableUtil.IsBeingControlled(base.mountableSupplier)))
			{
				BlockPos val = tmpPos;
				List<Block> list = traversedBlocks;
				List<FastVec3i> list2 = traversed;
				for (int i = 0; i < list.Count; i++)
				{
					val.Set(list2[i]);
					list[i].OnEntityInside(entity.World, entity, val);
				}
				entity.AfterPhysicsTick?.Invoke();
			}
		}

		public void HandleSneaking(EntityPos pos, EntityControls controls, float dt)
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Expected O, but got Unknown
			if (!controls.Sneak || !((EntityBehavior)this).entity.OnGround || pos.Motion.Y > 0.0)
			{
				return;
			}
			Vec3d val = new Vec3d();
			val.Set(pos.X, pos.InternalY - (double)(GlobalConstants.GravityPerSecond * dt), pos.Z);
			if (!((CollisionTester)PhysicsBehaviorBase.collisionTester).IsColliding(((EntityBehavior)this).entity.World.BlockAccessor, sneakTestCollisionbox, val, true))
			{
				return;
			}
			tmpPos.Set((int)pos.X, (int)pos.Y - 1, (int)pos.Z);
			Block block = ((EntityBehavior)this).entity.World.BlockAccessor.GetBlock(tmpPos);
			val.Set(newPos.X, newPos.Y - (double)(GlobalConstants.GravityPerSecond * dt) + (double)pos.DimensionYAdjustment, pos.Z);
			if (!((CollisionTester)PhysicsBehaviorBase.collisionTester).IsColliding(((EntityBehavior)this).entity.World.BlockAccessor, sneakTestCollisionbox, val, true))
			{
				if (block.IsClimbable(tmpPos))
				{
					Vec3d obj = newPos;
					obj.X += (pos.X - newPos.X) / 10.0;
				}
				else
				{
					newPos.X = pos.X;
				}
			}
			val.Set(pos.X, newPos.Y - (double)(GlobalConstants.GravityPerSecond * dt) + (double)pos.DimensionYAdjustment, newPos.Z);
			if (!((CollisionTester)PhysicsBehaviorBase.collisionTester).IsColliding(((EntityBehavior)this).entity.World.BlockAccessor, sneakTestCollisionbox, val, true))
			{
				if (block.IsClimbable(tmpPos))
				{
					Vec3d obj2 = newPos;
					obj2.Z += (pos.Z - newPos.Z) / 10.0;
				}
				else
				{
					newPos.Z = pos.Z;
				}
			}
		}

		protected virtual bool HandleSteppingOnBlocks(EntityPos pos, Vec3d moveDelta, float dtFac, EntityControls controls)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Invalid comparison between Unknown and I4
			if (controls.WalkVector.X == 0.0 && controls.WalkVector.Z == 0.0)
			{
				return false;
			}
			if ((!((EntityBehavior)this).entity.OnGround && !((EntityBehavior)this).entity.Swimming) || (int)((EntityBehavior)this).entity.Properties.Habitat == 3)
			{
				return false;
			}
			steppingCollisionBox.SetAndTranslate(((EntityBehavior)this).entity.CollisionBox, pos.X, pos.Y, pos.Z);
			steppingCollisionBox.Y2 = Math.Max(steppingCollisionBox.Y1 + (double)StepHeight, steppingCollisionBox.Y2);
			Vec3d walkVector = controls.WalkVector;
			Cuboidd val = FindSteppableCollisionBox(steppingCollisionBox, moveDelta.Y, walkVector);
			if (val != null)
			{
				Vec3d val2 = steppingTestMotion;
				val2.Set(moveDelta.X, moveDelta.Y, moveDelta.Z);
				if (TryStep(pos, val2, dtFac, val, steppingCollisionBox))
				{
					return true;
				}
				Vec3d val3 = steppingTestVec;
				val2.Z = 0.0;
				if (TryStep(pos, val2, dtFac, FindSteppableCollisionBox(steppingCollisionBox, moveDelta.Y, val3.Set(walkVector.X, walkVector.Y, 0.0)), steppingCollisionBox))
				{
					return true;
				}
				val2.Set(0.0, moveDelta.Y, moveDelta.Z);
				if (TryStep(pos, val2, dtFac, FindSteppableCollisionBox(steppingCollisionBox, moveDelta.Y, val3.Set(0.0, walkVector.Y, walkVector.Z)), steppingCollisionBox))
				{
					return true;
				}
				return false;
			}
			return false;
		}

		public bool TryStep(EntityPos pos, Vec3d moveDelta, float dtFac, Cuboidd steppableBox, Cuboidd entityCollisionBox)
		{
			if (steppableBox == null)
			{
				return false;
			}
			double num = steppableBox.Y2 - entityCollisionBox.Y1 + 0.03;
			Vec3d val = newPos.OffsetCopy(moveDelta.X, num, moveDelta.Z);
			if (!((CollisionTester)PhysicsBehaviorBase.collisionTester).IsColliding(((EntityBehavior)this).entity.World.BlockAccessor, ((EntityBehavior)this).entity.CollisionBox, val, false))
			{
				pos.Y += (double)(stepUpSpeed * dtFac);
				((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(((EntityBehavior)this).entity, pos, dtFac, ref newPos, 1f, 1f);
				return true;
			}
			return false;
		}

		public static bool GetCollidingCollisionBox(IBlockAccessor blockAccessor, Cuboidf entityBoxRel, Vec3d pos, out CachedCuboidList blocks, BlockPos tmpPos, bool alsoCheckTouch = true)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Expected O, but got Unknown
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Expected O, but got Unknown
			blocks = new CachedCuboidList();
			Vec3d val = new Vec3d();
			Cuboidd val2 = entityBoxRel.ToDouble().Translate((IVec3)(object)pos);
			int num = (int)((double)entityBoxRel.MinX + pos.X);
			int num2 = (int)((double)entityBoxRel.MinY + pos.Y - 1.0);
			int num3 = (int)((double)entityBoxRel.MinZ + pos.Z);
			int num4 = (int)Math.Ceiling((double)entityBoxRel.MaxX + pos.X);
			int num5 = (int)Math.Ceiling((double)entityBoxRel.MaxY + pos.Y);
			int num6 = (int)Math.Ceiling((double)entityBoxRel.MaxZ + pos.Z);
			for (int i = num2; i <= num5; i++)
			{
				for (int j = num; j <= num4; j++)
				{
					for (int k = num3; k <= num6; k++)
					{
						tmpPos.Set(j, i, k);
						Block block = blockAccessor.GetBlock(tmpPos);
						val.Set((double)j, (double)i, (double)k);
						Cuboidf[] collisionBoxes = block.GetCollisionBoxes(blockAccessor, tmpPos);
						if (collisionBoxes == null)
						{
							continue;
						}
						foreach (Cuboidf val3 in collisionBoxes)
						{
							if (val3 != null && (alsoCheckTouch ? val2.IntersectsOrTouches(val3, val) : val2.Intersects(val3, val)))
							{
								blocks.Add(val3, j, tmpPos.InternalY, k, block);
							}
						}
					}
				}
			}
			return blocks.Count > 0;
		}

		public Cuboidd FindSteppableCollisionBox(Cuboidd entityCollisionBox, double motionY, Vec3d walkVector)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Expected O, but got Unknown
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Invalid comparison between Unknown and I4
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Invalid comparison between Unknown and I4
			Cuboidd val = null;
			CachedCuboidListFaster collisionBoxList = ((CollisionTester)PhysicsBehaviorBase.collisionTester).CollisionBoxList;
			int count = collisionBoxList.Count;
			BlockPos val2 = new BlockPos(((EntityBehavior)this).entity.ServerPos.Dimension);
			for (int i = 0; i < count; i++)
			{
				Block val3 = collisionBoxList.blocks[i];
				if (val3.CollisionBoxes != null && !val3.CanStep && ((EntityBehavior)this).entity.CollisionBox.Height < 5f * val3.CollisionBoxes[0].Height)
				{
					continue;
				}
				val2.Set(collisionBoxList.positions[i]);
				if (!val3.SideIsSolid(val2, 4))
				{
					val2.Down(1);
					Block mostSolidBlock = ((EntityBehavior)this).entity.World.BlockAccessor.GetMostSolidBlock(val2);
					val2.Up(1);
					if (mostSolidBlock.CollisionBoxes != null && !mostSolidBlock.CanStep && ((EntityBehavior)this).entity.CollisionBox.Height < 5f * mostSolidBlock.CollisionBoxes[0].Height)
					{
						continue;
					}
				}
				Cuboidd val4 = collisionBoxList.cuboids[i];
				EnumIntersect val5 = CollisionTester.AabbIntersect(val4, entityCollisionBox, walkVector);
				if ((int)val5 != 0)
				{
					if (((int)val5 == 4 && !val3.AllowStepWhenStuck) || ((int)val5 == 2 && motionY > 0.0))
					{
						return null;
					}
					double num = val4.Y2 - entityCollisionBox.Y1;
					if (!(num <= 0.0) && num <= (double)StepHeight && (val == null || val.Y2 < val4.Y2))
					{
						val = val4;
					}
				}
			}
			return val;
		}

		public List<Cuboidd> FindSteppableCollisionboxSmooth(Cuboidd entityCollisionBox, Cuboidd entitySensorBox, double motionY, Vec3d walkVector)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Expected O, but got Unknown
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Invalid comparison between Unknown and I4
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Invalid comparison between Unknown and I4
			List<Cuboidd> list = new List<Cuboidd>();
			GetCollidingCollisionBox(((EntityBehavior)this).entity.World.BlockAccessor, entitySensorBox.ToFloat(), new Vec3d(), out var blocks, tmpPos);
			for (int i = 0; i < blocks.Count; i++)
			{
				Cuboidd val = blocks.cuboids[i];
				Block val2 = blocks.blocks[i];
				if (!val2.CanStep && val2.CollisionBoxes != null && ((EntityBehavior)this).entity.CollisionBox.Height < 5f * val2.CollisionBoxes[0].Height)
				{
					continue;
				}
				BlockPos val3 = blocks.positions[i];
				if (!val2.SideIsSolid(val3, 4))
				{
					val3.Down(1);
					Block mostSolidBlock = ((EntityBehavior)this).entity.World.BlockAccessor.GetMostSolidBlock(val3);
					val3.Up(1);
					if (!mostSolidBlock.CanStep && mostSolidBlock.CollisionBoxes != null && ((EntityBehavior)this).entity.CollisionBox.Height < 5f * mostSolidBlock.CollisionBoxes[0].Height)
					{
						continue;
					}
				}
				EnumIntersect val4 = CollisionTester.AabbIntersect(val, entityCollisionBox, walkVector);
				if (((int)val4 == 4 && !val2.AllowStepWhenStuck) || ((int)val4 == 2 && motionY > 0.0))
				{
					return null;
				}
				double num = val.Y2 - entityCollisionBox.Y1;
				if (!(num <= (((EntityBehavior)this).entity.CollidedVertically ? 0.0 : (-0.05))) && num <= (double)StepHeight)
				{
					list.Add(val);
				}
			}
			return list;
		}

		public void AdjustCollisionBoxToAnimation(float dtFac)
		{
			IAnimator animator = ((EntityBehavior)this).entity.AnimManager.Animator;
			AttachmentPointAndPose val = ((animator != null) ? animator.GetAttachmentPointPose("Center") : null);
			if (val != null)
			{
				float[] array = new float[4] { 0f, 0f, 0f, 1f };
				AttachmentPoint attachPoint = val.AttachPoint;
				CompositeShape shape = ((EntityBehavior)this).entity.Properties.Client.Shape;
				float num = shape?.rotateX ?? 0f;
				float num2 = shape?.rotateY ?? 0f;
				float num3 = shape?.rotateZ ?? 0f;
				float[] array2 = Mat4f.Create();
				Mat4f.Identity(array2);
				Mat4f.Translate(array2, array2, 0f, ((EntityBehavior)this).entity.CollisionBox.Y2 / 2f, 0f);
				double[] array3 = Quaterniond.Create();
				Quaterniond.RotateX(array3, array3, (double)(((EntityBehavior)this).entity.SidedPos.Pitch + num * ((float)Math.PI / 180f)));
				Quaterniond.RotateY(array3, array3, (double)(((EntityBehavior)this).entity.SidedPos.Yaw + (num2 + 90f) * ((float)Math.PI / 180f)));
				Quaterniond.RotateZ(array3, array3, (double)(((EntityBehavior)this).entity.SidedPos.Roll + num3 * ((float)Math.PI / 180f)));
				float[] array4 = new float[array3.Length];
				for (int i = 0; i < array3.Length; i++)
				{
					array4[i] = (float)array3[i];
				}
				Mat4f.Mul(array2, array2, Mat4f.FromQuat(Mat4f.Create(), array4));
				float size = ((EntityBehavior)this).entity.Properties.Client.Size;
				Mat4f.Translate(array2, array2, 0f, (0f - ((EntityBehavior)this).entity.CollisionBox.Y2) / 2f, 0f);
				Mat4f.Scale(array2, array2, new float[3] { size, size, size });
				Mat4f.Translate(array2, array2, -0.5f, 0f, -0.5f);
				tmpModelMat.Set(array2).Mul(val.AnimModelMatrix).Translate(attachPoint.PosX / 16.0, attachPoint.PosY / 16.0, attachPoint.PosZ / 16.0);
				EntityPos sidedPos = ((EntityBehavior)this).entity.SidedPos;
				float[] array5 = Mat4f.MulWithVec4(tmpModelMat.Values, array);
				float num4 = array5[0] - (((EntityBehavior)this).entity.CollisionBox.X1 - ((EntityBehavior)this).entity.OriginCollisionBox.X1);
				float num5 = array5[2] - (((EntityBehavior)this).entity.CollisionBox.Z1 - ((EntityBehavior)this).entity.OriginCollisionBox.Z1);
				if ((double)Math.Abs(num4) > 1E-05 || (double)Math.Abs(num5) > 1E-05)
				{
					EntityPos val2 = sidedPos.Copy();
					val2.Motion.X = num4;
					val2.Motion.Z = num5;
					moveDelta.Set(val2.Motion.X, val2.Motion.Y, val2.Motion.Z);
					((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(((EntityBehavior)this).entity, val2, dtFac, ref newPos, 1f, 1f);
					double x = (newPos.X - sidedPos.X) / (double)dtFac - (double)num4;
					double z = (newPos.Z - sidedPos.Z) / (double)dtFac - (double)num5;
					sidedPos.Motion.X = x;
					sidedPos.Motion.Z = z;
					((EntityBehavior)this).entity.CollisionBox.Set(((EntityBehavior)this).entity.OriginCollisionBox);
					((EntityBehavior)this).entity.CollisionBox.Translate(array5[0], 0f, array5[2]);
					((EntityBehavior)this).entity.SelectionBox.Set(((EntityBehavior)this).entity.OriginSelectionBox);
					((EntityBehavior)this).entity.SelectionBox.Translate(array5[0], 0f, array5[2]);
				}
			}
		}

		protected void callOnEntityInside()
		{
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Expected O, but got Unknown
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Expected O, but got Unknown
			EntityPos serverPos = ((EntityBehavior)this).entity.ServerPos;
			IWorldAccessor world = ((EntityBehavior)this).entity.World;
			Cuboidd val = ((CollisionTester)PhysicsBehaviorBase.collisionTester).entityBox;
			val.SetAndTranslate(((EntityBehavior)this).entity.CollisionBox, serverPos.X, serverPos.Y, serverPos.Z);
			val.RemoveRoundingErrors();
			BlockPos minPos = new BlockPos((int)val.X1, (int)val.Y1, (int)val.Z1, serverPos.Dimension);
			BlockPos val2 = new BlockPos((int)val.X2, (int)val.Y2, (int)val.Z2, serverPos.Dimension);
			world.BlockAccessor.WalkBlocks(minPos, val2, (Action<Block, int, int, int>)delegate(Block block, int x, int y, int z)
			{
				if (((CollectibleObject)block).Id != 0)
				{
					minPos.Set(x, y, z);
					block.OnEntityInside(world, ((EntityBehavior)this).entity, minPos);
				}
			}, false);
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			if (base.sapi != null)
			{
				base.sapi.Server.RemovePhysicsTickable((IPhysicsTickable)(object)this);
			}
		}

		public override string PropertyName()
		{
			return "entitycontrolledphysics";
		}
	}
	public class EntityBehaviorDeadDecay : EntityBehavior
	{
		private ITreeAttribute decayTree;

		private JsonObject typeAttributes;

		public float HoursToDecay { get; set; }

		public double TotalHoursDead
		{
			get
			{
				return decayTree.GetDouble("totalHoursDead", 0.0);
			}
			set
			{
				decayTree.SetDouble("totalHoursDead", value);
			}
		}

		public EntityBehaviorDeadDecay(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Expected O, but got Unknown
			//IL_007b: Expected O, but got Unknown
			((EntityBehavior)this).Initialize(properties, typeAttributes);
			Entity entity = base.entity;
			((EntityAgent)((entity is EntityAgent) ? entity : null)).AllowDespawn = false;
			this.typeAttributes = typeAttributes;
			HoursToDecay = typeAttributes["hoursToDecay"].AsFloat(96f);
			decayTree = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("decay");
			if (decayTree == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				ITreeAttribute val2 = (ITreeAttribute)val;
				decayTree = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("decay", (IAttribute)(object)val2);
				TotalHoursDead = base.entity.World.Calendar.TotalHours;
			}
		}

		public override void OnGameTick(float deltaTime)
		{
			if (!base.entity.Alive && TotalHoursDead + (double)HoursToDecay < base.entity.World.Calendar.TotalHours)
			{
				DecayNow();
			}
			((EntityBehavior)this).OnGameTick(deltaTime);
		}

		public void DecayNow()
		{
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Expected O, but got Unknown
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a7: Expected O, but got Unknown
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Expected O, but got Unknown
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Expected O, but got Unknown
			Entity entity = base.entity;
			if (((EntityAgent)((entity is EntityAgent) ? entity : null)).AllowDespawn)
			{
				return;
			}
			Entity entity2 = base.entity;
			((EntityAgent)((entity2 is EntityAgent) ? entity2 : null)).AllowDespawn = true;
			if (base.entity.DespawnReason == null)
			{
				base.entity.DespawnReason = new EntityDespawnData
				{
					DamageSourceForDeath = null,
					Reason = (EnumDespawnReason)0
				};
			}
			if (typeAttributes["decayedBlock"].Exists)
			{
				AssetLocation val = new AssetLocation(typeAttributes["decayedBlock"].AsString((string)null));
				Block block = base.entity.World.GetBlock(val);
				double num = base.entity.ServerPos.X + (double)base.entity.SelectionBox.X1 - (double)base.entity.OriginSelectionBox.X1;
				double num2 = base.entity.ServerPos.Y + (double)base.entity.SelectionBox.Y1 - (double)base.entity.OriginSelectionBox.Y1;
				double num3 = base.entity.ServerPos.Z + (double)base.entity.SelectionBox.Z1 - (double)base.entity.OriginSelectionBox.Z1;
				BlockPos val2 = new BlockPos((int)num, (int)num2, (int)num3);
				IBlockAccessor blockAccessor = base.entity.World.BlockAccessor;
				if (blockAccessor.GetBlock(val2).IsReplacableBy(block))
				{
					blockAccessor.SetBlock(block.BlockId, val2);
					blockAccessor.MarkBlockDirty(val2, (IPlayer)null);
				}
				else
				{
					BlockFacing[] hORIZONTALS = BlockFacing.HORIZONTALS;
					for (int i = 0; i < hORIZONTALS.Length; i++)
					{
						hORIZONTALS[i].IterateThruFacingOffsets(val2);
						if (base.entity.World.BlockAccessor.GetBlock(val2).IsReplacableBy(block))
						{
							base.entity.World.BlockAccessor.SetBlock(block.BlockId, val2);
							break;
						}
					}
				}
			}
			Vec3d val3 = base.entity.SidedPos.XYZ + base.entity.CollisionBox.Center - base.entity.OriginCollisionBox.Center;
			val3.Y += (double)(base.entity.Properties.DeadCollisionBoxSize.Y / 2f);
			base.entity.World.SpawnParticles((IParticlePropertiesProvider)new EntityCubeParticles(base.entity.World, base.entity.EntityId, val3, 0.15f, (int)(40f + base.entity.Properties.DeadCollisionBoxSize.X * 60f), 0.4f, 1f), (IPlayer)null);
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Invalid comparison between Unknown and I4
			((EntityBehavior)this).OnEntityDeath(damageSourceForDeath);
			TotalHoursDead = base.entity.World.Calendar.TotalHours;
			if (damageSourceForDeath != null && (int)damageSourceForDeath.Source == 5)
			{
				Entity entity = base.entity;
				((EntityAgent)((entity is EntityAgent) ? entity : null)).AllowDespawn = true;
			}
		}

		public override string PropertyName()
		{
			return "deaddecay";
		}
	}
	public class EntityBehaviorDespawn : EntityBehavior, ITimedDespawn
	{
		private float minPlayerDistance = -1f;

		private float belowLightLevel = -1f;

		private float minSeconds = 30f;

		private float accumSeconds;

		private float accumOffset = 2.5f;

		private EnumDespawnMode despawnMode;

		private float deathTimeLocal;

		public float DeathTime
		{
			get
			{
				float? num = ((TreeAttribute)base.entity.Attributes).TryGetFloat("deathTime");
				return deathTimeLocal = ((!num.HasValue) ? 0f : num.Value);
			}
			set
			{
				if (value != deathTimeLocal)
				{
					((TreeAttribute)base.entity.Attributes).SetFloat("deathTime", value);
					deathTimeLocal = value;
				}
			}
		}

		public float DespawnSeconds
		{
			get
			{
				return minSeconds;
			}
			set
			{
				minSeconds = value;
			}
		}

		public EntityBehaviorDespawn(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			JsonObject val = typeAttributes["minPlayerDistance"];
			minPlayerDistance = (val.Exists ? val.AsFloat(0f) : (-1f));
			JsonObject val2 = typeAttributes["belowLightLevel"];
			belowLightLevel = (val2.Exists ? val2.AsFloat(0f) : (-1f));
			int num = ((TreeAttribute)base.entity.Attributes).GetInt("minsecondsToDespawn", 0);
			if (num > 0)
			{
				minSeconds = num;
			}
			else
			{
				minSeconds = typeAttributes["minSeconds"].AsFloat(30f);
				minSeconds += (float)((double)base.entity.EntityId / 5.0 % (double)(minSeconds / 20f));
			}
			JsonObject val3 = typeAttributes["afterDays"];
			if (((TreeAttribute)base.entity.WatchedAttributes).HasAttribute("despawnTotalDays"))
			{
				despawnMode = (val3.Exists ? EnumDespawnMode.AfterSecondsOrAfterDays : EnumDespawnMode.AfterSecondsOrAfterDaysIgnorePlayer);
			}
			else if (val3.Exists)
			{
				despawnMode = EnumDespawnMode.AfterSecondsOrAfterDays;
				((TreeAttribute)base.entity.WatchedAttributes).SetDouble("despawnTotalDays", base.entity.World.Calendar.TotalDays + (double)val3.AsFloat(14f));
			}
			accumOffset += (float)((double)base.entity.EntityId / 200.0 % 1.0);
			deathTimeLocal = DeathTime;
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Invalid comparison between Unknown and I4
			if (!base.entity.Alive || (int)base.entity.World.Side == 2)
			{
				return;
			}
			deltaTime = (float)Math.Min(deltaTime, 0.2);
			if (!((accumSeconds += deltaTime) > accumOffset))
			{
				return;
			}
			if (despawnMode == EnumDespawnMode.AfterSecondsOrAfterDaysIgnorePlayer && base.entity.World.Calendar.TotalDays > ((TreeAttribute)base.entity.WatchedAttributes).GetDouble("despawnTotalDays", 0.0))
			{
				base.entity.Die((EnumDespawnReason)6, (DamageSource)null);
				accumSeconds = 0f;
				return;
			}
			bool flag = PlayerInRange();
			if (flag || LightLevelOk())
			{
				accumSeconds = 0f;
				DeathTime = 0f;
			}
			else if (despawnMode == EnumDespawnMode.AfterSecondsOrAfterDays && !flag && base.entity.World.Calendar.TotalDays > ((TreeAttribute)base.entity.WatchedAttributes).GetDouble("despawnTotalDays", 0.0))
			{
				base.entity.Die((EnumDespawnReason)6, (DamageSource)null);
				accumSeconds = 0f;
			}
			else if ((DeathTime += accumSeconds) > minSeconds)
			{
				base.entity.Die((EnumDespawnReason)6, (DamageSource)null);
				accumSeconds = 0f;
			}
			else
			{
				accumSeconds = 0f;
			}
		}

		public bool PlayerInRange()
		{
			if (minPlayerDistance < 0f)
			{
				return false;
			}
			return base.entity.NearestPlayerDistance < minPlayerDistance;
		}

		public bool LightLevelOk()
		{
			if (belowLightLevel < 0f)
			{
				return false;
			}
			EntityPos serverPos = base.entity.ServerPos;
			return (float)base.entity.World.BlockAccessor.GetLightLevel((int)serverPos.X, (int)serverPos.Y, (int)serverPos.Z, (EnumLightLevelType)2) >= belowLightLevel;
		}

		public override string PropertyName()
		{
			return "timeddespawn";
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			if (belowLightLevel >= 0f && !LightLevelOk() && base.entity.Alive)
			{
				infotext.AppendLine(Lang.Get("Deprived of light, might die soon", Array.Empty<object>()));
			}
			((EntityBehavior)this).GetInfoText(infotext);
		}

		public void SetDespawnByCalendarDate(double totaldays)
		{
			((TreeAttribute)base.entity.WatchedAttributes).SetDouble("despawnTotalDays", totaldays);
			despawnMode = EnumDespawnMode.AfterSecondsOrAfterDaysIgnorePlayer;
		}
	}
	internal enum EnumDespawnMode
	{
		AfterSeconds,
		AfterSecondsOrAfterDays,
		AfterSecondsOrAfterDaysIgnorePlayer
	}
	public class EntityBehaviorDrunkTyping : EntityBehavior
	{
		private ICoreAPI api;

		private bool isCommand;

		public EntityBehaviorDrunkTyping(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			api = base.entity.World.Api;
		}

		public override void OnEntityLoaded()
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Expected O, but got Unknown
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Expected O, but got Unknown
			ICoreAPI obj = base.entity.Api;
			ICoreClientAPI val = (ICoreClientAPI)(object)((obj is ICoreClientAPI) ? obj : null);
			if (val != null)
			{
				Entity entity = base.entity;
				Entity obj2 = ((entity is EntityPlayer) ? entity : null);
				if (((obj2 != null) ? ((EntityPlayer)obj2).PlayerUID : null) == val.Settings.String["playeruid"])
				{
					((IEventAPI)val.Event).RegisterEventBusListener(new EventBusListenerDelegate(onChatKeyDownPre), 1.0, "chatkeydownpre");
					((IEventAPI)val.Event).RegisterEventBusListener(new EventBusListenerDelegate(onChatKeyDownPost), 1.0, "chatkeydownpost");
				}
			}
		}

		public override string PropertyName()
		{
			return "drunktyping";
		}

		private void onChatKeyDownPre(string eventName, ref EnumHandling handling, IAttribute data)
		{
			IAttribute obj = ((TreeAttribute)((data is TreeAttribute) ? data : null))["text"];
			string value = ((ScalarAttribute<string>)(object)((obj is StringAttribute) ? obj : null)).value;
			isCommand = value.Length > 0 && (value[0] == '.' || value[0] == '/');
		}

		private void onChatKeyDownPost(string eventName, ref EnumHandling handling, IAttribute data)
		{
			TreeAttribute val = (TreeAttribute)(object)((data is TreeAttribute) ? data : null);
			IAttribute obj = val["key"];
			int value = ((ScalarAttribute<int>)(object)((obj is IntAttribute) ? obj : null)).value;
			IAttribute obj2 = val["text"];
			string value2 = ((ScalarAttribute<string>)(object)((obj2 is StringAttribute) ? obj2 : null)).value;
			int caretPos = 0;
			if (isCommand && value2.Length > 0 && value2[0] != '.' && value2[0] != '/')
			{
				string text = value2[0].ToString() ?? "";
				for (int i = 1; i < value2.Length; i++)
				{
					text = slurText(text, ref caretPos);
					text += value2[i];
				}
				value2 = text;
				IAttribute obj3 = val["text"];
				((ScalarAttribute<string>)(object)((obj3 is StringAttribute) ? obj3 : null)).value = value2;
			}
			else if (value != 53 && value != 47 && value != 48 && value != 55 && value != 5 && value != 3 && value2.Length > 0 && value2[0] != '.' && value2[0] != '/')
			{
				value2 = slurText(value2, ref caretPos);
				IAttribute obj4 = val["text"];
				((ScalarAttribute<string>)(object)((obj4 is StringAttribute) ? obj4 : null)).value = value2;
			}
			val.SetInt("deltacaretpos", caretPos);
		}

		private string slurText(string text, ref int caretPos)
		{
			Random rand = api.World.Rand;
			float num = ((TreeAttribute)base.entity.WatchedAttributes).GetFloat("intoxication", 0f);
			if (rand.NextDouble() < (double)num)
			{
				switch (rand.Next(9))
				{
				case 0:
				case 1:
					if (text.Length > 1)
					{
						text = text.Substring(0, text.Length - 2) + text[text.Length - 1] + text[text.Length - 2];
					}
					break;
				case 2:
				case 3:
				case 4:
					if (text.Length > 0)
					{
						text += text[text.Length - 1];
						caretPos++;
					}
					break;
				case 5:
				case 6:
				{
					if (text.Length <= 0)
					{
						break;
					}
					string[] array = new string[4] { "1234567890-", "qwertyuiop[", "asdfghjkl;", "zxcvbnm,." };
					char value = text[text.Length - 1];
					for (int i = 0; i < 3; i++)
					{
						int num2 = array[i].IndexOf(value);
						if (num2 >= 0)
						{
							int num3 = rand.Next(2) * 2 - 1;
							text += array[i][GameMath.Clamp(num2 + num3, 0, array[i].Length - 1)];
							caretPos++;
						}
					}
					break;
				}
				}
			}
			return text;
		}
	}
	public enum EnumAccumType
	{
		Sum,
		Max,
		NoAccum
	}
	public class EmotionState
	{
		public string Code = "";

		public float Duration;

		public float Chance;

		public int Slot;

		public float Priority;

		public float StressLevel;

		public int MaxGeneration = int.MaxValue;

		public EnumAccumType AccumType = EnumAccumType.Max;

		public float whenHealthRelBelow = 999f;

		public bool whenSourceUntargetable;

		public string[] NotifyEntityCodes = Array.Empty<string>();

		public string[] EntityCodes;

		public AssetLocation[] EntityCodeLocs;

		public float NotifyChances;

		public float NotifyRange = 12f;

		public float BelowTempDuration;

		public float BelowTempThreshold = -9999f;
	}
	public class ActiveEmoState
	{
		public int StateId;

		public float Duration;

		public long SourceEntityId;
	}
	public class EntityBehaviorEmotionStates : EntityBehavior
	{
		private EmotionState[] availableStates;

		public Dictionary<string, ActiveEmoState> ActiveStatesByCode = new Dictionary<string, ActiveEmoState>();

		private TreeAttribute entityAttr;

		private float healthRel;

		private float tickAccum;

		private EntityPartitioning epartSys;

		private EnumCreatureHostility _enumCreatureHostility;

		private PathfinderTask pathtask;

		private int nopathEmoStateid;

		private long sourceEntityId;

		public EntityBehaviorEmotionStates(Entity entity)
			: base(entity)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Expected O, but got Unknown
			//IL_0058: Expected O, but got Unknown
			if (((TreeAttribute)entity.Attributes).HasAttribute("emotionstates"))
			{
				ref TreeAttribute reference = ref entityAttr;
				IAttribute obj = ((TreeAttribute)entity.Attributes)["emotionstates"];
				reference = (TreeAttribute)(object)((obj is TreeAttribute) ? obj : null);
			}
			else
			{
				SyncedTreeAttribute attributes = entity.Attributes;
				TreeAttribute val = new TreeAttribute();
				TreeAttribute val2 = val;
				entityAttr = val;
				((TreeAttribute)attributes)["emotionstates"] = (IAttribute)(object)val2;
			}
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			((EntityBehavior)this).Initialize(properties, typeAttributes);
			JsonObject[] array = typeAttributes["states"].AsArray();
			availableStates = new EmotionState[array.Length];
			int num = 0;
			JsonObject[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				EmotionState emotionState = array2[i].AsObject<EmotionState>((EmotionState)null);
				availableStates[num++] = emotionState;
				if (emotionState.EntityCodes != null)
				{
					emotionState.EntityCodeLocs = ((IEnumerable<string>)emotionState.EntityCodes).Select((Func<string, AssetLocation>)((string str) => new AssetLocation(str))).ToArray();
				}
			}
			tickAccum = (float)(base.entity.World.Rand.NextDouble() * 0.33);
			epartSys = base.entity.Api.ModLoader.GetModSystem<EntityPartitioning>(true);
			_enumCreatureHostility = base.entity.World.Config.GetString("creatureHostility", (string)null) switch
			{
				"aggressive" => EnumCreatureHostility.Aggressive, 
				"passive" => EnumCreatureHostility.Passive, 
				"off" => EnumCreatureHostility.NeverHostile, 
				_ => EnumCreatureHostility.Aggressive, 
			};
		}

		public override void OnEntityReceiveDamage(DamageSource damageSource, ref float damage)
		{
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Invalid comparison between Unknown and I4
			EntityBehaviorHealth behavior = base.entity.GetBehavior<EntityBehaviorHealth>();
			healthRel = ((behavior == null) ? 1f : (behavior.Health / behavior.MaxHealth));
			EnumDamageSource source = damageSource.Source;
			bool flag = source - 2 <= 1;
			if (flag || _enumCreatureHostility == EnumCreatureHostility.NeverHostile)
			{
				return;
			}
			Entity causeEntity = damageSource.GetCauseEntity();
			long sourceEntityId = causeEntity?.EntityId ?? 0;
			long herdId = default(long);
			ref long reference = ref herdId;
			Entity entity = base.entity;
			reference = ((EntityAgent)((entity is EntityAgent) ? entity : null)).HerdId;
			if (TryTriggerState("alarmherdondamage", sourceEntityId) && causeEntity != null && herdId > 0)
			{
				EmotionState emotionState = availableStates.First((EmotionState s) => s.Code == "alarmherdondamage");
				base.entity.World.GetNearestEntity(base.entity.ServerPos.XYZ, emotionState.NotifyRange, emotionState.NotifyRange, (ActionConsumable<Entity>)delegate(Entity e)
				{
					EntityAgent val = (EntityAgent)(object)((e is EntityAgent) ? e : null);
					if (e.EntityId != base.entity.EntityId && val != null && ((Entity)val).Alive && val.HerdId == herdId)
					{
						((Entity)val).GetBehavior<EntityBehaviorEmotionStates>()?.TryTriggerState("aggressiveondamage", sourceEntityId);
					}
					return false;
				});
			}
			if (TryTriggerState("aggressiveondamage", sourceEntityId))
			{
				TryTriggerState("aggressivealarmondamage", sourceEntityId);
			}
			if (TryTriggerState("fleeondamage", sourceEntityId))
			{
				TryTriggerState("fleealarmondamage", sourceEntityId);
			}
		}

		public bool IsInEmotionState(string statecode)
		{
			return ActiveStatesByCode.ContainsKey(statecode);
		}

		public void ClearStates()
		{
			ActiveStatesByCode.Clear();
		}

		public ActiveEmoState GetActiveEmotionState(string statecode)
		{
			ActiveStatesByCode.TryGetValue(statecode, out var value);
			return value;
		}

		public bool TryTriggerState(string statecode, long sourceEntityId)
		{
			return TryTriggerState(statecode, base.entity.World.Rand.NextDouble(), sourceEntityId);
		}

		public bool TryTriggerState(string statecode, double rndValue, long sourceEntityId)
		{
			bool result = false;
			for (int i = 0; i < availableStates.Length; i++)
			{
				EmotionState emotionState = availableStates[i];
				if (!(emotionState.Code != statecode) && !(rndValue > (double)emotionState.Chance))
				{
					if (emotionState.whenSourceUntargetable)
					{
						TryTarget(i, sourceEntityId);
					}
					else if (tryActivateState(i, sourceEntityId))
					{
						result = true;
					}
				}
			}
			return result;
		}

		private void TryTarget(int emostateid, long sourceEntityId)
		{
			if (pathtask == null)
			{
				ICoreAPI api = base.entity.World.Api;
				PathfindingAsync modSystem = api.ModLoader.GetModSystem<PathfindingAsync>(true);
				WaypointsTraverser waypointsTraverser = base.entity.GetBehavior<EntityBehaviorTaskAI>()?.PathTraverser;
				if (waypointsTraverser != null)
				{
					pathtask = waypointsTraverser.PreparePathfinderTask(base.entity.ServerPos.AsBlockPos, api.World.GetEntityById(sourceEntityId).ServerPos.AsBlockPos);
					modSystem.EnqueuePathfinderTask(pathtask);
					nopathEmoStateid = emostateid;
					this.sourceEntityId = sourceEntityId;
				}
			}
		}

		private bool tryActivateState(int stateid, long sourceEntityId)
		{
			EmotionState emotionState = availableStates[stateid];
			string code = emotionState.Code;
			ActiveEmoState activeEmoState = null;
			if (emotionState.whenHealthRelBelow < healthRel)
			{
				return false;
			}
			foreach (KeyValuePair<string, ActiveEmoState> item in ActiveStatesByCode)
			{
				if (item.Key == emotionState.Code)
				{
					activeEmoState = item.Value;
					continue;
				}
				int stateId = item.Value.StateId;
				EmotionState emotionState2 = availableStates[stateId];
				if (emotionState2.Slot != emotionState.Slot)
				{
					continue;
				}
				if (emotionState2.Priority > emotionState.Priority)
				{
					return false;
				}
				ActiveStatesByCode.Remove(item.Key);
				entityAttr.RemoveAttribute(emotionState.Code);
				break;
			}
			if (emotionState.MaxGeneration < ((TreeAttribute)base.entity.WatchedAttributes).GetInt("generation", 0))
			{
				return false;
			}
			if (code == "aggressivearoundentities" && (activeEmoState != null || !entitiesNearby(emotionState)))
			{
				return false;
			}
			float num = emotionState.Duration;
			if (emotionState.BelowTempThreshold > -99f && base.entity.World.BlockAccessor.GetClimateAt(base.entity.Pos.AsBlockPos, (EnumGetClimateMode)3, base.entity.World.Calendar.TotalDays).Temperature < emotionState.BelowTempThreshold)
			{
				num = emotionState.BelowTempDuration;
			}
			float num2 = 0f;
			if (emotionState.AccumType == EnumAccumType.Sum)
			{
				num2 = activeEmoState?.Duration ?? (0f + num);
			}
			if (emotionState.AccumType == EnumAccumType.Max)
			{
				num2 = Math.Max(activeEmoState?.Duration ?? 0f, num);
			}
			if (emotionState.AccumType == EnumAccumType.NoAccum)
			{
				num2 = ((activeEmoState == null || !(activeEmoState.Duration > 0f)) ? num : (activeEmoState?.Duration ?? 0f));
			}
			if (activeEmoState == null)
			{
				ActiveStatesByCode[emotionState.Code] = new ActiveEmoState
				{
					Duration = num2,
					SourceEntityId = sourceEntityId,
					StateId = stateid
				};
			}
			else
			{
				activeEmoState.SourceEntityId = sourceEntityId;
			}
			entityAttr.SetFloat(emotionState.Code, num2);
			return true;
		}

		public override void OnGameTick(float deltaTime)
		{
			if (pathtask != null && pathtask.Finished)
			{
				if (pathtask.waypoints == null)
				{
					tryActivateState(nopathEmoStateid, sourceEntityId);
				}
				pathtask = null;
				nopathEmoStateid = 0;
				sourceEntityId = 0L;
			}
			if ((tickAccum += deltaTime) < 0.33f)
			{
				return;
			}
			tickAccum = 0f;
			if (_enumCreatureHostility == EnumCreatureHostility.Aggressive)
			{
				TryTriggerState("aggressivearoundentities", 0L);
			}
			float num = 0f;
			List<string> list = null;
			foreach (KeyValuePair<string, ActiveEmoState> item in ActiveStatesByCode)
			{
				string key = item.Key;
				ActiveEmoState value = item.Value;
				if ((value.Duration -= 10f * deltaTime) <= 0f)
				{
					if (list == null)
					{
						list = new List<string>();
					}
					list.Add(key);
					entityAttr.RemoveAttribute(key);
				}
				else
				{
					num += availableStates[value.StateId].StressLevel;
				}
			}
			if (list != null)
			{
				foreach (string item2 in list)
				{
					ActiveStatesByCode.Remove(item2);
				}
			}
			float num2 = ((TreeAttribute)base.entity.WatchedAttributes).GetFloat("stressLevel", 0f);
			if (num > 0f)
			{
				((TreeAttribute)base.entity.WatchedAttributes).SetFloat("stressLevel", Math.Max(num2, num));
			}
			else if (num2 > 0f)
			{
				num2 = Math.Max(0f, num2 - deltaTime * 1.25f);
				((TreeAttribute)base.entity.WatchedAttributes).SetFloat("stressLevel", num2);
			}
			if (base.entity.World.EntityDebugMode)
			{
				((TreeAttribute)base.entity.DebugAttributes).SetString("emotionstates", string.Join(", ", ActiveStatesByCode.Keys.ToList()));
			}
		}

		private bool entitiesNearby(EmotionState newstate)
		{
			return epartSys.GetNearestEntity(base.entity.ServerPos.XYZ, newstate.NotifyRange, delegate(Entity e)
			{
				if (newstate.EntityCodeLocs == null)
				{
					return false;
				}
				for (int i = 0; i < newstate.EntityCodeLocs.Length; i++)
				{
					if (newstate.EntityCodeLocs[i].Equals(((RegistryObject)e).Code))
					{
						return e.IsInteractable;
					}
				}
				return false;
			}, EnumEntitySearchType.Creatures) != null;
		}

		public override string PropertyName()
		{
			return "emotionstates";
		}
	}
	public class EntityBehaviorEntityStateTags : EntityBehavior
	{
		protected bool Swimming;

		protected bool FeetInLiquid;

		protected bool OnGround;

		protected bool Flying;

		protected bool Aiming;

		protected bool Moving;

		protected bool Alive;

		protected bool Sprinting;

		protected bool Sneaking;

		protected bool Armed;

		protected bool ArmedMelee;

		protected bool ArmedRanged;

		protected bool HoldingOpenFire;

		protected static EntityTagArray TagSwimming = EntityTagArray.Empty;

		protected static EntityTagArray TagFeetInLiquid = EntityTagArray.Empty;

		protected static EntityTagArray TagFlying = EntityTagArray.Empty;

		protected static EntityTagArray TagOnGround = EntityTagArray.Empty;

		protected static EntityTagArray TagMoving = EntityTagArray.Empty;

		protected static EntityTagArray TagAlive = EntityTagArray.Empty;

		protected static EntityTagArray TagAiming = EntityTagArray.Empty;

		protected static EntityTagArray TagSprinting = EntityTagArray.Empty;

		protected static EntityTagArray TagSneaking = EntityTagArray.Empty;

		protected static EntityTagArray TagArmed = EntityTagArray.Empty;

		protected static EntityTagArray TagArmedMelee = EntityTagArray.Empty;

		protected static EntityTagArray TagArmedRanged = EntityTagArray.Empty;

		protected static EntityTagArray TagHoldingOpenFire = EntityTagArray.Empty;

		protected static ItemTagArray ItemTagWeapon = ItemTagArray.Empty;

		protected static ItemTagArray ItemTagWeaponMelee = ItemTagArray.Empty;

		protected static ItemTagArray ItemTagWeaponRanged = ItemTagArray.Empty;

		protected static ItemTagArray ItemTagHasOpenFire = ItemTagArray.Empty;

		protected static BlockTagArray BlockTagHasOpenFire = BlockTagArray.Empty;

		protected float TimeSinceUpdateSec;

		protected float UpdatePeriodSec = 1f;

		public EntityBehaviorEntityStateTags(Entity entity)
			: base(entity)
		{
		}

		public override string PropertyName()
		{
			return "entityStateTags";
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			if (attributes.KeyExists("updatePeriodSec"))
			{
				UpdatePeriodSec = attributes["updatePeriodSec"].AsFloat(UpdatePeriodSec);
			}
			EntityTagArray tags = base.entity.Tags;
			TagsInitialUpdate(ref tags);
			if (base.entity.Tags != tags)
			{
				base.entity.Tags = tags;
				base.entity.MarkTagsDirty();
			}
			TimeSinceUpdateSec = (float)base.entity.World.Rand.NextDouble() * UpdatePeriodSec;
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			if ((int)base.entity.Api.Side != 1)
			{
				return;
			}
			TimeSinceUpdateSec += deltaTime;
			if (!(TimeSinceUpdateSec < UpdatePeriodSec))
			{
				TimeSinceUpdateSec = 0f;
				EntityTagArray tags = base.entity.Tags;
				TagsUpdate(ref tags);
				if (base.entity.Tags != tags)
				{
					base.entity.Tags = tags;
					base.entity.MarkTagsDirty();
				}
				base.entity.World.FrameProfiler.Mark("statetagsupdate");
			}
		}

		public static void GetTagsIds(ITagRegistry registry)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			TagSwimming = new EntityTagArray(registry.EntityTagToTagId("state-swimming"));
			TagFeetInLiquid = new EntityTagArray(registry.EntityTagToTagId("state-feet-in-liquid"));
			TagFlying = new EntityTagArray(registry.EntityTagToTagId("state-flying"));
			TagOnGround = new EntityTagArray(registry.EntityTagToTagId("state-on-ground"));
			TagMoving = new EntityTagArray(registry.EntityTagToTagId("state-moving"));
			TagAlive = new EntityTagArray(registry.EntityTagToTagId("state-alive"));
			TagAiming = new EntityTagArray(registry.EntityTagToTagId("state-aiming"));
			TagSprinting = new EntityTagArray(registry.EntityTagToTagId("state-sprinting"));
			TagSneaking = new EntityTagArray(registry.EntityTagToTagId("state-sneaking"));
			TagArmed = new EntityTagArray(registry.EntityTagToTagId("state-armed"));
			TagArmedMelee = new EntityTagArray(registry.EntityTagToTagId("state-armed-melee"));
			TagArmedRanged = new EntityTagArray(registry.EntityTagToTagId("state-armed-ranged"));
			ItemTagWeapon = new ItemTagArray(registry.ItemTagToTagId("weapon"));
			ItemTagWeaponMelee = new ItemTagArray(registry.ItemTagToTagId("weapon-melee"));
			ItemTagWeaponRanged = new ItemTagArray(registry.ItemTagToTagId("weapon-ranged"));
			ItemTagHasOpenFire = new ItemTagArray(registry.ItemTagToTagId("has-open-fire"));
			BlockTagHasOpenFire = new BlockTagArray(registry.BlockTagToTagId("has-open-fire"));
		}

		protected virtual void TagsInitialUpdate(ref EntityTagArray tags)
		{
			EntityTagsInitialUpdate(ref tags);
			Entity entity = base.entity;
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (val != null)
			{
				EntityAgentTagsInitialUpdate(val, ref tags);
				EntityAgentHandItemsTagsInitialUpdate(val, ref tags);
			}
		}

		protected virtual void TagsUpdate(ref EntityTagArray tags)
		{
			EntityTagsUpdate(ref tags);
			Entity entity = base.entity;
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (val != null)
			{
				EntityAgentTagsUpdate(val, ref tags);
				EntityAgentHandItemsTagsUpdate(val, ref tags);
			}
		}

		protected virtual void EntityTagsInitialUpdate(ref EntityTagArray tags)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			tags = ((EntityTagArray)(ref tags)).Remove(TagSwimming);
			tags = ((EntityTagArray)(ref tags)).Remove(TagFeetInLiquid);
			tags = ((EntityTagArray)(ref tags)).Remove(TagOnGround);
			tags = ((EntityTagArray)(ref tags)).Remove(TagAlive);
			EntityTagsUpdate(ref tags);
		}

		protected virtual void EntityAgentTagsInitialUpdate(EntityAgent entityAgent, ref EntityTagArray tags)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			tags = ((EntityTagArray)(ref tags)).Remove(TagMoving);
			tags = ((EntityTagArray)(ref tags)).Remove(TagAiming);
			tags = ((EntityTagArray)(ref tags)).Remove(TagFlying);
			tags = ((EntityTagArray)(ref tags)).Remove(TagSneaking);
			tags = ((EntityTagArray)(ref tags)).Remove(TagSprinting);
			EntityAgentTagsUpdate(entityAgent, ref tags);
		}

		protected virtual void EntityAgentHandItemsTagsInitialUpdate(EntityAgent entityAgent, ref EntityTagArray tags)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			ItemSlot rightHandItemSlot = entityAgent.RightHandItemSlot;
			ItemStack val = ((rightHandItemSlot != null) ? rightHandItemSlot.Itemstack : null);
			ItemTagArray val2 = (ItemTagArray)(((_003F?)((val == null) ? ((ItemTagArray?)null) : val.Item?.Tags)) ?? ItemTagArray.Empty);
			BlockTagArray val3 = (BlockTagArray)(((_003F?)((val == null) ? ((BlockTagArray?)null) : val.Block?.Tags)) ?? BlockTagArray.Empty);
			ItemSlot leftHandItemSlot = entityAgent.LeftHandItemSlot;
			val = ((leftHandItemSlot != null) ? leftHandItemSlot.Itemstack : null);
			if (((val != null) ? val.Item : null) != null)
			{
				val2 |= val.Item.Tags;
			}
			if (((val != null) ? val.Block : null) != null)
			{
				val3 |= val.Block.Tags;
			}
			InitializeTag(ref tags, Armed = ((ItemTagArray)(ref val2)).ContainsAll(ItemTagWeapon), TagArmed);
			InitializeTag(ref tags, ArmedMelee = ((ItemTagArray)(ref val2)).ContainsAll(ItemTagWeaponMelee), TagArmedMelee);
			InitializeTag(ref tags, ArmedRanged = ((ItemTagArray)(ref val2)).ContainsAll(ItemTagWeaponRanged), TagArmedRanged);
			InitializeTag(ref tags, HoldingOpenFire = ((ItemTagArray)(ref val2)).ContainsAll(ItemTagHasOpenFire) || ((BlockTagArray)(ref val3)).ContainsAll(BlockTagHasOpenFire), TagHoldingOpenFire);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected virtual void UpdateTag(ref EntityTagArray tags, ref bool storedValue, EntityTagArray mask, bool newValue)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (storedValue != newValue)
			{
				storedValue = newValue;
				if (newValue)
				{
					tags |= mask;
				}
				else
				{
					tags &= ~mask;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected virtual void InitializeTag(ref EntityTagArray tags, bool newValue, EntityTagArray mask)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			if (newValue)
			{
				tags |= mask;
			}
			else
			{
				tags &= ~mask;
			}
		}

		protected virtual void EntityTagsUpdate(ref EntityTagArray tags)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			UpdateTag(ref tags, ref Swimming, TagSwimming, base.entity.Swimming);
			UpdateTag(ref tags, ref FeetInLiquid, TagFeetInLiquid, base.entity.FeetInLiquid && !Swimming);
			UpdateTag(ref tags, ref OnGround, TagOnGround, base.entity.OnGround);
			UpdateTag(ref tags, ref Alive, TagAlive, base.entity.Alive);
		}

		protected virtual void EntityAgentTagsUpdate(EntityAgent entityAgent, ref EntityTagArray tags)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			EntityControls controls = entityAgent.Controls;
			UpdateTag(ref tags, ref Moving, TagMoving, controls.Forward || controls.Backward || controls.Right || controls.Left || controls.Jump || controls.Gliding);
			UpdateTag(ref tags, ref Aiming, TagAiming, controls.IsAiming);
			UpdateTag(ref tags, ref Flying, TagFlying, controls.IsFlying);
			UpdateTag(ref tags, ref Sneaking, TagSneaking, controls.Sneak);
			UpdateTag(ref tags, ref Sprinting, TagSprinting, controls.Sprint);
		}

		protected virtual void EntityAgentHandItemsTagsUpdate(EntityAgent entityAgent, ref EntityTagArray tags)
		{
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			ItemSlot activeHandItemSlot = entityAgent.ActiveHandItemSlot;
			ItemStack obj = ((activeHandItemSlot != null) ? activeHandItemSlot.Itemstack : null);
			Item val = ((obj != null) ? obj.Item : null);
			if (val == null)
			{
				UpdateTag(ref tags, ref Armed, TagArmed, newValue: false);
				UpdateTag(ref tags, ref ArmedMelee, TagArmedMelee, newValue: false);
				UpdateTag(ref tags, ref ArmedRanged, TagArmedRanged, newValue: false);
			}
			else
			{
				UpdateTag(ref tags, ref Armed, TagArmed, ((ItemTagArray)(ref ItemTagWeapon)).isPresentIn(ref val.Tags));
				UpdateTag(ref tags, ref ArmedMelee, TagArmedMelee, ((ItemTagArray)(ref ItemTagWeaponMelee)).isPresentIn(ref val.Tags));
				UpdateTag(ref tags, ref ArmedRanged, TagArmedRanged, ((ItemTagArray)(ref ItemTagWeaponRanged)).isPresentIn(ref val.Tags));
			}
			Block val2 = ((obj != null) ? obj.Block : null);
			UpdateTag(ref tags, ref HoldingOpenFire, TagHoldingOpenFire, (val != null && ((ItemTagArray)(ref ItemTagHasOpenFire)).isPresentIn(ref val.Tags)) || (val2 != null && ((BlockTagArray)(ref BlockTagHasOpenFire)).isPresentIn(ref val2.Tags)));
		}
	}
	public class EntityBehaviorFloatUpWhenStuck : EntityBehavior
	{
		private bool onlyWhenDead;

		private int counter;

		private bool stuckInBlock;

		private float pushVelocityMul = 1f;

		private Vec3d tmpPos = new Vec3d();

		public EntityBehaviorFloatUpWhenStuck(Entity entity)
			: base(entity)
		{
		}//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown


		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			((EntityBehavior)this).Initialize(properties, attributes);
			onlyWhenDead = attributes["onlyWhenDead"].AsBool(false);
			pushVelocityMul = attributes["pushVelocityMul"].AsFloat(1f);
			counter = (int)base.entity.EntityId / 10 % 10;
		}

		public override void OnTesselated()
		{
			((EntityBehavior)this).OnTesselated();
			ensureCenterAPExists();
		}

		private void ensureCenterAPExists()
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Invalid comparison between Unknown and I4
			if (base.entity.AnimManager == null || (int)base.entity.World.Side != 2)
			{
				return;
			}
			IAnimator animator = base.entity.AnimManager.Animator;
			if (((animator != null) ? animator.GetAttachmentPointPose("Center") : null) == null)
			{
				HashSet<AssetLocation> orCreate = ObjectCacheUtil.GetOrCreate<HashSet<AssetLocation>>(base.entity.Api, "missingCenterApEntityCodes", (CreateCachableObjectDelegate<HashSet<AssetLocation>>)(() => new HashSet<AssetLocation>()));
				if (!orCreate.Contains(((RegistryObject)base.entity).Code))
				{
					orCreate.Add(((RegistryObject)base.entity).Code);
					base.entity.World.Logger.Warning("Entity " + AssetLocation.op_Implicit(((RegistryObject)base.entity).Code) + " with shape " + ((object)base.entity.Properties.Client.Shape)?.ToString() + " seems to be missing attachment point center but also has the FloatUpWhenStuck behavior - it might not work correctly with the center point lacking");
				}
			}
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Invalid comparison between Unknown and I4
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			if (base.entity.World.ElapsedMilliseconds < 2000 || (int)base.entity.World.Side == 2 || (counter++ <= 10 && (!stuckInBlock || counter <= 1)))
			{
				return;
			}
			counter = 0;
			if ((onlyWhenDead && base.entity.Alive) || base.entity.Properties.CanClimbAnywhere)
			{
				return;
			}
			stuckInBlock = false;
			base.entity.Properties.Habitat = (EnumHabitat)1;
			if (!base.entity.Swimming)
			{
				tmpPos.Set(base.entity.SidedPos.X, base.entity.SidedPos.Y, base.entity.SidedPos.Z);
				Cuboidd collidingCollisionBox = base.entity.World.CollisionTester.GetCollidingCollisionBox(base.entity.World.BlockAccessor, base.entity.CollisionBox.Clone().ShrinkBy(0.01f), tmpPos, false);
				if (collidingCollisionBox != null)
				{
					PushoutOfCollisionbox(deltaTime, collidingCollisionBox);
					stuckInBlock = true;
				}
			}
		}

		private void PushoutOfCollisionbox(float dt, Cuboidd collBox)
		{
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			double x = base.entity.SidedPos.X;
			double y = base.entity.SidedPos.Y;
			double z = base.entity.SidedPos.Z;
			IBlockAccessor blockAccessor = base.entity.World.BlockAccessor;
			Vec3i val = null;
			double num = 99.0;
			for (int i = 0; i < Cardinal.ALL.Length; i++)
			{
				if (num <= 0.25)
				{
					break;
				}
				Cardinal val2 = Cardinal.ALL[i];
				for (int j = 1; j <= 4; j++)
				{
					float num2 = (float)j / 4f;
					if (!base.entity.World.CollisionTester.IsColliding(blockAccessor, base.entity.CollisionBox, tmpPos.Set(x + (double)((float)val2.Normali.X * num2), y, z + (double)((float)val2.Normali.Z * num2)), false) && (double)num2 < num)
					{
						num = num2 + (val2.IsDiagnoal ? 0.1f : 0f);
						val = val2.Normali;
						break;
					}
				}
			}
			if (val == (Vec3i)null)
			{
				val = BlockFacing.UP.Normali;
			}
			dt = Math.Min(dt, 0.1f);
			float num3 = ((float)base.entity.World.Rand.NextDouble() - 0.5f) / 600f;
			float num4 = ((float)base.entity.World.Rand.NextDouble() - 0.5f) / 600f;
			EntityPos sidedPos = base.entity.SidedPos;
			sidedPos.X += (double)((float)val.X * dt * 0.4f);
			EntityPos sidedPos2 = base.entity.SidedPos;
			sidedPos2.Y += (double)((float)val.Y * dt * 0.4f);
			EntityPos sidedPos3 = base.entity.SidedPos;
			sidedPos3.Z += (double)((float)val.Z * dt * 0.4f);
			base.entity.SidedPos.Motion.X = pushVelocityMul * (float)val.X * dt + num3;
			base.entity.SidedPos.Motion.Y = pushVelocityMul * (float)val.Y * dt * 2f;
			base.entity.SidedPos.Motion.Z = pushVelocityMul * (float)val.Z * dt + num4;
			base.entity.Properties.Habitat = (EnumHabitat)2;
		}

		public override string PropertyName()
		{
			return "floatupwhenstuck";
		}
	}
	public record GaitMeta
	{
		public required string Code { get; set; }

		public float YawMultiplier { get; set; } = 3.5f;

		public float MoveSpeed { get; set; }

		public bool Backwards { get; set; }

		public float StaminaCost { get; set; }

		public string? FallbackGaitCode { get; set; }

		public bool IsSprint { get; set; }

		public required AssetLocation Sound { get; set; }

		[CompilerGenerated]
		[SetsRequiredMembers]
		protected GaitMeta(GaitMeta original)
		{
			Code = original.Code;
			YawMultiplier = original.YawMultiplier;
			MoveSpeed = original.MoveSpeed;
			Backwards = original.Backwards;
			StaminaCost = original.StaminaCost;
			FallbackGaitCode = original.FallbackGaitCode;
			IsSprint = original.IsSprint;
			Sound = original.Sound;
		}

		public GaitMeta()
		{
		}
	}
	public class EntityBehaviorGait : EntityBehavior
	{
		public readonly FastSmallDictionary<string, GaitMeta> Gaits = new FastSmallDictionary<string, GaitMeta>(1);

		public GaitMeta IdleGait;

		protected ICoreAPI? api;

		public GaitMeta CurrentGait
		{
			get
			{
				return Gaits[((TreeAttribute)base.entity.WatchedAttributes).GetString("currentgait", (string)null)];
			}
			set
			{
				((TreeAttribute)base.entity.WatchedAttributes).SetString("currentgait", value.Code);
			}
		}

		public GaitMeta FallbackGait
		{
			get
			{
				if (CurrentGait.FallbackGaitCode != null)
				{
					return Gaits[CurrentGait.FallbackGaitCode];
				}
				return IdleGait;
			}
		}

		public bool IsIdle => IsIdleGait(CurrentGait);

		public bool IsBackward => IsBackwards(CurrentGait);

		public bool IsForward => IsForwards(CurrentGait);

		public override string PropertyName()
		{
			return "gait";
		}

		public float GetYawMultiplier()
		{
			return CurrentGait?.YawMultiplier ?? 3.5f;
		}

		public virtual void SetIdle()
		{
			CurrentGait = IdleGait;
		}

		public virtual bool IsIdleGait(GaitMeta gait)
		{
			return gait == IdleGait;
		}

		public bool IsBackwards(GaitMeta gait)
		{
			return gait.Backwards;
		}

		public bool IsForwards(GaitMeta gait)
		{
			if (!gait.Backwards)
			{
				return gait != IdleGait;
			}
			return false;
		}

		public GaitMeta CascadingFallbackGait(int n)
		{
			GaitMeta gaitMeta = CurrentGait;
			while (n > 0)
			{
				if (gaitMeta.FallbackGaitCode == null)
				{
					return IdleGait;
				}
				gaitMeta = Gaits[gaitMeta.FallbackGaitCode];
				n--;
			}
			return gaitMeta;
		}

		public EntityBehaviorGait(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			((EntityBehavior)this).Initialize(properties, attributes);
			api = base.entity.Api;
			GaitMeta[] array = attributes["gaits"].AsArray<GaitMeta>((GaitMeta[])null, (string)null);
			foreach (GaitMeta gaitMeta in array)
			{
				Gaits[gaitMeta.Code] = gaitMeta;
			}
			string text = attributes["idleGait"].AsString("idle");
			if (!Gaits.TryGetValue(text, ref IdleGait))
			{
				throw new ArgumentException("JSON error. No idle gait for {0}", AssetLocation.op_Implicit(((RegistryObject)base.entity).Code));
			}
			CurrentGait = IdleGait;
		}
	}
	public class EntityBehaviorGrow : EntityBehavior
	{
		private ITreeAttribute growTree;

		private long callbackId;

		public AssetLocation[] AdultEntityCodes;

		public AssetLocation[] FedAdultEntityCodes;

		public float HoursToGrow { get; set; }

		public float OrPortionsEatenForGrowing { get; set; }

		protected double SpawnedTotalHours
		{
			get
			{
				return growTree.GetDouble("timeSpawned", 0.0);
			}
			set
			{
				growTree.SetDouble("timeSpawned", value);
			}
		}

		public EntityBehaviorGrow(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Invalid comparison between Unknown and I4
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Expected O, but got Unknown
			//IL_00d3: Expected O, but got Unknown
			((EntityBehavior)this).Initialize(properties, typeAttributes);
			AdultEntityCodes = AssetLocation.toLocations(typeAttributes["adultEntityCodes"].AsArray<string>(Array.Empty<string>(), (string)null));
			FedAdultEntityCodes = AssetLocation.toLocations(typeAttributes["fedAdultEntityCodes"].AsArray<string>(Array.Empty<string>(), (string)null));
			HoursToGrow = typeAttributes["hoursToGrow"].AsFloat(96f);
			OrPortionsEatenForGrowing = typeAttributes["orPortionsEatenForGrowing"].AsFloat(12f);
			growTree = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("grow");
			if (growTree == null && (int)base.entity.Api.Side == 1)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				ITreeAttribute val2 = (ITreeAttribute)val;
				growTree = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("grow", (IAttribute)(object)val2);
				SpawnedTotalHours = base.entity.World.Calendar.TotalHours;
			}
			if (FedAdultEntityCodes.Length != 0)
			{
				double? num2;
				double? num = (num2 = ((TreeAttribute)base.entity.Attributes).TryGetDouble("totalDaysReleased"));
				if (num.HasValue)
				{
					float orPortionsEatenForGrowing = OrPortionsEatenForGrowing;
					ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("hunger");
					double num3 = 216f * (orPortionsEatenForGrowing - ((treeAttribute != null) ? treeAttribute.TryGetFloat("saturation") : ((float?)null)).GetValueOrDefault());
					double num4 = num2.Value * (double)base.entity.World.Calendar.HoursPerDay + num3 - (double)HoursToGrow;
					if (SpawnedTotalHours < num4)
					{
						SpawnedTotalHours = num4;
					}
				}
			}
			callbackId = base.entity.World.RegisterCallback((Action<float>)CheckGrowth, 3000);
		}

		private void CheckGrowth(float dt)
		{
			callbackId = 0L;
			if (!base.entity.Alive)
			{
				return;
			}
			ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("hunger");
			bool flag = FedAdultEntityCodes.Length != 0 && treeAttribute != null && treeAttribute.GetFloat("saturation", 0f) >= OrPortionsEatenForGrowing;
			if (base.entity.World.Calendar.TotalHours >= SpawnedTotalHours + (double)HoursToGrow || flag)
			{
				AssetLocation[] array = (flag ? FedAdultEntityCodes : AdultEntityCodes);
				if (array.Length == 0)
				{
					return;
				}
				AssetLocation val = array[base.entity.World.Rand.Next(array.Length)];
				EntityProperties entityType = base.entity.World.GetEntityType(val);
				if (entityType == null)
				{
					base.entity.World.Logger.Error("Misconfigured entity. Entity with code '{0}' is configured (via Grow behavior) to grow into '{1}', but no such entity type was registered.", new object[2]
					{
						((RegistryObject)base.entity).Code,
						val
					});
					return;
				}
				Cuboidf spawnCollisionBox = entityType.SpawnCollisionBox;
				if (base.entity.World.CollisionTester.IsColliding(base.entity.World.BlockAccessor, spawnCollisionBox, base.entity.ServerPos.XYZ, false))
				{
					callbackId = base.entity.World.RegisterCallback((Action<float>)CheckGrowth, 3000);
					return;
				}
				Entity val2 = base.entity.World.ClassRegistry.CreateEntity(entityType);
				val2.ServerPos.SetFrom(base.entity.ServerPos);
				val2.Pos.SetFrom(val2.ServerPos);
				bool keepTextureIndex = base.entity.Properties.Client != null && base.entity.Properties.Client.TexturesAlternatesCount > 0 && entityType.Client != null && base.entity.Properties.Client.TexturesAlternatesCount == entityType.Client.TexturesAlternatesCount;
				((TreeAttribute)val2.Attributes).SetBool("wasFedToAdulthood", flag);
				BecomeAdult(val2, keepTextureIndex);
			}
			else
			{
				callbackId = base.entity.World.RegisterCallback((Action<float>)CheckGrowth, 3000);
				double num = base.entity.World.Calendar.TotalHours - SpawnedTotalHours;
				if (num >= 0.1 * (double)HoursToGrow)
				{
					float num2 = (float)(num / (double)HoursToGrow - 0.1);
					if (num2 >= 1.01f * growTree.GetFloat("age", 0f))
					{
						growTree.SetFloat("age", num2);
						base.entity.WatchedAttributes.MarkPathDirty("grow");
					}
				}
			}
			base.entity.World.FrameProfiler.Mark("checkgrowth");
		}

		protected virtual void BecomeAdult(Entity adult, bool keepTextureIndex)
		{
			((TreeAttribute)adult.WatchedAttributes).SetInt("generation", ((TreeAttribute)base.entity.WatchedAttributes).GetInt("generation", 0));
			((TreeAttribute)adult.WatchedAttributes).SetDouble("birthTotalDays", base.entity.World.Calendar.TotalDays);
			if (keepTextureIndex && ((TreeAttribute)base.entity.WatchedAttributes).HasAttribute("textureIndex"))
			{
				((TreeAttribute)adult.WatchedAttributes).SetAttribute("textureIndex", ((TreeAttribute)base.entity.WatchedAttributes).GetAttribute("textureIndex"));
			}
			base.entity.Die((EnumDespawnReason)6, (DamageSource)null);
			base.entity.World.SpawnEntity(adult);
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			base.entity.World.UnregisterCallback(callbackId);
		}

		public override string PropertyName()
		{
			return "grow";
		}
	}
	public class ModSystemSyncHarvestableDropsToClient : ModSystem
	{
		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 1;
		}

		public override void AssetsFinalize(ICoreAPI api)
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Expected O, but got Unknown
			((ModSystem)this).AssetsFinalize(api);
			foreach (EntityProperties entityType in api.World.EntityTypes)
			{
				JsonObject[] behaviorsAsJsonObj = ((EntitySidedProperties)entityType.Server).BehaviorsAsJsonObj;
				foreach (JsonObject val in behaviorsAsJsonObj)
				{
					if (val["code"].AsString((string)null) == "harvestable")
					{
						if (entityType.Attributes == null)
						{
							entityType.Attributes = new JsonObject(JToken.Parse("{}"));
						}
						entityType.Attributes.Token[(object)"harvestableDrops"] = val["drops"].Token;
					}
				}
			}
		}
	}
	public interface IHarvestableDrops
	{
		ItemStack[] GetHarvestableDrops(IWorldAccessor world, BlockPos pos, IPlayer byPlayer)
		{
			return null;
		}
	}
	public class EntityBehaviorHarvestable : EntityBehaviorContainer
	{
		private const float minimumWeight = 0.5f;

		protected BlockDropItemStack[] jsonDrops;

		protected InventoryGeneric inv;

		protected GuiDialogCreatureContents dlg;

		private float baseHarvestDuration;

		private bool harshWinters;

		private bool fixedWeight;

		private float accum;

		private WorldInteraction[] interactions;

		public override bool ThreadSafe => true;

		private bool GotCrushed
		{
			get
			{
				if (!((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).HasAttribute("deathReason") || ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetInt("deathReason", 0) != 2)
				{
					if (((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).HasAttribute("deathDamageType"))
					{
						return ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetInt("deathDamageType", 0) == 9;
					}
					return false;
				}
				return true;
			}
		}

		private bool GotElectrocuted
		{
			get
			{
				if (((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).HasAttribute("deathDamageType"))
				{
					return ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetInt("deathDamageType", 0) == 11;
				}
				return false;
			}
		}

		private bool GotAcidified
		{
			get
			{
				if (((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).HasAttribute("deathDamageType"))
				{
					return ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetInt("deathDamageType", 0) == 14;
				}
				return false;
			}
		}

		public float AnimalWeight
		{
			get
			{
				return ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetFloat("animalWeight", 1f);
			}
			set
			{
				((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).SetFloat("animalWeight", value);
			}
		}

		public double LastWeightUpdateTotalHours
		{
			get
			{
				return ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetDouble("lastWeightUpdateTotalHours", 1.0);
			}
			set
			{
				((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).SetDouble("lastWeightUpdateTotalHours", value);
			}
		}

		protected float dropQuantityMultiplier
		{
			get
			{
				//IL_005c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0066: Expected O, but got Unknown
				if (GotCrushed)
				{
					return 0.5f;
				}
				if (GotAcidified)
				{
					return 0.25f;
				}
				string text = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetString("deathByEntity", (string)null);
				if (text != null && !((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).HasAttribute("deathByPlayer"))
				{
					EntityProperties entityType = Api.World.GetEntityType(new AssetLocation(text));
					float? obj;
					if (entityType == null)
					{
						obj = null;
					}
					else
					{
						JsonObject attributes = entityType.Attributes;
						if (attributes == null)
						{
							obj = null;
						}
						else
						{
							JsonObject obj2 = attributes["deathByMultiplier"];
							obj = ((obj2 != null) ? new float?(obj2.AsFloat(0.4f)) : ((float?)null));
						}
					}
					return obj ?? 0.4f;
				}
				return 1f;
			}
		}

		public bool Harvestable
		{
			get
			{
				if (!((EntityBehavior)this).entity.Alive)
				{
					return !IsHarvested;
				}
				return false;
			}
		}

		public bool IsHarvested => ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetBool("harvested", false);

		public override InventoryBase Inventory => (InventoryBase)(object)inv;

		public override string InventoryClassName => "harvestableInv";

		public bool DropsGenerated
		{
			get
			{
				return ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetBool("dropsgenerated", false);
			}
			set
			{
				((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).SetBool("dropsgenerated", value);
			}
		}

		public float GetHarvestDuration(Entity forEntity)
		{
			return baseHarvestDuration * forEntity.Stats.GetBlended("animalHarvestingTime");
		}

		public EntityBehaviorHarvestable(Entity entity)
			: base(entity)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Invalid comparison between Unknown and I4
			if ((int)entity.World.Side == 2)
			{
				entity.WatchedAttributes.RegisterModifiedListener("harvestableInv", (Action)onDropsModified);
			}
			harshWinters = StringUtil.ToBool(entity.World.Config.GetString("harshWinters", (string)null), true);
		}

		public override bool ShouldEarlyLoadCollectibleMappings()
		{
			return false;
		}

		public override void AfterInitialized(bool onSpawn)
		{
			if (onSpawn)
			{
				LastWeightUpdateTotalHours = Math.Max(1.0, ((EntityBehavior)this).entity.World.Calendar.TotalHours - 168.0);
				AnimalWeight = (fixedWeight ? 1f : (0.66f + 0.2f * (float)((EntityBehavior)this).entity.World.Rand.NextDouble()));
			}
			else if (fixedWeight)
			{
				AnimalWeight = 1f;
			}
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			if ((int)((EntityBehavior)this).entity.World.Side != 1)
			{
				return;
			}
			accum += deltaTime;
			if (!(accum > 1.5f))
			{
				return;
			}
			accum = 0f;
			if (!harshWinters || fixedWeight)
			{
				AnimalWeight = 1f;
				return;
			}
			double totalHours = ((EntityBehavior)this).entity.World.Calendar.TotalHours;
			double num = LastWeightUpdateTotalHours;
			double num2 = ((EntityBehavior)this).entity.World.Calendar.HoursPerDay;
			totalHours = Math.Min(totalHours, num + num2 * (double)((EntityBehavior)this).entity.World.Calendar.DaysPerMonth);
			if (num < totalHours - 1.0)
			{
				double num3 = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetDouble("lastMealEatenTotalHours", -9999.0);
				double num4 = (double)(4 * ((EntityBehavior)this).entity.World.Calendar.DaysPerMonth) * num2;
				double num5 = 7.0 * num2;
				BlockPos asBlockPos = ((EntityBehavior)this).entity.Pos.AsBlockPos;
				float num6 = AnimalWeight;
				float num7 = num6;
				float num8 = 3f;
				float temperature = 0f;
				ClimateCondition val = null;
				do
				{
					num += (double)num8;
					double num9 = num - num3;
					if (num9 < 0.0)
					{
						num9 = num4;
					}
					if (!(num9 < num4))
					{
						if (num6 <= 0.5f)
						{
							num = totalHours;
							break;
						}
						if (val == null)
						{
							val = ((EntityBehavior)this).entity.World.BlockAccessor.GetClimateAt(asBlockPos, (EnumGetClimateMode)3, num / num2);
							if (val == null)
							{
								base.OnGameTick(deltaTime);
								return;
							}
							temperature = val.WorldGenTemperature;
						}
						else
						{
							val.Temperature = temperature;
							((EntityBehavior)this).entity.World.BlockAccessor.GetClimateAt(asBlockPos, val, (EnumGetClimateMode)3, num / num2);
						}
						if (val.Temperature <= 0f)
						{
							num6 = Math.Max(0.5f, num6 - num8 * 0.001f);
						}
					}
					else
					{
						bool flag = num9 < num5;
						num6 = Math.Min(1f, num6 + num8 * (0.001f + (flag ? 0.05f : 0f)));
					}
				}
				while (num < totalHours - 1.0);
				if (num6 != num7)
				{
					AnimalWeight = num6;
				}
			}
			LastWeightUpdateTotalHours = num;
		}

		private void Inv_SlotModified(int slotid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			TreeAttribute val = new TreeAttribute();
			((InventoryBase)inv).ToTreeAttributes((ITreeAttribute)(object)val);
			((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes)["harvestableInv"] = (IAttribute)(object)val;
			((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("harvestableInv");
		}

		private void Inv_OnInventoryClosed(IPlayer player)
		{
			if (((InventoryBase)inv).Empty && ((EntityBehavior)this).entity.GetBehavior<EntityBehaviorDeadDecay>() != null)
			{
				((EntityBehavior)this).entity.GetBehavior<EntityBehaviorDeadDecay>().DecayNow();
			}
		}

		private void onDropsModified()
		{
			IAttribute obj = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes)["harvestableInv"];
			TreeAttribute val = (TreeAttribute)(object)((obj is TreeAttribute) ? obj : null);
			if (val != null)
			{
				int num = val.GetInt("qslots", 0) - ((InventoryBase)inv).Count;
				inv.AddSlots(num);
				((InventoryBase)inv).FromTreeAttributes((ITreeAttribute)(object)val);
				if (num > 0)
				{
					GuiDialogCreatureContents guiDialogCreatureContents = dlg;
					if (guiDialogCreatureContents != null && ((GuiDialog)guiDialogCreatureContents).IsOpened())
					{
						dlg.Compose("carcasscontents");
					}
				}
			}
			IWorldChunk chunkAtBlockPos = ((EntityBehavior)this).entity.World.BlockAccessor.GetChunkAtBlockPos(((EntityBehavior)this).entity.ServerPos.XYZ.AsBlockPos);
			if (chunkAtBlockPos != null)
			{
				chunkAtBlockPos.MarkModified();
			}
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected O, but got Unknown
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Invalid comparison between Unknown and I4
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Invalid comparison between Unknown and I4
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Expected O, but got Unknown
			inv = new InventoryGeneric(typeAttributes["quantitySlots"].AsInt(4), "harvestableContents-" + ((EntityBehavior)this).entity.EntityId, ((EntityBehavior)this).entity.Api, (NewSlotDelegate)null);
			IAttribute obj = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes)["harvestableInv"];
			TreeAttribute val = (TreeAttribute)(object)((obj is TreeAttribute) ? obj : null);
			if (val != null)
			{
				((InventoryBase)inv).FromTreeAttributes((ITreeAttribute)(object)val);
			}
			((InventoryBase)inv).PutLocked = true;
			if ((int)((EntityBehavior)this).entity.World.Side == 1)
			{
				((InventoryBase)inv).SlotModified += Inv_SlotModified;
				((InventoryBase)inv).OnInventoryClosed += new OnInventoryClosedDelegate(Inv_OnInventoryClosed);
			}
			base.Initialize(properties, typeAttributes);
			if ((int)((EntityBehavior)this).entity.World.Side == 1)
			{
				jsonDrops = typeAttributes["drops"].AsObject<BlockDropItemStack[]>((BlockDropItemStack[])null);
			}
			baseHarvestDuration = typeAttributes["duration"].AsFloat(5f);
			fixedWeight = typeAttributes["fixedweight"].AsBool(false);
		}

		public override void OnInteract(EntityAgent byEntity, ItemSlot itemslot, Vec3d hitPosition, EnumInteractMode mode, ref EnumHandling handled)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Invalid comparison between Unknown and I4
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Invalid comparison between Unknown and I4
			if ((int)mode == 0)
			{
				return;
			}
			_ = ((EntityBehavior)this).entity.Pos.XYZ;
			bool flag = ((EntityBehavior)this).entity.Pos.XYZ.Add(hitPosition).DistanceTo(((Entity)byEntity).SidedPos.XYZ.Add(((Entity)byEntity).LocalEyePos)) <= (float)(5 + (((int)Api.Side == 1) ? 1 : 0));
			if (!IsHarvested || !flag)
			{
				return;
			}
			EntityPlayer val = (EntityPlayer)(object)((byEntity is EntityPlayer) ? byEntity : null);
			IPlayer val2 = ((EntityBehavior)this).entity.World.PlayerByUid(val.PlayerUID);
			val2.InventoryManager.OpenInventory((IInventory)(object)inv);
			if ((int)((EntityBehavior)this).entity.World.Side == 2 && dlg == null)
			{
				ref GuiDialogCreatureContents reference = ref dlg;
				InventoryGeneric obj = inv;
				Entity entity = ((EntityBehavior)this).entity;
				ICoreAPI api = ((EntityBehavior)this).entity.Api;
				reference = new GuiDialogCreatureContents(obj, entity, (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null), "carcasscontents");
				if (((GuiDialog)dlg).TryOpen())
				{
					ICoreAPI api2 = ((EntityBehavior)this).entity.World.Api;
					((ICoreClientAPI)((api2 is ICoreClientAPI) ? api2 : null)).Network.SendPacketClient(((InventoryBase)inv).Open(val2));
				}
				((GuiDialog)dlg).OnClosed += delegate
				{
					((GuiDialog)dlg).Dispose();
					dlg = null;
				};
			}
		}

		public override void OnReceivedClientPacket(IServerPlayer player, int packetid, byte[] data, ref EnumHandling handled)
		{
			if (packetid < 1000 && ((InventoryBase)inv).HasOpened((IPlayer)(object)player))
			{
				((InventoryBase)inv).InvNetworkUtil.HandleClientPacket((IPlayer)(object)player, packetid, data);
				handled = (EnumHandling)3;
			}
		}

		public void SetHarvested(IPlayer byPlayer, float dropQuantityMultiplier = 1f)
		{
			if (!((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetBool("harvested", false))
			{
				((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).SetBool("harvested", true);
				GenerateDrops(byPlayer);
			}
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			base.OnEntityDeath(damageSourceForDeath);
			if (DropsGenerated && ((InventoryBase)inv).Empty && ((EntityBehavior)this).entity.GetBehavior<EntityBehaviorDeadDecay>() != null)
			{
				((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).SetBool("harvested", true);
			}
		}

		public void GenerateDrops(IPlayer byPlayer)
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Invalid comparison between Unknown and I4
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0314: Unknown result type (might be due to invalid IL or missing references)
			//IL_031a: Expected O, but got Unknown
			//IL_0399: Unknown result type (might be due to invalid IL or missing references)
			//IL_039f: Invalid comparison between Unknown and I4
			//IL_021a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Expected O, but got Unknown
			if ((int)((EntityBehavior)this).entity.World.Side == 2 || DropsGenerated)
			{
				return;
			}
			DropsGenerated = true;
			float num = 1f;
			JsonObject attributes = ((EntityBehavior)this).entity.Properties.Attributes;
			if (attributes == null || !attributes["isMechanical"].AsBool(false))
			{
				num *= ((Entity)byPlayer.Entity).Stats.GetBlended("animalLootDropRate");
			}
			List<ItemStack> todrop = new List<ItemStack>();
			for (int i = 0; i < jsonDrops.Length; i++)
			{
				BlockDropItemStack val = jsonDrops[i];
				if (val.Tool.HasValue && (byPlayer == null || val.Tool != byPlayer.InventoryManager.ActiveTool))
				{
					continue;
				}
				val.Resolve(((EntityBehavior)this).entity.World, "BehaviorHarvestable ", ((RegistryObject)((EntityBehavior)this).entity).Code);
				float num2 = 1f;
				if (val.DropModbyStat != null)
				{
					IPlayer obj = byPlayer;
					float? obj2;
					if (obj == null)
					{
						obj2 = null;
					}
					else
					{
						EntityPlayer entity = obj.Entity;
						obj2 = ((entity != null) ? new float?(((Entity)entity).Stats.GetBlended(val.DropModbyStat)) : ((float?)null));
					}
					float? num3 = obj2;
					num2 = num3.GetValueOrDefault();
				}
				if (val.ResolvedItemstack.Collectible.NutritionProps == null)
				{
					CombustibleProperties combustibleProps = val.ResolvedItemstack.Collectible.CombustibleProps;
					object obj3;
					if (combustibleProps == null)
					{
						obj3 = null;
					}
					else
					{
						JsonItemStack smeltedStack = combustibleProps.SmeltedStack;
						if (smeltedStack == null)
						{
							obj3 = null;
						}
						else
						{
							ItemStack resolvedItemstack = smeltedStack.ResolvedItemstack;
							obj3 = ((resolvedItemstack == null) ? null : resolvedItemstack.Collectible?.NutritionProps);
						}
					}
					if (obj3 == null)
					{
						goto IL_01df;
					}
				}
				num2 *= AnimalWeight;
				goto IL_01df;
				IL_01df:
				ItemStack val2 = val.GetNextItemStack(dropQuantityMultiplier * num * num2);
				if (val2 != null && val2.StackSize != 0)
				{
					CollectibleObject collectible = val2.Collectible;
					IResolvableCollectible val3 = (IResolvableCollectible)(object)((collectible is IResolvableCollectible) ? collectible : null);
					if (val3 != null)
					{
						DummySlot val4 = new DummySlot(val2);
						val3.Resolve((ItemSlot)(object)val4, ((EntityBehavior)this).entity.World, true);
						val2 = ((ItemSlot)val4).Itemstack;
					}
					while (val2.StackSize > val2.Collectible.MaxStackSize)
					{
						ItemStack emptyClone = val2.GetEmptyClone();
						emptyClone.StackSize = val2.Collectible.MaxStackSize;
						ItemStack obj4 = val2;
						obj4.StackSize -= val2.Collectible.MaxStackSize;
						todrop.Add(emptyClone);
					}
					todrop.Add(val2);
					if (val.LastDrop)
					{
						break;
					}
				}
			}
			((EntityBehavior)this).entity.GetInterfaces<IHarvestableDrops>()?.ForEach(delegate(IHarvestableDrops hInterface)
			{
				ItemStack[] harvestableDrops = hInterface.GetHarvestableDrops(((EntityBehavior)this).entity.World, ((EntityBehavior)this).entity.ServerPos.AsBlockPos, byPlayer);
				if (harvestableDrops != null)
				{
					EnumerableExtensions.Foreach<ItemStack>((IEnumerable<ItemStack>)harvestableDrops, (Action<ItemStack>)delegate(ItemStack stack)
					{
						todrop.Add(stack);
					});
				}
			});
			inv.AddSlots(todrop.Count - ((InventoryBase)inv).Count);
			ItemStack[] array = todrop.ToArray();
			TreeAttribute val5 = new TreeAttribute();
			for (int num4 = 0; num4 < array.Length; num4++)
			{
				((InventoryBase)inv)[num4].Itemstack = array[num4];
			}
			((InventoryBase)inv).ToTreeAttributes((ITreeAttribute)(object)val5);
			((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes)["harvestableInv"] = (IAttribute)(object)val5;
			((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("harvestableInv");
			((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("harvested");
			if ((int)((EntityBehavior)this).entity.World.Side == 1)
			{
				((EntityBehavior)this).entity.World.BlockAccessor.GetChunkAtBlockPos(((EntityBehavior)this).entity.ServerPos.AsBlockPos).MarkModified();
			}
		}

		public override WorldInteraction[] GetInteractionHelp(IClientWorldAccessor world, EntitySelection es, IClientPlayer player, ref EnumHandling handled)
		{
			interactions = ObjectCacheUtil.GetOrCreate<WorldInteraction[]>(((IWorldAccessor)world).Api, "harvestableEntityInteractions", (CreateCachableObjectDelegate<WorldInteraction[]>)delegate
			{
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0076: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0086: Unknown result type (might be due to invalid IL or missing references)
				//IL_0088: Unknown result type (might be due to invalid IL or missing references)
				//IL_008d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0098: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a5: Expected O, but got Unknown
				//IL_0050: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Expected O, but got Unknown
				List<ItemStack> list = new List<ItemStack>();
				foreach (Item item in ((IWorldAccessor)world).Items)
				{
					if (!(((RegistryObject)item).Code == (AssetLocation)null) && ((CollectibleObject)item).Tool == (EnumTool?)0)
					{
						list.Add(new ItemStack(item, 1));
					}
				}
				return (WorldInteraction[])(object)new WorldInteraction[1]
				{
					new WorldInteraction
					{
						ActionLangCode = "blockhelp-creature-harvest",
						MouseButton = (EnumMouseButton)2,
						HotKeyCode = "shift",
						Itemstacks = list.ToArray()
					}
				};
			});
			if (((EntityBehavior)this).entity.Alive || IsHarvested)
			{
				return null;
			}
			return interactions;
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			if (!((EntityBehavior)this).entity.Alive)
			{
				if (GotCrushed)
				{
					infotext.AppendLine(Lang.Get("Looks crushed. Won't be able to harvest as much from this carcass.", Array.Empty<object>()));
				}
				if (GotElectrocuted)
				{
					infotext.AppendLine(Lang.Get("Looks partially charred, perhaps due to a lightning strike.", Array.Empty<object>()));
				}
				if (GotAcidified)
				{
					infotext.AppendLine(Lang.Get("deadcreature-aciddissolved", Array.Empty<object>()));
				}
				string text = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetString("deathByEntity", (string)null);
				if (text != null && !((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).HasAttribute("deathByPlayer"))
				{
					string text2 = "deadcreature-killed";
					EntityProperties entityType = ((EntityBehavior)this).entity.World.GetEntityType(new AssetLocation(text));
					if (entityType != null)
					{
						JsonObject attributes = entityType.Attributes;
						if (attributes != null && attributes["killedByInfoText"].Exists)
						{
							text2 = entityType.Attributes["killedByInfoText"].AsString((string)null);
						}
					}
					infotext.AppendLine(Lang.Get(text2, Array.Empty<object>()));
				}
			}
			if (!fixedWeight)
			{
				if (AnimalWeight >= 0.95f)
				{
					infotext.AppendLine(Lang.Get("creature-weight-good", Array.Empty<object>()));
				}
				else if (AnimalWeight >= 0.75f)
				{
					infotext.AppendLine(Lang.Get("creature-weight-ok", Array.Empty<object>()));
				}
				else if (AnimalWeight >= 0.5f)
				{
					infotext.AppendLine(Lang.Get("creature-weight-low", Array.Empty<object>()));
				}
				else
				{
					infotext.AppendLine(Lang.Get("creature-weight-starving", Array.Empty<object>()));
				}
			}
			((EntityBehavior)this).GetInfoText(infotext);
		}

		public override string PropertyName()
		{
			return "harvestable";
		}
	}
	public interface ICanHealCreature
	{
		bool CanHeal(Entity target);

		WorldInteraction[] GetHealInteractionHelp(IClientWorldAccessor world, EntitySelection es, IClientPlayer player);
	}
	public delegate float OnDamagedDelegate(float damage, DamageSource dmgSource);
	public class DamageOverTimeEffect
	{
		public EnumDamageSource DamageSource;

		public EnumDamageType DamageType;

		public int DamageTier;

		public float Damage;

		public int EffectType;

		public TimeSpan TickDuration;

		public TimeSpan PreviousTickTime;

		public int TicksLeft;

		public void ToBytes(BinaryWriter writer)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			writer.Write((byte)DamageSource);
			writer.Write((byte)DamageType);
			writer.Write(DamageTier);
			writer.Write(Damage);
			writer.Write(TickDuration.Ticks);
			writer.Write(PreviousTickTime.Ticks);
			writer.Write(TicksLeft);
			writer.Write(EffectType);
		}

		public static DamageOverTimeEffect FromBytes(BinaryReader reader)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			return new DamageOverTimeEffect
			{
				DamageSource = (EnumDamageSource)reader.ReadByte(),
				DamageType = (EnumDamageType)reader.ReadByte(),
				DamageTier = reader.ReadInt32(),
				Damage = reader.ReadSingle(),
				TickDuration = TimeSpan.FromTicks(reader.ReadInt64()),
				PreviousTickTime = TimeSpan.FromTicks(reader.ReadInt64()),
				TicksLeft = reader.ReadInt32(),
				EffectType = reader.ReadInt32()
			};
		}
	}
	public class EntityBehaviorHealth : EntityBehavior
	{
		public const double FallDamageYMotionThreshold = -0.19;

		public const float FallDamageFallenDistanceThreshold = 3.5f;

		protected Dictionary<string, float>? maxHealthModifiers;

		protected string? HurtAnimationCode = "hurt";

		protected string HurtEntitySoundCode = "hurt";

		protected float timeSinceLastDoTTickSec;

		protected float timeBetweenDoTTicksSec = 0.5f;

		private float secondsSinceLastUpdate;

		public float Health
		{
			get
			{
				return healthTree.GetFloat("currenthealth", 0f);
			}
			set
			{
				healthTree.SetFloat("currenthealth", value);
				base.entity.WatchedAttributes.MarkPathDirty("health");
			}
		}

		public float? FutureHealth
		{
			get
			{
				return healthTree.GetFloat("futureHealth", 0f);
			}
			set
			{
				if (!value.HasValue)
				{
					healthTree.RemoveAttribute("futureHealth");
				}
				else
				{
					healthTree.SetFloat("futureHealth", value.Value);
				}
				base.entity.WatchedAttributes.MarkPathDirty("health");
			}
		}

		public float PreviousHealth
		{
			get
			{
				return healthTree.GetFloat("previousHealthValue", 0f);
			}
			set
			{
				healthTree.SetFloat("previousHealthValue", value);
				base.entity.WatchedAttributes.MarkPathDirty("health");
			}
		}

		public float HealthChangeRate
		{
			get
			{
				return healthTree.GetFloat("healthChangeRate", 0f);
			}
			set
			{
				healthTree.SetFloat("healthChangeRate", value);
				base.entity.WatchedAttributes.MarkPathDirty("health");
			}
		}

		public float BaseMaxHealth
		{
			get
			{
				return healthTree.GetFloat("basemaxhealth", 0f);
			}
			set
			{
				healthTree.SetFloat("basemaxhealth", value);
				base.entity.WatchedAttributes.MarkPathDirty("health");
			}
		}

		public float MaxHealth
		{
			get
			{
				return healthTree.GetFloat("maxhealth", 0f);
			}
			set
			{
				healthTree.SetFloat("maxhealth", value);
				base.entity.WatchedAttributes.MarkPathDirty("health");
			}
		}

		public List<DamageOverTimeEffect> ActiveDoTEffects { get; } = new List<DamageOverTimeEffect>();

		[Obsolete("Please call SetMaxHealthModifiers() instead of writing to it directly.")]
		public Dictionary<string, float>? MaxHealthModifiers { get; set; }

		protected virtual float HealthUpdateCooldownSec => 1f;

		protected virtual bool ReceiveHailDamage { get; set; }

		protected virtual float AutoRegenSaturationThreshold { get; set; } = 0.75f;

		protected virtual float SaturationPerHealthPoint { get; set; } = 150f;

		private ITreeAttribute healthTree => ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("health");

		public event OnDamagedDelegate onDamaged = (float dmg, DamageSource dmgSource) => dmg;

		public EntityBehaviorHealth(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0035: Expected O, but got Unknown
			ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("health");
			if (treeAttribute == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				treeAttribute = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("health", (IAttribute)val);
				BaseMaxHealth = attributes["maxhealth"].AsFloat(20f);
				Health = attributes["currenthealth"].AsFloat(BaseMaxHealth);
				PreviousHealth = Health;
				MarkDirty();
				return;
			}
			if (treeAttribute.GetFloat("basemaxhealth", 0f) == 0f)
			{
				BaseMaxHealth = attributes["maxhealth"].AsFloat(20f);
				MarkDirty();
			}
			secondsSinceLastUpdate = (float)base.entity.World.Rand.NextDouble();
			ReceiveHailDamage = base.entity is EntityPlayer;
			if (attributes.KeyExists("receiveHailDamage"))
			{
				ReceiveHailDamage = attributes["receiveHailDamage"].AsBool(base.entity is EntityPlayer);
			}
			if (attributes.KeyExists("autoRegenSaturationThreshold"))
			{
				AutoRegenSaturationThreshold = attributes["autoRegenSaturationThreshold"].AsFloat(0f);
			}
			if (attributes.KeyExists("saturationPerHealthPoint"))
			{
				SaturationPerHealthPoint = attributes["saturationPerHealthPoint"].AsFloat(0f);
			}
			if (attributes.KeyExists("hurtAnimationCode"))
			{
				HurtAnimationCode = attributes["hurtAnimationCode"].AsString((string)null);
			}
			timeBetweenDoTTicksSec = attributes["timeBetweenTicksSec"].AsFloat(0.5f);
			TimeSpan previousTickTime = TimeSpan.FromMilliseconds(base.entity.World.ElapsedMilliseconds);
			byte[] bytes = ((TreeAttribute)base.entity.WatchedAttributes).GetBytes("damageovertime-activeeffects", (byte[])null);
			if (bytes == null)
			{
				return;
			}
			ActiveDoTEffectsFromBytes(bytes);
			foreach (DamageOverTimeEffect activeDoTEffect in ActiveDoTEffects)
			{
				activeDoTEffect.PreviousTickTime = previousTickTime;
			}
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			if ((int)base.entity.World.Side == 2)
			{
				return;
			}
			ProcessDoTEffects(deltaTime);
			if (base.entity.Alive)
			{
				DamageIfFallingIntoVoid();
				secondsSinceLastUpdate += deltaTime;
				if (!(secondsSinceLastUpdate < HealthUpdateCooldownSec))
				{
					ApplyRegenAndHunger();
					ApplyHailDamage();
					secondsSinceLastUpdate = 0f;
				}
			}
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			((EntityBehavior)this).OnEntityDeath(damageSourceForDeath);
			Health = 0f;
		}

		public override void OnEntityReceiveDamage(DamageSource damageSource, ref float damage)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Invalid comparison between Unknown and I4
			if ((int)base.entity.World.Side == 2 || TurnIntoDoTEffect(damageSource, damage))
			{
				return;
			}
			float damageBeforeDelegatesApplied = damage;
			ApplyOnDamageDelegates(damageSource, ref damage);
			if ((int)damageSource.Type == 6)
			{
				ApplyHealing(damageSource, damage);
				base.entity.OnHurt(damageSource, damage);
				UpdateMaxHealth();
			}
			else
			{
				if (!base.entity.Alive || damage <= 0f)
				{
					return;
				}
				LogPlayerToPlayerDamage(damageSource, damage, damageBeforeDelegatesApplied);
				PreviousHealth = Health;
				Health -= damage;
				base.entity.OnHurt(damageSource, damage);
				UpdateMaxHealth();
				if (Health <= 0f)
				{
					Health = 0f;
					base.entity.Die((EnumDespawnReason)0, damageSource);
					return;
				}
				if (damage > 1f && HurtAnimationCode != null)
				{
					base.entity.AnimManager.StartAnimation(HurtAnimationCode);
				}
				base.entity.PlayEntitySound(HurtEntitySoundCode, (IPlayer)null, true, 24f);
			}
		}

		public override void OnFallToGround(Vec3d lastTerrainContact, double withYMotion)
		{
			//IL_0145: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_014c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0151: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0166: Expected O, but got Unknown
			if (!base.entity.Properties.FallDamage)
			{
				return;
			}
			Entity entity = base.entity;
			Entity obj = ((entity is EntityAgent) ? entity : null);
			bool flag = obj != null && ((EntityAgent)obj).ServerControls.Gliding;
			double num = Math.Abs(lastTerrainContact.Y - base.entity.Pos.Y);
			if (num < 3.5)
			{
				return;
			}
			if (flag)
			{
				num = Math.Min(num / 2.0, Math.Min(14.0, num));
				withYMotion /= 2.0;
				if ((double)base.entity.ServerPos.Pitch < 3.9269909262657166)
				{
					num = 0.0;
				}
			}
			if (!(withYMotion > -0.19))
			{
				num *= (double)base.entity.Properties.FallDamageMultiplier;
				double num2 = Math.Max(0.0, num - 3.5);
				double num3 = -0.04100000113248825 * Math.Pow(num2, 0.75) - 0.2199999988079071;
				double num4 = Math.Max(0.0, 0.0 - num3 + withYMotion);
				num2 -= 20.0 * num4;
				if (!(num2 <= 0.0))
				{
					base.entity.ReceiveDamage(new DamageSource
					{
						Source = (EnumDamageSource)2,
						Type = (EnumDamageType)0,
						IgnoreInvFrames = true
					}, (float)num2);
				}
			}
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Invalid comparison between Unknown and I4
			ICoreAPI api = base.entity.Api;
			ICoreAPI obj = ((api is ICoreClientAPI) ? api : null);
			if (obj != null)
			{
				IClientPlayer player = ((ICoreClientAPI)obj).World.Player;
				EnumGameMode? obj2;
				if (player == null)
				{
					obj2 = null;
				}
				else
				{
					IWorldPlayerData worldData = ((IPlayer)player).WorldData;
					obj2 = ((worldData != null) ? new EnumGameMode?(worldData.CurrentGameMode) : ((EnumGameMode?)null));
				}
				EnumGameMode? val = obj2;
				if ((int)val.GetValueOrDefault() == 2)
				{
					infotext.AppendLine(Lang.Get("Health: {0}/{1}", new object[2] { Health, MaxHealth }));
				}
			}
		}

		public override WorldInteraction[] GetInteractionHelp(IClientWorldAccessor world, EntitySelection es, IClientPlayer player, ref EnumHandling handled)
		{
			if (IsHealable((EntityAgent)(object)((IPlayer)player).Entity))
			{
				ItemSlot activeHotbarSlot = ((IPlayer)player).InventoryManager.ActiveHotbarSlot;
				object obj;
				if (activeHotbarSlot == null)
				{
					obj = null;
				}
				else
				{
					ItemStack itemstack = activeHotbarSlot.Itemstack;
					if (itemstack == null)
					{
						obj = null;
					}
					else
					{
						CollectibleObject collectible = itemstack.Collectible;
						obj = ((collectible != null) ? collectible.GetCollectibleInterface<ICanHealCreature>() : null);
					}
				}
				ICanHealCreature canHealCreature = (ICanHealCreature)obj;
				if (canHealCreature != null)
				{
					return ArrayExtensions.Append<WorldInteraction>(canHealCreature.GetHealInteractionHelp(world, es, player), ((EntityBehavior)this).GetInteractionHelp(world, es, player, ref handled));
				}
			}
			return ((EntityBehavior)this).GetInteractionHelp(world, es, player, ref handled);
		}

		public override string PropertyName()
		{
			return "health";
		}

		public override void ToBytes(bool forClient)
		{
			((EntityBehavior)this).ToBytes(forClient);
			((TreeAttribute)base.entity.WatchedAttributes).SetBytes("damageovertime-activeeffects", ActiveDoTEffectsToBytes());
		}

		public void SetMaxHealthModifiers(string key, float value)
		{
			bool flag = true;
			float value2;
			if (maxHealthModifiers == null)
			{
				maxHealthModifiers = new Dictionary<string, float>();
				if (value == 0f)
				{
					flag = false;
				}
			}
			else if (maxHealthModifiers.TryGetValue(key, out value2) && value2 == value)
			{
				flag = false;
			}
			maxHealthModifiers[key] = value;
			if (flag)
			{
				MarkDirty();
			}
		}

		public void MarkDirty()
		{
			UpdateMaxHealth();
			base.entity.WatchedAttributes.MarkPathDirty("health");
		}

		public void UpdateMaxHealth()
		{
			float num = BaseMaxHealth;
			Dictionary<string, float> dictionary = maxHealthModifiers;
			if (dictionary != null)
			{
				foreach (KeyValuePair<string, float> item in dictionary)
				{
					num += item.Value;
				}
			}
			num += base.entity.Stats.GetBlended("maxhealthExtraPoints") - 1f;
			bool num2 = Health >= MaxHealth;
			MaxHealth = num;
			if (num2)
			{
				Health = MaxHealth;
			}
		}

		public bool IsHealable(EntityAgent eagent, ItemSlot? slot = null)
		{
			ItemSlot? obj = slot ?? eagent.RightHandItemSlot;
			object obj2;
			if (obj == null)
			{
				obj2 = null;
			}
			else
			{
				ItemStack itemstack = obj.Itemstack;
				if (itemstack == null)
				{
					obj2 = null;
				}
				else
				{
					CollectibleObject collectible = itemstack.Collectible;
					obj2 = ((collectible != null) ? collectible.GetCollectibleInterface<ICanHealCreature>() : null);
				}
			}
			ICanHealCreature canHealCreature = (ICanHealCreature)obj2;
			if (Health < MaxHealth)
			{
				return canHealCreature?.CanHeal(base.entity) ?? false;
			}
			return false;
		}

		public virtual int ApplyDoTEffect(EnumDamageSource damageSource, EnumDamageType damageType, int damageTier, float totalDamage, TimeSpan totalTime, int ticksNumber, EnumDamageOverTimeEffectType effectType = (EnumDamageOverTimeEffectType)0)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Expected I4, but got Unknown
			return ApplyDoTEffect(damageSource, damageType, damageTier, totalDamage, totalTime, ticksNumber, (int)effectType);
		}

		public virtual int ApplyDoTEffect(EnumDamageSource damageSource, EnumDamageType damageType, int damageTier, float totalDamage, TimeSpan totalTime, int ticksNumber, int effectType = 0)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			DamageOverTimeEffect item = new DamageOverTimeEffect
			{
				DamageSource = damageSource,
				DamageType = damageType,
				DamageTier = damageTier,
				Damage = totalDamage / (float)ticksNumber,
				TickDuration = totalTime / ticksNumber,
				PreviousTickTime = TimeSpan.FromMilliseconds(base.entity.World.ElapsedMilliseconds),
				TicksLeft = ticksNumber,
				EffectType = effectType
			};
			ActiveDoTEffects.Add(item);
			return ActiveDoTEffects.Count - 1;
		}

		public virtual void StopDoTEffect(int effectType, int amount = int.MaxValue)
		{
			int num = 0;
			foreach (DamageOverTimeEffect item in ActiveDoTEffects.Where((DamageOverTimeEffect effect) => effect.EffectType == effectType))
			{
				item.TicksLeft = 0;
				num++;
				if (num >= amount)
				{
					break;
				}
			}
		}

		protected virtual void DamageIfFallingIntoVoid()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Expected O, but got Unknown
			if (base.entity.Pos.Y < -30.0)
			{
				base.entity.ReceiveDamage(new DamageSource
				{
					Source = (EnumDamageSource)5,
					Type = (EnumDamageType)0
				}, 4f);
			}
		}

		protected virtual void ApplyHailDamage()
		{
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Expected O, but got Unknown
			if (!ReceiveHailDamage)
			{
				return;
			}
			int rainMapHeightAt = base.entity.World.BlockAccessor.GetRainMapHeightAt((int)base.entity.ServerPos.X, (int)base.entity.ServerPos.Z);
			if (base.entity.ServerPos.Y >= (double)rainMapHeightAt)
			{
				PrecipitationState precipitationState = base.entity.Api.ModLoader.GetModSystem<WeatherSystemBase>(true).GetPrecipitationState(base.entity.ServerPos.XYZ);
				if (precipitationState != null && precipitationState.ParticleSize >= 0.5 && precipitationState.Type == EnumPrecipitationType.Hail && base.entity.World.Rand.NextDouble() < precipitationState.Level / 2.0)
				{
					base.entity.ReceiveDamage(new DamageSource
					{
						Source = (EnumDamageSource)12,
						Type = (EnumDamageType)2
					}, (float)precipitationState.ParticleSize / 15f);
				}
			}
		}

		protected virtual void ApplyRegenAndHunger()
		{
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Invalid comparison between Unknown and I4
			float health = Health;
			float maxHealth = MaxHealth;
			if (health >= maxHealth)
			{
				return;
			}
			float num = ((base.entity is EntityPlayer) ? StringUtil.ToFloat(base.entity.Api.World.Config.GetString("playerHealthRegenSpeed", "1"), 0f) : ((TreeAttribute)base.entity.WatchedAttributes).GetFloat("regenSpeed", 1f));
			float num2 = 0.000333333f * num;
			float num3 = secondsSinceLastUpdate * base.entity.Api.World.Calendar.SpeedOfTime * base.entity.Api.World.Calendar.CalendarSpeedMul;
			Entity entity = base.entity;
			EntityPlayer val = (EntityPlayer)(object)((entity is EntityPlayer) ? entity : null);
			if (val != null)
			{
				EntityBehaviorHunger behavior = base.entity.GetBehavior<EntityBehaviorHunger>();
				if (behavior != null && (int)val.Player.WorldData.CurrentGameMode != 2)
				{
					num2 = GameMath.Clamp(num2 * behavior.Saturation / behavior.MaxSaturation * 1f / AutoRegenSaturationThreshold, 0f, num2);
					behavior.ConsumeSaturation(SaturationPerHealthPoint * num3 * num2);
				}
			}
			Health = Math.Min(health + num3 * num2, maxHealth);
		}

		protected virtual void ApplyOnDamageDelegates(DamageSource damageSource, ref float damage)
		{
			if (this.onDamaged == null)
			{
				return;
			}
			foreach (OnDamagedDelegate item in this.onDamaged.GetInvocationList().OfType<OnDamagedDelegate>())
			{
				damage = item(damage, damageSource);
			}
		}

		protected virtual void ApplyHealing(DamageSource damageSource, float damage)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			if ((int)damageSource.Source != 4)
			{
				Health = Math.Min(Health + damage, MaxHealth);
				return;
			}
			damage = Math.Min(damage, MaxHealth);
			Health = damage;
		}

		protected virtual void LogPlayerToPlayerDamage(DamageSource damageSource, float damage, float damageBeforeDelegatesApplied)
		{
			Entity entity = base.entity;
			EntityPlayer val = (EntityPlayer)(object)((entity is EntityPlayer) ? entity : null);
			if (val == null)
			{
				return;
			}
			Entity causeEntity = damageSource.GetCauseEntity();
			EntityPlayer val2 = (EntityPlayer)(object)((causeEntity is EntityPlayer) ? causeEntity : null);
			if (val2 != null)
			{
				string value;
				if ((object)damageSource.SourceEntity != val2)
				{
					value = ((object)((RegistryObject)damageSource.SourceEntity).Code).ToString();
				}
				else
				{
					ItemStack itemstack = val2.Player.InventoryManager.ActiveHotbarSlot.Itemstack;
					value = ((itemstack != null) ? ((object)((RegistryObject)itemstack.Collectible).Code).ToString() : null) ?? "hands";
				}
				base.entity.Api.Logger.Audit($"{val.Player.PlayerName} at {base.entity.Pos.AsBlockPos} got {damage}/{damageBeforeDelegatesApplied} damage {((object)Unsafe.As<EnumDamageType, EnumDamageType>(ref damageSource.Type)/*cast due to .constrained prefix*/).ToString().ToLowerInvariant()} {value} by {((Entity)val2).GetName()}");
			}
		}

		protected virtual void ProcessDoTEffects(float dt)
		{
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Invalid comparison between Unknown and I4
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Expected O, but got Unknown
			if (!base.entity.Alive)
			{
				ActiveDoTEffects.Clear();
				return;
			}
			if (timeSinceLastDoTTickSec < timeBetweenDoTTicksSec)
			{
				timeSinceLastDoTTickSec += dt;
				return;
			}
			timeSinceLastDoTTickSec = 0f;
			TimeSpan timeSpan = TimeSpan.FromMilliseconds(base.entity.World.ElapsedMilliseconds);
			float num = 0f;
			float num2 = 0f;
			for (int num3 = ActiveDoTEffects.Count - 1; num3 >= 0; num3--)
			{
				DamageOverTimeEffect damageOverTimeEffect = ActiveDoTEffects[num3];
				if (timeSpan - damageOverTimeEffect.PreviousTickTime >= damageOverTimeEffect.TickDuration)
				{
					base.entity.ReceiveDamage(new DamageSource
					{
						Source = damageOverTimeEffect.DamageSource,
						Type = damageOverTimeEffect.DamageType,
						DamageTier = damageOverTimeEffect.DamageTier
					}, damageOverTimeEffect.Damage);
					damageOverTimeEffect.TicksLeft--;
					if (damageOverTimeEffect.TicksLeft <= 0)
					{
						ActiveDoTEffects.RemoveAt(num3);
					}
					else
					{
						damageOverTimeEffect.PreviousTickTime = timeSpan;
					}
				}
				if ((int)damageOverTimeEffect.DamageType == 6)
				{
					num += damageOverTimeEffect.Damage * (float)damageOverTimeEffect.TicksLeft;
					num2 += damageOverTimeEffect.Damage * (float)damageOverTimeEffect.TicksLeft;
				}
				else
				{
					num2 -= damageOverTimeEffect.Damage * (float)damageOverTimeEffect.TicksLeft;
				}
			}
			if ((double)Math.Abs(num) > 0.1)
			{
				FutureHealth = Health + num;
			}
			else
			{
				FutureHealth = null;
			}
			HealthChangeRate = num2;
		}

		protected virtual byte[] ActiveDoTEffectsToBytes()
		{
			MemoryStream memoryStream = new MemoryStream();
			BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
			binaryWriter.Write(ActiveDoTEffects.Count);
			foreach (DamageOverTimeEffect activeDoTEffect in ActiveDoTEffects)
			{
				activeDoTEffect.ToBytes(binaryWriter);
			}
			return memoryStream.ToArray();
		}

		protected virtual void ActiveDoTEffectsFromBytes(byte[] bytes)
		{
			BinaryReader binaryReader = new BinaryReader(new MemoryStream(bytes));
			ActiveDoTEffects.Clear();
			int num = binaryReader.ReadInt32();
			for (int i = 0; i < num; i++)
			{
				ActiveDoTEffects.Add(DamageOverTimeEffect.FromBytes(binaryReader));
			}
		}

		protected virtual bool TurnIntoDoTEffect(DamageSource damageSource, float damage)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (damageSource.Duration <= TimeSpan.Zero)
			{
				return false;
			}
			ApplyDoTEffect(damageSource.Source, damageSource.Type, damageSource.DamageTier, damage, damageSource.Duration, damageSource.TicksPerDuration, damageSource.DamageOverTimeType);
			return true;
		}
	}
	public class EntityBehaviorHunger : EntityBehavior
	{
		private ITreeAttribute hungerTree;

		private EntityAgent entityAgent;

		private float hungerCounter;

		private int sprintCounter;

		private long listenerId;

		private long lastMoveMs;

		private ICoreAPI api;

		private float detoxCounter;

		public float SaturationLossDelayFruit
		{
			get
			{
				return hungerTree.GetFloat("saturationlossdelayfruit", 0f);
			}
			set
			{
				hungerTree.SetFloat("saturationlossdelayfruit", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float SaturationLossDelayVegetable
		{
			get
			{
				return hungerTree.GetFloat("saturationlossdelayvegetable", 0f);
			}
			set
			{
				hungerTree.SetFloat("saturationlossdelayvegetable", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float SaturationLossDelayProtein
		{
			get
			{
				return hungerTree.GetFloat("saturationlossdelayprotein", 0f);
			}
			set
			{
				hungerTree.SetFloat("saturationlossdelayprotein", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float SaturationLossDelayGrain
		{
			get
			{
				return hungerTree.GetFloat("saturationlossdelaygrain", 0f);
			}
			set
			{
				hungerTree.SetFloat("saturationlossdelaygrain", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float SaturationLossDelayDairy
		{
			get
			{
				return hungerTree.GetFloat("saturationlossdelaydairy", 0f);
			}
			set
			{
				hungerTree.SetFloat("saturationlossdelaydairy", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float Saturation
		{
			get
			{
				return hungerTree.GetFloat("currentsaturation", 0f);
			}
			set
			{
				hungerTree.SetFloat("currentsaturation", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float MaxSaturation
		{
			get
			{
				return hungerTree.GetFloat("maxsaturation", 0f);
			}
			set
			{
				hungerTree.SetFloat("maxsaturation", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float FruitLevel
		{
			get
			{
				return hungerTree.GetFloat("fruitLevel", 0f);
			}
			set
			{
				hungerTree.SetFloat("fruitLevel", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float VegetableLevel
		{
			get
			{
				return hungerTree.GetFloat("vegetableLevel", 0f);
			}
			set
			{
				hungerTree.SetFloat("vegetableLevel", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float ProteinLevel
		{
			get
			{
				return hungerTree.GetFloat("proteinLevel", 0f);
			}
			set
			{
				hungerTree.SetFloat("proteinLevel", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float GrainLevel
		{
			get
			{
				return hungerTree.GetFloat("grainLevel", 0f);
			}
			set
			{
				hungerTree.SetFloat("grainLevel", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public float DairyLevel
		{
			get
			{
				return hungerTree.GetFloat("dairyLevel", 0f);
			}
			set
			{
				hungerTree.SetFloat("dairyLevel", value);
				base.entity.WatchedAttributes.MarkPathDirty("hunger");
			}
		}

		public EntityBehaviorHunger(Entity entity)
			: base(entity)
		{
			entityAgent = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Expected O, but got Unknown
			//IL_0059: Expected O, but got Unknown
			hungerTree = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("hunger");
			api = base.entity.World.Api;
			if (hungerTree == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				ITreeAttribute val2 = (ITreeAttribute)val;
				hungerTree = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("hunger", (IAttribute)(object)val2);
				Saturation = typeAttributes["currentsaturation"].AsFloat(1500f);
				MaxSaturation = typeAttributes["maxsaturation"].AsFloat(1500f);
				SaturationLossDelayFruit = 0f;
				SaturationLossDelayVegetable = 0f;
				SaturationLossDelayGrain = 0f;
				SaturationLossDelayProtein = 0f;
				SaturationLossDelayDairy = 0f;
				FruitLevel = 0f;
				VegetableLevel = 0f;
				GrainLevel = 0f;
				ProteinLevel = 0f;
				DairyLevel = 0f;
			}
			listenerId = base.entity.World.RegisterGameTickListener((Action<float>)SlowTick, 6000, 0);
			UpdateNutrientHealthBoost();
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			((EntityBehavior)this).OnEntityDespawn(despawn);
			base.entity.World.UnregisterGameTickListener(listenerId);
		}

		public override void DidAttack(DamageSource source, EntityAgent targetEntity, ref EnumHandling handled)
		{
			ConsumeSaturation(3f);
		}

		public virtual void ConsumeSaturation(float amount)
		{
			ReduceSaturation(amount / 10f);
		}

		public override void OnEntityReceiveSaturation(float saturation, EnumFoodCategory foodCat = (EnumFoodCategory)5, float saturationLossDelay = 10f, float nutritionGainMultiplier = 1f)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected I4, but got Unknown
			float maxSaturation = MaxSaturation;
			bool flag = Saturation >= maxSaturation;
			Saturation = Math.Min(maxSaturation, Saturation + saturation);
			switch ((int)foodCat)
			{
			case 0:
				if (!flag)
				{
					FruitLevel = Math.Min(maxSaturation, FruitLevel + saturation / 2.5f * nutritionGainMultiplier);
				}
				SaturationLossDelayFruit = Math.Max(SaturationLossDelayFruit, saturationLossDelay);
				break;
			case 1:
				if (!flag)
				{
					VegetableLevel = Math.Min(maxSaturation, VegetableLevel + saturation / 2.5f * nutritionGainMultiplier);
				}
				SaturationLossDelayVegetable = Math.Max(SaturationLossDelayVegetable, saturationLossDelay);
				break;
			case 2:
				if (!flag)
				{
					ProteinLevel = Math.Min(maxSaturation, ProteinLevel + saturation / 2.5f * nutritionGainMultiplier);
				}
				SaturationLossDelayProtein = Math.Max(SaturationLossDelayProtein, saturationLossDelay);
				break;
			case 3:
				if (!flag)
				{
					GrainLevel = Math.Min(maxSaturation, GrainLevel + saturation / 2.5f * nutritionGainMultiplier);
				}
				SaturationLossDelayGrain = Math.Max(SaturationLossDelayGrain, saturationLossDelay);
				break;
			case 4:
				if (!flag)
				{
					DairyLevel = Math.Min(maxSaturation, DairyLevel + saturation / 2.5f * nutritionGainMultiplier);
				}
				SaturationLossDelayDairy = Math.Max(SaturationLossDelayDairy, saturationLossDelay);
				break;
			}
			UpdateNutrientHealthBoost();
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Expected O, but got Unknown
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Invalid comparison between Unknown and I4
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Invalid comparison between Unknown and I4
			if (base.entity is EntityPlayer)
			{
				EntityPlayer val = (EntityPlayer)base.entity;
				EnumGameMode currentGameMode = base.entity.World.PlayerByUid(val.PlayerUID).WorldData.CurrentGameMode;
				detox(deltaTime);
				if ((int)currentGameMode == 2 || (int)currentGameMode == 3)
				{
					return;
				}
				if (((EntityAgent)val).Controls.TriesToMove || ((EntityAgent)val).Controls.Jump || ((EntityAgent)val).Controls.LeftMouseDown || ((EntityAgent)val).Controls.RightMouseDown)
				{
					lastMoveMs = base.entity.World.ElapsedMilliseconds;
				}
			}
			if (entityAgent != null && entityAgent.Controls.Sprint)
			{
				sprintCounter++;
			}
			if (hungerCounter < 0f)
			{
				hungerCounter = 0f;
			}
			hungerCounter += deltaTime;
			if (hungerCounter > 10f)
			{
				bool num = base.entity.World.ElapsedMilliseconds - lastMoveMs > 3000;
				float num2 = base.entity.Api.World.Calendar.SpeedOfTime * base.entity.Api.World.Calendar.CalendarSpeedMul;
				float num3 = GlobalConstants.HungerSpeedModifier / 30f;
				if (num)
				{
					num3 /= 4f;
				}
				num3 *= 1.2f * (8f + (float)sprintCounter / 15f) / 10f;
				num3 *= base.entity.Stats.GetBlended("hungerrate");
				ReduceSaturation(num3 * num2);
				hungerCounter = 0f;
				sprintCounter = 0;
				detox(deltaTime);
			}
		}

		private void detox(float dt)
		{
			detoxCounter += dt;
			if (detoxCounter > 1f)
			{
				float num = ((TreeAttribute)base.entity.WatchedAttributes).GetFloat("intoxication", 0f);
				if (num > 0f)
				{
					((TreeAttribute)base.entity.WatchedAttributes).SetFloat("intoxication", Math.Max(0f, num - 0.005f));
				}
				detoxCounter = 0f;
			}
		}

		private bool ReduceSaturation(float satLossMultiplier)
		{
			bool flag = false;
			satLossMultiplier *= GlobalConstants.HungerSpeedModifier;
			if (SaturationLossDelayFruit > 0f)
			{
				SaturationLossDelayFruit -= 10f * satLossMultiplier;
				flag = true;
			}
			else
			{
				FruitLevel = Math.Max(0f, FruitLevel - Math.Max(0.5f, 0.001f * FruitLevel) * satLossMultiplier * 0.25f);
			}
			if (SaturationLossDelayVegetable > 0f)
			{
				SaturationLossDelayVegetable -= 10f * satLossMultiplier;
				flag = true;
			}
			else
			{
				VegetableLevel = Math.Max(0f, VegetableLevel - Math.Max(0.5f, 0.001f * VegetableLevel) * satLossMultiplier * 0.25f);
			}
			if (SaturationLossDelayProtein > 0f)
			{
				SaturationLossDelayProtein -= 10f * satLossMultiplier;
				flag = true;
			}
			else
			{
				ProteinLevel = Math.Max(0f, ProteinLevel - Math.Max(0.5f, 0.001f * ProteinLevel) * satLossMultiplier * 0.25f);
			}
			if (SaturationLossDelayGrain > 0f)
			{
				SaturationLossDelayGrain -= 10f * satLossMultiplier;
				flag = true;
			}
			else
			{
				GrainLevel = Math.Max(0f, GrainLevel - Math.Max(0.5f, 0.001f * GrainLevel) * satLossMultiplier * 0.25f);
			}
			if (SaturationLossDelayDairy > 0f)
			{
				SaturationLossDelayDairy -= 10f * satLossMultiplier;
				flag = true;
			}
			else
			{
				DairyLevel = Math.Max(0f, DairyLevel - Math.Max(0.5f, 0.001f * DairyLevel) * satLossMultiplier * 0.25f / 2f);
			}
			UpdateNutrientHealthBoost();
			if (flag)
			{
				hungerCounter = 0f;
				return true;
			}
			float saturation = Saturation;
			if (saturation > 0f)
			{
				Saturation = Math.Max(0f, saturation - satLossMultiplier * 10f);
				sprintCounter = 0;
			}
			return false;
		}

		public void UpdateNutrientHealthBoost()
		{
			float num = FruitLevel / MaxSaturation;
			float num2 = GrainLevel / MaxSaturation;
			float num3 = VegetableLevel / MaxSaturation;
			float num4 = ProteinLevel / MaxSaturation;
			float num5 = DairyLevel / MaxSaturation;
			EntityBehaviorHealth behavior = base.entity.GetBehavior<EntityBehaviorHealth>();
			float value = 2.5f * (num + num2 + num3 + num4 + num5);
			behavior.SetMaxHealthModifiers("nutrientHealthMod", value);
		}

		private void SlowTick(float dt)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Invalid comparison between Unknown and I4
			//IL_0157: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Expected O, but got Unknown
			if (base.entity is EntityPlayer)
			{
				EntityPlayer val = (EntityPlayer)base.entity;
				if ((int)base.entity.World.PlayerByUid(val.PlayerUID).WorldData.CurrentGameMode == 2)
				{
					return;
				}
			}
			bool flag = StringUtil.ToBool(base.entity.World.Config.GetString("harshWinters", (string)null), true);
			float temperature = base.entity.World.BlockAccessor.GetClimateAt(base.entity.Pos.AsBlockPos, (EnumGetClimateMode)3, base.entity.World.Calendar.TotalDays).Temperature;
			if (temperature >= 2f || !flag)
			{
				base.entity.Stats.Remove("hungerrate", "resistcold");
			}
			else
			{
				float num = GameMath.Clamp(2f - temperature, 0f, 10f);
				Room roomForPosition = base.entity.World.Api.ModLoader.GetModSystem<RoomRegistry>(true).GetRoomForPosition(base.entity.Pos.AsBlockPos);
				base.entity.Stats.Set("hungerrate", "resistcold", (roomForPosition.ExitCount == 0) ? 0f : (num / 40f), true);
			}
			if (Saturation <= 0f)
			{
				base.entity.ReceiveDamage(new DamageSource
				{
					Source = (EnumDamageSource)7,
					Type = (EnumDamageType)8
				}, 0.125f);
				sprintCounter = 0;
			}
		}

		public override string PropertyName()
		{
			return "hunger";
		}

		public override void OnEntityReceiveDamage(DamageSource damageSource, ref float damage)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Invalid comparison between Unknown and I4
			if ((int)damageSource.Type == 6 && (int)damageSource.Source == 4)
			{
				SaturationLossDelayFruit = 60f;
				SaturationLossDelayVegetable = 60f;
				SaturationLossDelayProtein = 60f;
				SaturationLossDelayGrain = 60f;
				SaturationLossDelayDairy = 60f;
				Saturation = MaxSaturation / 2f;
				VegetableLevel /= 2f;
				ProteinLevel /= 2f;
				FruitLevel /= 2f;
				DairyLevel /= 2f;
				GrainLevel /= 2f;
			}
		}
	}
	public class EntityBehaviorMouthInventory : EntityBehavior
	{
		private EntityAgent entityAgent;

		private InventoryGeneric mouthInv;

		public List<ItemStack> acceptStacks = new List<ItemStack>();

		public long PickupCoolDownUntilMs;

		public EntityBehaviorMouthInventory(Entity entity)
			: base(entity)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Expected O, but got Unknown
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Expected O, but got Unknown
			entityAgent = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			mouthInv = new InventoryGeneric(1, "mouthslot-" + entity.EntityId, entity.Api, (NewSlotDelegate)((int id, InventoryGeneric inv) => (ItemSlot)(object)new ItemSlotMouth(this, inv)));
			((InventoryBase)mouthInv).SlotModified += MouthInv_SlotModified;
			entityAgent.LeftHandItemSlot = ((InventoryBase)mouthInv)[0];
		}

		private void MouthInv_SlotModified(int slotid)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Expected O, but got Unknown
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Expected O, but got Unknown
			ITreeAttribute tree = (ITreeAttribute)new TreeAttribute();
			((TreeAttribute)base.entity.WatchedAttributes)["mouthInv"] = (IAttribute)(object)tree;
			base.entity.WatchedAttributes.MarkPathDirty("mouthInv");
			((InventoryBase)mouthInv).ToTreeAttributes(tree);
			ICoreAPI api = ((Entity)entityAgent).Api;
			ICoreServerAPI val = (ICoreServerAPI)(object)((api is ICoreServerAPI) ? api : null);
			if (val != null)
			{
				val.Network.BroadcastEntityPacket(base.entity.EntityId, 1235, SerializerUtil.ToBytes((ByteWriteDelegatae)delegate(BinaryWriter w)
				{
					((IAttribute)tree).ToBytes(w);
				}));
			}
		}

		public override void OnReceivedServerPacket(int packetid, byte[] data, ref EnumHandling handled)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Expected O, but got Unknown
			if (packetid == 1235)
			{
				TreeAttribute tree = new TreeAttribute();
				SerializerUtil.FromBytes(data, (ByteReadDelegatae)delegate(BinaryReader r)
				{
					tree.FromBytes(r);
				});
				((InventoryBase)mouthInv).FromTreeAttributes((ITreeAttribute)(object)tree);
			}
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			JsonItemStack[] array = typeAttributes["acceptStacks"].AsObject<JsonItemStack[]>((JsonItemStack[])null);
			foreach (JsonItemStack val in array)
			{
				if (val.Resolve(base.entity.World, "mouth inventory accept stacks", true))
				{
					acceptStacks.Add(val.ResolvedItemstack);
				}
			}
			IAttribute obj = ((TreeAttribute)base.entity.WatchedAttributes)["mouthInv"];
			ITreeAttribute val2 = (ITreeAttribute)(object)((obj is ITreeAttribute) ? obj : null);
			if (val2 != null)
			{
				((InventoryBase)mouthInv).FromTreeAttributes(val2);
			}
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			((EntityBehavior)this).OnEntityDespawn(despawn);
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			if ((int)base.entity.World.Side == 1)
			{
				((InventoryBase)mouthInv).DropAll(base.entity.ServerPos.XYZ, 0);
			}
			((EntityBehavior)this).OnEntityDeath(damageSourceForDeath);
		}

		public override void OnEntityReceiveDamage(DamageSource damageSource, ref float damage)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			if ((int)base.entity.World.Side == 1 && base.entity.World.Rand.NextDouble() < 0.25)
			{
				((InventoryBase)mouthInv).DropAll(base.entity.ServerPos.XYZ, 0);
				PickupCoolDownUntilMs = base.entity.World.ElapsedMilliseconds + 10000;
			}
			((EntityBehavior)this).OnEntityReceiveDamage(damageSource, ref damage);
		}

		public override string PropertyName()
		{
			return "mouthslot";
		}
	}
	public class EntityBehaviorMultiply : EntityBehaviorMultiplyBase
	{
		private JsonObject typeAttributes;

		private long callbackId;

		private AssetLocation[] spawnEntityCodes;

		internal float PregnancyDays => typeAttributes["pregnancyDays"].AsFloat(3f);

		internal string RequiresNearbyEntityCode => typeAttributes["requiresNearbyEntityCode"].AsString("");

		internal float RequiresNearbyEntityRange => typeAttributes["requiresNearbyEntityRange"].AsFloat(5f);

		public float SpawnQuantityMin => typeAttributes["spawnQuantityMin"].AsFloat(1f);

		public float SpawnQuantityMax => typeAttributes["spawnQuantityMax"].AsFloat(2f);

		public double TotalDaysLastBirth
		{
			get
			{
				return multiplyTree.GetDouble("totalDaysLastBirth", -9999.0);
			}
			set
			{
				multiplyTree.SetDouble("totalDaysLastBirth", value);
				((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("multiply");
			}
		}

		public double TotalDaysPregnancyStart
		{
			get
			{
				return multiplyTree.GetDouble("totalDaysPregnancyStart", 0.0);
			}
			set
			{
				multiplyTree.SetDouble("totalDaysPregnancyStart", value);
				((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("multiply");
			}
		}

		public bool IsPregnant
		{
			get
			{
				return multiplyTree.GetBool("isPregnant", false);
			}
			set
			{
				multiplyTree.SetBool("isPregnant", value);
				((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("multiply");
			}
		}

		public override bool ShouldEat
		{
			get
			{
				if (!eatAnyway)
				{
					if (!IsPregnant && GetSaturation() < base.PortionsEatenForMultiply)
					{
						return base.TotalDaysCooldownUntil <= ((EntityBehavior)this).entity.World.Calendar.TotalDays;
					}
					return false;
				}
				return true;
			}
		}

		public EntityBehaviorMultiply(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Invalid comparison between Unknown and I4
			base.Initialize(properties, attributes);
			typeAttributes = attributes;
			if ((int)((EntityBehavior)this).entity.World.Side == 1)
			{
				if (!multiplyTree.HasAttribute("totalDaysLastBirth"))
				{
					TotalDaysLastBirth = -9999.0;
				}
				callbackId = ((EntityBehavior)this).entity.World.RegisterCallback((Action<float>)CheckMultiply, 3000);
			}
		}

		protected virtual void CheckMultiply(float dt)
		{
			if (!((EntityBehavior)this).entity.Alive)
			{
				callbackId = 0L;
				return;
			}
			callbackId = ((EntityBehavior)this).entity.World.RegisterCallback((Action<float>)CheckMultiply, 3000);
			if (((EntityBehavior)this).entity.World.Calendar == null)
			{
				return;
			}
			double totalDays = ((EntityBehavior)this).entity.World.Calendar.TotalDays;
			if (!IsPregnant)
			{
				if (TryGetPregnant())
				{
					IsPregnant = true;
					TotalDaysPregnancyStart = totalDays;
				}
				return;
			}
			if (totalDays - TotalDaysPregnancyStart > (double)PregnancyDays)
			{
				Random rand = ((EntityBehavior)this).entity.World.Rand;
				float q = SpawnQuantityMin + (float)rand.NextDouble() * (SpawnQuantityMax - SpawnQuantityMin);
				TotalDaysLastBirth = totalDays;
				base.TotalDaysCooldownUntil = totalDays + (base.MultiplyCooldownDaysMin + rand.NextDouble() * (base.MultiplyCooldownDaysMax - base.MultiplyCooldownDaysMin));
				IsPregnant = false;
				((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("multiply");
				GiveBirth(q);
			}
			((EntityBehavior)this).entity.World.FrameProfiler.Mark("multiply");
		}

		protected virtual void GiveBirth(float q)
		{
			Random rand = ((EntityBehavior)this).entity.World.Rand;
			int num = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetInt("generation", 0);
			if (spawnEntityCodes == null)
			{
				PopulateSpawnEntityCodes();
			}
			if (spawnEntityCodes == null)
			{
				return;
			}
			while (q > 1f || rand.NextDouble() < (double)q)
			{
				q -= 1f;
				AssetLocation val = spawnEntityCodes[rand.Next(spawnEntityCodes.Length)];
				EntityProperties entityType = ((EntityBehavior)this).entity.World.GetEntityType(val);
				if (entityType != null)
				{
					Entity val2 = ((EntityBehavior)this).entity.World.ClassRegistry.CreateEntity(entityType);
					val2.ServerPos.SetFrom(((EntityBehavior)this).entity.ServerPos);
					Vec3d motion = val2.ServerPos.Motion;
					motion.X += (rand.NextDouble() - 0.5) / 20.0;
					Vec3d motion2 = val2.ServerPos.Motion;
					motion2.Z += (rand.NextDouble() - 0.5) / 20.0;
					val2.Pos.SetFrom(val2.ServerPos);
					((TreeAttribute)val2.Attributes).SetString("origin", "reproduction");
					((TreeAttribute)val2.WatchedAttributes).SetInt("generation", num + 1);
					((EntityBehavior)this).entity.World.SpawnEntity(val2);
				}
			}
		}

		protected virtual void PopulateSpawnEntityCodes()
		{
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Expected O, but got Unknown
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Expected O, but got Unknown
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Expected O, but got Unknown
			JsonObject val = typeAttributes["spawnEntityCodes"];
			if (!val.Exists)
			{
				val = typeAttributes["spawnEntityCode"];
				if (val.Exists)
				{
					spawnEntityCodes = (AssetLocation[])(object)new AssetLocation[1]
					{
						new AssetLocation(val.AsString(""))
					};
				}
			}
			else if (val.IsArray())
			{
				SpawnEntityProperties[] array = val.AsArray<SpawnEntityProperties>((SpawnEntityProperties[])null, (string)null);
				spawnEntityCodes = (AssetLocation[])(object)new AssetLocation[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					spawnEntityCodes[i] = new AssetLocation(array[i].Code ?? "");
				}
			}
			else
			{
				spawnEntityCodes = (AssetLocation[])(object)new AssetLocation[1]
				{
					new AssetLocation(val.AsString(""))
				};
			}
		}

		public override void TestCommand(object arg)
		{
			GiveBirth((int)arg);
		}

		protected virtual bool TryGetPregnant()
		{
			if (((EntityBehavior)this).entity.World.Rand.NextDouble() > 0.06)
			{
				return false;
			}
			if (base.TotalDaysCooldownUntil > ((EntityBehavior)this).entity.World.Calendar.TotalDays)
			{
				return false;
			}
			ITreeAttribute treeAttribute = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute == null)
			{
				return false;
			}
			float num = treeAttribute.GetFloat("saturation", 0f);
			if (num >= base.PortionsEatenForMultiply)
			{
				Entity val = null;
				if (RequiresNearbyEntityCode != null && (val = GetRequiredEntityNearby()) == null)
				{
					return false;
				}
				if (((EntityBehavior)this).entity.World.Rand.NextDouble() < 0.2)
				{
					treeAttribute.SetFloat("saturation", num - 1f);
					return false;
				}
				treeAttribute.SetFloat("saturation", num - base.PortionsEatenForMultiply);
				if (val != null)
				{
					ITreeAttribute treeAttribute2 = ((TreeAttribute)val.WatchedAttributes).GetTreeAttribute("hunger");
					if (treeAttribute2 != null)
					{
						num = treeAttribute2.GetFloat("saturation", 0f);
						treeAttribute2.SetFloat("saturation", Math.Max(0f, num - 1f));
					}
				}
				IsPregnant = true;
				TotalDaysPregnancyStart = ((EntityBehavior)this).entity.World.Calendar.TotalDays;
				((EntityBehavior)this).entity.WatchedAttributes.MarkPathDirty("multiply");
				return true;
			}
			return false;
		}

		protected virtual Entity GetRequiredEntityNearby()
		{
			if (RequiresNearbyEntityCode == null)
			{
				return null;
			}
			return ((EntityBehavior)this).entity.World.GetNearestEntity(((EntityBehavior)this).entity.ServerPos.XYZ, RequiresNearbyEntityRange, RequiresNearbyEntityRange, (ActionConsumable<Entity>)delegate(Entity e)
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Expected O, but got Unknown
				if (((RegistryObject)e).WildCardMatch(new AssetLocation(RequiresNearbyEntityCode)))
				{
					if (((TreeAttribute)e.WatchedAttributes).GetBool("doesEat", false))
					{
						IAttribute obj = ((TreeAttribute)e.WatchedAttributes)["hunger"];
						IAttribute obj2 = ((obj is ITreeAttribute) ? obj : null);
						if (obj2 == null || !(((ITreeAttribute)obj2).GetFloat("saturation", 0f) >= 1f))
						{
							goto IL_005c;
						}
					}
					return true;
				}
				goto IL_005c;
				IL_005c:
				return false;
			});
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			((EntityBehavior)this).entity.World.UnregisterCallback(callbackId);
		}

		public override string PropertyName()
		{
			return "multiply";
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			multiplyTree = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetTreeAttribute("multiply");
			if (IsPregnant)
			{
				infotext.AppendLine(Lang.Get("Is pregnant", Array.Empty<object>()));
			}
			else
			{
				if (!((EntityBehavior)this).entity.Alive)
				{
					return;
				}
				ITreeAttribute treeAttribute = ((TreeAttribute)((EntityBehavior)this).entity.WatchedAttributes).GetTreeAttribute("hunger");
				if (treeAttribute != null)
				{
					float num = treeAttribute.GetFloat("saturation", 0f);
					infotext.AppendLine(Lang.Get("Portions eaten: {0}", new object[1] { num }));
				}
				double num2 = base.TotalDaysCooldownUntil - ((EntityBehavior)this).entity.World.Calendar.TotalDays;
				if (num2 > 0.0)
				{
					if (num2 > 3.0)
					{
						infotext.AppendLine(Lang.Get("Several days left before ready to mate", Array.Empty<object>()));
					}
					else
					{
						infotext.AppendLine(Lang.Get("Less than 3 days before ready to mate", Array.Empty<object>()));
					}
				}
				else
				{
					infotext.AppendLine(Lang.Get("Ready to mate", Array.Empty<object>()));
				}
			}
		}
	}
	public class SpawnEntityProperties
	{
		[JsonProperty]
		public string Code;
	}
	public class EntityBehaviorMultiplyBase : EntityBehavior
	{
		protected ITreeAttribute multiplyTree;

		protected bool eatAnyway;

		public double MultiplyCooldownDaysMin { get; set; }

		public double MultiplyCooldownDaysMax { get; set; }

		public float PortionsEatenForMultiply { get; set; }

		public double TotalDaysCooldownUntil
		{
			get
			{
				return multiplyTree.GetDouble("totalDaysCooldownUntil", 0.0);
			}
			set
			{
				multiplyTree.SetDouble("totalDaysCooldownUntil", value);
				base.entity.WatchedAttributes.MarkPathDirty("multiply");
			}
		}

		public virtual bool ShouldEat
		{
			get
			{
				if (!eatAnyway)
				{
					if (GetSaturation() < PortionsEatenForMultiply)
					{
						return TotalDaysCooldownUntil <= base.entity.World.Calendar.TotalDays;
					}
					return false;
				}
				return true;
			}
		}

		public virtual float PortionsLeftToEat => PortionsEatenForMultiply - GetSaturation();

		public EntityBehaviorMultiplyBase(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Invalid comparison between Unknown and I4
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Expected O, but got Unknown
			//IL_00c5: Expected O, but got Unknown
			((EntityBehavior)this).Initialize(properties, attributes);
			eatAnyway = attributes["eatAnyway"].AsBool(false);
			MultiplyCooldownDaysMin = attributes["multiplyCooldownDaysMin"].AsFloat(6f);
			MultiplyCooldownDaysMax = attributes["multiplyCooldownDaysMax"].AsFloat(12f);
			PortionsEatenForMultiply = attributes["portionsEatenForMultiply"].AsFloat(3f);
			multiplyTree = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("multiply");
			if ((int)base.entity.World.Side == 1 && multiplyTree == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				ITreeAttribute val2 = (ITreeAttribute)val;
				multiplyTree = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("multiply", (IAttribute)(object)val2);
				double num = base.entity.World.Calendar.TotalHours / 24.0;
				TotalDaysCooldownUntil = num + (MultiplyCooldownDaysMin + base.entity.World.Rand.NextDouble() * (MultiplyCooldownDaysMax - MultiplyCooldownDaysMin));
			}
		}

		protected float GetSaturation()
		{
			ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute == null)
			{
				return 0f;
			}
			return treeAttribute.GetFloat("saturation", 0f);
		}

		public override string PropertyName()
		{
			return "multiplybase";
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			if (!base.entity.Alive)
			{
				return;
			}
			ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute != null)
			{
				float num = treeAttribute.GetFloat("saturation", 0f);
				infotext.AppendLine(Lang.Get("Portions eaten: {0}", new object[1] { num }));
				if (num >= PortionsEatenForMultiply)
				{
					infotext.AppendLine(Lang.Get("Ready to lay", Array.Empty<object>()));
				}
			}
		}
	}
	public class EntityBehaviorNameTag : EntityBehavior, IRenderer, IDisposable
	{
		protected LoadedTexture nameTagTexture;

		protected bool showNameTagOnlyWhenTargeted;

		protected NameTagRendererDelegate nameTagRenderHandler;

		private ICoreClientAPI capi;

		protected int renderRange = 999;

		private IPlayer player;

		public string DisplayName
		{
			get
			{
				if (capi != null && TriggeredNameReveal && !IsNameRevealedFor(((IPlayer)capi.World.Player).PlayerUID))
				{
					return UnrevealedDisplayName;
				}
				ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
				if (treeAttribute == null)
				{
					return null;
				}
				return treeAttribute.GetString("name", (string)null);
			}
		}

		public string UnrevealedDisplayName { get; set; }

		public bool ShowOnlyWhenTargeted
		{
			get
			{
				ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
				if (treeAttribute == null)
				{
					return false;
				}
				return treeAttribute.GetBool("showtagonlywhentargeted", false);
			}
			set
			{
				ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
				if (treeAttribute != null)
				{
					treeAttribute.SetBool("showtagonlywhentargeted", value);
				}
			}
		}

		public bool TriggeredNameReveal { get; set; }

		public int RenderRange
		{
			get
			{
				return ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag").GetInt("renderRange", 0);
			}
			set
			{
				ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
				if (treeAttribute != null)
				{
					treeAttribute.SetInt("renderRange", value);
				}
			}
		}

		public double RenderOrder => 1.0;

		protected bool IsSelf => base.entity.EntityId == ((Entity)((IPlayer)capi.World.Player).Entity).EntityId;

		public bool IsNameRevealedFor(string playeruid)
		{
			ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
			if (treeAttribute == null)
			{
				return false;
			}
			ITreeAttribute treeAttribute2 = treeAttribute.GetTreeAttribute("nameRevealedFor");
			return ((treeAttribute2 != null) ? new bool?(treeAttribute2.HasAttribute(playeruid)) : ((bool?)null)) == true;
		}

		public void SetNameRevealedFor(string playeruid)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0035: Expected O, but got Unknown
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Expected O, but got Unknown
			//IL_005c: Expected O, but got Unknown
			ITreeAttribute val = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
			if (val == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val2 = new TreeAttribute();
				val = (ITreeAttribute)val2;
				((TreeAttribute)watchedAttributes)["nametag"] = (IAttribute)val2;
			}
			ITreeAttribute val3 = ((val != null) ? val.GetTreeAttribute("nameRevealedFor") : null);
			if (val3 == null)
			{
				ITreeAttribute obj = val;
				TreeAttribute val4 = new TreeAttribute();
				val3 = (ITreeAttribute)val4;
				obj["nameRevealedFor"] = (IAttribute)val4;
			}
			val3.SetBool(playeruid, true);
			OnNameChanged();
		}

		public EntityBehaviorNameTag(Entity entity)
			: base(entity)
		{
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Expected O, but got Unknown
			//IL_003d: Expected O, but got Unknown
			ITreeAttribute treeAttribute = ((TreeAttribute)entity.WatchedAttributes).GetTreeAttribute("nametag");
			if (treeAttribute == null)
			{
				SyncedTreeAttribute watchedAttributes = entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				treeAttribute = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("nametag", (IAttribute)val);
				treeAttribute.SetString("name", "");
				treeAttribute.SetInt("showtagonlywhentargeted", 0);
				treeAttribute.SetInt("renderRange", 999);
				entity.WatchedAttributes.MarkPathDirty("nametag");
			}
		}

		public override void Initialize(EntityProperties entityType, JsonObject attributes)
		{
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Expected O, but got Unknown
			((EntityBehavior)this).Initialize(entityType, attributes);
			if ((DisplayName == null || DisplayName.Length == 0) && attributes["selectFromRandomName"].Exists)
			{
				string[] array = attributes["selectFromRandomName"].AsArray<string>((string[])null, (string)null);
				SetName(array[base.entity.World.Rand.Next(array.Length)]);
			}
			TriggeredNameReveal = attributes["triggeredNameReveal"].AsBool(false);
			RenderRange = attributes["renderRange"].AsInt(999);
			ShowOnlyWhenTargeted = attributes["showtagonlywhentargeted"].AsBool(false);
			UnrevealedDisplayName = Lang.Get(attributes["unrevealedDisplayName"].AsString("nametag-default-unrevealedname"), Array.Empty<object>());
			base.entity.WatchedAttributes.OnModified.Add(new TreeModifiedListener
			{
				path = "nametag",
				listener = OnNameChanged
			});
			OnNameChanged();
			ref ICoreClientAPI reference = ref capi;
			ICoreAPI api = base.entity.World.Api;
			reference = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			if (capi != null)
			{
				capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)10, "nametag");
			}
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Invalid comparison between Unknown and I4
			if (IsSelf && (int)capi.Render.CameraType == 0)
			{
				return;
			}
			if (nameTagRenderHandler == null || (base.entity is EntityPlayer && player == null))
			{
				Entity entity = base.entity;
				Entity obj = ((entity is EntityPlayer) ? entity : null);
				player = ((obj != null) ? ((EntityPlayer)obj).Player : null);
				if (player != null || !(base.entity is EntityPlayer))
				{
					nameTagRenderHandler = ((ICoreAPI)capi).ModLoader.GetModSystem<EntityNameTagRendererRegistry>(true).GetNameTagRenderer(base.entity);
					OnNameChanged();
				}
			}
			if ((player != null && (int)player.WorldData.CurrentGameMode == 3) || nameTagTexture == null)
			{
				return;
			}
			IPlayer obj2 = player;
			if (obj2 != null)
			{
				EntityPlayer entity2 = obj2.Entity;
				if (((entity2 != null) ? new bool?(((EntityAgent)entity2).ServerControls.Sneak) : ((bool?)null)) == true)
				{
					return;
				}
			}
			IRenderAPI render = capi.Render;
			EntityPlayer entity3 = ((IPlayer)capi.World.Player).Entity;
			if (!(base.entity.Properties.Client.Renderer is EntityShapeRenderer entityShapeRenderer))
			{
				return;
			}
			Vec3d val = MatrixToolsd.Project(entityShapeRenderer.getAboveHeadPosition(entity3), render.PerspectiveProjectionMat, render.PerspectiveViewMat, render.FrameWidth, render.FrameHeight);
			if (!(val.Z < 0.0))
			{
				float val2 = 4f / Math.Max(1f, (float)val.Z);
				float num = Math.Min(1f, val2);
				if (num > 0.75f)
				{
					num = 0.75f + (num - 0.75f) / 2f;
				}
				float num2 = 0f;
				double num3 = ((Entity)entity3).Pos.SquareDistanceTo(base.entity.Pos);
				if (nameTagTexture != null && (!ShowOnlyWhenTargeted || ((IPlayer)capi.World.Player).CurrentEntitySelection?.Entity == base.entity) && (double)(renderRange * renderRange) > num3)
				{
					float num4 = (float)val.X - num * (float)nameTagTexture.Width / 2f;
					float num5 = (float)render.FrameHeight - (float)val.Y - (float)nameTagTexture.Height * Math.Max(0f, num);
					render.Render2DTexture(nameTagTexture.TextureId, num4, num5, num * (float)nameTagTexture.Width, num * (float)nameTagTexture.Height, 20f, (Vec4f)null);
					num2 += (float)nameTagTexture.Height;
				}
			}
		}

		public void Dispose()
		{
			if (nameTagTexture != null)
			{
				nameTagTexture.Dispose();
				nameTagTexture = null;
			}
			if (capi != null)
			{
				capi.Event.UnregisterRenderer((IRenderer)(object)this, (EnumRenderStage)10);
			}
		}

		public override string GetName(ref EnumHandling handling)
		{
			handling = (EnumHandling)2;
			return DisplayName;
		}

		public void SetName(string playername)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0035: Expected O, but got Unknown
			ITreeAttribute val = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("nametag");
			if (val == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val2 = new TreeAttribute();
				val = (ITreeAttribute)val2;
				((TreeAttribute)watchedAttributes).SetAttribute("nametag", (IAttribute)val2);
			}
			val.SetString("name", playername);
			base.entity.WatchedAttributes.MarkPathDirty("nametag");
		}

		protected void OnNameChanged()
		{
			if (nameTagRenderHandler != null)
			{
				if (nameTagTexture != null)
				{
					nameTagTexture.Dispose();
					nameTagTexture = null;
				}
				nameTagTexture = nameTagRenderHandler(capi, base.entity);
			}
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			Dispose();
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			Dispose();
		}

		public override string PropertyName()
		{
			return "displayname";
		}
	}
	public class EntityBehaviorOpenableContainer : EntityBehavior
	{
		protected InventoryGeneric inv;

		protected GuiDialogCreatureContents dlg;

		private WorldInteraction[] interactions;

		public EntityBehaviorOpenableContainer(Entity entity)
			: base(entity)
		{
		}

		public override void OnGameTick(float deltaTime)
		{
			((EntityBehavior)this).OnGameTick(deltaTime);
		}

		private void Inv_SlotModified(int slotid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			TreeAttribute val = new TreeAttribute();
			((InventoryBase)inv).ToTreeAttributes((ITreeAttribute)(object)val);
			((TreeAttribute)base.entity.WatchedAttributes)["harvestableInv"] = (IAttribute)(object)val;
			base.entity.WatchedAttributes.MarkPathDirty("harvestableInv");
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected O, but got Unknown
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Invalid comparison between Unknown and I4
			inv = new InventoryGeneric(typeAttributes["quantitySlots"].AsInt(8), "contents-" + base.entity.EntityId, base.entity.Api, (NewSlotDelegate)null);
			IAttribute obj = ((TreeAttribute)base.entity.WatchedAttributes)["harvestableInv"];
			TreeAttribute val = (TreeAttribute)(object)((obj is TreeAttribute) ? obj : null);
			if (val != null)
			{
				((InventoryBase)inv).FromTreeAttributes((ITreeAttribute)(object)val);
			}
			((InventoryBase)inv).PutLocked = false;
			if ((int)base.entity.World.Side == 1)
			{
				((InventoryBase)inv).SlotModified += Inv_SlotModified;
			}
			((EntityBehavior)this).Initialize(properties, typeAttributes);
		}

		public override void OnInteract(EntityAgent byEntity, ItemSlot itemslot, Vec3d hitPosition, EnumInteractMode mode, ref EnumHandling handled)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Invalid comparison between Unknown and I4
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Invalid comparison between Unknown and I4
			if ((((int)((Entity)byEntity).World.Side != 2 || !(((Entity)byEntity).Pos.SquareDistanceTo(base.entity.Pos) <= 5f)) && ((int)((Entity)byEntity).World.Side != 1 || !(((Entity)byEntity).Pos.SquareDistanceTo(base.entity.Pos) <= 14f))) || !byEntity.Controls.ShiftKey)
			{
				return;
			}
			EntityPlayer val = (EntityPlayer)(object)((byEntity is EntityPlayer) ? byEntity : null);
			IPlayer val2 = base.entity.World.PlayerByUid(val.PlayerUID);
			val2.InventoryManager.OpenInventory((IInventory)(object)inv);
			if ((int)base.entity.World.Side == 2 && dlg == null)
			{
				ref GuiDialogCreatureContents reference = ref dlg;
				InventoryGeneric obj = inv;
				Entity entity = base.entity;
				ICoreAPI api = base.entity.Api;
				reference = new GuiDialogCreatureContents(obj, entity, (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null), "invcontents");
				if (((GuiDialog)dlg).TryOpen())
				{
					ICoreAPI api2 = base.entity.World.Api;
					((ICoreClientAPI)((api2 is ICoreClientAPI) ? api2 : null)).Network.SendPacketClient(((InventoryBase)inv).Open(val2));
				}
				((GuiDialog)dlg).OnClosed += delegate
				{
					((GuiDialog)dlg).Dispose();
					dlg = null;
				};
			}
		}

		public override void OnReceivedClientPacket(IServerPlayer player, int packetid, byte[] data, ref EnumHandling handled)
		{
			if (packetid < 1000)
			{
				((InventoryBase)inv).InvNetworkUtil.HandleClientPacket((IPlayer)(object)player, packetid, data);
				handled = (EnumHandling)3;
			}
			else if (packetid == 1012)
			{
				((IPlayer)player).InventoryManager.OpenInventory((IInventory)(object)inv);
			}
		}

		public override WorldInteraction[] GetInteractionHelp(IClientWorldAccessor world, EntitySelection es, IClientPlayer player, ref EnumHandling handled)
		{
			interactions = ObjectCacheUtil.GetOrCreate<WorldInteraction[]>(((IWorldAccessor)world).Api, "entityContainerInteractions", (CreateCachableObjectDelegate<WorldInteraction[]>)(() => (WorldInteraction[])(object)new WorldInteraction[1]
			{
				new WorldInteraction
				{
					ActionLangCode = "blockhelp-open",
					MouseButton = (EnumMouseButton)2,
					HotKeyCode = "shift"
				}
			}));
			return interactions;
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			((EntityBehavior)this).GetInfoText(infotext);
		}

		public override string PropertyName()
		{
			return "openablecontainer";
		}
	}
	public class EntityBehaviorPlaceBlock : EntityBehavior
	{
		private ITreeAttribute createBlockTree;

		private JsonObject attributes;

		private long callbackId;

		internal float MinHourDelay => attributes["minHourDelay"].AsFloat(192f);

		internal float MaxHourDelay => attributes["maxHourDelay"].AsFloat(360f);

		internal float RndHourDelay
		{
			get
			{
				float minHourDelay = MinHourDelay;
				float maxHourDelay = MaxHourDelay;
				return minHourDelay + (float)base.entity.World.Rand.NextDouble() * (maxHourDelay - minHourDelay);
			}
		}

		internal AssetLocation[] BlockCodes
		{
			get
			{
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Expected O, but got Unknown
				string[] array = attributes["blockCodes"].AsArray<string>(Array.Empty<string>(), (string)null);
				AssetLocation[] array2 = (AssetLocation[])(object)new AssetLocation[array.Length];
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i] = new AssetLocation(array[i]);
				}
				return array2;
			}
		}

		internal double TotalHoursUntilPlace
		{
			get
			{
				return createBlockTree.GetDouble("TotalHoursUntilPlace", 0.0);
			}
			set
			{
				createBlockTree.SetDouble("TotalHoursUntilPlace", value);
			}
		}

		public override string PropertyName()
		{
			return "createblock";
		}

		public EntityBehaviorPlaceBlock(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Expected O, but got Unknown
			//IL_004f: Expected O, but got Unknown
			((EntityBehavior)this).Initialize(properties, attributes);
			this.attributes = attributes;
			createBlockTree = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("behaviorCreateBlock");
			if (createBlockTree == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				ITreeAttribute val2 = (ITreeAttribute)val;
				createBlockTree = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("behaviorCreateBlock", (IAttribute)(object)val2);
				TotalHoursUntilPlace = base.entity.World.Calendar.TotalHours + (double)RndHourDelay;
			}
			callbackId = base.entity.World.RegisterCallback((Action<float>)CheckShouldPlace, 3000);
		}

		private void CheckShouldPlace(float dt)
		{
			if (!base.entity.Alive || base.entity.Swimming || base.entity.FeetInLiquid)
			{
				callbackId = 0L;
				return;
			}
			callbackId = base.entity.World.RegisterCallback((Action<float>)CheckShouldPlace, 3000);
			if (base.entity.World.Calendar == null)
			{
				return;
			}
			while (base.entity.World.Calendar.TotalHours > TotalHoursUntilPlace && base.entity.World.Rand.NextDouble() < 0.5)
			{
				AssetLocation[] blockCodes = BlockCodes;
				Block block = base.entity.World.GetBlock(blockCodes[base.entity.World.Rand.Next(blockCodes.Length)]);
				if (block == null)
				{
					return;
				}
				int num;
				if (!TryPlace(block, 0, 0, 0) && !TryPlace(block, 1, 0, 0) && !TryPlace(block, 0, 0, -1) && !TryPlace(block, -1, 0, 0))
				{
					num = (TryPlace(block, 0, 0, 1) ? 1 : 0);
					if (num == 0)
					{
						goto IL_00f7;
					}
				}
				else
				{
					num = 1;
				}
				TotalHoursUntilPlace += RndHourDelay;
				goto IL_00f7;
				IL_00f7:
				if (num == 0 || MinHourDelay <= 0f)
				{
					break;
				}
			}
			base.entity.World.FrameProfiler.Mark("createblock");
		}

		private bool TryPlace(Block block, int dx, int dy, int dz)
		{
			IBlockAccessor blockAccessor = base.entity.World.BlockAccessor;
			BlockPos val = base.entity.ServerPos.XYZ.AsBlockPos.Add(dx, dy, dz);
			Block block2 = blockAccessor.GetBlock(val);
			val.Y--;
			if (block2.IsReplacableBy(block) && blockAccessor.GetMostSolidBlock(val).CanAttachBlockAt(blockAccessor, block, val, BlockFacing.UP, (Cuboidi)null))
			{
				val.Y++;
				blockAccessor.SetBlock(block.BlockId, val);
				BlockEntityTransient obj = blockAccessor.GetBlockEntity(val) as BlockEntityTransient;
				obj?.SetPlaceTime(TotalHoursUntilPlace);
				if (obj != null && obj.IsDueTransition())
				{
					blockAccessor.SetBlock(0, val);
				}
				return true;
			}
			return false;
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			base.entity.World.UnregisterCallback(callbackId);
		}
	}
	public class EntityBehaviorPlayerPhysics : EntityBehaviorControlledPhysics, IRenderer, IDisposable, IRemotePhysics
	{
		private IPlayer player;

		private IServerPlayer serverPlayer;

		private EntityPlayer entityPlayer;

		private const float interval = 1f / 60f;

		private float accum;

		private int currentTick;

		private int prevDimension;

		public const float ClippingToleranceOnDimensionChange = 0.0625f;

		public double RenderOrder => 1.0;

		public int RenderRange => 9999;

		public EntityBehaviorPlayerPhysics(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Invalid comparison between Unknown and I4
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			ref EntityPlayer reference = ref entityPlayer;
			Entity entity = ((EntityBehavior)this).entity;
			reference = (EntityPlayer)(object)((entity is EntityPlayer) ? entity : null);
			((PhysicsBehaviorBase)this).Init();
			SetProperties(properties, attributes);
			if ((int)((EntityBehavior)this).entity.Api.Side == 2)
			{
				smoothStepping = true;
				((PhysicsBehaviorBase)this).capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)0, "playerphysics");
			}
			else
			{
				EnumHandling val = (EnumHandling)1;
				((EntityBehavior)this).OnReceivedServerPos(true, ref val);
			}
			PhysicsTickDelegate physicsUpdateWatcher = ((EntityBehavior)this).entity.PhysicsUpdateWatcher;
			if (physicsUpdateWatcher != null)
			{
				physicsUpdateWatcher.Invoke(0f, ((EntityBehavior)this).entity.SidedPos.XYZ);
			}
		}

		public override void SetModules()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Expected O, but got Unknown
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Expected O, but got Unknown
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Expected O, but got Unknown
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Expected O, but got Unknown
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Expected O, but got Unknown
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Expected O, but got Unknown
			physicsModules.Add((PModule)new PModuleWind());
			physicsModules.Add((PModule)new PModuleOnGround());
			physicsModules.Add((PModule)new PModulePlayerInLiquid(entityPlayer));
			physicsModules.Add((PModule)new PModulePlayerInAir());
			physicsModules.Add((PModule)new PModuleGravity());
			physicsModules.Add((PModule)new PModuleMotionDrag());
			physicsModules.Add((PModule)new PModuleKnockback());
		}

		public override void OnReceivedServerPos(bool isTeleport, ref EnumHandling handled)
		{
		}

		public new void OnReceivedClientPos(int version)
		{
			if (serverPlayer == null)
			{
				ref IServerPlayer reference = ref serverPlayer;
				IPlayer obj = entityPlayer.Player;
				reference = (IServerPlayer)(object)((obj is IServerPlayer) ? obj : null);
			}
			((EntityBehavior)this).entity.ServerPos.SetFrom(((EntityBehavior)this).entity.Pos);
			if (version > ((PhysicsBehaviorBase)this).previousVersion)
			{
				((PhysicsBehaviorBase)this).previousVersion = version;
				HandleRemotePhysics(1f / 15f, isTeleport: true);
			}
			else
			{
				HandleRemotePhysics(1f / 15f, isTeleport: false);
			}
		}

		public new void HandleRemotePhysics(float dt, bool isTeleport)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Expected O, but got Unknown
			if (player == null)
			{
				player = entityPlayer.Player;
			}
			if (player == null)
			{
				return;
			}
			Entity entity = ((EntityBehavior)this).entity;
			if (((PhysicsBehaviorBase)this).nPos == (Vec3d)null)
			{
				((PhysicsBehaviorBase)this).nPos = new Vec3d();
				((PhysicsBehaviorBase)this).nPos.Set(entity.ServerPos);
			}
			EntityPos lPos = ((PhysicsBehaviorBase)this).lPos;
			float num = dt * 60f;
			lPos.SetFrom(((PhysicsBehaviorBase)this).nPos);
			((PhysicsBehaviorBase)this).nPos.Set(entity.ServerPos);
			lPos.Dimension = entity.Pos.Dimension;
			if (isTeleport)
			{
				lPos.SetFrom(((PhysicsBehaviorBase)this).nPos);
			}
			lPos.Motion.X = (((PhysicsBehaviorBase)this).nPos.X - lPos.X) / (double)num;
			lPos.Motion.Y = (((PhysicsBehaviorBase)this).nPos.Y - lPos.Y) / (double)num;
			lPos.Motion.Z = (((PhysicsBehaviorBase)this).nPos.Z - lPos.Z) / (double)num;
			if (lPos.Motion.Length() > 20.0)
			{
				lPos.Motion.Set(0.0, 0.0, 0.0);
			}
			entity.Pos.Motion.Set(lPos.Motion);
			entity.ServerPos.Motion.Set(lPos.Motion);
			PhysicsBehaviorBase.collisionTester.NewTick(lPos);
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (val.MountedOn != null)
			{
				entity.Swimming = false;
				entity.OnGround = false;
				if (((PhysicsBehaviorBase)this).capi != null)
				{
					entity.Pos.SetPos(val.MountedOn.SeatPosition);
				}
				entity.ServerPos.Motion.X = 0.0;
				entity.ServerPos.Motion.Y = 0.0;
				entity.ServerPos.Motion.Z = 0.0;
				if (((PhysicsBehaviorBase)this).sapi != null)
				{
					((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(entity, lPos, num, ref newPos, 0f, 0f);
				}
				return;
			}
			entity.Pos.SetFrom(entity.ServerPos);
			SetState(lPos, dt);
			EntityControls controls = val.Controls;
			if (!controls.NoClip)
			{
				if (((PhysicsBehaviorBase)this).sapi != null)
				{
					((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(entity, lPos, num, ref newPos, 0f, 0f);
				}
				RemoteMotionAndCollision(lPos, num);
				ApplyTests(lPos, val.Controls, dt, remote: true);
			}
			else
			{
				EntityPos serverPos = entity.ServerPos;
				serverPos.X += serverPos.Motion.X * (double)dt * 60.0;
				serverPos.Y += serverPos.Motion.Y * (double)dt * 60.0;
				serverPos.Z += serverPos.Motion.Z * (double)dt * 60.0;
				entity.Swimming = false;
				entity.FeetInLiquid = false;
				entity.OnGround = false;
				controls.Gliding = false;
			}
		}

		public override void OnPhysicsTick(float dt)
		{
			SimPhysics(dt, ((EntityBehavior)this).entity.SidedPos);
		}

		public override void OnGameTick(float deltaTime)
		{
			if (((EntityBehavior)this).entity.World is IServerWorldAccessor)
			{
				callOnEntityInside();
				((EntityBehavior)this).entity.AfterPhysicsTick?.Invoke();
			}
		}

		public void SimPhysics(float dt, EntityPos pos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			Entity entity = ((EntityBehavior)this).entity;
			if ((int)entity.State != 0)
			{
				return;
			}
			if (player == null)
			{
				player = entityPlayer.Player;
			}
			if (player == null)
			{
				return;
			}
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			EntityControls controls = val.Controls;
			prevPos.Set(pos);
			tmpPos.dimension = pos.Dimension;
			SetState(pos, dt);
			SetPlayerControls(pos, controls, dt);
			if (val.MountedOn != null)
			{
				entity.Swimming = false;
				entity.OnGround = false;
				pos.SetPos(val.MountedOn.SeatPosition);
				pos.Motion.X = 0.0;
				pos.Motion.Y = 0.0;
				pos.Motion.Z = 0.0;
				return;
			}
			MotionAndCollision(pos, controls, dt);
			if (!controls.NoClip)
			{
				PhysicsBehaviorBase.collisionTester.NewTick(pos);
				if (prevDimension != pos.Dimension)
				{
					prevDimension = pos.Dimension;
					PhysicsBehaviorBase.collisionTester.PushOutFromBlocks(entity.World.BlockAccessor, entity, pos.XYZ, 0.075f);
				}
				ApplyTests(pos, controls, dt, remote: false);
				if (controls.Gliding)
				{
					if (entity.Collided || entity.FeetInLiquid || !entity.Alive || player.WorldData.FreeMove || controls.IsClimbing)
					{
						controls.GlideSpeed = 0.0;
						controls.Gliding = false;
						controls.IsFlying = false;
						entityPlayer.WalkPitch = 0f;
					}
				}
				else
				{
					controls.GlideSpeed = 0.0;
				}
			}
			else
			{
				pos.X += pos.Motion.X * (double)dt * 60.0;
				pos.Y += pos.Motion.Y * (double)dt * 60.0;
				pos.Z += pos.Motion.Z * (double)dt * 60.0;
				entity.Swimming = false;
				entity.FeetInLiquid = false;
				entity.OnGround = false;
				controls.Gliding = false;
				prevDimension = pos.Dimension;
			}
		}

		public void SetPlayerControls(EntityPos pos, EntityControls controls, float dt)
		{
			IWorldAccessor world = ((EntityBehavior)this).entity.World;
			IClientWorldAccessor val = (IClientWorldAccessor)(object)((world is IClientWorldAccessor) ? world : null);
			controls.IsFlying = player.WorldData.FreeMove || (val != null && ((IPlayer)val.Player).ClientId != player.ClientId && !controls.IsClimbing);
			controls.NoClip = player.WorldData.NoClip;
			controls.MovespeedMultiplier = player.WorldData.MoveSpeedMultiplier;
			if (controls.Gliding && !controls.IsClimbing)
			{
				controls.IsFlying = true;
			}
			if (controls.TriesToMove || controls.Gliding)
			{
				IPlayer obj = player;
				IClientPlayer val2 = (IClientPlayer)(object)((obj is IClientPlayer) ? obj : null);
				if (val2 != null)
				{
					float yaw = pos.Yaw;
					_003F val3 = pos;
					ICoreAPI api = ((EntityBehavior)this).entity.Api;
					((EntityPos)val3).Yaw = ((ICoreClientAPI)((api is ICoreClientAPI) ? api : null)).Input.MouseYaw;
					if (((EntityBehavior)this).entity.Swimming || controls.Gliding)
					{
						float pitch = pos.Pitch;
						pos.Pitch = val2.CameraPitch;
						controls.CalcMovementVectors(pos, dt);
						pos.Yaw = yaw;
						pos.Pitch = pitch;
					}
					else
					{
						controls.CalcMovementVectors(pos, dt);
						pos.Yaw = yaw;
					}
					float num = (float)Math.Atan2(controls.WalkVector.X, controls.WalkVector.Z);
					float num2 = GameMath.AngleRadDistance(entityPlayer.WalkYaw, num);
					EntityPlayer obj2 = entityPlayer;
					obj2.WalkYaw += GameMath.Clamp(num2, -6f * dt * GlobalConstants.OverallSpeedMultiplier, 6f * dt * GlobalConstants.OverallSpeedMultiplier);
					entityPlayer.WalkYaw = GameMath.Mod(entityPlayer.WalkYaw, (float)Math.PI * 2f);
					if (((EntityBehavior)this).entity.Swimming || controls.Gliding)
					{
						float num3 = 0f - (float)Math.Sin(pos.Pitch);
						float num4 = GameMath.AngleRadDistance(entityPlayer.WalkPitch, num3);
						EntityPlayer obj3 = entityPlayer;
						obj3.WalkPitch += GameMath.Clamp(num4, -2f * dt * GlobalConstants.OverallSpeedMultiplier, 2f * dt * GlobalConstants.OverallSpeedMultiplier);
						entityPlayer.WalkPitch = GameMath.Mod(entityPlayer.WalkPitch, (float)Math.PI * 2f);
					}
					else
					{
						entityPlayer.WalkPitch = 0f;
					}
					return;
				}
			}
			if (!((EntityBehavior)this).entity.Swimming && !controls.Gliding)
			{
				entityPlayer.WalkPitch = 0f;
			}
			else if (((EntityBehavior)this).entity.OnGround && entityPlayer.WalkPitch != 0f)
			{
				entityPlayer.WalkPitch = GameMath.Mod(entityPlayer.WalkPitch, (float)Math.PI * 2f);
				if (entityPlayer.WalkPitch < 0.01f || entityPlayer.WalkPitch > 3.1315928f)
				{
					entityPlayer.WalkPitch = 0f;
				}
				else
				{
					EntityPlayer obj4 = entityPlayer;
					obj4.WalkPitch -= GameMath.Clamp(entityPlayer.WalkPitch, 0f, 1.2f * dt * GlobalConstants.OverallSpeedMultiplier);
					if (entityPlayer.WalkPitch < 0f)
					{
						entityPlayer.WalkPitch = 0f;
					}
				}
			}
			float yaw2 = pos.Yaw;
			controls.CalcMovementVectors(pos, dt);
			pos.Yaw = yaw2;
		}

		public void OnRenderFrame(float dt, EnumRenderStage stage)
		{
			if (((PhysicsBehaviorBase)this).capi.IsGamePaused)
			{
				return;
			}
			if ((object)((IPlayer)((PhysicsBehaviorBase)this).capi.World.Player).Entity != ((EntityBehavior)this).entity)
			{
				smoothStepping = false;
				((PhysicsBehaviorBase)this).capi.Event.UnregisterRenderer((IRenderer)(object)this, (EnumRenderStage)0);
				return;
			}
			accum += dt;
			if (accum > 0.5f)
			{
				accum = 0.5f;
			}
			IMountableSeat mountedOn = ((EntityAgent)entityPlayer).MountedOn;
			Entity val = ((mountedOn != null) ? mountedOn.Entity : null);
			IPhysicsTickable val2 = null;
			IMountableSeat mountedOn2 = ((EntityAgent)entityPlayer).MountedOn;
			if ((object)((mountedOn2 != null) ? mountedOn2.MountSupplier.Controller : null) == entityPlayer)
			{
				EntityBehavior? obj = ((val != null) ? val.SidedProperties.Behaviors.Find((EntityBehavior b) => b is IPhysicsTickable) : null);
				val2 = (IPhysicsTickable)(object)((obj is IPhysicsTickable) ? obj : null);
			}
			while (accum >= 1f / 60f)
			{
				OnPhysicsTick(1f / 60f);
				if (val2 != null)
				{
					val2.OnPhysicsTick(1f / 60f);
				}
				accum -= 1f / 60f;
				currentTick++;
				if (currentTick % 4 == 0 && ((Entity)entityPlayer).EntityId != 0L && ((Entity)entityPlayer).Alive)
				{
					((PhysicsBehaviorBase)this).capi.Network.SendPlayerPositionPacket();
					if (val2 != null)
					{
						((PhysicsBehaviorBase)this).capi.Network.SendPlayerMountPositionPacket(val);
					}
				}
				AfterPhysicsTick(1f / 60f);
				if (val2 != null)
				{
					val2.AfterPhysicsTick(1f / 60f);
				}
			}
			PhysicsTickDelegate physicsUpdateWatcher = ((EntityBehavior)this).entity.PhysicsUpdateWatcher;
			if (physicsUpdateWatcher != null)
			{
				physicsUpdateWatcher.Invoke(accum, prevPos);
			}
			if (val != null)
			{
				PhysicsTickDelegate physicsUpdateWatcher2 = val.PhysicsUpdateWatcher;
				if (physicsUpdateWatcher2 != null)
				{
					physicsUpdateWatcher2.Invoke(accum, prevPos);
				}
			}
		}

		protected override bool HandleSteppingOnBlocks(EntityPos pos, Vec3d moveDelta, float dtFac, EntityControls controls)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Invalid comparison between Unknown and I4
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Expected O, but got Unknown
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_024e: Expected O, but got Unknown
			//IL_024e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0255: Expected O, but got Unknown
			if (!controls.TriesToMove || (!((EntityBehavior)this).entity.OnGround && !((EntityBehavior)this).entity.Swimming) || (int)((EntityBehavior)this).entity.Properties.Habitat == 3)
			{
				return false;
			}
			Cuboidd val = ((EntityBehavior)this).entity.CollisionBox.ToDouble();
			double num = 0.5 + (controls.Sprint ? 0.25 : (controls.Sneak ? 0.05 : 0.2));
			double num2 = (val.X1 + val.X2) / 2.0;
			double num3 = (val.Z1 + val.Z2) / 2.0;
			double y = Math.Max(val.Y1 + (double)StepHeight, val.Y2);
			Vec3d val2 = controls.WalkVector.Clone();
			Vec3d obj = val2.Clone().Normalize();
			double num4 = obj.X * num;
			double num5 = obj.Z * num;
			double num6 = val.Width / 2.0;
			double num7 = val.Length / 2.0;
			num4 += (double)Math.Sign(num4) * num6;
			num5 += (double)Math.Sign(num5) * num7;
			Cuboidd val3 = new Cuboidd
			{
				X1 = Math.Min(0.0 - num6, num4),
				X2 = Math.Max(num6, num4),
				Z1 = Math.Min(0.0 - num7, num5),
				Z2 = Math.Max(num7, num5),
				Y1 = (double)((EntityBehavior)this).entity.CollisionBox.Y1 + 0.01 - ((!((EntityBehavior)this).entity.CollidedVertically && !controls.Jump) ? 0.05 : 0.0),
				Y2 = y
			};
			val3.Translate(num2, 0.0, num3);
			val3.Translate(pos.X, pos.Y, pos.Z);
			val.Translate(pos.X, pos.Y, pos.Z);
			List<Cuboidd> list = FindSteppableCollisionboxSmooth(val, val3, moveDelta.Y, val2);
			if (list != null && list.Count > 0)
			{
				Vec3d val4 = new Vec3d();
				Vec2d val5 = new Vec2d();
				if (TryStepSmooth(controls, pos, val5.Set(val2.X, val2.Z), dtFac, list, val))
				{
					return true;
				}
				Cuboidd val6 = val3.Clone();
				if (val6.Z1 == pos.Z + num3)
				{
					val6.Z2 = val6.Z1;
				}
				else
				{
					val6.Z1 = val6.Z2;
				}
				if (TryStepSmooth(controls, pos, val5.Set(val2.X, 0.0), dtFac, FindSteppableCollisionboxSmooth(val, val6, moveDelta.Y, val4.Set(val2.X, val2.Y, 0.0)), val))
				{
					return true;
				}
				val6.Set(val3);
				if (val6.X1 == pos.X + num2)
				{
					val6.X2 = val6.X1;
				}
				else
				{
					val6.X1 = val6.X2;
				}
				if (TryStepSmooth(controls, pos, val5.Set(0.0, val2.Z), dtFac, FindSteppableCollisionboxSmooth(val, val6, moveDelta.Y, val4.Set(0.0, val2.Y, val2.Z)), val))
				{
					return true;
				}
			}
			return false;
		}

		public bool TryStepSmooth(EntityControls controls, EntityPos pos, Vec2d walkVec, float dtFac, List<Cuboidd> steppableBoxes, Cuboidd entityCollisionBox)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Expected O, but got Unknown
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Expected O, but got Unknown
			if (steppableBoxes == null || steppableBoxes.Count == 0)
			{
				return false;
			}
			double num = 0.03;
			Vec2d obj = new Vec2d(walkVec.Y, 0.0 - walkVec.X).Normalize();
			double num2 = Math.Abs(obj.X * 0.3) + 0.001;
			double num3 = 0.0 - num2;
			double num4 = Math.Abs(obj.Y * 0.3) + 0.001;
			double num5 = 0.0 - num4;
			Cuboidf val = new Cuboidf((float)num3, ((EntityBehavior)this).entity.CollisionBox.Y1, (float)num5, (float)num2, ((EntityBehavior)this).entity.CollisionBox.Y2, (float)num4);
			double num6 = pos.Y;
			bool flag = false;
			foreach (Cuboidd steppableBox in steppableBoxes)
			{
				double num7 = steppableBox.Y2 - entityCollisionBox.Y1 + num;
				Vec3d val2 = new Vec3d(GameMath.Clamp(newPos.X, steppableBox.MinX, steppableBox.MaxX), newPos.Y + num7 + (double)pos.DimensionYAdjustment, GameMath.Clamp(newPos.Z, steppableBox.MinZ, steppableBox.MaxZ));
				if (!((CollisionTester)PhysicsBehaviorBase.collisionTester).IsColliding(((EntityBehavior)this).entity.World.BlockAccessor, val, val2, false))
				{
					double num8 = (controls.Sprint ? 0.1 : (controls.Sneak ? 0.025 : 0.05));
					num6 = (steppableBox.IntersectsOrTouches(entityCollisionBox) ? Math.Max(num6, pos.Y + num8 * (double)dtFac) : Math.Max(num6, Math.Min(pos.Y + num8 * (double)dtFac, steppableBox.Y2 - (double)((EntityBehavior)this).entity.CollisionBox.Y1 + num)));
					flag = true;
				}
			}
			if (flag)
			{
				pos.Y = num6;
				((CollisionTester)PhysicsBehaviorBase.collisionTester).ApplyTerrainCollision(((EntityBehavior)this).entity, pos, dtFac, ref newPos, 1f, 1f);
			}
			return flag;
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			ICoreClientAPI capi = ((PhysicsBehaviorBase)this).capi;
			if (capi != null)
			{
				capi.Event.UnregisterRenderer((IRenderer)(object)this, (EnumRenderStage)0);
			}
		}

		public void Dispose()
		{
		}
	}
	public interface ICustomRepulseBehavior
	{
		bool Repulse(Entity entity, Vec3d pushVector);
	}
	public class EntityBehaviorEllipsoidalRepulseAgents : EntityBehaviorRepulseAgents, ICustomRepulseBehavior
	{
		protected Vec3d offset;

		protected Vec3d radius;

		public EntityBehaviorEllipsoidalRepulseAgents(Entity entity)
			: base(entity)
		{
			entity.customRepulseBehavior = true;
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Expected O, but got Unknown
			base.Initialize(properties, attributes);
			offset = attributes["offset"].AsObject<Vec3d>(new Vec3d());
			radius = attributes["radius"].AsObject<Vec3d>((Vec3d)null);
		}

		public override void AfterInitialized(bool onFirstSpawn)
		{
			touchdist = Math.Max(radius.X, radius.Z);
			((EntityBehavior)this).entity.BHRepulseAgents = (EntityBehavior)(object)this;
			((EntityBehavior)this).entity.AfterPhysicsTick = base.AfterPhysicsTick;
		}

		public override void UpdateColSelBoxes()
		{
			touchdist = Math.Max(radius.X, radius.Z);
		}

		public override float GetTouchDistance(ref EnumHandling handling)
		{
			handling = (EnumHandling)2;
			return (float)Math.Max(radius.X, radius.Z) + 0.5f;
		}

		public bool Repulse(Entity e, Vec3d pushVector)
		{
			if (!(e.BHRepulseAgents is EntityBehaviorRepulseAgents entityBehaviorRepulseAgents))
			{
				return true;
			}
			Entity entity = ((EntityBehavior)this).entity;
			Vec3d val = radius;
			double num = entityBehaviorRepulseAgents.ownPosRepulseY;
			if (num > ownPosRepulseY + val.Y || ownPosRepulseY > num + (double)e.SelectionBox.Height)
			{
				return true;
			}
			double num2 = ownPosRepulseX - entityBehaviorRepulseAgents.ownPosRepulseX;
			double num3 = ownPosRepulseZ - entityBehaviorRepulseAgents.ownPosRepulseZ;
			float yaw = entity.ServerPos.Yaw;
			double num4 = RelDistanceToEllipsoid(num2, num3, val.X, val.Z, yaw);
			if (num4 >= 1.0)
			{
				return true;
			}
			double num5 = -1.0 * (1.0 - num4);
			double num6 = num2 * num5;
			double num7 = 0.0;
			double num8 = num3 * num5;
			float num9 = entity.SelectionBox.Length * entity.SelectionBox.Height;
			float num10 = GameMath.Clamp(e.SelectionBox.Length * e.SelectionBox.Height / num9, 0f, 1f) / 1.5f;
			if (e.OnGround)
			{
				num10 *= 10f;
			}
			pushVector.Add(num6 * (double)num10, num7 * (double)num10 * 0.75, num8 * (double)num10);
			return true;
		}

		public double RelDistanceToEllipsoid(double x, double z, double wdt, double len, double yaw)
		{
			double num = x * Math.Cos(yaw) - z * Math.Sin(yaw);
			double num2 = x * Math.Sin(yaw) + z * Math.Cos(yaw);
			double num3 = num + offset.X;
			num2 += offset.Z;
			return num3 * num3 / (wdt * wdt) + num2 * num2 / (len * len);
		}
	}
	public class EntityBehaviorRepulseAgents : EntityBehavior
	{
		protected Vec3d pushVector = new Vec3d();

		protected EntityPartitioning partitionUtil;

		protected bool movable = true;

		protected bool ignorePlayers;

		protected double touchdist;

		private IClientWorldAccessor cworld;

		public double ownPosRepulseX;

		public double ownPosRepulseY;

		public double ownPosRepulseZ;

		public float mySize;

		protected int dimension;

		public override bool ThreadSafe => true;

		public EntityBehaviorRepulseAgents(Entity entity)
			: base(entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			entity.hasRepulseBehavior = true;
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			((EntityBehavior)this).Initialize(properties, attributes);
			movable = attributes["movable"].AsBool(true);
			partitionUtil = base.entity.Api.ModLoader.GetModSystem<EntityPartitioning>(true);
			ignorePlayers = base.entity is EntityPlayer && base.entity.World.Config.GetAsBool("player2PlayerCollisions", true);
			ref IClientWorldAccessor reference = ref cworld;
			IWorldAccessor world = base.entity.World;
			reference = (IClientWorldAccessor)(object)((world is IClientWorldAccessor) ? world : null);
		}

		public override void AfterInitialized(bool onFirstSpawn)
		{
			touchdist = base.entity.touchDistance;
			base.entity.BHRepulseAgents = (EntityBehavior)(object)this;
			base.entity.AfterPhysicsTick = AfterPhysicsTick;
		}

		public override void UpdateColSelBoxes()
		{
			touchdist = base.entity.touchDistance;
		}

		public void AfterPhysicsTick()
		{
			Entity entity = base.entity;
			EntityPos sidedPos = entity.SidedPos;
			Cuboidf collisionBox = entity.CollisionBox;
			Cuboidf originCollisionBox = entity.OriginCollisionBox;
			ownPosRepulseX = sidedPos.X + (double)(collisionBox.X2 - originCollisionBox.X2);
			ownPosRepulseY = sidedPos.Y + (double)(collisionBox.Y2 - originCollisionBox.Y2);
			ownPosRepulseZ = sidedPos.Z + (double)(collisionBox.Z2 - originCollisionBox.Z2);
		}

		public override void OnGameTick(float deltaTime)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Invalid comparison between Unknown and I4
			Entity entity = base.entity;
			if ((int)entity.State == 1 || !entity.IsInteractable || !movable)
			{
				return;
			}
			EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
			if (((val != null) ? val.MountedOn : null) != null || entity.World.ElapsedMilliseconds < 2000)
			{
				return;
			}
			Vec3d val2 = pushVector;
			val2.Set(0.0, 0.0, 0.0);
			mySize = entity.SelectionBox.Length * entity.SelectionBox.Height * (float)((val == null || !val.Controls.Sneak) ? 1 : 2);
			dimension = entity.ServerPos.Dimension;
			if (cworld != null && (object)entity != ((IPlayer)cworld.Player).Entity)
			{
				WalkEntity((Entity)(object)((IPlayer)cworld.Player).Entity);
			}
			else
			{
				partitionUtil.WalkEntities(ownPosRepulseX, ownPosRepulseY, ownPosRepulseZ, touchdist + partitionUtil.LargestTouchDistance + 0.1, WalkEntity, IsInRangePartition, EnumEntitySearchType.Creatures);
			}
			if (val2.X != 0.0 || val2.Z != 0.0 || val2.Y != 0.0)
			{
				val2.X = GameMath.Clamp(val2.X, -3.0, 3.0) / 30.0;
				val2.Y = GameMath.Clamp(val2.Y, -3.0, 0.5) / 30.0;
				val2.Z = GameMath.Clamp(val2.Z, -3.0, 3.0) / 30.0;
				if (cworld != null && (object)entity == ((IPlayer)cworld.Player).Entity)
				{
					entity.SidedPos.Motion.Add(val2);
				}
				else
				{
					entity.ServerPos.Motion.Add(val2);
				}
			}
		}

		private bool WalkEntity(Entity e)
		{
			Entity entity = base.entity;
			if (e == entity || !(e.BHRepulseAgents is EntityBehaviorRepulseAgents entityBehaviorRepulseAgents) || !e.IsInteractable || (ignorePlayers && e is EntityPlayer))
			{
				return true;
			}
			EntityAgent val = (EntityAgent)(object)((e is EntityAgent) ? e : null);
			if (val != null)
			{
				IMountableSeat mountedOn = val.MountedOn;
				if (((mountedOn != null) ? mountedOn.Entity : null) == entity)
				{
					return true;
				}
			}
			if (e.ServerPos.Dimension != dimension)
			{
				return true;
			}
			if (entityBehaviorRepulseAgents is ICustomRepulseBehavior customRepulseBehavior)
			{
				return customRepulseBehavior.Repulse(entity, pushVector);
			}
			double num = ownPosRepulseX - entityBehaviorRepulseAgents.ownPosRepulseX;
			double num2 = ownPosRepulseY - entityBehaviorRepulseAgents.ownPosRepulseY;
			double num3 = ownPosRepulseZ - entityBehaviorRepulseAgents.ownPosRepulseZ;
			double num4 = num * num + num2 * num2 + num3 * num3;
			double num5 = entity.touchDistanceSq + e.touchDistanceSq;
			if (num4 >= num5)
			{
				return true;
			}
			double num6 = (1.0 - num4 / num5) / (double)Math.Max(0.001f, GameMath.Sqrt(num4));
			double num7 = num * num6;
			double num8 = num2 * num6;
			double num9 = num3 * num6;
			float num10 = GameMath.Clamp(e.SelectionBox.Length * e.SelectionBox.Height / mySize, 0f, 1f);
			if (entity.OnGround)
			{
				num10 *= 3f;
			}
			pushVector.Add(num7 * (double)num10, num8 * (double)num10 * 0.75, num9 * (double)num10);
			return true;
		}

		public override string PropertyName()
		{
			return "repulseagents";
		}

		private bool IsInRangePartition(Entity e, double posX, double posY, double posZ, double radiusSq)
		{
			return true;
		}
	}
	public class EntityBehaviorReviveOnDeath : EntityBehavior
	{
		private float minHours;

		private float maxHours;

		public double DiedTotalHours
		{
			get
			{
				return ((TreeAttribute)base.entity.Attributes).GetDouble("diedTotalHours", 0.0);
			}
			set
			{
				((TreeAttribute)base.entity.Attributes).SetDouble("diedTotalHours", value);
			}
		}

		public double ReviveWaitHours
		{
			get
			{
				return ((TreeAttribute)base.entity.Attributes).GetDouble("reviveWaitHours", 0.0);
			}
			set
			{
				((TreeAttribute)base.entity.Attributes).SetDouble("reviveWaitHours", value);
			}
		}

		public EntityBehaviorReviveOnDeath(Entity entity)
			: base(entity)
		{
			if (!(entity is EntityAgent))
			{
				throw new InvalidOperationException("Reive on death behavior is only possible on entities deriving from EntityAgent");
			}
			((EntityAgent)((entity is EntityAgent) ? entity : null)).AllowDespawn = false;
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			minHours = typeAttributes["minHours"].AsFloat(24f);
			maxHours = typeAttributes["maxHours"].AsFloat(48f);
		}

		public override void OnGameTick(float deltaTime)
		{
			if (!base.entity.Alive && !base.entity.ShouldDespawn && base.entity.World.Calendar.TotalHours > DiedTotalHours + ReviveWaitHours)
			{
				base.entity.Revive();
			}
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			DiedTotalHours = base.entity.World.Calendar.TotalHours;
			ReviveWaitHours = (double)minHours + base.entity.World.Rand.NextDouble() * (double)(maxHours - minHours);
			((EntityBehavior)this).OnEntityDeath(damageSourceForDeath);
		}

		public override string PropertyName()
		{
			return "timeddespawn";
		}
	}
	public class EntityBehaviorSelectionBoxes : EntityBehavior, IRenderer, IDisposable
	{
		private ICoreClientAPI capi;

		private Matrixf mvmat = new Matrixf();

		private bool debug;

		private bool rendererRegistered;

		public AttachmentPointAndPose[] selectionBoxes = Array.Empty<AttachmentPointAndPose>();

		private string[] selectionBoxCodes;

		public WireframeCube BoxWireframe;

		private float accum;

		private static Cuboidd standardbox = new Cuboidd(0.0, 0.0, 0.0, 1.0, 1.0, 1.0);

		private Vec3d hitPositionOBBSpace;

		private Vec3d hitPositionAABBSpace;

		public double RenderOrder => 1.0;

		public int RenderRange => 24;

		public EntityBehaviorSelectionBoxes(Entity entity)
			: base(entity)
		{
		}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown


		public void Dispose()
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			((EntityBehavior)this).Initialize(properties, attributes);
			ref ICoreClientAPI reference = ref capi;
			ICoreAPI api = base.entity.Api;
			reference = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			if (capi != null)
			{
				debug = capi.Settings.Bool["debugEntitySelectionBoxes"];
			}
			setupWireframe();
			base.entity.trickleDownRayIntersects = true;
			base.entity.requirePosesOnServer = true;
			selectionBoxCodes = attributes["selectionBoxes"].AsArray<string>(Array.Empty<string>(), (string)null);
			if (selectionBoxCodes.Length == 0)
			{
				((IWorldAccessor)capi.World).Logger.Warning("EntityBehaviorSelectionBoxes, missing selectionBoxes property. Will ignore.");
			}
		}

		public override void OnTesselated()
		{
			loadSelectionBoxes();
		}

		private void loadSelectionBoxes()
		{
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Expected O, but got Unknown
			List<AttachmentPointAndPose> list = new List<AttachmentPointAndPose>();
			string[] array = selectionBoxCodes;
			foreach (string text in array)
			{
				IAnimationManager animManager = base.entity.AnimManager;
				object obj;
				if (animManager == null)
				{
					obj = null;
				}
				else
				{
					IAnimator animator = animManager.Animator;
					obj = ((animator != null) ? animator.GetAttachmentPointPose(text) : null);
				}
				AttachmentPointAndPose val = (AttachmentPointAndPose)obj;
				if (val != null)
				{
					AttachmentPointAndPose item = new AttachmentPointAndPose
					{
						AnimModelMatrix = val.AnimModelMatrix,
						AttachPoint = val.AttachPoint,
						CachedPose = val.CachedPose
					};
					list.Add(item);
				}
			}
			selectionBoxes = list.ToArray();
		}

		public override void OnGameTick(float deltaTime)
		{
			if (capi != null && (accum += deltaTime) >= 1f)
			{
				accum = 0f;
				debug = capi.Settings.Bool["debugEntitySelectionBoxes"];
				setupWireframe();
			}
			((EntityBehavior)this).OnGameTick(deltaTime);
		}

		private void setupWireframe()
		{
			if (!rendererRegistered)
			{
				if (capi != null)
				{
					capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)11, "selectionboxesbhdebug");
					BoxWireframe = WireframeCube.CreateUnitCube(capi, -1);
				}
				rendererRegistered = true;
			}
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Expected O, but got Unknown
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Expected O, but got Unknown
			if (capi.HideGuis)
			{
				return;
			}
			int hitIndex = getHitIndex();
			if (hitIndex < 0 && ((IPlayer)capi.World.Player).CurrentEntitySelection?.Entity != base.entity)
			{
				return;
			}
			EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
			if (debug)
			{
				for (int i = 0; i < selectionBoxes.Length; i++)
				{
					if (hitIndex != i)
					{
						Render(entity, i, ColorUtil.WhiteArgbVec);
					}
				}
				if (hitIndex >= 0)
				{
					Render(entity, hitIndex, new Vec4f(1f, 0f, 0f, 1f));
				}
			}
			else if (hitIndex >= 0)
			{
				Render(entity, hitIndex, new Vec4f(0f, 0f, 0f, 0.5f));
			}
		}

		private void Render(EntityPlayer eplr, int i, Vec4f color)
		{
			AttachmentPointAndPose apap = selectionBoxes[i];
			EntityPos pos = base.entity.Pos;
			mvmat.Identity();
			mvmat.Set(capi.Render.CameraMatrixOrigin);
			IMountable val = base.entity.GetInterface<IMountable>();
			IMountableSeat seatOfMountedEntity;
			if (val != null && (seatOfMountedEntity = MountableUtil.GetSeatOfMountedEntity(val, (Entity)(object)eplr)) != null)
			{
				Vec3d val2 = seatOfMountedEntity.SeatPosition.XYZ - seatOfMountedEntity.MountSupplier.Position.XYZ;
				mvmat.Translate(0f - (float)val2.X, 0f - (float)val2.Y, 0f - (float)val2.Z);
			}
			else
			{
				mvmat.Translate(pos.X - eplr.CameraPos.X, pos.InternalY - eplr.CameraPos.Y, pos.Z - eplr.CameraPos.Z);
			}
			applyBoxTransform(mvmat, apap);
			BoxWireframe.Render(capi, mvmat, 1.6f, color);
		}

		private int getHitIndex()
		{
			EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
			Ray pickingray = Ray.FromAngles(((Entity)entity).SidedPos.XYZ + ((Entity)entity).LocalEyePos - base.entity.SidedPos.XYZ, ((Entity)entity).SidedPos.Pitch, ((Entity)entity).SidedPos.Yaw, ((IPlayer)capi.World.Player).WorldData.PickingRange);
			return getHitIndex(pickingray);
		}

		private void applyBoxTransform(Matrixf mvmat, AttachmentPointAndPose apap)
		{
			EntityShapeRenderer entityShapeRenderer = base.entity.Properties.Client.Renderer as EntityShapeRenderer;
			mvmat.RotateY((float)Math.PI / 2f + base.entity.SidedPos.Yaw);
			if (entityShapeRenderer != null)
			{
				mvmat.Translate(0f, base.entity.SelectionBox.Y2 / 2f, 0f);
				mvmat.RotateX(entityShapeRenderer.xangle);
				mvmat.RotateY(entityShapeRenderer.yangle);
				mvmat.RotateZ(entityShapeRenderer.zangle);
				mvmat.Translate(0f, (0f - base.entity.SelectionBox.Y2) / 2f, 0f);
			}
			mvmat.Translate(0f, 0.7f, 0f);
			mvmat.RotateX(entityShapeRenderer?.nowSwivelRad ?? 0f);
			mvmat.Translate(0f, -0.7f, 0f);
			float size = base.entity.Properties.Client.Size;
			mvmat.Scale(size, size, size);
			mvmat.Translate(-0.5f, 0f, -0.5f);
			mvmat.Mul(apap.AnimModelMatrix);
			ShapeElement parentElement = apap.AttachPoint.ParentElement;
			float num = (float)(parentElement.To[0] - parentElement.From[0]) / 16f;
			float num2 = (float)(parentElement.To[1] - parentElement.From[1]) / 16f;
			float num3 = (float)(parentElement.To[2] - parentElement.From[2]) / 16f;
			mvmat.Scale(num, num2, num3);
		}

		public override bool IntersectsRay(Ray ray, AABBIntersectionTest intersectionTester, out double intersectionDistance, ref int selectionBoxIndex, ref EnumHandling handled)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			Ray pickingray = new Ray(ray.origin - base.entity.SidedPos.XYZ, ray.dir);
			int hitIndex = getHitIndex(pickingray);
			if (hitIndex >= 0)
			{
				intersectionDistance = hitPositionAABBSpace.Length();
				intersectionTester.hitPosition = hitPositionAABBSpace.AddCopy(base.entity.SidedPos.XYZ);
				selectionBoxIndex = 1 + hitIndex;
				handled = (EnumHandling)2;
				return true;
			}
			intersectionDistance = double.MaxValue;
			return false;
		}

		private int getHitIndex(Ray pickingray)
		{
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Expected O, but got Unknown
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Expected O, but got Unknown
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Expected O, but got Unknown
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Expected O, but got Unknown
			int num = -1;
			double num2 = double.MaxValue;
			double num3 = pickingray.Length * pickingray.Length;
			for (int i = 0; i < selectionBoxes.Length; i++)
			{
				AttachmentPointAndPose apap = selectionBoxes[i];
				mvmat.Identity();
				applyBoxTransform(mvmat, apap);
				Matrixf obj = mvmat.Clone().Invert();
				Vec4d val = obj.TransformVector(new Vec4d(pickingray.origin.X, pickingray.origin.Y, pickingray.origin.Z, 1.0));
				Vec4d val2 = obj.TransformVector(new Vec4d(pickingray.dir.X, pickingray.dir.Y, pickingray.dir.Z, 0.0));
				Ray r = new Ray(val.XYZ, val2.XYZ);
				if (Testintersection(standardbox, r))
				{
					Vec4d val3 = mvmat.TransformVector(new Vec4d(hitPositionOBBSpace.X, hitPositionOBBSpace.Y, hitPositionOBBSpace.Z, 1.0));
					double num4 = (val3.XYZ - pickingray.origin).LengthSq();
					if ((num < 0 || !(num2 < num4)) && !(num3 < num4))
					{
						hitPositionAABBSpace = val3.XYZ;
						num2 = num4;
						num = i;
					}
				}
			}
			return num;
		}

		public Vec3d GetCenterPosOfBox(int selectionBoxIndex)
		{
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Expected O, but got Unknown
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Expected O, but got Unknown
			if (selectionBoxIndex >= selectionBoxes.Length)
			{
				return null;
			}
			AttachmentPointAndPose val = selectionBoxes[selectionBoxIndex];
			mvmat.Identity();
			applyBoxTransform(mvmat, val);
			ShapeElement parentElement = val.AttachPoint.ParentElement;
			Vec4d val2 = new Vec4d((parentElement.To[0] - parentElement.From[0]) / 2.0 / 16.0, (parentElement.To[1] - parentElement.From[1]) / 2.0 / 16.0, (parentElement.To[2] - parentElement.From[2]) / 2.0 / 16.0, 1.0);
			Vec3d val3 = base.entity.Pos.XYZ;
			EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
			object obj;
			if (entity == null)
			{
				obj = null;
			}
			else
			{
				IMountableSeat mountedOn = ((EntityAgent)entity).MountedOn;
				obj = ((mountedOn != null) ? mountedOn.Entity : null);
			}
			if (obj == base.entity)
			{
				Vec3d val4 = ((EntityAgent)entity).MountedOn.SeatPosition.XYZ - base.entity.Pos.XYZ;
				val3 = new Vec3d(entity.CameraPos.X - val4.X, entity.CameraPos.Y - val4.Y, entity.CameraPos.Z - val4.Z);
			}
			return mvmat.TransformVector(val2).XYZ.Add(val3);
		}

		public bool Testintersection(Cuboidd b, Ray r)
		{
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016f: Expected O, but got Unknown
			double num = b.X2 - b.X1;
			double num2 = b.Y2 - b.Y1;
			double num3 = b.Z2 - b.Z1;
			for (int i = 0; i < 6; i++)
			{
				BlockFacing val = BlockFacing.ALLFACES[i];
				Vec3i normali = val.Normali;
				double num4 = (double)normali.X * r.dir.X + (double)normali.Y * r.dir.Y + (double)normali.Z * r.dir.Z;
				if (!(num4 < -1E-05))
				{
					continue;
				}
				Vec3d val2 = val.PlaneCenter.ToVec3d().Mul(num, num2, num3).Add(b.X1, b.Y1, b.Z1);
				Vec3d val3 = Vec3d.Sub(val2, r.origin);
				double num5 = (val3.X * (double)normali.X + val3.Y * (double)normali.Y + val3.Z * (double)normali.Z) / num4;
				if (num5 >= 0.0)
				{
					hitPositionOBBSpace = new Vec3d(r.origin.X + r.dir.X * num5, r.origin.Y + r.dir.Y * num5, r.origin.Z + r.dir.Z * num5);
					Vec3d val4 = Vec3d.Sub(hitPositionOBBSpace, val2);
					if (Math.Abs(val4.X) <= num / 2.0 && Math.Abs(val4.Y) <= num2 / 2.0 && Math.Abs(val4.Z) <= num3 / 2.0)
					{
						return true;
					}
				}
			}
			return false;
		}

		public bool IsAPCode(EntitySelection es, string apcode)
		{
			EntityBehaviorSelectionBoxes behavior = base.entity.GetBehavior<EntityBehaviorSelectionBoxes>();
			if (behavior != null)
			{
				int num = ((es != null) ? (es.SelectionBoxIndex - 1) : (-1));
				AttachmentPointAndPose[] array = behavior.selectionBoxes;
				if (num > 0 && array.Length >= num)
				{
					return array[num].AttachPoint.Code == apcode;
				}
			}
			return false;
		}

		public override void GetInfoText(StringBuilder infotext)
		{
			int hitIndex = getHitIndex();
			if (hitIndex >= 0)
			{
				if (capi.Settings.Bool["extendedDebugInfo"])
				{
					infotext.AppendLine("<font color=\"#bbbbbb\">looking at AP " + selectionBoxes[hitIndex].AttachPoint.Code + "</font>");
				}
				infotext.AppendLine(Lang.GetMatching("creature-" + ((RegistryObject)base.entity).Code.ToShortString() + "-selectionbox-" + selectionBoxes[hitIndex].AttachPoint.Code, Array.Empty<object>()));
			}
			((EntityBehavior)this).GetInfoText(infotext);
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			((EntityBehavior)this).OnEntityDespawn(despawn);
			ICoreClientAPI obj = capi;
			if (obj != null)
			{
				obj.Event.UnregisterRenderer((IRenderer)(object)this, (EnumRenderStage)11);
			}
			WireframeCube boxWireframe = BoxWireframe;
			if (boxWireframe != null)
			{
				boxWireframe.Dispose();
			}
		}

		public override string PropertyName()
		{
			return "selectionboxes";
		}
	}
	public class EntityBehaviorTiredness : EntityBehavior
	{
		public Random Rand;

		private double hoursTotal;

		private long listenerId;

		public float Tiredness
		{
			get
			{
				return ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("tiredness").GetFloat("tiredness", 0f);
			}
			set
			{
				((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("tiredness").SetFloat("tiredness", value);
				base.entity.WatchedAttributes.MarkPathDirty("tiredness");
			}
		}

		public bool IsSleeping
		{
			get
			{
				ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("tiredness");
				if (treeAttribute != null)
				{
					return treeAttribute.GetInt("isSleeping", 0) > 0;
				}
				return false;
			}
			set
			{
				((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("tiredness").SetInt("isSleeping", value ? 1 : 0);
				base.entity.WatchedAttributes.MarkPathDirty("tiredness");
			}
		}

		public EntityBehaviorTiredness(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject typeAttributes)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0035: Expected O, but got Unknown
			ITreeAttribute treeAttribute = ((TreeAttribute)base.entity.WatchedAttributes).GetTreeAttribute("tiredness");
			if (treeAttribute == null)
			{
				SyncedTreeAttribute watchedAttributes = base.entity.WatchedAttributes;
				TreeAttribute val = new TreeAttribute();
				treeAttribute = (ITreeAttribute)val;
				((TreeAttribute)watchedAttributes).SetAttribute("tiredness", (IAttribute)val);
				Tiredness = typeAttributes["currenttiredness"].AsFloat(0f);
			}
			listenerId = base.entity.World.RegisterGameTickListener((Action<float>)SlowTick, 3000, 0);
			hoursTotal = base.entity.World.Calendar.TotalHours;
		}

		private void SlowTick(float dt)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Invalid comparison between Unknown and I4
			bool flag = IsSleeping;
			if (flag)
			{
				Entity entity = base.entity;
				Entity obj = ((entity is EntityAgent) ? entity : null);
				if (((obj != null) ? ((EntityAgent)obj).MountedOn : null) == null)
				{
					flag = (IsSleeping = false);
				}
			}
			if (!flag && (int)base.entity.World.Side != 2)
			{
				float num = (float)(base.entity.World.Calendar.TotalHours - hoursTotal);
				Tiredness = GameMath.Clamp(Tiredness + num * 0.75f, 0f, base.entity.World.Calendar.HoursPerDay / 2f);
				hoursTotal = base.entity.World.Calendar.TotalHours;
			}
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			((EntityBehavior)this).OnEntityDespawn(despawn);
			base.entity.World.UnregisterGameTickListener(listenerId);
		}

		public override string PropertyName()
		{
			return "tiredness";
		}
	}
	public class EntityBehaviorPlayerInventory : EntityBehaviorTexturedClothing
	{
		private bool slotModifiedRegistered;

		private float accum;

		private IPlayer Player
		{
			get
			{
				Entity entity = ((EntityBehavior)this).entity;
				return ((EntityPlayer)((entity is EntityPlayer) ? entity : null)).Player;
			}
		}

		public override InventoryBase Inventory
		{
			get
			{
				IPlayer player = Player;
				IInventory obj = ((player != null) ? player.InventoryManager.GetOwnInventory("character") : null);
				return (InventoryBase)(object)((obj is InventoryBase) ? obj : null);
			}
		}

		public override string InventoryClassName => "gear";

		public override string PropertyName()
		{
			return "playerinventory";
		}

		public EntityBehaviorPlayerInventory(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			base.Initialize(properties, attributes);
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			base.OnEntityDespawn(despawn);
			IPlayer player = Player;
			IInventory val = ((player != null) ? player.InventoryManager.GetOwnInventory("backpack") : null);
			if (val != null)
			{
				val.SlotModified -= base.Inventory_SlotModifiedBackpack;
			}
		}

		protected override void loadInv()
		{
		}

		public override void storeInv()
		{
		}

		public override void OnGameTick(float deltaTime)
		{
			if (!slotModifiedRegistered)
			{
				slotModifiedRegistered = true;
				IPlayer player = Player;
				IInventory val = ((player != null) ? player.InventoryManager.GetOwnInventory("backpack") : null);
				if (val != null)
				{
					val.SlotModified += base.Inventory_SlotModifiedBackpack;
				}
			}
			base.OnGameTick(deltaTime);
			accum += deltaTime;
			if (!(accum > 1f))
			{
				return;
			}
			((TreeAttribute)((EntityBehavior)this).entity.Attributes).SetBool("hasProtectiveEyeGear", Inventory != null && ((IEnumerable<ItemSlot>)Inventory).FirstOrDefault((Func<ItemSlot, bool>)delegate(ItemSlot slot)
			{
				if (!slot.Empty)
				{
					JsonObject attributes = slot.Itemstack.Collectible.Attributes;
					if (attributes == null)
					{
						return false;
					}
					return attributes.IsTrue("eyeprotective");
				}
				return false;
			}) != null);
		}

		public override void OnTesselation(ref Shape entityShape, string shapePathForLogging, ref bool shapeIsCloned, ref string[] willDeleteElements)
		{
			IPlayer player = Player;
			IInventory val = ((player != null) ? player.InventoryManager.GetOwnInventory("backpack") : null);
			Dictionary<string, ItemSlot> dictionary = new Dictionary<string, ItemSlot>();
			int num = 0;
			while (val != null && num < 4)
			{
				ItemSlot val2 = val[num];
				if (!val2.Empty)
				{
					JsonObject itemAttributes = val2.Itemstack.ItemAttributes;
					object obj;
					if (itemAttributes == null)
					{
						obj = null;
					}
					else
					{
						JsonObject obj2 = itemAttributes["attachableToEntity"];
						if (obj2 == null)
						{
							obj = null;
						}
						else
						{
							JsonObject obj3 = obj2["categoryCode"];
							obj = ((obj3 != null) ? obj3.AsString((string)null) : null);
						}
					}
					if (obj == null)
					{
						obj = ((object)Unsafe.As<EnumItemClass, EnumItemClass>(ref val2.Itemstack.Class)/*cast due to .constrained prefix*/).ToString() + val2.Itemstack.Collectible.Id;
					}
					dictionary[(string)obj] = val2;
				}
				num++;
			}
			foreach (KeyValuePair<string, ItemSlot> item in dictionary)
			{
				entityShape = addGearToShape(entityShape, item.Value, "default", shapePathForLogging, ref shapeIsCloned, ref willDeleteElements);
			}
			base.OnTesselation(ref entityShape, shapePathForLogging, ref shapeIsCloned, ref willDeleteElements);
		}

		public override void OnEntityDeath(DamageSource damageSourceForDeath)
		{
			Api.Event.EnqueueMainThreadTask((Action)delegate
			{
				EntityServerProperties server = ((EntityBehavior)this).entity.Properties.Server;
				if (server != null)
				{
					ITreeAttribute attributes = ((EntitySidedProperties)server).Attributes;
					if (((attributes != null) ? new bool?(attributes.GetBool("keepContents", false)) : ((bool?)null)) == true)
					{
						goto IL_0058;
					}
				}
				Player.InventoryManager.OnDeath();
				goto IL_0058;
				IL_0058:
				EntityServerProperties server2 = ((EntityBehavior)this).entity.Properties.Server;
				if (server2 != null)
				{
					ITreeAttribute attributes2 = ((EntitySidedProperties)server2).Attributes;
					if (((attributes2 != null) ? new bool?(attributes2.GetBool("dropArmorOnDeath", false)) : ((bool?)null)) == true)
					{
						foreach (ItemSlot item in Inventory)
						{
							if (!item.Empty)
							{
								JsonObject itemAttributes = item.Itemstack.ItemAttributes;
								if (itemAttributes != null && itemAttributes["protectionModifiers"].Exists)
								{
									Api.World.SpawnItemEntity(item.Itemstack, ((EntityBehavior)this).entity.ServerPos.XYZ, (Vec3d)null);
									item.Itemstack = null;
									item.MarkDirty();
								}
							}
						}
					}
				}
			}, "dropinventoryondeath");
		}
	}
	public class EntityBehaviorSemiTamed : EntityBehavior
	{
		public EntityBehaviorSemiTamed(Entity entity)
			: base(entity)
		{
		}

		public override void AfterInitialized(bool onFirstSpawn)
		{
			((EntityBehavior)this).AfterInitialized(onFirstSpawn);
			base.entity.GetBehavior<EntityBehaviorTaskAI>().TaskManager.OnShouldExecuteTask += TaskManager_OnShouldExecuteTask;
		}

		private bool TaskManager_OnShouldExecuteTask(IAiTask t)
		{
			if (t is AiTaskFleeEntity aiTaskFleeEntity)
			{
				if (aiTaskFleeEntity.WhenInEmotionState == null)
				{
					return !(aiTaskFleeEntity.targetEntity is EntityPlayer);
				}
				return false;
			}
			return true;
		}

		public override string PropertyName()
		{
			return "semitamed";
		}
	}
	public abstract class EntityBehaviorTexturedClothing : EntityBehaviorContainer
	{
		protected int skinTextureSubId;

		private ICoreClientAPI capi;

		private bool textureSpaceAllocated;

		public bool doReloadShapeAndSkin = true;

		protected TextureAtlasPosition skinTexPos
		{
			get
			{
				return (((EntityBehavior)this).entity.Properties.Client.Renderer as EntityShapeRenderer).skinTexPos;
			}
			set
			{
				(((EntityBehavior)this).entity.Properties.Client.Renderer as EntityShapeRenderer).skinTexPos = value;
			}
		}

		public Size2i AtlasSize => capi.EntityTextureAtlas.Size;

		public event Action<LoadedTexture, TextureAtlasPosition, int> OnReloadSkin;

		public EntityBehaviorTexturedClothing(Entity entity)
			: base(entity)
		{
		}

		public override void Initialize(EntityProperties properties, JsonObject attributes)
		{
			base.Initialize(properties, attributes);
			ref ICoreClientAPI reference = ref capi;
			ICoreAPI api = Api;
			reference = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
		}

		public override void OnTesselation(ref Shape entityShape, string shapePathForLogging, ref bool shapeIsCloned, ref string[] willDeleteElements)
		{
			base.OnTesselation(ref entityShape, shapePathForLogging, ref shapeIsCloned, ref willDeleteElements);
			reloadSkin();
		}

		public override ITexPositionSource GetTextureSource(ref EnumHandling handling)
		{
			if (Environment.CurrentManagedThreadId != RuntimeEnv.MainThreadId)
			{
				throw new InvalidOperationException("Potentially attempting to insert a texture into the atlas outside of the main thread (if this allocation causes a new atlas to be created).");
			}
			handling = (EnumHandling)0;
			if (!textureSpaceAllocated)
			{
				TextureAtlasPosition val = capi.EntityTextureAtlas.Positions[((EntityBehavior)this).entity.Properties.Client.FirstTexture.Baked.TextureSubId];
				JsonObject attributes = ((EntityBehavior)this).entity.Properties.Attributes;
				string text = ((attributes != null) ? attributes["skinBaseTextureKey"].AsString((string)null) : null);
				if (text != null)
				{
					val = capi.EntityTextureAtlas.Positions[((EntityBehavior)this).entity.Properties.Client.Textures[text].Baked.TextureSubId];
				}
				int num = (int)((val.x2 - val.x1) * (float)AtlasSize.Width);
				int num2 = (int)((val.y2 - val.y1) * (float)AtlasSize.Height);
				TextureAtlasPosition val2 = default(TextureAtlasPosition);
				capi.EntityTextureAtlas.AllocateTextureSpace(num, num2, ref skinTextureSubId, ref val2, (AssetLocationAndSource)null);
				skinTexPos = val2;
				textureSpaceAllocated = true;
			}
			return null;
		}

		public void reloadSkin()
		{
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Expected O, but got Unknown
			//IL_028b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0290: Unknown result type (might be due to invalid IL or missing references)
			//IL_029d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d5: Expected O, but got Unknown
			if (capi == null || !doReloadShapeAndSkin || skinTexPos == null)
			{
				return;
			}
			TextureAtlasPosition val = capi.EntityTextureAtlas.Positions[((EntityBehavior)this).entity.Properties.Client.FirstTexture.Baked.TextureSubId];
			JsonObject attributes = ((EntityBehavior)this).entity.Properties.Attributes;
			string text = ((attributes != null) ? attributes["skinBaseTextureKey"].AsString((string)null) : null);
			if (text != null)
			{
				val = capi.EntityTextureAtlas.Positions[((EntityBehavior)this).entity.Properties.Client.Textures[text].Baked.TextureSubId];
			}
			LoadedTexture val2 = new LoadedTexture((ICoreClientAPI)null)
			{
				TextureId = val.atlasTextureId,
				Width = capi.EntityTextureAtlas.Size.Width,
				Height = capi.EntityTextureAtlas.Size.Height
			};
			capi.Render.GlToggleBlend(false, (EnumBlendMode)0);
			capi.EntityTextureAtlas.RenderTextureIntoAtlas(skinTexPos.atlasTextureId, val2, (float)(int)(val.x1 * (float)AtlasSize.Width), (float)(int)(val.y1 * (float)AtlasSize.Height), (float)(int)((val.x2 - val.x1) * (float)AtlasSize.Width), (float)(int)((val.y2 - val.y1) * (float)AtlasSize.Height), skinTexPos.x1 * (float)capi.EntityTextureAtlas.Size.Width, skinTexPos.y1 * (float)capi.EntityTextureAtlas.Size.Height, -1f);
			capi.Render.GlToggleBlend(true, (EnumBlendMode)5);
			this.OnReloadSkin?.Invoke(val2, skinTexPos, skinTextureSubId);
			int[] array = new int[12]
			{
				3, 4, 2, 11, 9, 1, 7, 6, 0, 5,
				10, 8
			};
			foreach (int num in array)
			{
				ItemSlot obj = Inventory[num];
				ItemStack val3 = ((obj != null) ? obj.Itemstack : null);
				if (val3 != null && !hideClothing && val3.Item.FirstTexture != null)
				{
					int textureSubId = val3.Item.FirstTexture.Baked.TextureSubId;
					TextureAtlasPosition val4 = ((ITextureAtlasAPI)capi.ItemTextureAtlas).Positions[textureSubId];
					LoadedTexture val5 = new LoadedTexture((ICoreClientAPI)null)
					{
						TextureId = val4.atlasTextureId,
						Width = ((ITextureAtlasAPI)capi.ItemTextureAtlas).Size.Width,
						Height = ((ITextureAtlasAPI)capi.ItemTextureAtlas).Size.Height
					};
					capi.EntityTextureAtlas.RenderTextureIntoAtlas(skinTexPos.atlasTextureId, val5, val4.x1 * (float)((ITextureAtlasAPI)capi.ItemTextureAtlas).Size.Width, val4.y1 * (float)((ITextureAtlasAPI)capi.ItemTextureAtlas).Size.Height, (val4.x2 - val4.x1) * (float)((ITextureAtlasAPI)capi.ItemTextureAtlas).Size.Width, (val4.y2 - val4.y1) * (float)((ITextureAtlasAPI)capi.ItemTextureAtlas).Size.Height, skinTexPos.x1 * (float)capi.EntityTextureAtlas.Size.Width, skinTexPos.y1 * (float)capi.EntityTextureAtlas.Size.Height, 0.005f);
				}
			}
			capi.Render.GlToggleBlend(true, (EnumBlendMode)0);
			capi.Render.BindTexture2d(skinTexPos.atlasTextureId);
			capi.Render.GlGenerateTex2DMipmaps();
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			base.OnEntityDespawn(despawn);
			ICoreClientAPI obj = capi;
			if (obj != null)
			{
				obj.EntityTextureAtlas.FreeTextureSpace(skinTextureSubId);
			}
		}

		public override string PropertyName()
		{
			return "clothing";
		}
	}
	public class FallingBlockParticlesModSystem : ModSystem
	{
		private static SimpleParticleProperties dustParticles;

		private static SimpleParticleProperties bitsParticles;

		private ICoreClientAPI capi;

		private HashSet<EntityBlockFalling> fallingBlocks = new HashSet<EntityBlockFalling>();

		private ConcurrentQueue<EntityBlockFalling> toRegister = new ConcurrentQueue<EntityBlockFalling>();

		private ConcurrentQueue<EntityBlockFalling> toRemove = new ConcurrentQueue<EntityBlockFalling>();

		public int ActiveFallingBlocks => fallingBlocks.Count;

		static FallingBlockParticlesModSystem()
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Expected O, but got Unknown
			//IL_006c: Expected O, but got Unknown
			//IL_006c: Expected O, but got Unknown
			//IL_006c: Expected O, but got Unknown
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Expected O, but got Unknown
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cd: Expected O, but got Unknown
			//IL_01cd: Expected O, but got Unknown
			//IL_01cd: Expected O, but got Unknown
			//IL_01cd: Expected O, but got Unknown
			//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Expected O, but got Unknown
			dustParticles = new SimpleParticleProperties(1f, 3f, ColorUtil.ToRgba(40, 220, 220, 220), new Vec3d(), new Vec3d(), new Vec3f(-0.25f, -0.25f, -0.25f), new Vec3f(0.25f, 0.25f, 0.25f), 1f, 1f, 0.3f, 0.3f, (EnumParticleModel)0);
			dustParticles.AddQuantity = 5f;
			dustParticles.MinVelocity.Set(-0.05f, -0.4f, -0.05f);
			dustParticles.AddVelocity.Set(0.1f, 0.2f, 0.1f);
			dustParticles.WithTerrainCollision = true;
			dustParticles.ParticleModel = (EnumParticleModel)0;
			dustParticles.OpacityEvolve = EvolvingNatFloat.create((EnumTransformFunction)5, -16f);
			dustParticles.SizeEvolve = EvolvingNatFloat.create((EnumTransformFunction)5, 3f);
			dustParticles.GravityEffect = 0f;
			dustParticles.MaxSize = 1.3f;
			dustParticles.LifeLength = 3f;
			dustParticles.SelfPropelled = true;
			dustParticles.AddPos.Set(1.4, 1.4, 1.4);
			bitsParticles = new SimpleParticleProperties(1f, 3f, ColorUtil.ToRgba(40, 220, 220, 220), new Vec3d(), new Vec3d(), new Vec3f(-0.25f, -0.25f, -0.25f), new Vec3f(0.25f, 0.25f, 0.25f), 1f, 1f, 0.1f, 0.3f, (EnumParticleModel)0);
			bitsParticles.AddPos.Set(1.4, 1.4, 1.4);
			bitsParticles.AddQuantity = 20f;
			bitsParticles.MinVelocity.Set(-0.25f, 0f, -0.25f);
			bitsParticles.AddVelocity.Set(0.5f, 1f, 0.5f);
			bitsParticles.WithTerrainCollision = true;
			bitsParticles.ParticleModel = (EnumParticleModel)1;
			bitsParticles.LifeLength = 1.5f;
			bitsParticles.SizeEvolve = EvolvingNatFloat.create((EnumTransformFunction)5, -0.5f);
			bitsParticles.GravityEffect = 2.5f;
			bitsParticles.MinSize = 0.5f;
			bitsParticles.MaxSize = 1.5f;
		}

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Expected O, but got Unknown
			capi = api;
			api.Event.RegisterAsyncParticleSpawner(new ContinousParticleSpawnTaskDelegate(asyncParticleSpawn));
		}

		public void Register(EntityBlockFalling entity)
		{
			toRegister.Enqueue(entity);
		}

		public void Unregister(EntityBlockFalling entity)
		{
			toRemove.Enqueue(entity);
		}

		private bool asyncParticleSpawn(float dt, IAsyncParticleManager manager)
		{
			int num = manager.ParticlesAlive((EnumParticleModel)0);
			float num2 = Math.Max(0.05f, (float)Math.Pow(0.949999988079071, (float)num / 200f));
			foreach (EntityBlockFalling fallingBlock in fallingBlocks)
			{
				float num3 = 0f;
				if (fallingBlock.nowImpacted)
				{
					if (((CollectibleObject)((IWorldAccessor)capi.World).BlockAccessor.GetBlock(((Entity)fallingBlock).Pos.AsBlockPos, 2)).Id == 0)
					{
						num3 = 20f;
					}
					fallingBlock.nowImpacted = false;
				}
				if (((CollectibleObject)fallingBlock.Block).Id != 0)
				{
					dustParticles.Color = fallingBlock.stackForParticleColor.Collectible.GetRandomColor(capi, fallingBlock.stackForParticleColor);
					SimpleParticleProperties obj = dustParticles;
					obj.Color &= 0xFFFFFF;
					SimpleParticleProperties obj2 = dustParticles;
					obj2.Color |= -1778384896;
					dustParticles.MinPos.Set(((Entity)fallingBlock).Pos.X - 0.2 - 0.5, ((Entity)fallingBlock).Pos.Y, ((Entity)fallingBlock).Pos.Z - 0.2 - 0.5);
					dustParticles.MinSize = 1f;
					float num4 = num3 / 20f;
					dustParticles.AddPos.Y = fallingBlock.maxSpawnHeightForParticles;
					dustParticles.MinVelocity.Set(-0.2f * num4, 1f * (float)((Entity)fallingBlock).Pos.Motion.Y, -0.2f * num4);
					dustParticles.AddVelocity.Set(0.4f * num4, 0.2f * (float)((Entity)fallingBlock).Pos.Motion.Y + (0f - num4), 0.4f * num4);
					dustParticles.MinQuantity = num3 * fallingBlock.dustIntensity * num2 / 2f;
					dustParticles.AddQuantity = (6f * Math.Abs((float)((Entity)fallingBlock).Pos.Motion.Y) + num3) * fallingBlock.dustIntensity * num2 / 2f;
					manager.Spawn((IParticlePropertiesProvider)(object)dustParticles);
				}
				bitsParticles.MinPos.Set(((Entity)fallingBlock).Pos.X - 0.2 - 0.5, ((Entity)fallingBlock).Pos.Y - 0.5, ((Entity)fallingBlock).Pos.Z - 0.2 - 0.5);
				bitsParticles.MinVelocity.Set(-2f, 30f * (float)((Entity)fallingBlock).Pos.Motion.Y, -2f);
				bitsParticles.AddVelocity.Set(4f, 0.2f * (float)((Entity)fallingBlock).Pos.Motion.Y, 4f);
				bitsParticles.MinQuantity = num2;
				bitsParticles.AddQuantity = 6f * Math.Abs((float)((Entity)fallingBlock).Pos.Motion.Y) * num2;
				bitsParticles.Color = dustParticles.Color;
				bitsParticles.AddPos.Y = fallingBlock.maxSpawnHeightForParticles;
				dustParticles.Color = ((CollectibleObject)fallingBlock.Block).GetRandomColor(capi, fallingBlock.stackForParticleColor);
				((IWorldAccessor)capi.World).SpawnParticles((IParticlePropertiesProvider)(object)bitsParticles, (IPlayer)null);
			}
			int count = toRegister.Count;
			while (count-- > 0)
			{
				if (toRegister.TryDequeue(out var result))
				{
					fallingBlocks.Add(result);
				}
			}
			count = toRemove.Count;
			while (count-- > 0)
			{
				if (toRemove.TryDequeue(out var result2))
				{
					fallingBlocks.Remove(result2);
				}
			}
			return true;
		}
	}
	public class EntityBlockFalling : Entity
	{
		private const int packetIdMagicNumber = 1234;

		private static HashSet<long> fallingNow = new HashSet<long>();

		private readonly List<int> fallDirections = new List<int> { 0, 1, 2, 3 };

		private int lastFallDirection;

		private int hopUpHeight = 1;

		private FallingBlockParticlesModSystem particleSys;

		private int ticksAlive;

		private int lingerTicks;

		private AssetLocation blockCode;

		private ItemStack[] drops;

		private float impactDamageMul;

		private bool fallHandled;

		private byte[] lightHsv;

		private AssetLocation fallSound;

		private ILoadedSound sound;

		private float soundStartDelay;

		private bool canFallSideways;

		private Vec3d fallMotion = new Vec3d();

		private float pushaccum;

		internal float dustIntensity;

		internal ItemStack stackForParticleColor;

		internal bool nowImpacted;

		public bool InitialBlockRemoved;

		public BlockPos initialPos;

		public TreeAttribute blockEntityAttributes;

		public string blockEntityClass;

		public BlockEntity removedBlockentity;

		public bool DoRemoveBlock = true;

		public float maxSpawnHeightForParticles = 1.4f;

		public override float MaterialDensity => 99999f;

		public override byte[] LightHsv => lightHsv;

		public Block Block => base.World.BlockAccessor.GetBlock(blockCode);

		public override bool IsInteractable => false;

		public EntityBlockFalling()
		{
		}//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown


		public EntityBlockFalling(Block block, BlockEntity blockEntity, BlockPos initialPos, AssetLocation fallSound, float impactDamageMul, bool canFallSideways, float dustIntensity)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Expected O, but got Unknown
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Expected O, but got Unknown
			this.impactDamageMul = impactDamageMul;
			this.fallSound = fallSound;
			this.canFallSideways = canFallSideways;
			this.dustIntensity = dustIntensity;
			((TreeAttribute)base.WatchedAttributes).SetBool("canFallSideways", canFallSideways);
			((TreeAttribute)base.WatchedAttributes).SetFloat("dustIntensity", dustIntensity);
			if (fallSound != (AssetLocation)null)
			{
				((TreeAttribute)base.WatchedAttributes).SetString("fallSound", fallSound.ToShortString());
			}
			((RegistryObject)this).Code = new AssetLocation("blockfalling");
			blockCode = ((RegistryObject)block).Code;
			removedBlockentity = blockEntity;
			this.initialPos = initialPos.Copy();
			base.ServerPos.SetPos(initialPos);
			EntityPos serverPos = base.ServerPos;
			serverPos.X += 0.5;
			EntityPos serverPos2 = base.ServerPos;
			serverPos2.Y -= 0.01;
			EntityPos serverPos3 = base.ServerPos;
			serverPos3.Z += 0.5;
			base.Pos.SetFrom(base.ServerPos);
		}

		public override void Initialize(EntityProperties properties, ICoreAPI api, long InChunkIndex3d)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Expected O, but got Unknown
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Expected O, but got Unknown
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Invalid comparison between Unknown and I4
			//IL_028c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0292: Invalid comparison between Unknown and I4
			//IL_027c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0286: Expected O, but got Unknown
			//IL_015a: Unknown result type (might be due to invalid IL or missing references)
			//IL_015f: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Expected O, but got Unknown
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Expected O, but got Unknown
			if (removedBlockentity != null)
			{
				blockEntityAttributes = new TreeAttribute();
				removedBlockentity.ToTreeAttributes((ITreeAttribute)(object)blockEntityAttributes);
				blockEntityClass = api.World.ClassRegistry.GetBlockEntityClass(((object)removedBlockentity).GetType());
			}
			base.SimulationRange = (int)(0.75f * (float)GlobalConstants.DefaultSimulationRange);
			((Entity)this).Initialize(properties, api, InChunkIndex3d);
			try
			{
				drops = Block.GetDrops(api.World, initialPos, (IPlayer)null, 1f);
			}
			catch (Exception)
			{
				drops = null;
				api.Logger.Warning("Falling block entity could not properly initialise its drops during chunk loading, as original block is no longer at " + (object)initialPos);
			}
			lightHsv = ((CollectibleObject)Block).GetLightHsv(base.World.BlockAccessor, initialPos, (ItemStack)null);
			if (drops != null && drops.Length != 0)
			{
				stackForParticleColor = drops[0];
			}
			else
			{
				stackForParticleColor = new ItemStack(Block, 1);
			}
			if ((int)api.Side == 2 && fallSound != (AssetLocation)null && fallingNow.Count < 100)
			{
				fallingNow.Add(base.EntityId);
				ICoreClientAPI val = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
				sound = val.World.LoadSound(new SoundParams
				{
					Location = fallSound.WithPathPrefixOnce("sounds/").WithPathAppendixOnce(".ogg"),
					Position = new Vec3f((float)base.Pos.X, (float)base.Pos.Y, (float)base.Pos.Z),
					Range = 32f,
					Pitch = 0.8f + (float)((IWorldAccessor)val.World).Rand.NextDouble() * 0.3f,
					Volume = 1f,
					SoundType = (EnumSoundType)2
				});
				sound.Start();
				soundStartDelay = 0.05f + (float)((IWorldAccessor)val.World).Rand.NextDouble() / 3f;
			}
			canFallSideways = ((TreeAttribute)base.WatchedAttributes).GetBool("canFallSideways", false);
			dustIntensity = ((TreeAttribute)base.WatchedAttributes).GetFloat("dustIntensity", 0f);
			if (((TreeAttribute)base.WatchedAttributes).HasAttribute("fallSound"))
			{
				fallSound = new AssetLocation(((TreeAttribute)base.WatchedAttributes).GetString("fallSound", (string)null));
			}
			if ((int)api.World.Side == 2)
			{
				particleSys = api.ModLoader.GetModSystem<FallingBlockParticlesModSystem>(true);
				particleSys.Register(this);
			}
			RandomizeFallingDirectionsOrder();
			if (DoRemoveBlock)
			{
				base.World.BlockAccessor.SetBlock(0, initialPos);
			}
		}

		public override void OnGameTick(float dt)
		{
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Invalid comparison between Unknown and I4
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Invalid comparison between Unknown and I4
			//IL_03be: Unknown result type (might be due to invalid IL or missing references)
			//IL_03c4: Invalid comparison between Unknown and I4
			//IL_0206: Unknown result type (might be due to invalid IL or missing references)
			//IL_020c: Invalid comparison between Unknown and I4
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_026a: Unknown result type (might be due to invalid IL or missing references)
			//IL_026c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0274: Unknown result type (might be due to invalid IL or missing references)
			//IL_0279: Unknown result type (might be due to invalid IL or missing references)
			//IL_0285: Unknown result type (might be due to invalid IL or missing references)
			//IL_02be: Expected O, but got Unknown
			base.World.FrameProfiler.Enter("entity-tick-unsstablefalling");
			if (soundStartDelay > 0f)
			{
				soundStartDelay -= dt;
				if (soundStartDelay <= 0f)
				{
					sound.Start();
				}
			}
			if (sound != null)
			{
				sound.SetPosition((float)base.Pos.X, (float)base.Pos.Y, (float)base.Pos.Z);
			}
			if (lingerTicks > 0)
			{
				lingerTicks--;
				if (lingerTicks != 0)
				{
					return;
				}
				if ((int)base.Api.Side == 2 && sound != null)
				{
					sound.FadeOut(3f, (Action<ILoadedSound>)delegate(ILoadedSound s)
					{
						((IDisposable)s).Dispose();
					});
				}
				((Entity)this).Die((EnumDespawnReason)0, (DamageSource)null);
				return;
			}
			base.World.FrameProfiler.Mark("entity-tick-unsstablefalling-sound(etc)");
			ticksAlive++;
			if (ticksAlive >= 2 || (int)base.Api.World.Side == 2)
			{
				if (!InitialBlockRemoved)
				{
					InitialBlockRemoved = true;
					UpdateBlock(remove: true, initialPos);
				}
				foreach (EntityBehavior behavior in ((Entity)this).SidedProperties.Behaviors)
				{
					behavior.OnGameTick(dt);
				}
				base.World.FrameProfiler.Mark("entity-tick-unsstablefalling-physics(etc)");
			}
			pushaccum += dt;
			Vec3d obj = fallMotion;
			obj.X *= 0.9900000095367432;
			Vec3d obj2 = fallMotion;
			obj2.Z *= 0.9900000095367432;
			if (pushaccum > 0.2f)
			{
				pushaccum = 0f;
				if (!((Entity)this).Collided)
				{
					Entity[] entitiesAround;
					if ((int)base.Api.Side == 1)
					{
						entitiesAround = base.World.GetEntitiesAround(((Entity)this).SidedPos.XYZ, 1.1f, 1.1f, (ActionConsumable<Entity>)((Entity e) => !(e is EntityBlockFalling)));
						bool flag = false;
						Entity[] array = entitiesAround;
						foreach (Entity val in array)
						{
							bool flag2 = val.ReceiveDamage(new DamageSource
							{
								Source = (EnumDamageSource)0,
								Type = (EnumDamageType)9,
								SourceBlock = Block,
								SourcePos = ((Entity)this).SidedPos.XYZ
							}, 10f * (float)Math.Abs(base.ServerPos.Motion.Y) * impactDamageMul);
							if (flag2 && !flag)
							{
								flag = flag2;
								base.Api.World.PlaySoundAt(Block.Sounds.Break, val, (IPlayer)null, true, 32f, 1f);
							}
						}
					}
					else
					{
						entitiesAround = base.World.GetEntitiesAround(((Entity)this).SidedPos.XYZ, 1.1f, 1.1f, (ActionConsumable<Entity>)((Entity e) => e is EntityPlayer));
					}
					for (int num2 = 0; num2 < entitiesAround.Length; num2++)
					{
						entitiesAround[num2].SidedPos.Motion.Add(fallMotion.X / 10.0, 0.0, fallMotion.Z / 10.0);
					}
				}
			}
			base.World.FrameProfiler.Mark("entity-tick-unsstablefalling-finalizemotion");
			if ((int)base.Api.Side == 1 && !((Entity)this).Collided && base.World.Rand.NextDouble() < 0.01)
			{
				base.World.BlockAccessor.TriggerNeighbourBlockUpdate(base.ServerPos.AsBlockPos);
				base.World.FrameProfiler.Mark("entity-tick-unsstablefalling-neighborstrigger");
			}
			if (base.CollidedVertically && base.Pos.Motion.Length() < 0.0010000000474974513)
			{
				((Entity)this).OnFallToGround(0.0);
				base.World.FrameProfiler.Mark("entity-tick-unsstablefalling-falltoground");
			}
			base.World.FrameProfiler.Leave();
		}

		public override void OnEntityDespawn(EntityDespawnData despawn)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Invalid comparison between Unknown and I4
			((Entity)this).OnEntityDespawn(despawn);
			if ((int)base.Api.World.Side == 2)
			{
				fallingNow.Remove(base.EntityId);
				particleSys.Unregister(this);
			}
		}

		private void UpdateBlock(bool remove, BlockPos pos)
		{
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Invalid comparison between Unknown and I4
			if (remove)
			{
				if (DoRemoveBlock)
				{
					base.World.BlockAccessor.MarkBlockDirty(pos, (Action)delegate
					{
						OnChunkRetesselated(on: true);
					});
				}
				else
				{
					OnChunkRetesselated(on: true);
				}
			}
			else
			{
				if (((CollectibleObject)base.World.BlockAccessor.GetBlock(pos, 2)).Id == 0 || (int)Block.BlockMaterial != 9)
				{
					base.World.BlockAccessor.SetBlock(Block.BlockId, pos);
					base.World.BlockAccessor.MarkBlockDirty(pos, (Action)delegate
					{
						OnChunkRetesselated(on: false);
					});
				}
				else
				{
					OnChunkRetesselated(on: true);
				}
				if (blockEntityAttributes != null)
				{
					BlockEntity blockEntity = base.World.BlockAccessor.GetBlockEntity(pos);
					blockEntityAttributes.SetInt("posx", pos.X);
					blockEntityAttributes.SetInt("posy", pos.Y);
					blockEntityAttributes.SetInt("posz", pos.Z);
					if (blockEntity != null)
					{
						blockEntity.FromTreeAttributes((ITreeAttribute)(object)blockEntityAttributes, base.World);
					}
				}
			}
			base.World.BlockAccessor.TriggerNeighbourBlockUpdate(pos);
		}

		private void OnChunkRetesselated(bool on)
		{
			if (((Entity)this).Properties.Client.Renderer is EntityBlockFallingRenderer entityBlockFallingRenderer)
			{
				entityBlockFallingRenderer.DoRender = on;
			}
		}

		private void RandomizeFallingDirectionsOrder()
		{
			for (int num = fallDirections.Count - 1; num > 0; num--)
			{
				int index = GameMath.MurmurHash3Mod(base.EntityId.GetHashCode(), num, num, fallDirections.Count);
				int value = fallDirections[num];
				fallDirections[num] = fallDirections[index];
				fallDirections[index] = value;
			}
			lastFallDirection = fallDirections[3];
		}

		public override void OnFallToGround(double motionY)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Invalid comparison between Unknown and I4
			//IL_02df: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e5: Invalid comparison between Unknown and I4
			//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0304: Invalid comparison between Unknown and I4
			//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0400: Unknown result type (might be due to invalid IL or missing references)
			//IL_0402: Unknown result type (might be due to invalid IL or missing references)
			//IL_0407: Unknown result type (might be due to invalid IL or missing references)
			//IL_040a: Unknown result type (might be due to invalid IL or missing references)
			//IL_040f: Unknown result type (might be due to invalid IL or missing references)
			//IL_041b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0445: Expected O, but got Unknown
			//IL_0216: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Invalid comparison between Unknown and I4
			if (fallHandled)
			{
				return;
			}
			BlockPos asBlockPos = ((Entity)this).SidedPos.AsBlockPos;
			BlockPos finalPos = base.ServerPos.AsBlockPos;
			Block block = null;
			if ((int)base.Api.Side == 1)
			{
				block = base.World.BlockAccessor.GetMostSolidBlock(finalPos);
				if (block.CanAcceptFallOnto(base.World, finalPos, Block, blockEntityAttributes))
				{
					base.Api.Event.EnqueueMainThreadTask((Action)delegate
					{
						block.OnFallOnto(base.World, finalPos, Block, blockEntityAttributes);
					}, "BlockFalling-OnFallOnto");
					lingerTicks = 3;
					fallHandled = true;
					return;
				}
			}
			if (canFallSideways)
			{
				foreach (int fallDirection in fallDirections)
				{
					BlockFacing val = BlockFacing.ALLFACES[fallDirection];
					if ((val != BlockFacing.NORTH || lastFallDirection != BlockFacing.SOUTH.Index) && (val != BlockFacing.WEST || lastFallDirection != BlockFacing.EAST.Index) && (val != BlockFacing.SOUTH || lastFallDirection != BlockFacing.NORTH.Index) && (val != BlockFacing.EAST || lastFallDirection != BlockFacing.WEST.Index) && base.World.BlockAccessor.GetMostSolidBlock(asBlockPos.X + val.Normali.X, asBlockPos.InternalY + val.Normali.Y, asBlockPos.Z + val.Normali.Z).Replaceable >= 6000 && base.World.BlockAccessor.GetMostSolidBlock(asBlockPos.X + val.Normali.X, asBlockPos.InternalY + val.Normali.Y - 1, asBlockPos.Z + val.Normali.Z).Replaceable >= 6000)
					{
						if ((int)base.Api.Side == 1)
						{
							EntityPos sidedPos = ((Entity)this).SidedPos;
							sidedPos.X += (double)val.Normali.X;
							EntityPos sidedPos2 = ((Entity)this).SidedPos;
							sidedPos2.Y += (double)val.Normali.Y;
							EntityPos sidedPos3 = ((Entity)this).SidedPos;
							sidedPos3.Z += (double)val.Normali.Z;
						}
						fallMotion.Set((double)val.Normalf.X, 0.0, (double)val.Normalf.Z);
						lastFallDirection = fallDirection;
						return;
					}
				}
			}
			nowImpacted = true;
			if ((int)base.Api.Side == 1)
			{
				if ((((CollectibleObject)block).Id != 0 && (int)Block.BlockMaterial == 9) || block.IsReplacableBy(Block))
				{
					base.Api.Event.EnqueueMainThreadTask((Action)delegate
					{
						//IL_0018: Unknown result type (might be due to invalid IL or missing references)
						//IL_001f: Invalid comparison between Unknown and I4
						if (((CollectibleObject)block).Id != 0 && (int)Block.BlockMaterial == 9)
						{
							UpdateSnowLayer(finalPos, block);
							ICoreAPI api = base.Api;
							((ICoreServerAPI)((api is ICoreServerAPI) ? api : null)).Network.BroadcastEntityPacket(base.EntityId, 1234, (byte[])null);
						}
						else if (block.IsReplacableBy(Block))
						{
							if (!InitialBlockRemoved)
							{
								InitialBlockRemoved = true;
								UpdateBlock(remove: true, initialPos);
							}
							UpdateBlock(remove: false, finalPos);
							ICoreAPI api2 = base.Api;
							((ICoreServerAPI)((api2 is ICoreServerAPI) ? api2 : null)).Network.BroadcastEntityPacket(base.EntityId, 1234, (byte[])null);
						}
					}, "BlockFalling-consequences");
				}
				else
				{
					if (block.Replaceable < 6000)
					{
						EntityPos sidedPos4 = ((Entity)this).SidedPos;
						sidedPos4.Y += (double)hopUpHeight;
						hopUpHeight++;
						if (hopUpHeight > 3)
						{
							hopUpHeight = 1;
						}
						return;
					}
					DropItems(finalPos);
				}
				if (impactDamageMul > 0f)
				{
					Entity[] entitiesInsideCuboid = base.World.GetEntitiesInsideCuboid(finalPos, finalPos.AddCopy(1, 1, 1), (ActionConsumable<Entity>)((Entity e) => !(e is EntityBlockFalling)));
					bool flag = false;
					Entity[] array = entitiesInsideCuboid;
					foreach (Entity val2 in array)
					{
						bool flag2 = val2.ReceiveDamage(new DamageSource
						{
							Source = (EnumDamageSource)0,
							Type = (EnumDamageType)9,
							SourceBlock = Block,
							SourcePos = finalPos.ToVec3d()
						}, 18f * (float)Math.Abs(motionY) * impactDamageMul);
						if (flag2 && !flag)
						{
							flag = flag2;
							base.Api.World.PlaySoundAt(Block.Sounds.Break, val2, (IPlayer)null, true, 32f, 1f);
						}
					}
				}
			}
			lingerTicks = 50;
			fallHandled = true;
			hopUpHeight = 1;
		}

		private void UpdateSnowLayer(BlockPos finalPos, Block block)
		{
			Block snowCoveredVariant = block.GetSnowCoveredVariant(finalPos, block.snowLevel + 1f);
			if (snowCoveredVariant != null && snowCoveredVariant != block)
			{
				base.World.BlockAccessor.ExchangeBlock(((CollectibleObject)snowCoveredVariant).Id, finalPos);
			}
		}

		public override void OnReceivedServerPacket(int packetid, byte[] data)
		{
			((Entity)this).OnReceivedServerPacket(packetid, data);
			if (packetid != 1234)
			{
				return;
			}
			if (((Entity)this).Properties.Client.Renderer is EntityBlockFallingRenderer)
			{
				base.World.BlockAccessor.MarkBlockDirty(base.Pos.AsBlockPos, (Action)delegate
				{
					OnChunkRetesselated(on: false);
				});
			}
			lingerTicks = 50;
			fallHandled = true;
			nowImpacted = true;
			particleSys.Unregister(this);
		}

		private void DropItems(BlockPos pos)
		{
			Vec3d val = pos.ToVec3d().Add(0.5, 0.5, 0.5);
			if (drops != null)
			{
				for (int i = 0; i < drops.Length; i++)
				{
					base.World.SpawnItemEntity(drops[i], val, (Vec3d)null);
				}
			}
			BlockEntity obj = removedBlockentity;
			IBlockEntityContainer val2 = (IBlockEntityContainer)(object)((obj is IBlockEntityContainer) ? obj : null);
			if (val2 != null)
			{
				val2.DropContents(val);
			}
		}

		public override void ToBytes(BinaryWriter writer, bool forClient)
		{
			((TreeAttribute)base.WatchedAttributes).SetFloat("maxSpawnHeightForParticles", maxSpawnHeightForParticles);
			((Entity)this).ToBytes(writer, forClient);
			writer.Write(initialPos.X);
			writer.Write(initialPos.Y);
			writer.Write(initialPos.Z);
			writer.Write(blockCode.ToShortString());
			writer.Write(blockEntityAttributes == null);
			if (blockEntityAttributes != null)
			{
				blockEntityAttributes.ToBytes(writer);
				writer.Write(blockEntityClass);
			}
			writer.Write(DoRemoveBlock);
		}

		public override void FromBytes(BinaryReader reader, bool forClient)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Expected O, but got Unknown
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Expected O, but got Unknown
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Expected O, but got Unknown
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Expected O, but got Unknown
			((Entity)this).FromBytes(reader, forClient);
			initialPos = new BlockPos();
			initialPos.X = reader.ReadInt32();
			initialPos.Y = reader.ReadInt32();
			initialPos.Z = reader.ReadInt32();
			blockCode = new AssetLocation(reader.ReadString());
			if (!reader.ReadBoolean())
			{
				blockEntityAttributes = new TreeAttribute();
				blockEntityAttributes.FromBytes(reader);
				blockEntityClass = reader.ReadString();
			}
			if (((TreeAttribute)base.WatchedAttributes).HasAttribute("fallSound"))
			{
				fallSound = new AssetLocation(((TreeAttribute)base.WatchedAttributes).GetString("fallSound", (string)null));
			}
			canFallSideways = ((TreeAttribute)base.WatchedAttributes).GetBool("canFallSideways", false);
			dustIntensity = ((TreeAttribute)base.WatchedAttributes).GetFloat("dustIntensity", 0f);
			maxSpawnHeightForParticles = ((TreeAttribute)base.WatchedAttributes).GetFloat("maxSpawnHeightForParticles", 0f);
			DoRemoveBlock = reader.ReadBoolean();
		}

		public override bool ShouldReceiveDamage(DamageSource damageSource, float damage)
		{
			return false;
		}
	}
	public interface ICustomDialogPositioning
	{
		Vec3d GetDialogPosition();
	}
	public class GuiDialogCreatureContents : GuiDialog
	{
		private InventoryGeneric inv;

		private Entity owningEntity;

		public int packetIdOffset;

		private EnumPosFlag screenPos;

		private string title;

		private ICustomDialogPositioning icdp;

		private Vec3d entityPos = new Vec3d();

		public override string ToggleKeyCombinationCode => null;

		protected double FloatyDialogPosition => 0.6;

		protected double FloatyDialogAlign => 0.8;

		public override bool UnregisterOnClose => true;

		public override bool PrefersUngrabbedMouse => false;

		public GuiDialogCreatureContents(InventoryGeneric inv, Entity owningEntity, ICoreClientAPI capi, string code, string title = null, ICustomDialogPositioning icdp = null)
			: base(capi)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			this.inv = inv;
			this.title = title;
			this.owningEntity = owningEntity;
			this.icdp = icdp;
			Compose(code);
		}

		public void Compose(string code)
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			double unscaledSlotPadding = GuiElementItemSlotGridBase.unscaledSlotPadding;
			int num = (int)Math.Ceiling((float)((InventoryBase)inv).Count / 4f);
			ElementBounds val = ElementStdBounds.SlotGrid((EnumDialogArea)0, unscaledSlotPadding, 40.0 + unscaledSlotPadding, 4, num).FixedGrow(2.0 * unscaledSlotPadding, 2.0 * unscaledSlotPadding);
			screenPos = ((GuiDialog)this).GetFreePos("smallblockgui");
			float num2 = 10f;
			ElementBounds val2 = val.ForkBoundingParent((double)num2, (double)(num2 + 30f), (double)num2, (double)num2).WithFixedAlignmentOffset(((GuiDialog)this).IsRight(screenPos) ? (0.0 - GuiStyle.DialogToScreenPadding) : GuiStyle.DialogToScreenPadding, 0.0).WithAlignment((EnumDialogArea)(((GuiDialog)this).IsRight(screenPos) ? 10 : 2));
			if (!base.capi.Settings.Bool["immersiveMouseMode"])
			{
				val2.fixedOffsetY += (val2.fixedHeight + 10.0) * (double)((GuiDialog)this).YOffsetMul(screenPos);
				val2.fixedOffsetX += (val2.fixedWidth + 10.0) * (double)((GuiDialog)this).XOffsetMul(screenPos);
			}
			((GuiDialog)this).SingleComposer = GuiComposerHelpers.AddItemSlotGrid(GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(base.capi.Gui.CreateCompo(code + owningEntity.EntityId, val2), ElementBounds.Fill, true, 5.0, 0.75f), Lang.Get(title ?? code, Array.Empty<object>()), (Action)OnTitleBarClose, (CairoFont)null, (ElementBounds)null, (string)null), (IInventory)(object)inv, (Action<object>)DoSendPacket, 4, val, "slots").Compose(true);
		}

		private void DoSendPacket(object p)
		{
			base.capi.Network.SendEntityPacketWithOffset(owningEntity.EntityId, packetIdOffset, p);
		}

		private void OnTitleBarClose()
		{
			((GuiDialog)this).TryClose();
		}

		public override void OnGuiOpened()
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			((GuiDialog)this).OnGuiOpened();
			if (base.capi.Gui.GetDialogPosition(((GuiDialog)this).SingleComposer.DialogName) == (Vec2i)null)
			{
				((GuiDialog)this).OccupyPos("smallblockgui", screenPos);
			}
		}

		public override void OnGuiClosed()
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			((GuiDialog)this).OnGuiClosed();
			((IPlayer)base.capi.World.Player).InventoryManager.CloseInventoryAndSync((IInventory)(object)inv);
			((GuiElementItemSlotGridBase)GuiComposerHelpers.GetSlotGrid(((GuiDialog)this).SingleComposer, "slots")).OnGuiClosed(base.capi);
			((GuiDialog)this).FreePos("smallblockgui", screenPos);
		}

		public override void OnRenderGUI(float deltaTime)
		{
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Expected O, but got Unknown
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			if (base.capi.Settings.Bool["immersiveMouseMode"])
			{
				double num = owningEntity.SelectionBox.X2 - owningEntity.OriginSelectionBox.X2;
				double num2 = owningEntity.SelectionBox.Z2 - owningEntity.OriginSelectionBox.Z2;
				Vec3d val = new Vec3d(owningEntity.Pos.X + num, owningEntity.Pos.Y + FloatyDialogPosition, owningEntity.Pos.Z + num2);
				if (icdp != null)
				{
					val = icdp.GetDialogPosition();
				}
				Vec3d val2 = MatrixToolsd.Project(val, base.capi.Render.PerspectiveProjectionMat, base.capi.Render.PerspectiveViewMat, base.capi.Render.FrameWidth, base.capi.Render.FrameHeight);
				if (val2.Z < 0.0)
				{
					return;
				}
				((GuiDialog)this).SingleComposer.Bounds.Alignment = (EnumDialogArea)0;
				((GuiDialog)this).SingleComposer.Bounds.fixedOffsetX = 0.0;
				((GuiDialog)this).SingleComposer.Bounds.fixedOffsetY = 0.0;
				((GuiDialog)this).SingleComposer.Bounds.absFixedX = val2.X - ((GuiDialog)this).SingleComposer.Bounds.OuterWidth / 2.0;
				((GuiDialog)this).SingleComposer.Bounds.absFixedY = (double)base.capi.Render.FrameHeight - val2.Y - ((GuiDialog)this).SingleComposer.Bounds.OuterHeight * FloatyDialogAlign;
				((GuiDialog)this).SingleComposer.Bounds.absMarginX = 0.0;
				((GuiDialog)this).SingleComposer.Bounds.absMarginY = 0.0;
			}
			((GuiDialog)this).OnRenderGUI(deltaTime);
		}

		public override void OnFinalizeFrame(float dt)
		{
			((GuiDialog)this).OnFinalizeFrame(dt);
			entityPos.Set(owningEntity.Pos.X, owningEntity.Pos.Y, owningEntity.Pos.Z);
			entityPos.Add((double)(owningEntity.SelectionBox.X2 - owningEntity.OriginSelectionBox.X2), 0.0, (double)(owningEntity.SelectionBox.Z2 - owningEntity.OriginSelectionBox.Z2));
			if (!IsInRangeOfBlock())
			{
				((IEventAPI)base.capi.Event).EnqueueMainThreadTask((Action)delegate
				{
					((GuiDialog)this).TryClose();
				}, "closedlg");
			}
		}

		public override bool TryClose()
		{
			return ((GuiDialog)this).TryClose();
		}

		public virtual bool IsInRangeOfBlock()
		{
			return (double)GameMath.Sqrt(((Entity)((IPlayer)base.capi.World.Player).Entity).Pos.XYZ.Add(((Entity)((IPlayer)base.capi.World.Player).Entity).LocalEyePos).SquareDistanceTo(entityPos)) <= (double)((IPlayer)base.capi.World.Player).WorldData.PickingRange;
		}
	}
	public class GuiDialogLogViewer : GuiDialogGeneric
	{
		public GuiDialogLogViewer(string text, ICoreClientAPI capi)
			: base("Log Viewer", capi)
		{
			//IL_023a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Expected O, but got Unknown
			ElementBounds val = ElementBounds.Fixed(GuiStyle.ElementToDialogPadding, 40.0, 900.0, 30.0);
			ElementBounds val2 = ElementBounds.Fixed(0.0, 0.0, 900.0, 300.0).FixedUnder(val, 5.0);
			ElementBounds val3 = val2.ForkBoundingParent(0.0, 0.0, 0.0, 0.0);
			ElementBounds val4 = val2.FlatCopy().FixedGrow(6.0).WithFixedOffset(-3.0, -3.0);
			ElementBounds val5 = val4.CopyOffsetedSibling(val2.fixedWidth + 7.0, 0.0, 0.0, 0.0).WithFixedWidth(20.0);
			ElementBounds val6 = ElementBounds.FixedSize(0.0, 0.0).FixedUnder(val3, 10.0).WithAlignment((EnumDialogArea)12)
				.WithFixedPadding(20.0, 4.0);
			ElementBounds val7 = ElementBounds.Fill.WithFixedPadding(GuiStyle.ElementToDialogPadding);
			val7.BothSizing = (ElementSizing)2;
			val7.WithChildren((ElementBounds[])(object)new ElementBounds[4] { val4, val3, val5, val6 });
			ElementBounds val8 = ElementStdBounds.AutosizedMainDialog.WithAlignment((EnumDialogArea)6);
			((GuiDialog)this).SingleComposer = GuiComposerHelpers.AddSmallButton(GuiComposerHelpers.AddVerticalScrollbar(GuiElementClipHelpler.EndClip(GuiElementDynamicTextHelper.AddDynamicText(GuiElementInsetHelper.AddInset(GuiElementClipHelpler.BeginClip(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(capi.Gui.CreateCompo("dialogviewer", val8), val7, true, 5.0, 0.75f), base.DialogTitle, (Action)OnTitleBarClose, (CairoFont)null, (ElementBounds)null, (string)null), "The following warnings and errors were reported during startup:", CairoFont.WhiteDetailText(), val, (string)null).BeginChildElements(val7), val3), val4, 3, 0.85f), "", CairoFont.WhiteDetailText(), val2, "text")), (Action<float>)OnNewScrollbarvalue, val5, "scrollbar"), "Close", new ActionConsumable(OnButtonClose), val6, (EnumButtonStyle)2, (string)null).EndChildElements().Compose(true);
			GuiElementDynamicText dynamicText = GuiElementDynamicTextHelper.GetDynamicText(((GuiDialog)this).SingleComposer, "text");
			dynamicText.AutoHeight();
			dynamicText.SetNewText(text, false, false, false);
			GuiComposerHelpers.GetScrollbar(((GuiDialog)this).SingleComposer, "scrollbar").SetHeights(300f, (float)val2.fixedHeight);
		}

		private void OnNewScrollbarvalue(float value)
		{
			GuiElementDynamicText dynamicText = GuiElementDynamicTextHelper.GetDynamicText(((GuiDialog)this).SingleComposer, "text");
			((GuiElement)dynamicText).Bounds.fixedY = 3f - value;
			((GuiElement)dynamicText).Bounds.CalcWorldBounds();
		}

		private void OnTitleBarClose()
		{
			OnButtonClose();
		}

		private bool OnButtonClose()
		{
			((GuiDialog)this).TryClose();
			return true;
		}
	}
	public delegate BlockPos PositionProviderDelegate();
	public delegate InventoryBase InventorySupplierDelegate();
	public interface ICollectibleResolveOnLoad
	{
		void ResolveOnLoad(ItemSlot slot, IWorldAccessor worldForResolve, bool resolveImports);
	}
	public class InWorldContainer
	{
		protected RoomRegistry roomReg;

		protected Room room;

		protected ICoreAPI Api;

		protected float temperatureCached = -1000f;

		protected PositionProviderDelegate positionProvider;

		protected Action onRequireSyncToClient;

		public InventorySupplierDelegate inventorySupplier;

		private string treeAttrKey;

		private InventoryBase prevInventory;

		private bool didInit;

		public Room Room => room;

		public InventoryBase Inventory => inventorySupplier();

		public InWorldContainer(InventorySupplierDelegate inventorySupplier, string treeAttrKey)
		{
			this.inventorySupplier = inventorySupplier;
			this.treeAttrKey = treeAttrKey;
		}

		public void Init(ICoreAPI Api, PositionProviderDelegate positionProvider, Action onRequireSyncToClient)
		{
			this.Api = Api;
			this.positionProvider = positionProvider;
			this.onRequireSyncToClient = onRequireSyncToClient;
			roomReg = Api.ModLoader.GetModSystem<RoomRegistry>(true);
			LateInit();
		}

		public void Reset()
		{
			didInit = false;
		}

		public void LateInit()
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Expected O, but got Unknown
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Invalid comparison between Unknown and I4
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Expected O, but got Unknown
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Expected O, but got Unknown
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Invalid comparison between Unknown and I4
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Expected O, but got Unknown
			if (Inventory == null || didInit)
			{
				return;
			}
			if (prevInventory != null && Inventory != prevInventory)
			{
				prevInventory.OnAcquireTransitionSpeed -= new CustomGetTransitionSpeedMulDelegate(Inventory_OnAcquireTransitionSpeed);
				if ((int)Api.Side == 2)
				{
					prevInventory.OnInventoryOpened -= new OnInventoryOpenedDelegate(Inventory_OnInventoryOpenedClient);
				}
			}
			didInit = true;
			Inventory.ResolveBlocksOrItems();
			Inventory.OnAcquireTransitionSpeed += new CustomGetTransitionSpeedMulDelegate(Inventory_OnAcquireTransitionSpeed);
			if ((int)Api.Side == 2)
			{
				Inventory.OnInventoryOpened += new OnInventoryOpenedDelegate(Inventory_OnInventoryOpenedClient);
			}
			else
			{
				Inventory.SlotModified += Inventory_SlotModified;
			}
			prevInventory = Inventory;
		}

		private void Inventory_SlotModified(int obj)
		{
			if (!(Inventory is InventoryBasePlayer))
			{
				IWorldChunk chunkAtBlockPos = Api.World.BlockAccessor.GetChunkAtBlockPos(positionProvider());
				if (chunkAtBlockPos != null)
				{
					chunkAtBlockPos.MarkModified();
				}
			}
		}

		private void Inventory_OnInventoryOpenedClient(IPlayer player)
		{
			OnTick(1f);
		}

		public virtual void OnTick(float dt)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			if ((int)Api.Side == 2)
			{
				return;
			}
			temperatureCached = -1000f;
			if (!HasTransitionables())
			{
				return;
			}
			room = roomReg.GetRoomForPosition(positionProvider());
			if (room.AnyChunkUnloaded != 0)
			{
				return;
			}
			foreach (ItemSlot item in Inventory)
			{
				if (item.Itemstack != null)
				{
					AssetLocation code = ((RegistryObject)item.Itemstack.Collectible).Code;
					item.Itemstack.Collectible.UpdateAndGetTransitionStates(Api.World, item);
					ItemStack itemstack = item.Itemstack;
					if (((itemstack != null) ? ((RegistryObject)itemstack.Collectible).Code : null) != code)
					{
						onRequireSyncToClient();
					}
				}
			}
			temperatureCached = -1000f;
		}

		protected virtual bool HasTransitionables()
		{
			foreach (ItemSlot item in Inventory)
			{
				ItemStack itemstack = item.Itemstack;
				if (itemstack != null && itemstack.Collectible.RequiresTransitionableTicking(Api.World, itemstack))
				{
					return true;
				}
			}
			return false;
		}

		protected virtual float Inventory_OnAcquireTransitionSpeed(EnumTransitionType transType, ItemStack stack, float baseMul)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Invalid comparison between Unknown and I4
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Invalid comparison between Unknown and I4
			float num = ((Api != null && (int)transType == 0) ? GetPerishRate() : 1f);
			if ((int)transType == 1 || (int)transType == 6)
			{
				num = 0.25f;
			}
			return baseMul * num;
		}

		public virtual float GetPerishRate()
		{
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Invalid comparison between Unknown and I4
			BlockPos val = positionProvider().Copy();
			val.Y = Api.World.SeaLevel;
			float temperature = temperatureCached;
			if (temperature < -999f)
			{
				temperature = Api.World.BlockAccessor.GetClimateAt(val, (EnumGetClimateMode)3, Api.World.Calendar.TotalDays).Temperature;
				if ((int)Api.Side == 1)
				{
					temperatureCached = temperature;
				}
			}
			if (room == null)
			{
				room = roomReg.GetRoomForPosition(positionProvider());
			}
			float num = 0f;
			float num2 = (float)room.SkylightCount / (float)Math.Max(1, room.SkylightCount + room.NonSkylightCount);
			if (room.IsSmallRoom)
			{
				num = 1f;
				num -= 0.4f * num2;
				num -= 0.5f * GameMath.Clamp((float)room.NonCoolingWallCount / (float)Math.Max(1, room.CoolingWallCount), 0f, 1f);
			}
			int lightLevel = Api.World.BlockAccessor.GetLightLevel(positionProvider(), (EnumLightLevelType)1);
			float num3 = 0.1f;
			num3 = (room.IsSmallRoom ? (num3 + (0.3f * num + 1.75f * num2)) : ((!((float)room.ExitCount <= 0.1f * (float)(room.CoolingWallCount + room.NonCoolingWallCount))) ? (num3 + 0.5f * num2) : (num3 + 1.25f * num2)));
			num3 = GameMath.Clamp(num3, 0f, 1.5f);
			float num4 = temperature + (float)GameMath.Clamp(lightLevel - 11, 0, 10) * num3;
			float num5 = 5f;
			float val2 = GameMath.Lerp(num4, num5, num);
			val2 = Math.Min(val2, num4);
			return Math.Max(0.1f, Math.Min(2.4f, (float)Math.Pow(3.0, (double)(val2 / 19f) - 1.2) - 0.1f));
		}

		public void ReloadRoom()
		{
			room = roomReg.GetRoomForPosition(positionProvider());
		}

		public void OnStoreCollectibleMappings(Dictionary<int, AssetLocation> blockIdMapping, Dictionary<int, AssetLocation> itemIdMapping)
		{
			foreach (ItemSlot item in Inventory)
			{
				ItemStack itemstack = item.Itemstack;
				if (itemstack != null)
				{
					itemstack.Collectible.OnStoreCollectibleMappings(Api.World, item, blockIdMapping, itemIdMapping);
				}
			}
		}

		public void OnLoadCollectibleMappings(IWorldAccessor worldForResolve, Dictionary<int, AssetLocation> oldBlockIdMapping, Dictionary<int, AssetLocation> oldItemIdMapping, int schematicSeed, bool resolveImports)
		{
			foreach (ItemSlot item in Inventory)
			{
				if (item.Itemstack != null)
				{
					if (!item.Itemstack.FixMapping(oldBlockIdMapping, oldItemIdMapping, worldForResolve))
					{
						item.Itemstack = null;
					}
					else
					{
						item.Itemstack.Collectible.OnLoadCollectibleMappings(worldForResolve, item, oldBlockIdMapping, oldItemIdMapping, resolveImports);
					}
					ItemStack itemstack = item.Itemstack;
					CollectibleObject obj = ((itemstack != null) ? itemstack.Collectible : null);
					IResolvableCollectible val = (IResolvableCollectible)(object)((obj is IResolvableCollectible) ? obj : null);
					if (val != null)
					{
						val.Resolve(item, worldForResolve, resolveImports);
					}
				}
			}
		}

		public void ToTreeAttributes(ITreeAttribute tree)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Expected O, but got Unknown
			if (Inventory != null)
			{
				ITreeAttribute val = (ITreeAttribute)new TreeAttribute();
				Inventory.ToTreeAttributes(val);
				tree[treeAttrKey] = (IAttribute)(object)val;
			}
		}

		public void FromTreeAttributes(ITreeAttribute tree, IWorldAccessor worldForResolving)
		{
			Inventory.FromTreeAttributes(tree.GetTreeAttribute(treeAttrKey));
		}
	}
	public class ItemSlotMouth : ItemSlotSurvival
	{
		private EntityBehaviorMouthInventory beh;

		public ItemSlotMouth(EntityBehaviorMouthInventory beh, InventoryGeneric inventory)
			: base((InventoryBase)(object)inventory)
		{
			this.beh = beh;
			((ItemSlot)this).MaxSlotStackSize = 1;
		}

		public override bool CanTakeFrom(ItemSlot sourceSlot, EnumMergePriority priority = (EnumMergePriority)0)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			if (((ItemSlotSurvival)this).CanTakeFrom(sourceSlot, priority))
			{
				return mouthable(sourceSlot);
			}
			return false;
		}

		public override bool CanHold(ItemSlot itemstackFromSourceSlot)
		{
			if (((ItemSlotSurvival)this).CanHold(itemstackFromSourceSlot))
			{
				return mouthable(itemstackFromSourceSlot);
			}
			return false;
		}

		public bool mouthable(ItemSlot sourceSlot)
		{
			if (!((ItemSlot)this).Empty)
			{
				return false;
			}
			if (beh.PickupCoolDownUntilMs > ((EntityBehavior)beh).entity.World.ElapsedMilliseconds)
			{
				return false;
			}
			for (int i = 0; i < beh.acceptStacks.Count; i++)
			{
				if (beh.acceptStacks[i].Equals(((EntityBehavior)beh).entity.World, sourceSlot.Itemstack, GlobalConstants.IgnoredStackAttributes))
				{
					return true;
				}
			}
			return ((EntityBehavior)beh).entity.World.Rand.NextDouble() < 0.005;
		}

		public override void OnBeforeRender(ItemRenderInfo renderInfo)
		{
			string text = "inMouthTransform";
			JsonObject attributes = ((ItemSlot)this).itemstack.Collectible.Attributes;
			if (attributes != null)
			{
				JsonObject obj = attributes[text];
				ModelTransform val = ((obj != null) ? obj.AsObject<ModelTransform>((ModelTransform)null) : null);
				if (val != null)
				{
					renderInfo.Transform = val;
				}
			}
		}
	}
	public class BlockEntityParticleEmitter : BlockEntity
	{
		private Block block;

		private long listenerId;

		public override void Initialize(ICoreAPI api)
		{
			((BlockEntity)this).Initialize(api);
			if (api.World is IClientWorldAccessor)
			{
				listenerId = api.Event.RegisterGameTickListener((Action<float>)OnGameTick, 25, 0);
				block = api.World.BlockAccessor.GetBlock(base.Pos);
			}
		}

		public override void OnBlockRemoved()
		{
			((BlockEntity)this).OnBlockRemoved();
			base.Api.World.UnregisterGameTickListener(listenerId);
		}

		private void OnGameTick(float dt)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			if (((Entity)((IPlayer)((IClientWorldAccessor)base.Api.World).Player).Entity).Pos.InRangeOf(base.Pos, 16384f) && block != null && ((CollectibleObject)block).ParticleProperties != null)
			{
				for (int i = 0; i < ((CollectibleObject)block).ParticleProperties.Length; i++)
				{
					AdvancedParticleProperties val = ((CollectibleObject)block).ParticleProperties[i];
					val.basePos.X = (float)base.Pos.X + ((CollectibleObject)block).TopMiddlePos.X;
					val.basePos.Y = (float)base.Pos.InternalY + ((CollectibleObject)block).TopMiddlePos.Y;
					val.basePos.Z = (float)base.Pos.Z + ((CollectibleObject)block).TopMiddlePos.Z;
					base.Api.World.SpawnParticles((IParticlePropertiesProvider)(object)val, (IPlayer)null);
				}
			}
		}
	}
	public class CharacterExtraDialogs : ModSystem
	{
		private ICoreClientAPI capi;

		private GuiDialogCharacterBase dlg;

		private DlgComposers Composers => ((GuiDialog)dlg).Composers;

		public event Action<StringBuilder> OnEnvText;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		private bool IsOpened()
		{
			return ((GuiDialog)dlg).IsOpened();
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			capi = api;
			((ModSystem)this).StartClientSide(api);
			ref GuiDialogCharacterBase reference = ref dlg;
			GuiDialog? obj = api.Gui.LoadedGuis.Find((GuiDialog dlg) => dlg is GuiDialogCharacterBase);
			reference = (GuiDialogCharacterBase)(object)((obj is GuiDialogCharacterBase) ? obj : null);
			((GuiDialog)dlg).OnOpened += Dlg_OnOpened;
			((GuiDialog)dlg).OnClosed += Dlg_OnClosed;
			dlg.TabClicked += Dlg_TabClicked;
			dlg.ComposeExtraGuis += Dlg_ComposeExtraGuis;
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)On2sTick, 2000, 0);
		}

		private void Dlg_TabClicked(int tabIndex)
		{
			if (tabIndex != 0)
			{
				Dlg_OnClosed();
			}
			if (tabIndex == 0)
			{
				Dlg_OnOpened();
			}
		}

		private void Dlg_ComposeExtraGuis()
		{
			ComposeEnvGui();
			ComposeStatsGui();
		}

		private void On2sTick(float dt)
		{
			if (IsOpened())
			{
				updateEnvText();
			}
		}

		private void Dlg_OnClosed()
		{
			((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes.UnregisterListener((Action)UpdateStatBars);
			((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes.UnregisterListener((Action)UpdateStats);
		}

		private void Dlg_OnOpened()
		{
			((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes.RegisterModifiedListener("hunger", (Action)UpdateStatBars);
			((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes.RegisterModifiedListener("stats", (Action)UpdateStats);
			((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes.RegisterModifiedListener("bodyTemp", (Action)UpdateStats);
		}

		public virtual void ComposeEnvGui()
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			ElementBounds bounds = Composers["playercharacter"].Bounds;
			CairoFont val = CairoFont.WhiteSmallText().WithLineHeightMultiplier(1.2);
			string envText = getEnvText();
			int num = 1 + Regex.Matches(envText, "\n").Count;
			FontExtents fontExtents = val.GetFontExtents();
			double num2 = ((FontExtents)(ref fontExtents)).Height * val.LineHeightMultiplier * (double)num / (double)RuntimeEnv.GUIScale;
			ElementBounds val2 = ElementBounds.Fixed(0.0, 25.0, (double)(int)(bounds.InnerWidth / (double)RuntimeEnv.GUIScale - 40.0), num2);
			val2.Name = "textbounds";
			ElementBounds val3 = ElementBounds.Fill.WithFixedPadding(GuiStyle.ElementToDialogPadding);
			val3.Name = "bgbounds";
			val3.BothSizing = (ElementSizing)2;
			val3.WithChildren((ElementBounds[])(object)new ElementBounds[1] { val2 });
			ElementBounds val4 = ElementStdBounds.AutosizedMainDialog.WithAlignment((EnumDialogArea)0).WithFixedPosition(bounds.renderX / (double)RuntimeEnv.GUIScale, bounds.renderY / (double)RuntimeEnv.GUIScale + bounds.OuterHeight / (double)RuntimeEnv.GUIScale + 10.0);
			val4.Name = "dialogbounds";
			Composers["environment"] = GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(capi.Gui.CreateCompo("environment", val4), val3, true, 5.0, 0.75f), Lang.Get("Environment", Array.Empty<object>()), (Action)delegate
			{
				dlg.OnTitleBarClose();
			}, (CairoFont)null, (ElementBounds)null, (string)null).BeginChildElements(val3), envText, val, val2, "dyntext").EndChildElements().Compose(true);
		}

		private void updateEnvText()
		{
			if (IsOpened())
			{
				DlgComposers composers = Composers;
				if (((composers != null) ? composers["environment"] : null) != null)
				{
					GuiElementDynamicTextHelper.GetDynamicText(Composers["environment"], "dyntext").SetNewTextAsync(getEnvText(), false, false);
				}
			}
		}

		private string getEnvText()
		{
			string text = ((IGameCalendar)capi.World.Calendar).PrettyDate();
			ClimateCondition climateAt = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(((Entity)((IPlayer)capi.World.Player).Entity).Pos.AsBlockPos, (EnumGetClimateMode)1, 0.0);
			string text2 = "?";
			string text3 = "?";
			if (climateAt != null)
			{
				text2 = (int)climateAt.Temperature + "Â°C";
				text3 = Lang.Get("freq-veryrare", Array.Empty<object>());
				if ((double)climateAt.WorldgenRainfall > 0.9)
				{
					text3 = Lang.Get("freq-allthetime", Array.Empty<object>());
				}
				else if ((double)climateAt.WorldgenRainfall > 0.7)
				{
					text3 = Lang.Get("freq-verycommon", Array.Empty<object>());
				}
				else if ((double)climateAt.WorldgenRainfall > 0.45)
				{
					text3 = Lang.Get("freq-common", Array.Empty<object>());
				}
				else if ((double)climateAt.WorldgenRainfall > 0.3)
				{
					text3 = Lang.Get("freq-uncommon", Array.Empty<object>());
				}
				else if ((double)climateAt.WorldgenRainfall > 0.15)
				{
					text3 = Lang.Get("freq-rarely", Array.Empty<object>());
				}
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(Lang.Get("character-envtext", new object[3] { text, text2, text3 }));
			this.OnEnvText?.Invoke(stringBuilder);
			return stringBuilder.ToString();
		}

		public virtual void ComposeStatsGui()
		{
			ElementBounds bounds = Composers["playercharacter"].Bounds;
			ElementBounds bounds2 = Composers["environment"].Bounds;
			ElementBounds val = ElementBounds.Fixed(0.0, 25.0, 90.0, 20.0);
			ElementBounds val2 = ElementBounds.Fixed(120.0, 30.0, 120.0, 8.0);
			ElementBounds leftColumnBoundsW = ElementBounds.Fixed(0.0, 0.0, 140.0, 20.0);
			ElementBounds val3 = ElementBounds.Fixed(165.0, 0.0, 120.0, 20.0);
			EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
			double num = bounds2.InnerHeight / (double)RuntimeEnv.GUIScale + 10.0;
			ElementBounds val4 = ElementBounds.Fixed(0.0, 0.0, 235.0, bounds.InnerHeight / (double)RuntimeEnv.GUIScale - GuiStyle.ElementToDialogPadding - 20.0 + num).WithFixedPadding(GuiStyle.ElementToDialogPadding);
			ElementBounds val5 = val4.ForkBoundingParent(0.0, 0.0, 0.0, 0.0).WithAlignment((EnumDialogArea)2).WithFixedAlignmentOffset((bounds.renderX + bounds.OuterWidth + 10.0) / (double)RuntimeEnv.GUIScale, num / 2.0);
			getHealthSat(out var health, out var maxHealth, out var saturation, out var maxSaturation);
			float blended = ((Entity)entity).Stats.GetBlended("walkspeed");
			float blended2 = ((Entity)entity).Stats.GetBlended("healingeffectivness");
			float blended3 = ((Entity)entity).Stats.GetBlended("hungerrate");
			float blended4 = ((Entity)entity).Stats.GetBlended("rangedWeaponsAcc");
			float blended5 = ((Entity)entity).Stats.GetBlended("rangedWeaponsSpeed");
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("bodyTemp");
			float num2 = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetFloat("wetness", 0f);
			string text = "";
			if ((double)num2 > 0.7)
			{
				text = Lang.Get("wetness_soakingwet", Array.Empty<object>());
			}
			else if ((double)num2 > 0.4)
			{
				text = Lang.Get("wetness_wet", Array.Empty<object>());
			}
			else if ((double)num2 > 0.1)
			{
				text = Lang.Get("wetness_slightlywet", Array.Empty<object>());
			}
			Composers["playerstats"] = GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(capi.Gui.CreateCompo("playerstats", val5), val4, true, 5.0, 0.75f), Lang.Get("Stats", Array.Empty<object>()), (Action)delegate
			{
				dlg.OnTitleBarClose();
			}, (CairoFont)null, (ElementBounds)null, (string)null).BeginChildElements(val4);
			if (saturation.HasValue)
			{
				GuiComposerHelpers.AddStatbar(GuiComposerHelpers.AddStatbar(GuiComposerHelpers.AddStatbar(GuiComposerHelpers.AddStatbar(GuiComposerHelpers.AddStatbar(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("playerinfo-nutrition", Array.Empty<object>()), CairoFont.WhiteSmallText().WithWeight((FontWeight)1), val.WithFixedWidth(200.0), (string)null), Lang.Get("playerinfo-nutrition-Freeza", Array.Empty<object>()), CairoFont.WhiteDetailText(), val = val.BelowCopy(0.0, 0.0, 0.0, 0.0).WithFixedWidth(90.0), (string)null), Lang.Get("playerinfo-nutrition-Vegita", Array.Empty<object>()), CairoFont.WhiteDetailText(), val = val.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), Lang.Get("playerinfo-nutrition-Krillin", Array.Empty<object>()), CairoFont.WhiteDetailText(), val = val.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), Lang.Get("playerinfo-nutrition-Cell", Array.Empty<object>()), CairoFont.WhiteDetailText(), val = val.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), Lang.Get("playerinfo-nutrition-Dairy", Array.Empty<object>()), CairoFont.WhiteDetailText(), val = val.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), val2 = val2.BelowCopy(0.0, 16.0, 0.0, 0.0), GuiStyle.FoodBarColor, "fruitBar"), val2 = val2.BelowCopy(0.0, 12.0, 0.0, 0.0), GuiStyle.FoodBarColor, "vegetableBar"), val2 = val2.BelowCopy(0.0, 12.0, 0.0, 0.0), GuiStyle.FoodBarColor, "grainBar"), val2 = val2.BelowCopy(0.0, 12.0, 0.0, 0.0), GuiStyle.FoodBarColor, "proteinBar"), val2 = val2.BelowCopy(0.0, 12.0, 0.0, 0.0), GuiStyle.FoodBarColor, "dairyBar");
				leftColumnBoundsW = leftColumnBoundsW.FixedUnder(val, -5.0);
			}
			GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Physical", Array.Empty<object>()), CairoFont.WhiteSmallText().WithWeight((FontWeight)1), leftColumnBoundsW.WithFixedWidth(200.0).WithFixedOffset(0.0, 23.0), (string)null).Execute((Action)delegate
			{
				leftColumnBoundsW = leftColumnBoundsW.FlatCopy();
				ElementBounds obj2 = leftColumnBoundsW;
				obj2.fixedY += 5.0;
			});
			if (health.HasValue)
			{
				GuiComposer obj = GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Health Points", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null);
				float? num3 = health;
				string? text2 = num3.ToString();
				num3 = maxHealth;
				GuiElementDynamicTextHelper.AddDynamicText(obj, text2 + " / " + num3, CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY).WithFixedHeight(30.0), "health");
			}
			if (saturation.HasValue)
			{
				GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Satiety", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (int)saturation.Value + " / " + (int)maxSaturation.Value, CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "satiety");
			}
			if (treeAttribute != null)
			{
				GuiComposerHelpers.AddRichtext(GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Body Temperature", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (treeAttribute == null) ? "-" : getBodyTempText(treeAttribute), CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "bodytemp");
			}
			if (text.Length > 0)
			{
				GuiComposerHelpers.AddRichtext(Composers["playerstats"], text, CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null);
			}
			GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddStaticText(GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Walk speed", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (int)Math.Round(100f * blended) + "%", CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "walkspeed"), Lang.Get("Healing effectivness", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (int)Math.Round(100f * blended2) + "%", CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "healeffectiveness");
			if (saturation.HasValue)
			{
				GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Hunger rate", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (int)Math.Round(100f * blended3) + "%", CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "hungerrate");
			}
			GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddStaticText(GuiElementDynamicTextHelper.AddDynamicText(GuiComposerHelpers.AddStaticText(Composers["playerstats"], Lang.Get("Ranged Accuracy", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (int)Math.Round(100f * blended4) + "%", CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "rangedweaponacc"), Lang.Get("Ranged Charge Speed", Array.Empty<object>()), CairoFont.WhiteDetailText(), leftColumnBoundsW = leftColumnBoundsW.BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), (int)Math.Round(100f * blended5) + "%", CairoFont.WhiteDetailText(), val3 = val3.FlatCopy().WithFixedPosition(val3.fixedX, leftColumnBoundsW.fixedY), "rangedweaponchargespeed").EndChildElements().Compose(true);
			UpdateStatBars();
		}

		private string getBodyTempText(ITreeAttribute tempTree)
		{
			float num = tempTree.GetFloat("bodytemp", 0f);
			if (num > 37f)
			{
				num = 37f + (num - 37f) / 10f;
			}
			return $"{num:0.#}Â°C";
		}

		private void getHealthSat(out float? health, out float? maxHealth, out float? saturation, out float? maxSaturation)
		{
			health = null;
			maxHealth = null;
			saturation = null;
			maxSaturation = null;
			ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes).GetTreeAttribute("health");
			if (treeAttribute != null)
			{
				health = treeAttribute.TryGetFloat("currenthealth");
				maxHealth = treeAttribute.TryGetFloat("maxhealth");
			}
			if (health.HasValue)
			{
				health = (float)Math.Round(health.Value, 1);
			}
			if (maxHealth.HasValue)
			{
				maxHealth = (float)Math.Round(maxHealth.Value, 1);
			}
			ITreeAttribute treeAttribute2 = ((TreeAttribute)((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes).GetTreeAttribute("hunger");
			if (treeAttribute2 != null)
			{
				saturation = treeAttribute2.TryGetFloat("currentsaturation");
				maxSaturation = treeAttribute2.TryGetFloat("maxsaturation");
			}
			if (saturation.HasValue)
			{
				saturation = (int)saturation.Value;
			}
		}

		private void UpdateStats()
		{
			EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
			GuiComposer val = Composers["playerstats"];
			if (val != null && IsOpened())
			{
				getHealthSat(out var health, out var maxHealth, out var saturation, out var maxSaturation);
				float blended = ((Entity)entity).Stats.GetBlended("walkspeed");
				float blended2 = ((Entity)entity).Stats.GetBlended("healingeffectivness");
				float blended3 = ((Entity)entity).Stats.GetBlended("hungerrate");
				float blended4 = ((Entity)entity).Stats.GetBlended("rangedWeaponsAcc");
				float blended5 = ((Entity)entity).Stats.GetBlended("rangedWeaponsSpeed");
				if (health.HasValue)
				{
					GuiElementDynamicText dynamicText = GuiElementDynamicTextHelper.GetDynamicText(val, "health");
					float? num = health;
					string? text = num.ToString();
					num = maxHealth;
					dynamicText.SetNewText(text + " / " + num, false, false, false);
				}
				if (saturation.HasValue)
				{
					GuiElementDynamicTextHelper.GetDynamicText(val, "satiety").SetNewText((int)saturation.Value + " / " + (int)maxSaturation.Value, false, false, false);
				}
				GuiElementDynamicTextHelper.GetDynamicText(val, "walkspeed").SetNewText((int)Math.Round(100f * blended) + "%", false, false, false);
				GuiElementDynamicTextHelper.GetDynamicText(val, "healeffectiveness").SetNewText((int)Math.Round(100f * blended2) + "%", false, false, false);
				GuiElementDynamicText dynamicText2 = GuiElementDynamicTextHelper.GetDynamicText(val, "hungerrate");
				if (dynamicText2 != null)
				{
					dynamicText2.SetNewText((int)Math.Round(100f * blended3) + "%", false, false, false);
				}
				GuiElementDynamicTextHelper.GetDynamicText(val, "rangedweaponacc").SetNewText((int)Math.Round(100f * blended4) + "%", false, false, false);
				GuiElementDynamicTextHelper.GetDynamicText(val, "rangedweaponchargespeed").SetNewText((int)Math.Round(100f * blended5) + "%", false, false, false);
				ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)entity).WatchedAttributes).GetTreeAttribute("bodyTemp");
				GuiComposerHelpers.GetRichtext(val, "bodytemp").SetNewText(getBodyTempText(treeAttribute), CairoFont.WhiteDetailText(), (Action<LinkTextComponent>)null);
			}
		}

		private void UpdateStatBars()
		{
			GuiComposer val = Composers["playerstats"];
			if (val != null && IsOpened())
			{
				ITreeAttribute treeAttribute = ((TreeAttribute)((Entity)((IPlayer)capi.World.Player).Entity).WatchedAttributes).GetTreeAttribute("hunger");
				if (treeAttribute != null)
				{
					float num = treeAttribute.GetFloat("currentsaturation", 0f);
					float num2 = treeAttribute.GetFloat("maxsaturation", 0f);
					float num3 = treeAttribute.GetFloat("fruitLevel", 0f);
					float num4 = treeAttribute.GetFloat("vegetableLevel", 0f);
					float num5 = treeAttribute.GetFloat("grainLevel", 0f);
					float num6 = treeAttribute.GetFloat("proteinLevel", 0f);
					float num7 = treeAttribute.GetFloat("dairyLevel", 0f);
					GuiElementDynamicTextHelper.GetDynamicText(val, "satiety").SetNewText((int)num + " / " + num2, false, false, false);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "fruitBar").SetLineInterval(num2 / 10f);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "vegetableBar").SetLineInterval(num2 / 10f);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "grainBar").SetLineInterval(num2 / 10f);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "proteinBar").SetLineInterval(num2 / 10f);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "dairyBar").SetLineInterval(num2 / 10f);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "fruitBar").SetValues(num3, 0f, num2);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "vegetableBar").SetValues(num4, 0f, num2);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "grainBar").SetValues(num5, 0f, num2);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "proteinBar").SetValues(num6, 0f, num2);
					GuiComposerHelpers.GetStatbar(Composers["playerstats"], "dairyBar").SetValues(num7, 0f, num2);
				}
			}
		}
	}
	[ProtoContract]
	public class ClothConstraint
	{
		private static Random Rand = new Random();

		[ProtoMember(1)]
		public int PointIndex1;

		[ProtoMember(2)]
		public int PointIndex2;

		[ProtoMember(3)]
		private float squared_rest_length;

		private ClothPoint p1;

		private ClothPoint p2;

		private float rest_length;

		private float inverse_length;

		private Vec3f tensionDirection = new Vec3f();

		private float StretchStiffness = 200f;

		private double springLength;

		public Vec3d renderCenterPos;

		private double extension;

		public ClothPoint Point1 => p1;

		public ClothPoint Point2 => p2;

		public double SpringLength => springLength;

		public double Extension => extension;

		public ClothConstraint()
		{
		}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown


		public ClothConstraint(ClothPoint p1, ClothPoint p2)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			this.p1 = p1;
			this.p2 = p2;
			PointIndex1 = p1.PointIndex;
			PointIndex2 = p2.PointIndex;
			squared_rest_length = p1.Pos.SquareDistanceTo(p2.Pos);
			rest_length = GameMath.Sqrt(squared_rest_length);
			inverse_length = 1f / rest_length;
			renderCenterPos = p1.Pos + (p1.Pos - p2.Pos) / 2f;
		}

		public void RestorePoints(Dictionary<int, ClothPoint> pointsByIndex)
		{
			p1 = pointsByIndex[PointIndex1];
			p2 = pointsByIndex[PointIndex2];
			rest_length = GameMath.Sqrt(squared_rest_length);
			inverse_length = 1f / rest_length;
			renderCenterPos = p1.Pos + (p1.Pos - p2.Pos) / 2f;
		}

		public void satisfy(float pdt)
		{
			tensionDirection.Set((float)(p1.Pos.X - p2.Pos.X), (float)(p1.Pos.Y - p2.Pos.Y), (float)(p1.Pos.Z - p2.Pos.Z));
			springLength = tensionDirection.Length();
			if (springLength == 0.0)
			{
				tensionDirection.Set((float)Rand.NextDouble() / 100f - 0.02f, (float)Rand.NextDouble() / 100f - 0.02f, (float)Rand.NextDouble() / 100f - 0.02f);
				springLength = tensionDirection.Length();
			}
			extension = springLength - (double)rest_length;
			double num = (double)StretchStiffness * (extension * (double)inverse_length);
			tensionDirection *= (float)(num / springLength);
			p2.Tension.Add(tensionDirection);
			p1.Tension.Sub(tensionDirection);
			p2.TensionDirection.Set(tensionDirection);
			p1.TensionDirection.Set((double)(0f - tensionDirection.X), (double)(0f - tensionDirection.Y), (double)(0f - tensionDirection.Z));
			p1.extension = extension;
			p2.extension = extension;
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class UnregisterClothSystemPacket
	{
		public int[] ClothIds;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class ClothSystemPacket
	{
		public ClothSystem[] ClothSystems;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class ClothPointPacket
	{
		public int ClothId;

		public int PointX;

		public int PointY;

		public ClothPoint Point;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class ClothLengthPacket
	{
		public int ClothId;

		public double LengthChange;
	}
	public class ClothManager : ModSystem, IRenderer, IDisposable
	{
		private int nextClothId = 1;

		private ICoreClientAPI capi;

		private ICoreServerAPI sapi;

		private ICoreAPI api;

		private Dictionary<int, ClothSystem> clothSystems = new Dictionary<int, ClothSystem>();

		internal ParticlePhysics partPhysics;

		private MeshRef ropeMeshRef;

		private MeshData updateMesh;

		private IShaderProgram prog;

		private ILoadedSound stretchSound;

		public float accum3s;

		public float accum100ms;

		private IServerNetworkChannel clothSystemChannel;

		public double RenderOrder => 1.0;

		public int RenderRange => 12;

		public override double ExecuteOrder()
		{
			return 0.4;
		}

		public override void Start(ICoreAPI api)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Expected O, but got Unknown
			((ModSystem)this).Start(api);
			this.api = api;
			partPhysics = new ParticlePhysics(api.World.GetLockFreeBlockAccessor());
			partPhysics.PhysicsTickTime = 1f / 60f;
			partPhysics.MotionCap = 10f;
			api.Network.RegisterChannel("clothphysics").RegisterMessageType<UnregisterClothSystemPacket>().RegisterMessageType<ClothSystemPacket>()
				.RegisterMessageType<ClothPointPacket>()
				.RegisterMessageType<ClothLengthPacket>();
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Expected O, but got Unknown
			capi = api;
			((ICoreAPI)api).ChatCommands.GetOrCreate("debug").BeginSubCommand("clothtest").WithDescription("Commands to test the cloth system")
				.BeginSubCommand("clear")
				.WithDescription("clears")
				.HandleWith(new OnCommandDelegate(onClothTestClear))
				.EndSubCommand()
				.EndSubCommand();
			api.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)1, "clothsimu");
			api.Event.BlockTexturesLoaded += Event_BlockTexturesLoaded;
			api.Network.GetChannel("clothphysics").SetMessageHandler<UnregisterClothSystemPacket>((NetworkServerMessageHandler<UnregisterClothSystemPacket>)onUnregPacketClient).SetMessageHandler<ClothSystemPacket>((NetworkServerMessageHandler<ClothSystemPacket>)onRegPacketClient)
				.SetMessageHandler<ClothPointPacket>((NetworkServerMessageHandler<ClothPointPacket>)onPointPacketClient)
				.SetMessageHandler<ClothLengthPacket>((NetworkServerMessageHandler<ClothLengthPacket>)onLengthPacketClient);
			api.Event.LeaveWorld += Event_LeaveWorld;
		}

		public ClothSystem GetClothSystem(int clothid)
		{
			clothSystems.TryGetValue(clothid, out var value);
			return value;
		}

		public ClothSystem GetClothSystemAttachedToBlock(BlockPos pos)
		{
			foreach (ClothSystem value in clothSystems.Values)
			{
				if (value.FirstPoint.PinnedToBlockPos == pos || value.LastPoint.PinnedToBlockPos == pos)
				{
					return value;
				}
			}
			return null;
		}

		public void OnRenderFrame(float dt, EnumRenderStage stage)
		{
			if (updateMesh == null)
			{
				return;
			}
			dt = Math.Min(dt, 0.5f);
			if (!capi.IsGamePaused)
			{
				tickPhysics(dt);
			}
			accum100ms += dt;
			if ((double)accum100ms > 0.1)
			{
				accum100ms = 0f;
				if (clothSystems.Count > 0)
				{
					float num = -1f;
					ClothSystem clothSystem = null;
					float num2 = 0.4f;
					foreach (KeyValuePair<int, ClothSystem> clothSystem2 in clothSystems)
					{
						ClothSystem value = clothSystem2.Value;
						if (value.MaxExtension > (double)value.StretchWarn)
						{
							value.secondsOverStretched += dt;
						}
						else
						{
							value.secondsOverStretched = 0f;
						}
						if (value.MaxExtension > (double)num)
						{
							num = (float)value.MaxExtension;
							clothSystem = value;
							num2 = value.StretchWarn;
						}
					}
					if (num > num2 && (double)clothSystem.secondsOverStretched > 0.2)
					{
						float num3 = 10f * (num - num2);
						if (!stretchSound.IsPlaying)
						{
							stretchSound.Start();
						}
						stretchSound.SetPosition((float)clothSystem.CenterPosition.X, (float)clothSystem.CenterPosition.Y, (float)clothSystem.CenterPosition.Z);
						stretchSound.SetVolume(GameMath.Clamp(num3, 0.5f, 1f));
						stretchSound.SetPitch(GameMath.Clamp(num3 + 0.7f, 0.7f, 1.2f));
					}
					else
					{
						stretchSound.Stop();
					}
				}
				else
				{
					stretchSound.Stop();
				}
			}
			int num4 = 0;
			((CustomMeshDataPart<float>)(object)updateMesh.CustomFloats).Count = 0;
			foreach (KeyValuePair<int, ClothSystem> clothSystem3 in clothSystems)
			{
				if (clothSystem3.Value.Active)
				{
					num4 += clothSystem3.Value.UpdateMesh(updateMesh, dt);
					((CustomMeshDataPart<float>)(object)updateMesh.CustomFloats).Count = num4 * 20;
				}
			}
			if (num4 > 0)
			{
				if (prog.Disposed)
				{
					prog = capi.Shader.GetProgramByName("instanced");
				}
				capi.Render.GlToggleBlend(false, (EnumBlendMode)0);
				prog.Use();
				prog.BindTexture2D("tex", ((ITextureAtlasAPI)capi.ItemTextureAtlas).Positions[0].atlasTextureId, 0);
				prog.Uniform("rgbaFogIn", capi.Render.FogColor);
				prog.Uniform("rgbaAmbientIn", capi.Render.AmbientColor);
				prog.Uniform("fogMinIn", capi.Render.FogMin);
				prog.Uniform("fogDensityIn", capi.Render.FogDensity);
				prog.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
				prog.UniformMatrix("modelViewMatrix", capi.Render.CameraMatrixOriginf);
				((CustomMeshDataPart<float>)(object)updateMesh.CustomFloats).Count = num4 * 20;
				capi.Render.UpdateMesh(ropeMeshRef, updateMesh);
				capi.Render.RenderMeshInstanced(ropeMeshRef, num4);
				prog.Stop();
			}
			foreach (KeyValuePair<int, ClothSystem> clothSystem4 in clothSystems)
			{
				if (clothSystem4.Value.Active)
				{
					clothSystem4.Value.CustomRender(dt);
				}
			}
		}

		private void tickPhysics(float dt)
		{
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Expected O, but got Unknown
			//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fe: Expected O, but got Unknown
			//IL_0231: Unknown result type (might be due to invalid IL or missing references)
			//IL_0245: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Expected O, but got Unknown
			//IL_0260: Expected O, but got Unknown
			//IL_0455: Unknown result type (might be due to invalid IL or missing references)
			//IL_045f: Expected O, but got Unknown
			//IL_0480: Unknown result type (might be due to invalid IL or missing references)
			//IL_048a: Expected O, but got Unknown
			//IL_04ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b8: Expected O, but got Unknown
			//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_04db: Expected O, but got Unknown
			foreach (KeyValuePair<int, ClothSystem> clothSystem2 in clothSystems)
			{
				if (clothSystem2.Value.Active)
				{
					clothSystem2.Value.updateFixedStep(dt);
				}
			}
			if (sapi == null)
			{
				return;
			}
			List<int> list = new List<int>();
			accum100ms += dt;
			if (accum100ms > 0.1f)
			{
				accum100ms = 0f;
				List<ClothPointPacket> list2 = new List<ClothPointPacket>();
				foreach (KeyValuePair<int, ClothSystem> clothSystem3 in clothSystems)
				{
					ClothSystem value = clothSystem3.Value;
					value.CollectDirtyPoints(list2);
					if (value.MaxExtension > (double)value.StretchRip)
					{
						value.secondsOverStretched += 0.1f;
						if ((double)value.secondsOverStretched > 4.0 - value.MaxExtension * 2.0)
						{
							Vec3d val = value.CenterPosition;
							if (value.FirstPoint.PinnedToEntity != null)
							{
								val = value.FirstPoint.PinnedToEntity.Pos.XYZ;
							}
							((IWorldAccessor)sapi.World).PlaySoundAt(new AssetLocation("sounds/effect/roperip"), val.X, val.Y, val.Z, (IPlayer)null, true, 32f, 1f);
							ClothPoint firstPoint = value.FirstPoint;
							Vec3d val2 = value.LastPoint.Pos - firstPoint.Pos;
							double num = val2.Length();
							for (float num2 = 0f; (double)num2 < num; num2 += 0.15f)
							{
								Vec3d val3 = new Vec3d(firstPoint.Pos.X + val2.X * (double)num2 / num, firstPoint.Pos.Y + val2.Y * (double)num2 / num, firstPoint.Pos.Z + val2.Z * (double)num2 / num);
								((IWorldAccessor)sapi.World).SpawnParticles(2f, ColorUtil.ColorFromRgba(60, 97, 115, 255), val3, val3, new Vec3f(-4f, -1f, -4f), new Vec3f(4f, 2f, 4f), 2f, 1f, 0.5f, (EnumParticleModel)1, (IPlayer)null);
							}
							list.Add(clothSystem3.Key);
						}
					}
					else
					{
						value.secondsOverStretched = 0f;
					}
				}
				foreach (ClothPointPacket item in list2)
				{
					clothSystemChannel.BroadcastPacket<ClothPointPacket>(item, Array.Empty<IServerPlayer>());
				}
			}
			accum3s += dt;
			if (accum3s > 3f)
			{
				accum3s = 0f;
				foreach (KeyValuePair<int, ClothSystem> clothSystem4 in clothSystems)
				{
					if (!clothSystem4.Value.PinnedAnywhere)
					{
						list.Add(clothSystem4.Key);
					}
					else
					{
						clothSystem4.Value.slowTick3s();
					}
				}
			}
			foreach (int id in list)
			{
				bool spawnitem = true;
				ClothSystem clothSystem = clothSystems[id];
				bool num3 = spawnitem;
				Entity pinnedToEntity = clothSystem.FirstPoint.PinnedToEntity;
				Entity obj = ((pinnedToEntity is EntityItem) ? pinnedToEntity : null);
				object obj2;
				if (obj == null)
				{
					obj2 = null;
				}
				else
				{
					ItemStack itemstack = ((EntityItem)obj).Itemstack;
					obj2 = ((itemstack != null) ? ((RegistryObject)itemstack.Collectible).Code.Path : null);
				}
				int num4;
				if ((string?)obj2 != "rope")
				{
					Entity pinnedToEntity2 = clothSystem.LastPoint.PinnedToEntity;
					Entity obj3 = ((pinnedToEntity2 is EntityItem) ? pinnedToEntity2 : null);
					object obj4;
					if (obj3 == null)
					{
						obj4 = null;
					}
					else
					{
						ItemStack itemstack2 = ((EntityItem)obj3).Itemstack;
						obj4 = ((itemstack2 != null) ? ((RegistryObject)itemstack2.Collectible).Code.Path : null);
					}
					num4 = (((string?)obj4 != "rope") ? 1 : 0);
				}
				else
				{
					num4 = 0;
				}
				spawnitem = (byte)((num3 ? 1u : 0u) & (uint)num4) != 0;
				Entity pinnedToEntity3 = clothSystem.FirstPoint.PinnedToEntity;
				EntityAgent val4 = (EntityAgent)(object)((pinnedToEntity3 is EntityAgent) ? pinnedToEntity3 : null);
				if (val4 != null)
				{
					val4.WalkInventory((OnInventorySlot)delegate(ItemSlot slot)
					{
						if (slot.Empty)
						{
							return true;
						}
						ITreeAttribute attributes = slot.Itemstack.Attributes;
						if (((attributes != null) ? attributes.GetInt("clothId", 0) : 0) == id)
						{
							spawnitem = false;
							slot.Itemstack.Attributes.RemoveAttribute("clothId");
							slot.Itemstack.Attributes.RemoveAttribute("ropeHeldByEntityId");
							return false;
						}
						return true;
					});
				}
				Entity pinnedToEntity4 = clothSystem.LastPoint.PinnedToEntity;
				EntityAgent val5 = (EntityAgent)(object)((pinnedToEntity4 is EntityAgent) ? pinnedToEntity4 : null);
				if (val5 != null)
				{
					val5.WalkInventory((OnInventorySlot)delegate(ItemSlot slot)
					{
						if (slot.Empty)
						{
							return true;
						}
						ITreeAttribute attributes = slot.Itemstack.Attributes;
						if (((attributes != null) ? attributes.GetInt("clothId", 0) : 0) == id)
						{
							spawnitem = false;
							slot.Itemstack.Attributes.RemoveAttribute("clothId");
							slot.Itemstack.Attributes.RemoveAttribute("ropeHeldByEntityId");
							return false;
						}
						return true;
					});
				}
				if (spawnitem)
				{
					((IWorldAccessor)sapi.World).SpawnItemEntity(new ItemStack(((IWorldAccessor)sapi.World).GetItem(new AssetLocation("rope")), 1), clothSystems[id].CenterPosition, (Vec3d)null);
				}
				else if (clothSystem.FirstPoint.PinnedToEntity is EntityItem && clothSystem.LastPoint.PinnedToEntity is EntityPlayer)
				{
					clothSystem.FirstPoint.PinnedToEntity.Die((EnumDespawnReason)7, (DamageSource)null);
				}
				UnregisterCloth(id);
			}
		}

		public override bool ShouldLoad(EnumAppSide side)
		{
			return true;
		}

		private void Event_LeaveWorld()
		{
			MeshRef obj = ropeMeshRef;
			if (obj != null)
			{
				obj.Dispose();
			}
		}

		private void onPointPacketClient(ClothPointPacket msg)
		{
			if (clothSystems.TryGetValue(msg.ClothId, out var value))
			{
				value.updatePoint(msg);
			}
		}

		private void onLengthPacketClient(ClothLengthPacket msg)
		{
			if (clothSystems.TryGetValue(msg.ClothId, out var value))
			{
				value.ChangeRopeLength(msg.LengthChange);
			}
		}

		private void onRegPacketClient(ClothSystemPacket msg)
		{
			ClothSystem[] array = msg.ClothSystems;
			foreach (ClothSystem clothSystem in array)
			{
				clothSystem.Init((ICoreAPI)(object)capi, this);
				clothSystem.restoreReferences();
				clothSystems[clothSystem.ClothId] = clothSystem;
			}
		}

		private void onUnregPacketClient(UnregisterClothSystemPacket msg)
		{
			int[] clothIds = msg.ClothIds;
			foreach (int clothId in clothIds)
			{
				UnregisterCloth(clothId);
			}
		}

		private void Event_BlockTexturesLoaded()
		{
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Expected O, but got Unknown
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Expected O, but got Unknown
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Expected O, but got Unknown
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Expected O, but got Unknown
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Expected O, but got Unknown
			if (stretchSound == null)
			{
				stretchSound = capi.World.LoadSound(new SoundParams
				{
					Location = new AssetLocation("sounds/effect/ropestretch"),
					DisposeOnFinish = false,
					ShouldLoop = true,
					SoundType = (EnumSoundType)0,
					Volume = 0.5f,
					ReferenceDistance = 5f
				});
			}
			prog = capi.Shader.GetProgramByName("instanced");
			Item item = ((IWorldAccessor)capi.World).GetItem(new AssetLocation("rope"));
			Shape val = Shape.TryGet((ICoreAPI)(object)capi, "shapes/item/ropesection.json");
			if (item != null && val != null)
			{
				MeshData val2 = default(MeshData);
				capi.Tesselator.TesselateShape((CollectibleObject)(object)item, val, ref val2, (Vec3f)null, (int?)null, (string[])null);
				updateMesh = new MeshData(false);
				MeshData obj = updateMesh;
				CustomMeshDataPartFloat val3 = new CustomMeshDataPartFloat(202000);
				((CustomMeshDataPart<float>)(object)val3).Instanced = true;
				((CustomMeshDataPart<float>)(object)val3).InterleaveOffsets = new int[5] { 0, 16, 32, 48, 64 };
				((CustomMeshDataPart<float>)(object)val3).InterleaveSizes = new int[5] { 4, 4, 4, 4, 4 };
				((CustomMeshDataPart<float>)(object)val3).InterleaveStride = 80;
				((CustomMeshDataPart<float>)(object)val3).StaticDraw = false;
				obj.CustomFloats = val3;
				((CustomMeshDataPart<float>)(object)updateMesh.CustomFloats).SetAllocationSize(202000);
				val2.CustomFloats = updateMesh.CustomFloats;
				ropeMeshRef = capi.Render.UploadMesh(val2);
				((CustomMeshDataPart<float>)(object)updateMesh.CustomFloats).Count = 0;
			}
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Expected O, but got Unknown
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Expected O, but got Unknown
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Expected O, but got Unknown
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Expected O, but got Unknown
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Expected O, but got Unknown
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Expected O, but got Unknown
			//IL_0187: Unknown result type (might be due to invalid IL or missing references)
			//IL_0191: Expected O, but got Unknown
			sapi = api;
			((ModSystem)this).StartServerSide(api);
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)tickPhysics, 30, 0);
			((IEventAPI)api.Event).MapRegionLoaded += new MapRegionLoadedDelegate(Event_MapRegionLoaded);
			((IEventAPI)api.Event).MapRegionUnloaded += new MapRegionUnloadDelegate(Event_MapRegionUnloaded);
			api.Event.SaveGameLoaded += Event_SaveGameLoaded;
			api.Event.GameWorldSave += Event_GameWorldSave;
			api.Event.ServerRunPhase((EnumServerRunPhase)8, (Action)onNowRunGame);
			api.Event.PlayerJoin += new PlayerDelegate(Event_PlayerJoin);
			clothSystemChannel = api.Network.GetChannel("clothphysics");
			((ICoreAPI)api).ChatCommands.GetOrCreate("debug").BeginSubCommand("clothtest").WithDescription("Commands to test the cloth system")
				.BeginSubCommand("cloth")
				.WithDescription("cloth")
				.HandleWith(new OnCommandDelegate(onClothTestCloth))
				.EndSubCommand()
				.BeginSubCommand("rope")
				.WithDescription("rope")
				.HandleWith(new OnCommandDelegate(onClothTestRope))
				.EndSubCommand()
				.BeginSubCommand("clear")
				.WithDescription("clears")
				.HandleWith(new OnCommandDelegate(onClothTestClearServer))
				.EndSubCommand()
				.BeginSubCommand("deleteloaded")
				.WithDescription("deleteloaded")
				.HandleWith(new OnCommandDelegate(onClothTestDeleteloaded))
				.EndSubCommand()
				.EndSubCommand();
		}

		private void onNowRunGame()
		{
			foreach (ClothSystem value in clothSystems.Values)
			{
				value.updateActiveState(EnumActiveStateChange.Default);
			}
		}

		private void Event_PlayerJoin(IServerPlayer byPlayer)
		{
			if (clothSystems.Values.Count > 0)
			{
				clothSystemChannel.BroadcastPacket<ClothSystemPacket>(new ClothSystemPacket
				{
					ClothSystems = clothSystems.Values.ToArray()
				}, Array.Empty<IServerPlayer>());
			}
		}

		private void Event_GameWorldSave()
		{
			byte[] data = sapi.WorldManager.SaveGame.GetData("nextClothId");
			if (data != null)
			{
				nextClothId = SerializerUtil.Deserialize<int>(data);
			}
		}

		private void Event_SaveGameLoaded()
		{
			sapi.WorldManager.SaveGame.StoreData("nextClothId", SerializerUtil.Serialize<int>(nextClothId));
		}

		private void Event_MapRegionUnloaded(Vec2i mapCoord, IMapRegion region)
		{
			List<ClothSystem> list = new List<ClothSystem>();
			int regionSize = sapi.WorldManager.RegionSize;
			foreach (ClothSystem value in clothSystems.Values)
			{
				BlockPos asBlockPos = value.FirstPoint.Pos.AsBlockPos;
				int num = asBlockPos.X / regionSize;
				int num2 = asBlockPos.Z / regionSize;
				if (num == mapCoord.X && num2 == mapCoord.Y)
				{
					list.Add(value);
				}
			}
			region.SetModdata("clothSystems", SerializerUtil.Serialize<List<ClothSystem>>(list));
			if (list.Count == 0)
			{
				return;
			}
			int[] array = new int[list.Count];
			for (int i = 0; i < list.Count; i++)
			{
				clothSystems.Remove(list[i].ClothId);
				array[i] = list[i].ClothId;
			}
			foreach (ClothSystem value2 in clothSystems.Values)
			{
				value2.updateActiveState(EnumActiveStateChange.RegionNowUnloaded);
			}
			if (!sapi.Server.IsShuttingDown)
			{
				clothSystemChannel.BroadcastPacket<UnregisterClothSystemPacket>(new UnregisterClothSystemPacket
				{
					ClothIds = array
				}, Array.Empty<IServerPlayer>());
			}
		}

		private void Event_MapRegionLoaded(Vec2i mapCoord, IMapRegion region)
		{
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Invalid comparison between Unknown and I4
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Invalid comparison between Unknown and I4
			byte[] moddata = region.GetModdata("clothSystems");
			if (moddata != null && moddata.Length != 0)
			{
				List<ClothSystem> list = SerializerUtil.Deserialize<List<ClothSystem>>(moddata);
				if ((int)sapi.Server.CurrentRunPhase < 8)
				{
					foreach (ClothSystem item in list)
					{
						item.Active = false;
						item.Init(api, this);
						clothSystems[item.ClothId] = item;
					}
					return;
				}
				foreach (ClothSystem value in clothSystems.Values)
				{
					value.updateActiveState(EnumActiveStateChange.RegionNowLoaded);
				}
				foreach (ClothSystem item2 in list)
				{
					item2.Init(api, this);
					item2.restoreReferences();
					clothSystems[item2.ClothId] = item2;
				}
				if (list.Count > 0)
				{
					clothSystemChannel.BroadcastPacket<ClothSystemPacket>(new ClothSystemPacket
					{
						ClothSystems = list.ToArray()
					}, Array.Empty<IServerPlayer>());
				}
			}
			else
			{
				if ((int)sapi.Server.CurrentRunPhase < 8)
				{
					return;
				}
				foreach (ClothSystem value2 in clothSystems.Values)
				{
					value2.updateActiveState(EnumActiveStateChange.RegionNowLoaded);
				}
			}
		}

		private TextCommandResult onClothTestClearServer(TextCommandCallingArgs args)
		{
			int count = clothSystems.Count;
			int[] array = clothSystems.Select((KeyValuePair<int, ClothSystem> s) => s.Value.ClothId).ToArray();
			if (array.Length != 0)
			{
				clothSystemChannel.BroadcastPacket<UnregisterClothSystemPacket>(new UnregisterClothSystemPacket
				{
					ClothIds = array
				}, Array.Empty<IServerPlayer>());
			}
			clothSystems.Clear();
			nextClothId = 1;
			return TextCommandResult.Success(count + " cloth sims removed", (object)null);
		}

		private TextCommandResult onClothTestDeleteloaded(TextCommandCallingArgs args)
		{
			int num = 0;
			foreach (KeyValuePair<long, IMapRegion> allLoadedMapRegion in sapi.WorldManager.AllLoadedMapRegions)
			{
				allLoadedMapRegion.Value.RemoveModdata("clothSystems");
				num++;
			}
			clothSystems.Clear();
			nextClothId = 1;
			return TextCommandResult.Success($"Ok, deleted in {num} regions", (object)null);
		}

		public void RegisterCloth(ClothSystem sys)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			if ((int)api.Side != 2)
			{
				sys.ClothId = nextClothId++;
				clothSystems[sys.ClothId] = sys;
				sys.updateActiveState(EnumActiveStateChange.Default);
				clothSystemChannel.BroadcastPacket<ClothSystemPacket>(new ClothSystemPacket
				{
					ClothSystems = new ClothSystem[1] { sys }
				}, Array.Empty<IServerPlayer>());
			}
		}

		public void UnregisterCloth(int clothId)
		{
			if (sapi != null)
			{
				clothSystemChannel.BroadcastPacket<UnregisterClothSystemPacket>(new UnregisterClothSystemPacket
				{
					ClothIds = new int[1] { clothId }
				}, Array.Empty<IServerPlayer>());
			}
			clothSystems.Remove(clothId);
		}

		private TextCommandResult onClothTestClear(TextCommandCallingArgs textCommandCallingArgs)
		{
			int count = clothSystems.Count;
			clothSystems.Clear();
			nextClothId = 1;
			return TextCommandResult.Success(count + " cloth sims removed", (object)null);
		}

		private TextCommandResult onClothTestCloth(TextCommandCallingArgs args)
		{
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Expected O, but got Unknown
			float num = 0.5f + (float)api.World.Rand.NextDouble() * 3f;
			float num2 = 0.5f + (float)api.World.Rand.NextDouble() * 3f;
			float num3 = 0.5f + (float)api.World.Rand.NextDouble() * 3f;
			Vec3d val = args.Caller.Entity.Pos.AheadCopy(2.0).XYZ.Add(0.0, 1.0, 0.0);
			ClothSystem clothSystem = ClothSystem.CreateCloth(api, this, val, val.AddCopy(num, num2, num3));
			RegisterCloth(clothSystem);
			clothSystem.FirstPoint.PinTo(args.Caller.Entity, new Vec3f(0f, 0.5f, 0f));
			return TextCommandResult.Success("", (object)null);
		}

		private TextCommandResult onClothTestRope(TextCommandCallingArgs args)
		{
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Expected O, but got Unknown
			float num = 0.5f + (float)api.World.Rand.NextDouble() * 3f;
			float num2 = 0.5f + (float)api.World.Rand.NextDouble() * 3f;
			num = 5f;
			Vec3d val = args.Caller.Entity.Pos.AheadCopy(2.0).XYZ.Add(0.0, 1.0, 0.0);
			ClothSystem clothSystem = ClothSystem.CreateRope(api, this, val, val.AddCopy(num, num2, num), null);
			clothSystem.FirstPoint.PinTo(args.Caller.Entity, new Vec3f(0f, 0.5f, 0f));
			RegisterCloth(clothSystem);
			return TextCommandResult.Success("", (object)null);
		}
	}
	[ProtoContract]
	public class ClothPoint
	{
		public static bool PushingPhysics;

		[ProtoMember(1)]
		public int PointIndex;

		[ProtoMember(2)]
		public float Mass;

		[ProtoMember(3)]
		public float InvMass;

		[ProtoMember(4)]
		public Vec3d Pos;

		[ProtoMember(5)]
		public Vec3f Velocity = new Vec3f();

		[ProtoMember(6)]
		public Vec3f Tension = new Vec3f();

		[ProtoMember(7)]
		private float GravityStrength = 1f;

		[ProtoMember(8)]
		private bool pinned;

		[ProtoMember(9)]
		public long pinnedToEntityId;

		[ProtoMember(10)]
		private BlockPos pinnedToBlockPos;

		[ProtoMember(11)]
		public Vec3f pinnedToOffset;

		[ProtoMember(12)]
		private float pinnedToOffsetStartYaw;

		[ProtoMember(13)]
		private string pinnedToPlayerUid;

		public EnumCollideFlags CollideFlags;

		public float YCollideRestMul;

		private Vec4f tmpvec = new Vec4f();

		private ClothSystem cs;

		private Entity pinnedTo;

		private Matrixf pinOffsetTransform;

		public Vec3d TensionDirection = new Vec3d();

		public double extension;

		private float dampFactor = 0.9f;

		private float accum1s;

		public bool Dirty { get; internal set; }

		public Entity PinnedToEntity => pinnedTo;

		public BlockPos PinnedToBlockPos => pinnedToBlockPos;

		public bool Pinned => pinned;

		public ClothPoint(ClothSystem cs)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Expected O, but got Unknown
			this.cs = cs;
			Pos = new Vec3d();
			init();
		}

		protected ClothPoint()
		{
		}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown


		public ClothPoint(ClothSystem cs, int pointIndex, double x, double y, double z)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Expected O, but got Unknown
			this.cs = cs;
			PointIndex = pointIndex;
			Pos = new Vec3d(x, y, z);
			init();
		}

		public void setMass(float mass)
		{
			Mass = mass;
			InvMass = 1f / mass;
		}

		private void init()
		{
			setMass(1f);
		}

		public void PinTo(Entity toEntity, Vec3f pinOffset)
		{
			pinned = true;
			pinnedTo = toEntity;
			pinnedToEntityId = toEntity.EntityId;
			pinnedToOffset = pinOffset;
			pinnedToOffsetStartYaw = toEntity.SidedPos.Yaw;
			pinOffsetTransform = Matrixf.Create();
			pinnedToBlockPos = null;
			EntityPlayer val = (EntityPlayer)(object)((toEntity is EntityPlayer) ? toEntity : null);
			if (val != null)
			{
				pinnedToPlayerUid = val.PlayerUID;
			}
			MarkDirty();
		}

		public void PinTo(BlockPos blockPos, Vec3f offset)
		{
			pinnedToBlockPos = blockPos;
			pinnedToOffset = offset;
			pinnedToPlayerUid = null;
			pinned = true;
			Pos.Set(pinnedToBlockPos).Add(pinnedToOffset);
			pinnedTo = null;
			pinnedToEntityId = 0L;
			MarkDirty();
		}

		public void UnPin()
		{
			pinned = false;
			pinnedTo = null;
			pinnedToPlayerUid = null;
			pinnedToEntityId = 0L;
			MarkDirty();
		}

		public void MarkDirty()
		{
			Dirty = true;
		}

		public void update(float dt, IWorldAccessor world)
		{
			//IL_071d: Unknown result type (might be due to invalid IL or missing references)
			//IL_07ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_07b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Invalid comparison between Unknown and I4
			//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Expected O, but got Unknown
			//IL_026b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0275: Expected O, but got Unknown
			//IL_0398: Unknown result type (might be due to invalid IL or missing references)
			//IL_039f: Expected O, but got Unknown
			//IL_0510: Unknown result type (might be due to invalid IL or missing references)
			//IL_051c: Expected O, but got Unknown
			//IL_0630: Unknown result type (might be due to invalid IL or missing references)
			//IL_063c: Expected O, but got Unknown
			if (pinnedTo == null && pinnedToPlayerUid != null)
			{
				IPlayer obj = world.PlayerByUid(pinnedToPlayerUid);
				EntityPlayer val = ((obj != null) ? obj.Entity : null);
				if (((Entity)(val?)).World != null)
				{
					PinTo((Entity)(object)val, pinnedToOffset);
				}
			}
			if (pinned)
			{
				if (pinnedTo != null)
				{
					Entity val2 = pinnedTo;
					Entity obj2 = ((val2 is EntityAgent) ? val2 : null);
					object obj3;
					if (obj2 == null)
					{
						obj3 = null;
					}
					else
					{
						IMountableSeat mountedOn = ((EntityAgent)obj2).MountedOn;
						obj3 = ((mountedOn != null) ? mountedOn.Entity : null);
					}
					if (obj3 == null)
					{
						obj3 = val2;
					}
					val2 = (Entity)obj3;
					if (val2.ShouldDespawn)
					{
						EntityDespawnData despawnReason = val2.DespawnReason;
						if (despawnReason == null || (int)despawnReason.Reason != 4)
						{
							UnPin();
							return;
						}
					}
					float weight = val2.Properties.Weight;
					float num = GameMath.Clamp(50f / weight, 0.1f, 2f);
					Entity obj4 = ((val2 is EntityAgent) ? val2 : null);
					int num2;
					if (obj4 == null || !((EntityAgent)obj4).Controls.Sneak)
					{
						if (val2 is EntityPlayer)
						{
							IAnimationManager animManager = val2.AnimManager;
							if (animManager == null || !animManager.IsAnimationActive(new string[1] { "sit" }))
							{
								IAnimationManager animManager2 = val2.AnimManager;
								num2 = ((animManager2 != null && animManager2.IsAnimationActive(new string[1] { "sleep" })) ? 1 : 0);
							}
							else
							{
								num2 = 1;
							}
						}
						else
						{
							num2 = 0;
						}
					}
					else
					{
						num2 = 1;
					}
					bool flag = (byte)num2 != 0;
					float num3 = weight / 10f * (float)((!flag) ? 1 : 200);
					Entity obj5 = pinnedTo;
					EntityPlayer val3 = (EntityPlayer)(object)((obj5 is EntityPlayer) ? obj5 : null);
					Entity obj6 = pinnedTo;
					EntityAgent val4 = (EntityAgent)(object)((obj6 is EntityAgent) ? obj6 : null);
					object obj7;
					if (val3 == null)
					{
						obj7 = null;
					}
					else
					{
						IAnimationManager animManager3 = ((Entity)val3).AnimManager;
						if (animManager3 == null)
						{
							obj7 = null;
						}
						else
						{
							IAnimator animator = animManager3.Animator;
							obj7 = ((animator != null) ? animator.GetAttachmentPointPose("RightHand") : null);
						}
					}
					AttachmentPointAndPose val5 = (AttachmentPointAndPose)obj7;
					if (val5 == null)
					{
						Entity obj8 = pinnedTo;
						object obj9;
						if (obj8 == null)
						{
							obj9 = null;
						}
						else
						{
							IAnimationManager animManager4 = obj8.AnimManager;
							if (animManager4 == null)
							{
								obj9 = null;
							}
							else
							{
								IAnimator animator2 = animManager4.Animator;
								obj9 = ((animator2 != null) ? animator2.GetAttachmentPointPose("rope") : null);
							}
						}
						val5 = (AttachmentPointAndPose)obj9;
					}
					Vec4f val7;
					if (val5 != null)
					{
						Matrixf val6 = new Matrixf();
						if (val3 != null)
						{
							val6.RotateY(val4.BodyYaw + (float)Math.PI / 2f);
						}
						else
						{
							val6.RotateY(pinnedTo.SidedPos.Yaw + (float)Math.PI / 2f);
						}
						val6.Translate(-0.5, 0.0, -0.5);
						val5.MulUncentered(val6);
						val7 = val6.TransformVector(new Vec4f(0f, 0f, 0f, 1f));
					}
					else
					{
						pinOffsetTransform.Identity();
						pinOffsetTransform.RotateY(pinnedTo.SidedPos.Yaw - pinnedToOffsetStartYaw);
						tmpvec.Set(pinnedToOffset.X, pinnedToOffset.Y, pinnedToOffset.Z, 1f);
						val7 = pinOffsetTransform.TransformVector(tmpvec);
					}
					EntityPos sidedPos = pinnedTo.SidedPos;
					Pos.Set(sidedPos.X + (double)val7.X, sidedPos.Y + (double)val7.Y, sidedPos.Z + (double)val7.Z);
					if (true && extension > 0.0)
					{
						float num4 = num * dt * 0.006f;
						Vec3d val8 = TensionDirection.Clone();
						val8.Normalize();
						double num5 = num3 * 1.65f;
						double num6 = num3;
						Vec3d val9 = new Vec3d(val8.X, 0.0, val8.Z);
						double num7 = val9.Length();
						if (num7 > 0.001)
						{
							val9 /= num7;
						}
						else
						{
							val9.Set(0.0, 0.0, 0.0);
						}
						_ = val8.Y;
						double num8 = Math.Sqrt(num5 * num5 + num6 * num6);
						double num9 = num3 * 1.65f;
						double num10 = num5 - num9;
						double num11 = num9 + num10;
						double num12 = Math.Sqrt(num11 * num11 + num6 * num6);
						double num13 = 0.0 - num6;
						bool onGround = val2.OnGround;
						bool flag2 = extension > 0.05;
						if (flag2 && onGround)
						{
							Vec3d val10 = new Vec3d(GameMath.Clamp(Math.Abs(TensionDirection.X) + num12 - num8, 0.0, 400.0) * (double)Math.Sign(TensionDirection.X), GameMath.Clamp(Math.Abs(TensionDirection.Y) + num12 - num8 + num13, 0.0, 400.0) * (double)Math.Sign(TensionDirection.Y), GameMath.Clamp(Math.Abs(TensionDirection.Z) + num12 - num8, 0.0, 400.0) * (double)Math.Sign(TensionDirection.Z)) * num4;
							val2.SidedPos.Motion.Add(val10);
						}
						else if (flag2)
						{
							Vec3d val11 = new Vec3d(GameMath.Clamp(Math.Abs(TensionDirection.X * 0.1) + (num12 - num8) * 0.5, 0.0, 400.0) * (double)Math.Sign(TensionDirection.X), GameMath.Clamp(Math.Abs(TensionDirection.Y * 0.3) + num12 - num8 + num13, 0.0, 400.0) * (double)Math.Sign(TensionDirection.Y), GameMath.Clamp(Math.Abs(TensionDirection.Z * 0.1) + (num12 - num8) * 0.5, 0.0, 400.0) * (double)Math.Sign(TensionDirection.Z)) * num4;
							val2.SidedPos.Motion.Add(val11);
						}
					}
					Velocity.Set(0f, 0f, 0f);
					return;
				}
				Velocity.Set(0f, 0f, 0f);
				if (!(pinnedToBlockPos != (BlockPos)null))
				{
					return;
				}
				accum1s += dt;
				if (accum1s >= 1f)
				{
					accum1s = 0f;
					if (!((CollectibleObject)cs.api.World.BlockAccessor.GetBlock(PinnedToBlockPos)).HasBehavior<BlockBehaviorRopeTieable>(false))
					{
						UnPin();
					}
				}
			}
			else
			{
				Vec3f obj10 = Tension.Clone();
				obj10.Y -= GravityStrength * 10f;
				Vec3f val12 = obj10 * InvMass;
				if ((int)CollideFlags == 0)
				{
					val12.X += (float)cs.windSpeed.X * InvMass;
				}
				Vec3f val13 = Velocity + val12 * dt;
				val13 *= dampFactor;
				float num14 = 0.1f;
				cs.pp.HandleBoyancy(Pos, val13, cs.boyant, GravityStrength, dt, num14);
				CollideFlags = cs.pp.UpdateMotion(Pos, val13, num14);
				dt *= 0.99f;
				Pos.Add((double)(val13.X * dt), (double)(val13.Y * dt), (double)(val13.Z * dt));
				Velocity.Set(val13);
				Tension.Set(0f, 0f, 0f);
			}
		}

		public void restoreReferences(ClothSystem cs, IWorldAccessor world)
		{
			this.cs = cs;
			if (pinnedToEntityId != 0L)
			{
				pinnedTo = world.GetEntityById(pinnedToEntityId);
				if (pinnedTo != null)
				{
					PinTo(pinnedTo, pinnedToOffset);
				}
			}
			if (pinnedToBlockPos != (BlockPos)null)
			{
				PinTo(pinnedToBlockPos, pinnedToOffset);
			}
		}

		public void restoreReferences(Entity entity)
		{
			if (pinnedToEntityId == entity.EntityId)
			{
				PinTo(entity, pinnedToOffset);
			}
		}

		public void updateFromPoint(ClothPoint point, IWorldAccessor world)
		{
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			PointIndex = point.PointIndex;
			Mass = point.Mass;
			InvMass = point.InvMass;
			Pos.Set(point.Pos);
			Velocity.Set(point.Velocity);
			Tension.Set(point.Tension);
			GravityStrength = point.GravityStrength;
			pinned = point.pinned;
			pinnedToPlayerUid = point.pinnedToPlayerUid;
			pinnedToOffsetStartYaw = point.pinnedToOffsetStartYaw;
			pinnedToEntityId = point.pinnedToEntityId;
			pinnedToBlockPos = PosUtil.SetOrCreate(pinnedToBlockPos, point.PinnedToBlockPos);
			pinnedToOffset = PosUtil.SetOrCreate(pinnedToOffset, point.pinnedToOffset);
			CollideFlags = point.CollideFlags;
			YCollideRestMul = point.YCollideRestMul;
			if (pinnedToEntityId != 0L)
			{
				pinnedTo = world.GetEntityById(pinnedToEntityId);
				if (pinnedTo != null)
				{
					PinTo(pinnedTo, pinnedToOffset);
				}
				else
				{
					UnPin();
				}
			}
			else if (pinnedToBlockPos != (BlockPos)null)
			{
				PinTo(pinnedToBlockPos, pinnedToOffset);
			}
		}
	}
	[ProtoContract]
	public enum EnumClothType
	{
		Rope,
		Cloth
	}
	[ProtoContract]
	public class PointList
	{
		[ProtoMember(1)]
		public List<ClothPoint> Points = new List<ClothPoint>();
	}
	[ProtoContract]
	public class ClothSystem
	{
		[ProtoMember(1)]
		public int ClothId;

		[ProtoMember(2)]
		private EnumClothType clothType;

		[ProtoMember(3)]
		private List<PointList> Points2d = new List<PointList>();

		[ProtoMember(4)]
		private List<ClothConstraint> Constraints = new List<ClothConstraint>();

		public static float Resolution = 2f;

		public float StretchWarn = 0.6f;

		public float StretchRip = 0.75f;

		public bool LineDebug;

		public bool boyant;

		protected ICoreClientAPI capi;

		public ICoreAPI api;

		public Vec3d windSpeed = new Vec3d();

		public ParticlePhysics pp;

		protected NormalizedSimplexNoise noiseGen;

		protected float[] tmpMat = new float[16];

		protected Vec3f distToCam = new Vec3f();

		protected AssetLocation ropeSectionModel;

		protected MeshData debugUpdateMesh;

		protected MeshRef debugMeshRef;

		public float secondsOverStretched;

		private double minLen = 1.5;

		private double maxLen = 10.0;

		private Matrixf mat = new Matrixf();

		private float accum;

		[ProtoMember(5)]
		public bool Active { get; set; }

		public bool PinnedAnywhere
		{
			get
			{
				foreach (PointList item in Points2d)
				{
					foreach (ClothPoint point in item.Points)
					{
						if (point.Pinned)
						{
							return true;
						}
					}
				}
				return false;
			}
		}

		public double MaxExtension
		{
			get
			{
				if (Constraints.Count != 0)
				{
					return Constraints.Max((ClothConstraint c) => c.Extension);
				}
				return 0.0;
			}
		}

		public Vec3d CenterPosition
		{
			get
			{
				//IL_0000: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Expected O, but got Unknown
				Vec3d val = new Vec3d();
				int num = 0;
				foreach (PointList item in Points2d)
				{
					foreach (ClothPoint point in item.Points)
					{
						_ = point;
						num++;
					}
				}
				foreach (PointList item2 in Points2d)
				{
					foreach (ClothPoint point2 in item2.Points)
					{
						val.Add(point2.Pos.X / (double)num, point2.Pos.Y / (double)num, point2.Pos.Z / (double)num);
					}
				}
				return val;
			}
		}

		public ClothPoint FirstPoint => Points2d[0].Points[0];

		public ClothPoint LastPoint
		{
			get
			{
				List<ClothPoint> points = Points2d[Points2d.Count - 1].Points;
				return points[points.Count - 1];
			}
		}

		public ClothPoint[] Ends => new ClothPoint[2] { FirstPoint, LastPoint };

		public static ClothSystem CreateCloth(ICoreAPI api, ClothManager cm, Vec3d start, Vec3d end)
		{
			return new ClothSystem(api, cm, start, end, EnumClothType.Cloth);
		}

		public static ClothSystem CreateRope(ICoreAPI api, ClothManager cm, Vec3d start, Vec3d end, AssetLocation clothSectionModel)
		{
			return new ClothSystem(api, cm, start, end, EnumClothType.Rope, clothSectionModel);
		}

		private ClothSystem()
		{
		}//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Expected O, but got Unknown
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Expected O, but got Unknown


		public bool ChangeRopeLength(double len)
		{
			PointList pointList = Points2d[0];
			double num = (float)pointList.Points.Count / Resolution;
			bool flag = len > 0.0;
			if (flag && len + num > maxLen)
			{
				return false;
			}
			if (!flag && len + num < minLen)
			{
				return false;
			}
			int num2 = pointList.Points.Max((ClothPoint clothPoint2) => clothPoint2.PointIndex) + 1;
			ClothPoint firstPoint = FirstPoint;
			Entity pinnedToEntity = firstPoint.PinnedToEntity;
			BlockPos pinnedToBlockPos = firstPoint.PinnedToBlockPos;
			Vec3f pinnedToOffset = firstPoint.pinnedToOffset;
			firstPoint.UnPin();
			float num3 = 1f / Resolution;
			int num4 = Math.Abs((int)(len * (double)Resolution));
			if (flag)
			{
				for (int num5 = 0; num5 <= num4; num5++)
				{
					pointList.Points.Insert(0, new ClothPoint(this, num2++, firstPoint.Pos.X + (double)(num3 * (float)(num5 + 1)), firstPoint.Pos.Y, firstPoint.Pos.Z));
					ClothPoint p = pointList.Points[0];
					ClothPoint p2 = pointList.Points[1];
					ClothConstraint item = new ClothConstraint(p, p2);
					Constraints.Add(item);
				}
			}
			else
			{
				for (int num6 = 0; num6 <= num4; num6++)
				{
					ClothPoint clothPoint = pointList.Points[0];
					pointList.Points.RemoveAt(0);
					for (int num7 = 0; num7 < Constraints.Count; num7++)
					{
						ClothConstraint clothConstraint = Constraints[num7];
						if (clothConstraint.Point1 == clothPoint || clothConstraint.Point2 == clothPoint)
						{
							Constraints.RemoveAt(num7);
							num7--;
						}
					}
				}
			}
			if (pinnedToEntity != null)
			{
				FirstPoint.PinTo(pinnedToEntity, pinnedToOffset);
			}
			if (pinnedToBlockPos != (BlockPos)null)
			{
				FirstPoint.PinTo(pinnedToBlockPos, pinnedToOffset);
			}
			genDebugMesh();
			return true;
		}

		private ClothSystem(ICoreAPI api, ClothManager cm, Vec3d start, Vec3d end, EnumClothType clothType, AssetLocation ropeSectionModel = null)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Expected O, but got Unknown
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Expected O, but got Unknown
			this.clothType = clothType;
			this.ropeSectionModel = ropeSectionModel;
			Init(api, cm);
			_ = 1f / Resolution;
			Vec3d val = end - start;
			if (clothType == EnumClothType.Rope)
			{
				double num = val.Length();
				PointList pointList = new PointList();
				Points2d.Add(pointList);
				int num2 = (int)(num * (double)Resolution);
				for (int i = 0; i <= num2; i++)
				{
					float num3 = (float)i / (float)num2;
					pointList.Points.Add(new ClothPoint(this, i, start.X + val.X * (double)num3, start.Y + val.Y * (double)num3, start.Z + val.Z * (double)num3));
					if (i > 0)
					{
						ClothPoint p = pointList.Points[i - 1];
						ClothPoint p2 = pointList.Points[i];
						ClothConstraint item = new ClothConstraint(p, p2);
						Constraints.Add(item);
					}
				}
			}
			if (clothType != EnumClothType.Cloth)
			{
				return;
			}
			double num4 = (end - start).HorLength();
			double num5 = Math.Abs(end.Y - start.Y);
			int num6 = (int)(num4 * (double)Resolution);
			int num7 = (int)(num5 * (double)Resolution);
			int num8 = 0;
			for (int j = 0; j < num6; j++)
			{
				Points2d.Add(new PointList());
				for (int k = 0; k < num7; k++)
				{
					double num9 = (double)j / num4;
					double num10 = (double)k / num5;
					Points2d[j].Points.Add(new ClothPoint(this, num8++, start.X + val.X * num9, start.Y + val.Y * num10, start.Z + val.Z * num9));
					if (j > 0)
					{
						ClothPoint p3 = Points2d[j - 1].Points[k];
						ClothPoint p4 = Points2d[j].Points[k];
						ClothConstraint item2 = new ClothConstraint(p3, p4);
						Constraints.Add(item2);
					}
					if (k > 0)
					{
						ClothPoint p5 = Points2d[j].Points[k - 1];
						ClothPoint p6 = Points2d[j].Points[k];
						ClothConstraint item3 = new ClothConstraint(p5, p6);
						Constraints.Add(item3);
					}
				}
			}
		}

		public void genDebugMesh()
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Expected O, but got Unknown
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			if (capi != null)
			{
				MeshRef obj = debugMeshRef;
				if (obj != null)
				{
					obj.Dispose();
				}
				debugUpdateMesh = new MeshData(20, 15, false, false, true, true);
				int num = 0;
				for (int i = 0; i < Constraints.Count; i++)
				{
					_ = Constraints[i];
					int num2 = ((i % 2 > 0) ? (-1) : ColorUtil.BlackArgb);
					debugUpdateMesh.AddVertexSkipTex(0f, 0f, 0f, num2);
					debugUpdateMesh.AddVertexSkipTex(0f, 0f, 0f, num2);
					debugUpdateMesh.AddIndex(num++);
					debugUpdateMesh.AddIndex(num++);
				}
				debugUpdateMesh.mode = (EnumDrawMode)1;
				debugMeshRef = capi.Render.UploadMesh(debugUpdateMesh);
				debugUpdateMesh.Indices = null;
				debugUpdateMesh.Rgba = null;
			}
		}

		public void Init(ICoreAPI api, ClothManager cm)
		{
			this.api = api;
			capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			pp = cm.partPhysics;
			noiseGen = NormalizedSimplexNoise.FromDefaultOctaves(4, 100.0, 0.9, (long)(api.World.Seed + ((object)CenterPosition).GetHashCode()));
		}

		public void WalkPoints(Action<ClothPoint> onPoint)
		{
			foreach (PointList item in Points2d)
			{
				foreach (ClothPoint point in item.Points)
				{
					onPoint(point);
				}
			}
		}

		public int UpdateMesh(MeshData updateMesh, float dt)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Expected O, but got Unknown
			CustomMeshDataPartFloat customFloats = updateMesh.CustomFloats;
			Vec3d cameraPos = ((IPlayer)capi.World.Player).Entity.CameraPos;
			int count = ((CustomMeshDataPart<float>)(object)customFloats).Count;
			Vec4f val = new Vec4f();
			if (Constraints.Count > 0)
			{
				val = api.World.BlockAccessor.GetLightRGBs(Constraints[Constraints.Count / 2].Point1.Pos.AsBlockPos);
			}
			for (int i = 0; i < Constraints.Count; i++)
			{
				ClothConstraint clothConstraint = Constraints[i];
				Vec3d pos = clothConstraint.Point1.Pos;
				Vec3d pos2 = clothConstraint.Point2.Pos;
				double num = pos.X - pos2.X;
				double num2 = pos.Y - pos2.Y;
				double num3 = pos.Z - pos2.Z;
				float num4 = (float)Math.Atan2(num, num3) + (float)Math.PI / 2f;
				float num5 = (float)Math.Atan2(Math.Sqrt(num3 * num3 + num * num), num2) + (float)Math.PI / 2f;
				double num6 = pos.X + (pos.X - pos2.X) / 2.0;
				double num7 = pos.Y + (pos.Y - pos2.Y) / 2.0;
				double num8 = pos.Z + (pos.Z - pos2.Z) / 2.0;
				distToCam.Set((float)(num6 - cameraPos.X), (float)(num7 - cameraPos.Y), (float)(num8 - cameraPos.Z));
				Mat4f.Identity(tmpMat);
				Mat4f.Translate(tmpMat, tmpMat, 0f, 1f / 32f, 0f);
				Mat4f.Translate(tmpMat, tmpMat, distToCam.X, distToCam.Y, distToCam.Z);
				Mat4f.RotateY(tmpMat, tmpMat, num4);
				Mat4f.RotateZ(tmpMat, tmpMat, num5);
				float num9 = (float)i / 5f;
				Mat4f.RotateX(tmpMat, tmpMat, num9);
				float num10 = GameMath.Sqrt(num * num + num2 * num2 + num3 * num3);
				Mat4f.Scale(tmpMat, tmpMat, new float[3] { num10, 1f, 1f });
				Mat4f.Translate(tmpMat, tmpMat, -1.5f, -1f / 32f, -0.5f);
				int num11 = count + i * 20;
				((CustomMeshDataPart<float>)(object)customFloats).Values[num11++] = val.R;
				((CustomMeshDataPart<float>)(object)customFloats).Values[num11++] = val.G;
				((CustomMeshDataPart<float>)(object)customFloats).Values[num11++] = val.B;
				((CustomMeshDataPart<float>)(object)customFloats).Values[num11++] = val.A;
				for (int j = 0; j < 16; j++)
				{
					((CustomMeshDataPart<float>)(object)customFloats).Values[num11 + j] = tmpMat[j];
				}
			}
			return Constraints.Count;
		}

		public void setRenderCenterPos()
		{
			for (int i = 0; i < Constraints.Count; i++)
			{
				ClothConstraint clothConstraint = Constraints[i];
				Vec3d pos = clothConstraint.Point1.Pos;
				Vec3d pos2 = clothConstraint.Point2.Pos;
				double x = pos.X + (pos.X - pos2.X) / 2.0;
				double y = pos.Y + (pos.Y - pos2.Y) / 2.0;
				double z = pos.Z + (pos.Z - pos2.Z) / 2.0;
				clothConstraint.renderCenterPos.X = x;
				clothConstraint.renderCenterPos.Y = y;
				clothConstraint.renderCenterPos.Z = z;
			}
		}

		public void CustomRender(float dt)
		{
			if (LineDebug && capi != null)
			{
				if (debugMeshRef == null)
				{
					genDebugMesh();
				}
				BlockPos asBlockPos = CenterPosition.AsBlockPos;
				for (int i = 0; i < Constraints.Count; i++)
				{
					ClothConstraint clothConstraint = Constraints[i];
					Vec3d pos = clothConstraint.Point1.Pos;
					Vec3d pos2 = clothConstraint.Point2.Pos;
					debugUpdateMesh.xyz[i * 6] = (float)(pos.X - (double)asBlockPos.X);
					debugUpdateMesh.xyz[i * 6 + 1] = (float)(pos.Y - (double)asBlockPos.Y) + 0.005f;
					debugUpdateMesh.xyz[i * 6 + 2] = (float)(pos.Z - (double)asBlockPos.Z);
					debugUpdateMesh.xyz[i * 6 + 3] = (float)(pos2.X - (double)asBlockPos.X);
					debugUpdateMesh.xyz[i * 6 + 4] = (float)(pos2.Y - (double)asBlockPos.Y) + 0.005f;
					debugUpdateMesh.xyz[i * 6 + 5] = (float)(pos2.Z - (double)asBlockPos.Z);
				}
				capi.Render.UpdateMesh(debugMeshRef, debugUpdateMesh);
				IShaderProgram program = capi.Shader.GetProgram(23);
				program.Use();
				capi.Render.LineWidth = 6f;
				capi.Render.BindTexture2d(0);
				capi.Render.GLDisableDepthTest();
				Vec3d cameraPos = ((IPlayer)capi.World.Player).Entity.CameraPos;
				mat.Set(capi.Render.CameraMatrixOrigin);
				mat.Translate((float)((double)asBlockPos.X - cameraPos.X), (float)((double)asBlockPos.Y - cameraPos.Y), (float)((double)asBlockPos.Z - cameraPos.Z));
				program.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
				program.UniformMatrix("modelViewMatrix", mat.Values);
				capi.Render.RenderMesh(debugMeshRef);
				program.Stop();
				capi.Render.GLEnableDepthTest();
			}
		}

		public void updateFixedStep(float dt)
		{
			accum += dt;
			if (accum > 1f)
			{
				accum = 0.25f;
			}
			float physicsTickTime = pp.PhysicsTickTime;
			while (accum >= physicsTickTime)
			{
				accum -= physicsTickTime;
				tickNow(physicsTickTime);
			}
		}

		private void tickNow(float pdt)
		{
			for (int num = Constraints.Count - 1; num >= 0; num--)
			{
				Constraints[num].satisfy(pdt);
			}
			for (int num2 = Points2d.Count - 1; num2 >= 0; num2--)
			{
				for (int num3 = Points2d[num2].Points.Count - 1; num3 >= 0; num3--)
				{
					Points2d[num2].Points[num3].update(pdt, api.World);
				}
			}
		}

		public void slowTick3s()
		{
			if (!double.IsNaN(CenterPosition.X))
			{
				windSpeed = api.World.BlockAccessor.GetWindSpeedAt(CenterPosition) * (0.2 + noiseGen.Noise(0.0, api.World.Calendar.TotalHours * 50.0 % 2000.0) * 0.8);
			}
		}

		public void restoreReferences()
		{
			if (!Active)
			{
				return;
			}
			Dictionary<int, ClothPoint> pointsByIndex = new Dictionary<int, ClothPoint>();
			WalkPoints(delegate(ClothPoint p)
			{
				pointsByIndex[p.PointIndex] = p;
				p.restoreReferences(this, api.World);
			});
			foreach (ClothConstraint constraint in Constraints)
			{
				constraint.RestorePoints(pointsByIndex);
			}
		}

		public void updateActiveState(EnumActiveStateChange stateChange)
		{
			if ((!Active || stateChange != EnumActiveStateChange.RegionNowLoaded) && (Active || stateChange != EnumActiveStateChange.RegionNowUnloaded))
			{
				bool active = Active;
				Active = true;
				WalkPoints(delegate(ClothPoint p)
				{
					Active &= api.World.BlockAccessor.GetChunkAtBlockPos((int)p.Pos.X, (int)p.Pos.Y, (int)p.Pos.Z) != null;
				});
				if (!active && Active)
				{
					restoreReferences();
				}
			}
		}

		public void CollectDirtyPoints(List<ClothPointPacket> packets)
		{
			for (int i = 0; i < Points2d.Count; i++)
			{
				for (int j = 0; j < Points2d[i].Points.Count; j++)
				{
					ClothPoint clothPoint = Points2d[i].Points[j];
					if (clothPoint.Dirty)
					{
						packets.Add(new ClothPointPacket
						{
							ClothId = ClothId,
							PointX = i,
							PointY = j,
							Point = clothPoint
						});
						clothPoint.Dirty = false;
					}
				}
			}
		}

		public void updatePoint(ClothPointPacket msg)
		{
			if (msg.PointX >= Points2d.Count)
			{
				api.Logger.Error($"ClothSystem: {ClothId} got invalid Points2d update index for {msg.PointX}/{Points2d.Count}");
			}
			else if (msg.PointY >= Points2d[msg.PointX].Points.Count)
			{
				api.Logger.Error($"ClothSystem: {ClothId} got invalid Points2d[{msg.PointX}] update index for {msg.PointY}/{Points2d[msg.PointX].Points.Count}");
			}
			else
			{
				Points2d[msg.PointX].Points[msg.PointY].updateFromPoint(msg.Point, api.World);
			}
		}

		public void OnPinnnedEntityLoaded(Entity entity)
		{
			if (FirstPoint.pinnedToEntityId == entity.EntityId)
			{
				FirstPoint.restoreReferences(entity);
			}
			if (LastPoint.pinnedToEntityId == entity.EntityId)
			{
				LastPoint.restoreReferences(entity);
			}
		}
	}
	public enum EnumActiveStateChange
	{
		Default,
		RegionNowLoaded,
		RegionNowUnloaded
	}
	public class ModSystemEmotes : ModSystem
	{
		public override bool ShouldLoad(EnumAppSide side)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)side == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Expected O, but got Unknown
			IChatCommandApi chatCommands = ((ICoreAPI)api).ChatCommands;
			CommandArgumentParsers parsers = ((ICoreAPI)api).ChatCommands.Parsers;
			chatCommands.Create("emote").RequiresPrivilege(Privilege.chat).WithDescription("Execute an emote on your player")
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)parsers.OptionalWord("emote") })
				.HandleWith((OnCommandDelegate)delegate(TextCommandCallingArgs args)
				{
					Entity entity = args.Caller.Entity;
					EntityAgent val = (EntityAgent)(object)((entity is EntityAgent) ? entity : null);
					string[] array = ((Entity)val).Properties.Attributes["emotes"].AsArray<string>((string[])null, (string)null);
					string text = (string)args[0];
					if (text == null || !ArrayExtensions.Contains<string>(array, text))
					{
						return TextCommandResult.Error(Lang.Get("Choose emote: {0}", new object[1] { string.Join(", ", array) }), "");
					}
					if (text != "shakehead" && !val.RightHandItemSlot.Empty && val.RightHandItemSlot.Itemstack.Collectible.GetHeldTpIdleAnimation(val.RightHandItemSlot, (Entity)(object)val, (EnumHand)1) != null)
					{
						return TextCommandResult.Error("Only with free hands", "");
					}
					api.Network.BroadcastEntityPacket(((Entity)val).EntityId, 197, SerializerUtil.Serialize<string>(text));
					return TextCommandResult.Success("", (object)null);
				});
		}
	}
	public delegate LoadedTexture NameTagRendererDelegate(ICoreClientAPI capi, Entity forEntity);
	public class EntityNameTagRendererRegistry : ModSystem
	{
		public class DefaultEntitlementTagRenderer
		{
			public double[] color;

			public TextBackground background;

			public LoadedTexture renderTag(ICoreClientAPI capi, Entity entity)
			{
				string text = entity.GetBehavior<EntityBehaviorNameTag>()?.DisplayName;
				if (text != null && text.Length > 0)
				{
					return capi.Gui.TextTexture.GenUnscaledTextTexture(text, CairoFont.WhiteMediumText().WithColor(color), background);
				}
				return null;
			}
		}

		public static NameTagRendererDelegate DefaultNameTagRenderer = delegate(ICoreClientAPI capi, Entity entity)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Expected O, but got Unknown
			string text = entity.GetBehavior<EntityBehaviorNameTag>()?.DisplayName;
			return (text != null && text.Length > 0) ? capi.Gui.TextTexture.GenUnscaledTextTexture(Lang.GetIfExists("nametag-" + text.ToLowerInvariant(), Array.Empty<object>()) ?? text, CairoFont.WhiteMediumText().WithColor(ColorUtil.WhiteArgbDouble), new TextBackground
			{
				FillColor = GuiStyle.DialogLightBgColor,
				Padding = 3,
				Radius = GuiStyle.ElementBGRadius,
				Shade = true,
				BorderColor = GuiStyle.DialogBorderColor,
				BorderWidth = 3.0
			}) : null;
		};

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			((ModSystem)this).StartClientSide(api);
		}

		internal NameTagRendererDelegate GetNameTagRenderer(Entity entity)
		{
			Entity obj = ((entity is EntityPlayer) ? entity : null);
			object obj2;
			if (obj == null)
			{
				obj2 = null;
			}
			else
			{
				IPlayer player = ((EntityPlayer)obj).Player;
				obj2 = ((player != null) ? player.Entitlements : null);
			}
			List<Entitlement> list = (List<Entitlement>)obj2;
			if (list != null && list.Count > 0)
			{
				Entitlement val = list[0];
				if (GlobalConstants.playerColorByEntitlement.TryGetValue(val.Code, out var value))
				{
					GlobalConstants.playerTagBackgroundByEntitlement.TryGetValue(val.Code, out var value2);
					return new DefaultEntitlementTagRenderer
					{
						color = value,
						background = value2
					}.renderTag;
				}
			}
			return DefaultNameTagRenderer;
		}
	}
	public class EntityPartitionChunk
	{
		public List<Entity>[] Entities;

		public List<Entity>[] InanimateEntities;

		public EntityPartitionChunk()
		{
			Entities = new List<Entity>[16];
		}

		public List<Entity> Add(Entity e, int gridIndex)
		{
			List<Entity> obj = (e.IsCreature ? FetchOrCreateList(ref Entities[gridIndex]) : FetchOrCreateList(ref (InanimateEntities ?? (InanimateEntities = new List<Entity>[16]))[gridIndex]));
			obj.Add(e);
			return obj;
		}

		private List<Entity> FetchOrCreateList(ref List<Entity> list)
		{
			return list ?? (list = new List<Entity>(4));
		}
	}
	public struct GridAndChunkIndex
	{
		public int GridIndex;

		public long ChunkIndex;

		public GridAndChunkIndex(int gridIndex, long chunkIndex)
		{
			GridIndex = gridIndex;
			ChunkIndex = chunkIndex;
		}
	}
	public enum EnumEntitySearchType
	{
		Creatures,
		Inanimate
	}
	public class EntityPartitioning : ModSystem, IEntityPartitioning
	{
		public delegate bool RangeTestDelegate(Entity e, double posX, double posY, double posZ, double radiuSq);

		public const int partitionsLength = 4;

		private const int gridSizeInBlocks = 8;

		private ICoreAPI api;

		private ICoreClientAPI capi;

		private ICoreServerAPI sapi;

		public Dictionary<long, EntityPartitionChunk> Partitions = new Dictionary<long, EntityPartitionChunk>();

		private const int chunkSize = 32;

		public double LargestTouchDistance;

		public override double ExecuteOrder()
		{
			return 0.0;
		}

		public override bool ShouldLoad(EnumAppSide side)
		{
			return true;
		}

		public override void Start(ICoreAPI api)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Expected O, but got Unknown
			this.api = api;
			api.Event.PlayerDimensionChanged += new PlayerCommonDelegate(Event_PlayerDimensionChanged);
		}

		private void Event_PlayerDimensionChanged(IPlayer byPlayer)
		{
			RePartitionPlayer(byPlayer.Entity);
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			capi = api;
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)OnClientTick, 32, 0);
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Expected O, but got Unknown
			sapi = api;
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)OnServerTick, 32, 0);
			api.Event.PlayerSwitchGameMode += new PlayerDelegate(OnSwitchedGameMode);
		}

		private void OnClientTick(float dt)
		{
			PartitionEntities(capi.World.LoadedEntities.Values);
		}

		private void OnServerTick(float dt)
		{
			PartitionEntities(((CachingConcurrentDictionary<long, Entity>)(object)sapi.World.LoadedEntities).Values);
		}

		private void PartitionEntities(ICollection<Entity> entities)
		{
			long num = api.World.BlockAccessor.MapSizeX / 32;
			long num2 = api.World.BlockAccessor.MapSizeZ / 32;
			double num3 = 0.0;
			Dictionary<long, EntityPartitionChunk> partitions = Partitions;
			partitions.Clear();
			foreach (Entity entity in entities)
			{
				if (entity.IsCreature && entity.touchDistance > num3)
				{
					num3 = entity.touchDistance;
				}
				EntityPos sidedPos = entity.SidedPos;
				int num4 = (int)sidedPos.X;
				int num5 = (int)sidedPos.Z;
				int num6 = num5 / 8 % 4 * 4 + num4 / 8 % 4;
				if (num6 >= 0)
				{
					long key = MapUtil.Index3dL(num4 / 32, (int)sidedPos.InternalY / 32, num5 / 32, num, num2);
					if (!partitions.TryGetValue(key, out var value))
					{
						value = (partitions[key] = new EntityPartitionChunk());
					}
					List<Entity> entityListForPartitioning = value.Add(entity, num6);
					EntityPlayer val = (EntityPlayer)(object)((entity is EntityPlayer) ? entity : null);
					if (val != null)
					{
						val.entityListForPartitioning = entityListForPartitioning;
					}
				}
			}
			LargestTouchDistance = num3;
		}

		public void RePartitionPlayer(EntityPlayer entity)
		{
			entity.entityListForPartitioning?.Remove((Entity)(object)entity);
			PartitionEntities((ICollection<Entity>)(object)new Entity[1] { (Entity)entity });
		}

		private void OnSwitchedGameMode(IServerPlayer player)
		{
			RePartitionPlayer(((IPlayer)player).Entity);
		}

		[Obsolete("In version 1.19.2 and later, this searches only entities which are Creatures, which is probably what the caller wants but you should specify EnumEntitySearchType explicitly")]
		public Entity GetNearestEntity(Vec3d position, double radius, ActionConsumable<Entity> matches = null)
		{
			return GetNearestEntity(position, radius, matches, EnumEntitySearchType.Creatures);
		}

		public Entity GetNearestInteractableEntity(Vec3d position, double radius, ActionConsumable<Entity> matches = null)
		{
			if (matches == null)
			{
				return GetNearestEntity(position, radius, (Entity e) => e.IsInteractable, EnumEntitySearchType.Creatures);
			}
			return GetNearestEntity(position, radius, (Entity e) => matches.Invoke(e) && e.IsInteractable, EnumEntitySearchType.Creatures);
		}

		public Entity GetNearestEntity(Vec3d position, double radius, ActionConsumable<Entity> matches, EnumEntitySearchType searchType)
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Invalid comparison between Unknown and I4
			Entity nearestEntity = null;
			double num = radius * radius;
			double nearestDistanceSq = num;
			if ((int)api.Side == 2)
			{
				WalkEntities(position.X, position.Y, position.Z, radius, delegate(Entity e)
				{
					if (matches.Invoke(e))
					{
						double num2 = e.Pos.SquareDistanceTo(position);
						if (num2 < nearestDistanceSq)
						{
							nearestDistanceSq = num2;
							nearestEntity = e;
						}
					}
					return true;
				}, null, searchType);
			}
			else
			{
				WalkEntities(position.X, position.Y, position.Z, radius, delegate(Entity e)
				{
					double num2 = e.ServerPos.SquareDistanceTo(position);
					if (num2 < nearestDistanceSq && matches.Invoke(e))
					{
						nearestDistanceSq = num2;
						nearestEntity = e;
					}
					return true;
				}, null, searchType);
			}
			return nearestEntity;
		}

		private bool onIsInRangeServer(Entity e, double posX, double posY, double posZ, double radiusSq)
		{
			EntityPos serverPos = e.ServerPos;
			double num = serverPos.X - posX;
			double num2 = serverPos.InternalY - posY;
			double num3 = serverPos.Z - posZ;
			return num * num + num2 * num2 + num3 * num3 < radiusSq;
		}

		private bool onIsInRangeClient(Entity e, double posX, double posY, double posZ, double radiusSq)
		{
			EntityPos pos = e.Pos;
			double num = pos.X - posX;
			double num2 = pos.InternalY - posY;
			double num3 = pos.Z - posZ;
			return num * num + num2 * num2 + num3 * num3 < radiusSq;
		}

		[Obsolete("In version 1.19.2 and later, this walks through Creature entities only, so recommended to call WalkEntityPartitions() specifying the type of search explicitly for clarity in the calling code")]
		public void WalkEntities(Vec3d centerPos, double radius, ActionConsumable<Entity> callback)
		{
			WalkEntities(centerPos, radius, callback, EnumEntitySearchType.Creatures);
		}

		[Obsolete("In version 1.19.2 and later, use WalkEntities specifying the searchtype (Creatures or Inanimate) explitly in the calling code.")]
		public void WalkInteractableEntities(Vec3d centerPos, double radius, ActionConsumable<Entity> callback)
		{
			WalkEntities(centerPos, radius, callback, EnumEntitySearchType.Creatures);
		}

		public void WalkEntities(Vec3d centerPos, double radius, ActionConsumable<Entity> callback, EnumEntitySearchType searchType)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			if ((int)api.Side == 2)
			{
				WalkEntities(centerPos.X, centerPos.Y, centerPos.Z, radius, callback, onIsInRangeClient, searchType);
			}
			else
			{
				WalkEntities(centerPos.X, centerPos.Y, centerPos.Z, radius, callback, onIsInRangeServer, searchType);
			}
		}

		public void WalkEntityPartitions(Vec3d centerPos, double radius, ActionConsumable<Entity> callback)
		{
			WalkEntities(centerPos.X, centerPos.Y, centerPos.Z, radius, callback, null, EnumEntitySearchType.Creatures);
		}

		public void WalkEntities(double centerPosX, double centerPosY, double centerPosZ, double radius, ActionConsumable<Entity> callback, RangeTestDelegate onRangeTest, EnumEntitySearchType searchType)
		{
			IBlockAccessor blockAccessor = api.World.BlockAccessor;
			long num = blockAccessor.MapSizeX / 32;
			long num2 = blockAccessor.MapSizeZ / 32;
			int num3 = blockAccessor.MapSizeX / 8 - 1;
			int num4 = blockAccessor.MapSizeY / 32 - 1;
			int num5 = blockAccessor.MapSizeZ / 8 - 1;
			int num6 = (int)GameMath.Clamp((centerPosX - radius) / 8.0, 0.0, (double)num3);
			int num7 = (int)GameMath.Clamp((centerPosX + radius) / 8.0, 0.0, (double)num3);
			int num8 = (int)GameMath.Clamp((centerPosY - radius) / 32.0, 0.0, (double)num4);
			int num9 = (int)GameMath.Clamp((centerPosY + radius) / 32.0, 0.0, (double)num4);
			int num10 = (int)GameMath.Clamp((centerPosZ - radius) / 8.0, 0.0, (double)num5);
			int num11 = (int)GameMath.Clamp((centerPosZ + radius) / 8.0, 0.0, (double)num5);
			double radiuSq = radius * radius;
			Dictionary<long, EntityPartitionChunk> partitions = Partitions;
			EntityPartitionChunk value = null;
			long num12 = -1L;
			for (int i = num8; i <= num9; i++)
			{
				for (int j = num10; j <= num11; j++)
				{
					int num13 = j / 4;
					int num14 = j % 4 * 4;
					long num15 = MapUtil.Index3dL(0, i, num13, num, num2);
					for (int k = num6; k <= num7; k++)
					{
						if (num15 + k / 4 != num12)
						{
							num12 = num15 + k / 4;
							partitions.TryGetValue(num12, out value);
						}
						if (value == null)
						{
							continue;
						}
						object obj;
						if (searchType != EnumEntitySearchType.Creatures)
						{
							List<Entity>[] inanimateEntities = value.InanimateEntities;
							obj = ((inanimateEntities != null) ? inanimateEntities[num14 + k % 4] : null);
						}
						else
						{
							obj = value.Entities[num14 + k % 4];
						}
						List<Entity> list = (List<Entity>)obj;
						if (list == null)
						{
							continue;
						}
						if (onRangeTest == null)
						{
							foreach (Entity item in list)
							{
								if (!callback.Invoke(item))
								{
									return;
								}
							}
							continue;
						}
						foreach (Entity item2 in list)
						{
							if (onRangeTest(item2, centerPosX, centerPosY, centerPosZ, radiuSq) && !callback.Invoke(item2))
							{
								return;
							}
						}
					}
				}
			}
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class ServerLogEntries
	{
		public string[] LogEntries;
	}
	public class ErrorReporter : ModSystem
	{
		private ICoreAPI api;

		private bool clientEnabled;

		private int readyFlags;

		private ICoreClientAPI capi;

		private GuiDialog dialog;

		private IServerNetworkChannel serverChannel;

		private const int maxLogEntries = 180;

		private object logEntiresLock = new object();

		private LimitedList<string> logEntries = new LimitedList<string>(180);

		public override double ExecuteOrder()
		{
			return 0.0;
		}

		public override bool ShouldLoad(EnumAppSide side)
		{
			return true;
		}

		public override void StartPre(ICoreAPI api)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Expected O, but got Unknown
			this.api = api;
			api.World.Logger.EntryAdded += new LogEntryDelegate(Logger_EntryAdded);
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Expected O, but got Unknown
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Expected O, but got Unknown
			((ICoreAPI)api).ChatCommands.Create("errorreporter").WithDescription("Toggles on/off the error reporting dialog on startup").RequiresPrivilege(Privilege.controlserver)
				.RequiresPlayer()
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.Bool("activate", "on") })
				.HandleWith(new OnCommandDelegate(OnCmdErrRep));
			serverChannel = api.Network.RegisterChannel("errorreporter").RegisterMessageType(typeof(ServerLogEntries));
			api.Event.PlayerJoin += new PlayerDelegate(OnPlrJoin);
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Expected O, but got Unknown
			capi = api;
			((ICoreAPI)api).ChatCommands.Create("errorreporter").WithDescription("Reopens the error reporting dialog").HandleWith(new OnCommandDelegate(ClientCmdErrorRep));
			api.Event.LevelFinalize += OnClientReady;
			api.Network.RegisterChannel("errorreporter").RegisterMessageType(typeof(ServerLogEntries)).SetMessageHandler<ServerLogEntries>((NetworkServerMessageHandler<ServerLogEntries>)OnServerLogEntriesReceived);
		}

		private TextCommandResult ClientCmdErrorRep(TextCommandCallingArgs textCommandCallingArgs)
		{
			if (dialog != null && dialog.IsOpened())
			{
				dialog.TryClose();
			}
			else
			{
				ShowDialog();
			}
			return TextCommandResult.Success("", (object)null);
		}

		private void OnClientReady()
		{
			readyFlags++;
			if (readyFlags == 2 && logEntries.Count > 0)
			{
				ShowDialog();
			}
		}

		private void OnServerLogEntriesReceived(ServerLogEntries msg)
		{
			clientEnabled = true;
			readyFlags++;
			lock (logEntiresLock)
			{
				string[] array = msg.LogEntries;
				foreach (string text in array)
				{
					logEntries.Add(text);
				}
			}
			if (readyFlags == 2 && logEntries.Count > 0)
			{
				ShowDialog();
			}
		}

		private void ShowDialog()
		{
			lock (logEntiresLock)
			{
				if (!clientEnabled)
				{
					logEntries.Clear();
					return;
				}
				List<string> list = ((IEnumerable<string>)logEntries).ToList();
				if (logEntries.Count > 180)
				{
					list = ((IEnumerable<string>)logEntries).Take(180).ToList();
					list.Add($"...{logEntries.Count} more");
				}
				dialog = (GuiDialog)(object)new GuiDialogLogViewer(string.Join("\n", list), capi);
			}
			dialog.TryOpen();
		}

		private void OnPlrJoin(IServerPlayer byPlayer)
		{
			byPlayer.ServerData.CustomPlayerData.TryGetValue("errorReporting", out var value);
			if (value == "1" && logEntries.Count > 0)
			{
				lock (logEntiresLock)
				{
					serverChannel.SendPacket<ServerLogEntries>(new ServerLogEntries
					{
						LogEntries = logEntries.ToArray()
					}, (IServerPlayer[])(object)new IServerPlayer[1] { byPlayer });
				}
			}
		}

		private TextCommandResult OnCmdErrRep(TextCommandCallingArgs args)
		{
			bool flag = (bool)args.Parsers[0].GetValue();
			IPlayer player = args.Caller.Player;
			((IServerPlayer)((player is IServerPlayer) ? player : null)).ServerData.CustomPlayerData["errorReporting"] = (flag ? "1" : "0");
			return TextCommandResult.Success(Lang.Get("Error reporting now {0}", new object[1] { flag ? "on" : "off" }), (object)null);
		}

		private void Logger_EntryAdded(EnumLogType logType, string message, params object[] args)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0004: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Invalid comparison between Unknown and I4
			if ((int)logType == 8 || (int)logType == 9 || (int)logType == 7)
			{
				string text;
				try
				{
					text = $"[{api.Side} {logType}] {string.Format(message, args)}";
				}
				catch (Exception)
				{
					text = string.Format("[{0} {1}] {2}", api.Side, logType, "Error reporter failed formatting for \"" + message + "\"");
				}
				lock (logEntiresLock)
				{
					logEntries.Add(text);
				}
			}
		}
	}
	public class LeafBlockDecay : ModSystem
	{
		private class CheckDecayThread : IAsyncServerSystem
		{
			public static int leafDecayCheckTickInterval = 10;

			private HashSet<BlockPos> checkDecay;

			private HashSet<BlockPos> performDecay;

			private ICoreServerAPI sapi;

			public bool Stopping { get; set; }

			public CheckDecayThread(ICoreServerAPI sapi)
			{
				this.sapi = sapi;
			}

			public void Start(HashSet<BlockPos> checkDecay, HashSet<BlockPos> performDecay)
			{
				this.checkDecay = checkDecay;
				this.performDecay = performDecay;
				sapi.Server.AddServerThread("CheckLeafDecay", (IAsyncServerSystem)(object)this);
			}

			public int OffThreadInterval()
			{
				return leafDecayCheckTickInterval;
			}

			public void OnSeparateThreadTick()
			{
				for (int i = 0; i < 100; i++)
				{
					if (checkDecay.Count == 0)
					{
						break;
					}
					BlockPos val = null;
					lock (checkDecayLock)
					{
						val = checkDecay.First();
						checkDecay.Remove(val);
					}
					if (shouldDecay(val))
					{
						lock (performDecayLock)
						{
							performDecay.Add(val);
						}
					}
				}
			}

			public void ThreadDispose()
			{
				lock (checkDecayLock)
				{
					checkDecay.Clear();
				}
				lock (performDecayLock)
				{
					performDecay.Clear();
				}
			}

			private bool shouldDecay(BlockPos startPos)
			{
				//IL_0030: Unknown result type (might be due to invalid IL or missing references)
				//IL_003a: Expected O, but got Unknown
				//IL_009f: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a6: Expected O, but got Unknown
				//IL_012f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0139: Expected O, but got Unknown
				Queue<Vec4i> queue = new Queue<Vec4i>();
				HashSet<BlockPos> hashSet = new HashSet<BlockPos>();
				IBlockAccessor blockAccessor = ((IWorldAccessor)sapi.World).BlockAccessor;
				Block block = blockAccessor.GetBlock(startPos);
				if (canDecay(block))
				{
					queue.Enqueue(new Vec4i(startPos, 2));
					hashSet.Add(startPos);
					while (queue.Count > 0)
					{
						if (hashSet.Count > 600)
						{
							return false;
						}
						Vec4i val = queue.Dequeue();
						for (int i = 0; i < Vec3i.DirectAndIndirectNeighbours.Length; i++)
						{
							Vec3i val2 = Vec3i.DirectAndIndirectNeighbours[i];
							BlockPos val3 = new BlockPos(val.X + val2.X, val.Y + val2.Y, val.Z + val2.Z);
							if (hashSet.Contains(val3))
							{
								continue;
							}
							hashSet.Add(val3);
							block = blockAccessor.GetBlock(val3);
							if (preventsDecay(block))
							{
								return false;
							}
							int value = val3.X - startPos.X;
							int value2 = val3.Y - startPos.Y;
							int value3 = val3.Z - startPos.Z;
							if (Math.Abs(value) > 4 || Math.Abs(value2) > 4 || Math.Abs(value3) > 4)
							{
								if (((CollectibleObject)block).Id != 0)
								{
									return false;
								}
							}
							else if (canDecay(block))
							{
								queue.Enqueue(new Vec4i(val3, 0));
							}
						}
					}
					return true;
				}
				return false;
			}
		}

		private ICoreServerAPI sapi;

		private HashSet<BlockPos> checkDecayQueue = new HashSet<BlockPos>();

		public static object checkDecayLock = new object();

		private HashSet<BlockPos> performDecayQueue = new HashSet<BlockPos>();

		public static object performDecayLock = new object();

		private CheckDecayThread checkDecayThread;

		public static int leafRemovalInterval = 1000;

		public override bool ShouldLoad(EnumAppSide side)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)side == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Expected O, but got Unknown
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Expected O, but got Unknown
			sapi = api;
			api.Event.SaveGameLoaded += onSaveGameLoaded;
			api.Event.GameWorldSave += onGameGettingSaved;
			((IEventAPI)api.Event).RegisterEventBusListener(new EventBusListenerDelegate(onLeafDecayEventReceived), 0.5, "testForDecay");
			((IEventAPI)api.Event).RegisterGameTickListener((Action<float>)processReadyToDecayQueue, leafRemovalInterval, 0);
			((ICoreAPI)sapi).ChatCommands.GetOrCreate("debug").BeginSubCommand("leafdecaydebug").WithDescription("Shows leaf decay stats")
				.RequiresPrivilege(Privilege.controlserver)
				.HandleWith((OnCommandDelegate)((TextCommandCallingArgs _) => TextCommandResult.Success("Queue sizes: pdq: " + performDecayQueue.Count + " / cdq: " + checkDecayQueue.Count, (object)null)))
				.EndSubCommand();
		}

		private void processReadyToDecayQueue(float dt)
		{
			if (performDecayQueue.Count != 0)
			{
				BlockPos val = null;
				lock (performDecayLock)
				{
					val = performDecayQueue.First();
					performDecayQueue.Remove(val);
				}
				doDecay(val);
			}
		}

		private void onLeafDecayEventReceived(string eventName, ref EnumHandling handling, IAttribute data)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Expected O, but got Unknown
			if (checkDecayThread != null)
			{
				TreeAttribute val = (TreeAttribute)(object)((data is TreeAttribute) ? data : null);
				BlockPos pos = new BlockPos(val.GetInt("x", 0), val.GetInt("y", 0), val.GetInt("z", 0));
				queueNeighborsForCheckDecay(pos);
			}
		}

		private void queueNeighborsForCheckDecay(BlockPos pos)
		{
			lock (checkDecayLock)
			{
				for (int i = 0; i < Vec3i.DirectAndIndirectNeighbours.Length; i++)
				{
					Vec3i val = Vec3i.DirectAndIndirectNeighbours[i];
					Block blockRaw = ((IWorldAccessor)sapi.World).BlockAccessor.GetBlockRaw(pos.X + val.X, pos.InternalY + val.Y, pos.Z + val.Z, 0);
					if (((CollectibleObject)blockRaw).Id != 0 && canDecay(blockRaw))
					{
						checkDecayQueue.Add(pos.AddCopy(val));
					}
				}
			}
		}

		private void doDecay(BlockPos pos)
		{
			if (canDecay(((IWorldAccessor)sapi.World).BlockAccessor.GetBlock(pos)))
			{
				((IWorldAccessor)sapi.World).BlockAccessor.SetBlock(0, pos);
				for (int i = 0; i < 6; i++)
				{
					((IWorldAccessor)sapi.World).BlockAccessor.MarkBlockDirty(pos.AddCopy(BlockFacing.ALLFACES[i]), (IPlayer)null);
				}
				queueNeighborsForCheckDecay(pos);
			}
		}

		private void onGameGettingSaved()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			FastMemoryStream val = new FastMemoryStream();
			try
			{
				lock (checkDecayLock)
				{
					sapi.WorldManager.SaveGame.StoreData("checkDecayQueue", SerializerUtil.Serialize<HashSet<BlockPos>>(checkDecayQueue, val));
					sapi.WorldManager.SaveGame.StoreData("performDecayQueue", SerializerUtil.Serialize<HashSet<BlockPos>>(performDecayQueue, val));
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		private void onSaveGameLoaded()
		{
			((ICoreAPI)sapi).Logger.Debug("Loading leaf block decay system");
			checkDecayQueue = deserializeQueue("checkDecayQueue");
			performDecayQueue = deserializeQueue("performDecayQueue");
			checkDecayThread = new CheckDecayThread(sapi);
			checkDecayThread.Start(checkDecayQueue, performDecayQueue);
			((ICoreAPI)sapi).Logger.Debug("Finished loading leaf block decay system");
		}

		private HashSet<BlockPos> deserializeQueue(string name)
		{
			try
			{
				byte[] data = sapi.WorldManager.SaveGame.GetData(name);
				if (data != null)
				{
					return SerializerUtil.Deserialize<HashSet<BlockPos>>(data);
				}
			}
			catch (Exception ex)
			{
				((IWorldAccessor)sapi.World).Logger.Error("Failed loading LeafBlockDecay.{0}. Resetting. Exception:", new object[1] { name });
				((IWorldAccessor)sapi.World).Logger.Error(ex);
			}
			return new HashSet<BlockPos>();
		}

		public static bool canDecay(Block block)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			if ((int)block.BlockMaterial == 5)
			{
				JsonObject attributes = ((CollectibleObject)block).Attributes;
				if (attributes == null)
				{
					return false;
				}
				return attributes.IsTrue("canDecay");
			}
			return false;
		}

		public static bool preventsDecay(Block block)
		{
			if (((CollectibleObject)block).Id != 0)
			{
				JsonObject attributes = ((CollectibleObject)block).Attributes;
				if (attributes == null)
				{
					return false;
				}
				return attributes.IsTrue("preventsDecay");
			}
			return false;
		}
	}
	public class ModSystemAmbientParticles : ModSystem
	{
		private SimpleParticleProperties liquidParticles;

		private SimpleParticleProperties summerAirParticles;

		private SimpleParticleProperties fireflyParticles;

		private ClampedSimplexNoise fireflyLocationNoise;

		private ClampedSimplexNoise fireflyrateNoise;

		private ICoreClientAPI capi;

		[CompilerGenerated]
		private ActionBoolReturn m_ShouldSpawnAmbientParticles;

		private ClimateCondition climate = new ClimateCondition();

		private bool spawnParticles;

		private Vec3d position = new Vec3d();

		private BlockPos blockPos = new BlockPos();

		public event ActionBoolReturn ShouldSpawnAmbientParticles
		{
			[CompilerGenerated]
			add
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Expected O, but got Unknown
				ActionBoolReturn val = this.m_ShouldSpawnAmbientParticles;
				ActionBoolReturn val2;
				do
				{
					val2 = val;
					ActionBoolReturn value2 = (ActionBoolReturn)Delegate.Combine((Delegate?)(object)val2, (Delegate?)(object)value);
					val = Interlocked.CompareExchange(ref this.m_ShouldSpawnAmbientParticles, value2, val2);
				}
				while (val != val2);
			}
			[CompilerGenerated]
			remove
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Expected O, but got Unknown
				ActionBoolReturn val = this.m_ShouldSpawnAmbientParticles;
				ActionBoolReturn val2;
				do
				{
					val2 = val;
					ActionBoolReturn value2 = (ActionBoolReturn)Delegate.Remove((Delegate?)(object)val2, (Delegate?)(object)value);
					val = Interlocked.CompareExchange(ref this.m_ShouldSpawnAmbientParticles, value2, val2);
				}
				while (val != val2);
			}
		}

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Expected O, but got Unknown
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Expected O, but got Unknown
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Expected O, but got Unknown
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Expected O, but got Unknown
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Expected O, but got Unknown
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Expected O, but got Unknown
			//IL_0196: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0204: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Expected O, but got Unknown
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_0245: Expected O, but got Unknown
			//IL_025a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0264: Expected O, but got Unknown
			//IL_031e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0328: Expected O, but got Unknown
			//IL_0363: Unknown result type (might be due to invalid IL or missing references)
			//IL_036d: Expected O, but got Unknown
			capi = api;
			((IEventAPI)capi.Event).RegisterGameTickListener((Action<float>)OnSlowTick, 1000, 0);
			capi.Event.RegisterAsyncParticleSpawner(new ContinousParticleSpawnTaskDelegate(AsyncParticleSpawnTick));
			liquidParticles = new SimpleParticleProperties
			{
				MinSize = 0.1f,
				MaxSize = 0.1f,
				MinQuantity = 1f,
				GravityEffect = 0f,
				LifeLength = 2f,
				ParticleModel = (EnumParticleModel)0,
				ShouldDieInAir = true,
				VertexFlags = 512
			};
			liquidParticles.OpacityEvolve = new EvolvingNatFloat((EnumTransformFunction)5, -9f);
			summerAirParticles = new SimpleParticleProperties
			{
				Color = ColorUtil.ToRgba(35, 230, 230, 150),
				ParticleModel = (EnumParticleModel)0,
				MinSize = 0.05f,
				MaxSize = 0.1f,
				GravityEffect = 0f,
				LifeLength = 2f,
				WithTerrainCollision = false,
				ShouldDieInLiquid = true,
				MinVelocity = new Vec3f(-0.125f, -0.125f, -0.125f),
				MinQuantity = 1f,
				AddQuantity = 0f
			};
			summerAirParticles.AddVelocity = new Vec3f(0.25f, 0.25f, 0.25f);
			summerAirParticles.OpacityEvolve = EvolvingNatFloat.create((EnumTransformFunction)9, (float)Math.PI);
			summerAirParticles.MinPos = new Vec3d();
			fireflyParticles = new SimpleParticleProperties
			{
				Color = ColorUtil.ToRgba(150, 150, 250, 139),
				ParticleModel = (EnumParticleModel)0,
				MinSize = 0.1f,
				MaxSize = 0.1f,
				GravityEffect = 0f,
				LifeLength = 2f,
				ShouldDieInLiquid = true,
				MinVelocity = new Vec3f(-0.25f, -0.0625f, -0.25f),
				MinQuantity = 2f,
				AddQuantity = 0f,
				LightEmission = ColorUtil.ToRgba(255, 77, 250, 139)
			};
			fireflyParticles.AddVelocity = new Vec3f(0.5f, 0.125f, 0.5f);
			fireflyParticles.VertexFlags = 255;
			fireflyParticles.AddPos.Set(1.0, 1.0, 1.0);
			fireflyParticles.AddQuantity = 8f;
			fireflyParticles.addLifeLength = 1f;
			fireflyParticles.OpacityEvolve = EvolvingNatFloat.create((EnumTransformFunction)9, (float)Math.PI);
			fireflyParticles.RandomVelocityChange = true;
			fireflyLocationNoise = new ClampedSimplexNoise(new double[1] { 1.0 }, new double[1] { 5.0 }, (long)((IWorldAccessor)capi.World).Rand.Next());
			fireflyrateNoise = new ClampedSimplexNoise(new double[1] { 1.0 }, new double[1] { 5.0 }, (long)((IWorldAccessor)capi.World).Rand.Next());
		}

		private void OnSlowTick(float dt)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Expected O, but got Unknown
			climate = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(((Entity)((IPlayer)capi.World.Player).Entity).Pos.AsBlockPos, (EnumGetClimateMode)1, 0.0);
			if (climate == null)
			{
				climate = new ClimateCondition();
			}
			spawnParticles = capi.Settings.Bool["ambientParticles"];
		}

		private bool AsyncParticleSpawnTick(float dt, IAsyncParticleManager manager)
		{
			//IL_0345: Unknown result type (might be due to invalid IL or missing references)
			//IL_034f: Expected O, but got Unknown
			if (!spawnParticles)
			{
				return true;
			}
			if (this.ShouldSpawnAmbientParticles != null && !this.ShouldSpawnAmbientParticles.Invoke())
			{
				return true;
			}
			int num = capi.Settings.Int["particleLevel"];
			IClientWorldAccessor world = capi.World;
			EntityPlayer entity = ((IPlayer)world.Player).Entity;
			ClimateCondition climateAt = ((IWorldAccessor)world).BlockAccessor.GetClimateAt(blockPos.Set((int)((Entity)entity).Pos.X, (int)((Entity)entity).Pos.Y, (int)((Entity)entity).Pos.Z), (EnumGetClimateMode)1, 0.0);
			float num2 = 0.5f * (float)num;
			while (num2-- > 0f)
			{
				double num3 = ((IWorldAccessor)world).Rand.NextDouble() * 32.0 - 16.0;
				double num4 = ((IWorldAccessor)world).Rand.NextDouble() * 20.0 - 10.0;
				double num5 = ((IWorldAccessor)world).Rand.NextDouble() * 32.0 - 16.0;
				position.Set(((Entity)entity).Pos.X, ((Entity)entity).Pos.Y, ((Entity)entity).Pos.Z).Add(num3, num4, num5);
				blockPos.Set(position);
				if (!((IWorldAccessor)world).BlockAccessor.IsValidPos(blockPos))
				{
					continue;
				}
				double num6 = 0.05 + (double)Math.Max(0f, world.Calendar.DayLightStrength) * 0.4;
				if ((double)climateAt.Rainfall <= 0.01 && GlobalConstants.CurrentWindSpeedClient.X < 0.2f && ((IWorldAccessor)world).Rand.NextDouble() < num6 && climate.Temperature >= 14f && climate.WorldgenRainfall >= 0.4f && blockPos.Y > ((IWorldAccessor)world).SeaLevel && ((CollectibleObject)manager.BlockAccess.GetBlock(blockPos)).Id == 0)
				{
					IMapChunk mapChunk = manager.BlockAccess.GetMapChunk(blockPos.X / 32, blockPos.Z / 32);
					if (mapChunk != null && blockPos.Y > mapChunk.RainHeightMap[blockPos.Z % 32 * 32 + blockPos.X % 32])
					{
						summerAirParticles.MinPos.Set(position);
						summerAirParticles.RandomVelocityChange = true;
						manager.Spawn((IParticlePropertiesProvider)(object)summerAirParticles);
					}
					continue;
				}
				Block block = manager.BlockAccess.GetBlock(blockPos, 2);
				if (((CollectibleObject)block).IsLiquid() && block.LiquidLevel >= 7)
				{
					liquidParticles.MinVelocity = new Vec3f((float)((IWorldAccessor)world).Rand.NextDouble() / 16f - 1f / 32f, (float)((IWorldAccessor)world).Rand.NextDouble() / 16f - 1f / 32f, (float)((IWorldAccessor)world).Rand.NextDouble() / 16f - 1f / 32f);
					liquidParticles.MinPos = position;
					if (((IWorldAccessor)world).Rand.Next(3) > 0)
					{
						liquidParticles.RandomVelocityChange = false;
						liquidParticles.Color = ColorUtil.HsvToRgba(110, 40 + ((IWorldAccessor)world).Rand.Next(50), 200 + ((IWorldAccessor)world).Rand.Next(30), 50 + ((IWorldAccessor)world).Rand.Next(40));
					}
					else
					{
						liquidParticles.RandomVelocityChange = true;
						liquidParticles.Color = ColorUtil.HsvToRgba(110, 20 + ((IWorldAccessor)world).Rand.Next(25), 100 + ((IWorldAccessor)world).Rand.Next(15), 100 + ((IWorldAccessor)world).Rand.Next(40));
					}
					manager.Spawn((IParticlePropertiesProvider)(object)liquidParticles);
				}
			}
			if ((double)climateAt.Rainfall < 0.15 && climateAt.Temperature > 5f)
			{
				double num7 = (fireflyrateNoise.Noise(((IGameCalendar)world.Calendar).TotalDays / 3.0, 0.0, 0.0) - 0.4000000059604645) * 4.0;
				float num8 = Math.Max(0f, (float)(num7 - (double)(Math.Abs(GlobalConstants.CurrentWindSpeedClient.X) * 2f)));
				int num9 = GameMath.RoundRandom(((IWorldAccessor)world).Rand, num8 * 0.01f * (float)num);
				while (num9-- > 0)
				{
					double num10 = ((IWorldAccessor)world).Rand.NextDouble() * 80.0 - 40.0;
					double num11 = ((IWorldAccessor)world).Rand.NextDouble() * 80.0 - 40.0;
					double num12 = ((IWorldAccessor)world).Rand.NextDouble() * 80.0 - 40.0;
					position.Set(((Entity)entity).Pos.X, ((Entity)entity).Pos.Y, ((Entity)entity).Pos.Z).Add(num10, num11, num12);
					blockPos.Set(position);
					if (!((IWorldAccessor)world).BlockAccessor.IsValidPos(blockPos))
					{
						continue;
					}
					double num13 = Math.Max(0.0, fireflyLocationNoise.Noise((double)blockPos.X / 60.0, (double)blockPos.Z / 60.0, ((IGameCalendar)world.Calendar).TotalDays / 5.0 - 0.800000011920929) - 0.5) * 2.0;
					double num14 = (double)Math.Max(0f, 1f - world.Calendar.DayLightStrength * 2f) * num13;
					int y = blockPos.Y;
					blockPos.Y = manager.BlockAccess.GetTerrainMapheightAt(blockPos);
					Block block2 = manager.BlockAccess.GetBlock(blockPos);
					if (((IWorldAccessor)world).Rand.NextDouble() <= num14 && climate.Temperature >= 8f && climate.Temperature <= 29f && climate.WorldgenRainfall >= 0.4f && block2.Fertility > 30 && blockPos.Y > ((IWorldAccessor)world).SeaLevel)
					{
						BlockPos obj = blockPos;
						obj.Y += ((IWorldAccessor)world).Rand.Next(4);
						Vec3d obj2 = position;
						obj2.Y += (double)(blockPos.Y - y);
						block2 = manager.BlockAccess.GetBlock(blockPos);
						Cuboidf[] collisionBoxes = block2.GetCollisionBoxes(manager.BlockAccess, blockPos);
						if (collisionBoxes == null || collisionBoxes.Length == 0)
						{
							fireflyParticles.AddVelocity.X = 0.5f + GlobalConstants.CurrentWindSpeedClient.X;
							fireflyParticles.MinPos = position;
							manager.Spawn((IParticlePropertiesProvider)(object)fireflyParticles);
						}
					}
				}
			}
			return true;
		}
	}
	public abstract class EntityParticle : ParticleBase
	{
		protected float dirNormalizedX;

		protected float dirNormalizedY;

		protected float dirNormalizedZ;

		protected bool SwimOnLiquid;

		public abstract string Type { get; }

		protected float Size
		{
			set
			{
				float num = (SizeZ = value);
				float sizeX = (SizeY = num);
				SizeX = sizeX;
			}
		}

		protected float SizeX { get; set; } = 1f;

		protected float SizeY { get; set; } = 1f;

		protected float SizeZ { get; set; } = 1f;

		protected float GravityStrength { get; set; } = 1f;

		public void OnSpawned(ParticlePhysics physicsSim)
		{
			base.lightrgbs = physicsSim.BlockAccess.GetLightRGBsAsInt((int)base.Position.X, (int)base.Position.Y, (int)base.Position.Z);
		}

		public override void TickNow(float dt, float physicsdt, ICoreClientAPI api, ParticlePhysics physicsSim)
		{
			base.motion.Set(base.Velocity.X * dt, base.Velocity.Y * dt, base.Velocity.Z * dt);
			float num = SizeY / 4f;
			((ParticleBase)this).updatePositionWithCollision(dt, api, physicsSim, num);
			Vec3f velocity = base.Velocity;
			velocity.Y -= GravityStrength * dt;
			physicsSim.HandleBoyancy(base.Position, base.Velocity, SwimOnLiquid, GravityStrength, dt, num);
			base.tickCount++;
			if (base.tickCount > 2)
			{
				doSlowTick(physicsSim, dt * 3f);
			}
			if ((double)base.Velocity.Length() > 0.05)
			{
				dirNormalizedX = base.Velocity.X;
				dirNormalizedY = base.Velocity.Y;
				dirNormalizedZ = base.Velocity.Z;
			}
		}

		protected virtual void doSlowTick(ParticlePhysics physicsSim, float dt)
		{
			base.lightrgbs = physicsSim.BlockAccess.GetLightRGBsAsInt((int)base.Position.X, (int)base.Position.Y, (int)base.Position.Z);
			base.tickCount = 0;
		}

		public override void UpdateBuffers(MeshData buffer, Vec3d cameraPos, ref int posPosition, ref int rgbaPosition, ref int flagPosition)
		{
			float num = 1f - base.prevPosAdvance;
			float[] values = ((CustomMeshDataPart<float>)(object)buffer.CustomFloats).Values;
			values[posPosition++] = (float)(base.Position.X - (double)(base.prevPosDeltaX * num) - cameraPos.X);
			values[posPosition++] = (float)(base.Position.Y - (double)(base.prevPosDeltaY * num) - cameraPos.Y);
			values[posPosition++] = (float)(base.Position.Z - (double)(base.prevPosDeltaZ * num) - cameraPos.Z);
			values[posPosition++] = SizeX;
			values[posPosition++] = SizeY;
			values[posPosition++] = SizeZ;
			posPosition = UpdateAngles(values, posPosition);
			byte[] values2 = ((CustomMeshDataPart<byte>)(object)buffer.CustomBytes).Values;
			values2[rgbaPosition++] = (byte)base.lightrgbs;
			values2[rgbaPosition++] = (byte)(base.lightrgbs >> 8);
			values2[rgbaPosition++] = (byte)(base.lightrgbs >> 16);
			values2[rgbaPosition++] = (byte)(base.lightrgbs >> 24);
			values2[rgbaPosition++] = base.ColorBlue;
			values2[rgbaPosition++] = base.ColorGreen;
			values2[rgbaPosition++] = base.ColorRed;
			values2[rgbaPosition++] = base.ColorAlpha;
			buffer.Flags[flagPosition++] = base.VertexFlags;
		}

		public virtual int UpdateAngles(float[] customFloats, int posPosition)
		{
			customFloats[posPosition++] = dirNormalizedX;
			customFloats[posPosition++] = dirNormalizedY;
			customFloats[posPosition++] = dirNormalizedZ;
			customFloats[posPosition++] = 0f;
			return posPosition;
		}
	}
	public abstract class EntityParticleInsect : EntityParticle
	{
		protected ICoreClientAPI capi;

		protected float jumpCooldown;

		protected float dieAccum;

		protected float soundCoolDownLeft;

		protected static Random rand = new Random();

		protected float jumpHeight = 1.3f;

		protected AssetLocation sound;

		protected bool doubleJump = true;

		protected float soundCoolDown = 5f;

		protected virtual float soundRange => 16f;

		protected virtual float despawnDistanceSq => 400f;

		public EntityParticleInsect(ICoreClientAPI capi, double x, double y, double z)
		{
			this.capi = capi;
			((ParticleBase)this).Position.Set(x, y, z);
			((ParticleBase)this).ColorAlpha = byte.MaxValue;
			SwimOnLiquid = true;
			((ParticleBase)this).Alive = true;
			base.Size = 0.5f + (float)((IWorldAccessor)capi.World).Rand.NextDouble() * 0.5f;
		}

		protected override void doSlowTick(ParticlePhysics physicsSim, float dt)
		{
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Invalid comparison between Unknown and I4
			base.doSlowTick(physicsSim, dt);
			if (((CollectibleObject)((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)((ParticleBase)this).Position.X, (int)((ParticleBase)this).Position.Y, (int)((ParticleBase)this).Position.Z, 2)).IsLiquid())
			{
				dieAccum += dt;
				if (dieAccum > 10f)
				{
					((ParticleBase)this).Alive = false;
				}
				return;
			}
			if (jumpHeight > 0f && doubleJump && jumpCooldown < 1.5f && jumpCooldown > 0f && (((ParticleBase)this).flags & 2) > 0 && ((ParticleBase)this).Velocity.Y <= 0f && rand.NextDouble() < 0.4)
			{
				jump((float)rand.NextDouble() - 0.5f, jumpHeight, (float)rand.NextDouble() - 0.5f);
			}
			if (jumpCooldown > 0f)
			{
				jumpCooldown = GameMath.Max(0f, jumpCooldown - dt);
				return;
			}
			soundCoolDownLeft = GameMath.Max(0f, soundCoolDownLeft - dt);
			if (jumpHeight > 0f && rand.NextDouble() < 0.005)
			{
				jump((float)rand.NextDouble() - 0.5f, jumpHeight, (float)rand.NextDouble() - 0.5f);
				return;
			}
			if (soundCoolDownLeft <= 0f && shouldPlaySound())
			{
				playsound();
				soundCoolDownLeft = soundCoolDown;
				return;
			}
			EntityPlayer entity = ((IWorldAccessor)capi.World).NearestPlayer(((ParticleBase)this).Position.X, ((ParticleBase)this).Position.Y, ((ParticleBase)this).Position.Z).Entity;
			double num = 2500.0;
			if (entity != null && (num = ((Entity)entity).Pos.SquareHorDistanceTo(((ParticleBase)this).Position)) < 9.0 && jumpHeight > 0f)
			{
				Vec3d val = ((Entity)entity).Pos.XYZ.Sub(((ParticleBase)this).Position).Normalize();
				jump((float)(0.0 - val.X), jumpHeight, (float)(0.0 - val.Z));
			}
			if (entity == null || num > (double)despawnDistanceSq)
			{
				dieAccum += dt;
				if (dieAccum > 10f)
				{
					((ParticleBase)this).Alive = false;
				}
			}
			else
			{
				dieAccum = 0f;
			}
		}

		private void playsound()
		{
			EntityPos pos = ((Entity)((IPlayer)capi.World.Player).Entity).Pos;
			float num = ((((ICoreAPI)capi).ModLoader.GetModSystem<RoomRegistry>(true).GetRoomForPosition(pos.AsBlockPos).ExitCount < 2) ? 0.1f : 1f);
			float volume = 1f * num;
			if (volume > 0.05f)
			{
				((IEventAPI)capi.Event).EnqueueMainThreadTask((Action)delegate
				{
					((IWorldAccessor)capi.World).PlaySoundAt(sound, ((ParticleBase)this).Position.X, ((ParticleBase)this).Position.Y, ((ParticleBase)this).Position.Z, (IPlayer)null, RandomPitch(), soundRange, volume);
				}, "playginsectsound");
			}
		}

		protected virtual float RandomPitch()
		{
			return (float)((IWorldAccessor)capi.World).Rand.NextDouble() * 0.5f + 0.75f;
		}

		protected virtual bool shouldPlaySound()
		{
			return rand.NextDouble() < 0.01;
		}

		private void jump(float dirx, float diry, float dirz)
		{
			((ParticleBase)this).Velocity.Add(dirx, diry, dirz);
			jumpCooldown = 2f;
		}
	}
	public class EntityParticleSpawner : ModSystem
	{
		private ICoreClientAPI capi;

		private Random rand = new Random();

		private NormalizedSimplexNoise grasshopperNoise;

		private NormalizedSimplexNoise cicadaNoise;

		private NormalizedSimplexNoise matingGnatsSwarmNoise;

		private NormalizedSimplexNoise coquiNoise;

		private NormalizedSimplexNoise waterstriderNoise;

		private Queue<Action> SimTickExecQueue = new Queue<Action>();

		public HashSet<string> disabledInsects;

		private EntityParticleSystem sys;

		private float accum;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Expected O, but got Unknown
			//IL_026e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0278: Expected O, but got Unknown
			//IL_0298: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Expected O, but got Unknown
			//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cc: Expected O, but got Unknown
			//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f6: Expected O, but got Unknown
			capi = api;
			grasshopperNoise = NormalizedSimplexNoise.FromDefaultOctaves(4, 0.01, 0.9, (long)(((IWorldAccessor)api.World).Seed * 100));
			coquiNoise = NormalizedSimplexNoise.FromDefaultOctaves(4, 0.0025, 0.9, (long)(((IWorldAccessor)api.World).Seed * 101));
			waterstriderNoise = NormalizedSimplexNoise.FromDefaultOctaves(4, 0.01, 0.9, (long)(((IWorldAccessor)api.World).Seed * 102));
			matingGnatsSwarmNoise = NormalizedSimplexNoise.FromDefaultOctaves(4, 0.01, 0.9, (long)(((IWorldAccessor)api.World).Seed * 103));
			cicadaNoise = NormalizedSimplexNoise.FromDefaultOctaves(4, 0.01, 0.9, (long)(((IWorldAccessor)api.World).Seed * 104));
			sys = ((ICoreAPI)api).ModLoader.GetModSystem<EntityParticleSystem>(true);
			sys.OnSimTick += Sys_OnSimTick;
			disabledInsects = new HashSet<string>();
			List<string> list = capi.Settings.Strings["disabledInsects"];
			if (list != null)
			{
				HashsetExtensions.AddRange<string>(disabledInsects, (IEnumerable<string>)list);
			}
			((ICoreAPI)api).ChatCommands.GetOrCreate("insectconfig").WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[2]
			{
				(ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.WordRange("type", new string[5] { "grasshopper", "cicada", "gnats", "coqui", "waterstrider" }),
				(ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.OptionalBool("enable/disable", "on")
			}).HandleWith(new OnCommandDelegate(onCmdInsectConfig));
			IChatCommandExt.EndSub(IChatCommandExt.EndSub(IChatCommandExt.WithDesc(IChatCommandExt.BeginSub(IChatCommandExt.EndSub(IChatCommandExt.WithDesc(IChatCommandExt.BeginSub(IChatCommandExt.EndSub(IChatCommandExt.WithDesc(IChatCommandExt.BeginSub(IChatCommandExt.EndSub(IChatCommandExt.WithDesc(IChatCommandExt.BeginSub(IChatCommandExt.WithDesc(IChatCommandExt.BeginSub(((ICoreAPI)api).ChatCommands.GetOrCreate("debug"), "eps"), "eps"), "testspawn"), "testspawn").WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.WordRange("type", new string[6] { "gh", "ws", "coq", "mg", "cic", "fis" }) }).HandleWith(new OnCommandDelegate(handleSpawn))), "count"), "count").HandleWith(new OnCommandDelegate(handleCount))), "clear"), "clear").HandleWith(new OnCommandDelegate(handleClear))), "testnoise"), "testnoise").HandleWith(new OnCommandDelegate(handleTestnoise)).WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.OptionalWordRange("clear", new string[1] { "clear" }) })));
		}

		private TextCommandResult onCmdInsectConfig(TextCommandCallingArgs args)
		{
			string text = (string)args[0];
			if (args.Parsers[1].IsMissing)
			{
				return TextCommandResult.Success(Lang.Get("{0} are currently {1}", new object[2]
				{
					text,
					disabledInsects.Contains(text) ? Lang.Get("disabled", Array.Empty<object>()) : Lang.Get("enabled", Array.Empty<object>())
				}), (object)null);
			}
			bool flag = !(bool)args[1];
			if (flag)
			{
				disabledInsects.Add(text);
			}
			else
			{
				disabledInsects.Remove(text);
			}
			capi.Settings.Strings["disabledInsects"] = disabledInsects.ToList();
			return TextCommandResult.Success(Lang.Get("{0} are now {1}", new object[2]
			{
				text,
				flag ? Lang.Get("disabled", Array.Empty<object>()) : Lang.Get("enabled", Array.Empty<object>())
			}), (object)null);
		}

		private TextCommandResult handleCount(TextCommandCallingArgs args)
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (KeyValuePair<string, int> item in sys.Count.Dict)
			{
				stringBuilder.AppendLine($"{item.Key}: {item.Value}");
			}
			if (stringBuilder.Length == 0)
			{
				return TextCommandResult.Success("No entityparticle alive", (object)null);
			}
			return TextCommandResult.Success(stringBuilder.ToString(), (object)null);
		}

		private TextCommandResult handleTestnoise(TextCommandCallingArgs args)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Expected O, but got Unknown
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Expected O, but got Unknown
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Expected O, but got Unknown
			BlockPos asBlockPos = ((Entity)((IPlayer)capi.World.Player).Entity).Pos.XYZ.AsBlockPos;
			Block block = ((IWorldAccessor)capi.World).GetBlock(new AssetLocation("creativeblock-35"));
			bool flag = !args.Parsers[0].IsMissing;
			for (int i = -200; i <= 200; i++)
			{
				for (int j = -200; j <= 200; j++)
				{
					double num = matingGnatsSwarmNoise.Noise((double)(asBlockPos.X + i), (double)(asBlockPos.Z + j));
					if (flag || num < 0.65)
					{
						((IWorldAccessor)capi.World).BlockAccessor.SetBlock(0, new BlockPos(asBlockPos.X + i, 160, asBlockPos.Z + j));
					}
					else
					{
						((IWorldAccessor)capi.World).BlockAccessor.SetBlock(((CollectibleObject)block).Id, new BlockPos(asBlockPos.X + i, 160, asBlockPos.Z + j));
					}
				}
			}
			return TextCommandResult.Success("testnoise", (object)null);
		}

		private TextCommandResult handleClear(TextCommandCallingArgs args)
		{
			sys.Clear();
			sys.SpawnedFish.Clear();
			return TextCommandResult.Success("cleared", (object)null);
		}

		private TextCommandResult handleSpawn(TextCommandCallingArgs args)
		{
			string type = args[0] as string;
			SimTickExecQueue.Enqueue(delegate
			{
				//IL_0344: Unknown result type (might be due to invalid IL or missing references)
				//IL_0354: Expected O, but got Unknown
				EntityPos pos = ((Entity)((IPlayer)capi.World.Player).Entity).Pos;
				ClimateCondition climateAt = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(pos.AsBlockPos, (EnumGetClimateMode)1, 0.0);
				float cohesion = (float)GameMath.Max(rand.NextDouble() * 1.1, 0.25);
				Vec3d val = pos.XYZ.AddCopy(0f, 1.5f, 0f);
				for (int i = 0; i < 20; i++)
				{
					double num = pos.X + (rand.NextDouble() - 0.5) * 10.0;
					double num2 = pos.Z + (rand.NextDouble() - 0.5) * 10.0;
					double num3 = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num, (int)num2);
					if (type == "gh")
					{
						EntityParticleGrasshopper eparticle = new EntityParticleGrasshopper(capi, num, num3 + 1.0 + rand.NextDouble() * 0.25, num2);
						sys.SpawnParticle(eparticle);
					}
					if (type == "coq")
					{
						EntityParticleCoqui eparticle2 = new EntityParticleCoqui(capi, num, num3 + 1.0 + rand.NextDouble() * 0.25, num2);
						sys.SpawnParticle(eparticle2);
					}
					if (type == "ws")
					{
						Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3, (int)num2, 2);
						if (blockRaw.LiquidCode == "water" && blockRaw.PushVector == (Vec3d)null)
						{
							EntityParticleWaterStrider eparticle3 = new EntityParticleWaterStrider(capi, num, num3 + (double)((float)blockRaw.LiquidLevel / 8f), num2);
							sys.SpawnParticle(eparticle3);
						}
					}
					if (type == "fis")
					{
						num = pos.X + (rand.NextDouble() - 0.5) * 2.0;
						num2 = pos.Z + (rand.NextDouble() - 0.5) * 2.0;
						Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3, (int)num2, 2);
						if (blockRaw2.LiquidCode == "saltwater" && blockRaw2.PushVector == (Vec3d)null)
						{
							EntityParticleFish eparticle4 = new EntityParticleFish(capi, num, num3 - (double)blockRaw2.LiquidLevel, num2, new Vec3f(0.4f), 0, 0.3f);
							sys.SpawnParticle(eparticle4);
						}
					}
					if (type == "mg")
					{
						sys.SpawnParticle(new EntityParticleMatingGnats(capi, cohesion, val.X, val.Y, val.Z));
					}
					if (type == "cic")
					{
						spawnCicadas(pos, climateAt);
					}
				}
			});
			return TextCommandResult.Success(type + " spawned.", (object)null);
		}

		private void Sys_OnSimTick(float dt)
		{
			accum += dt;
			while (SimTickExecQueue.Count > 0)
			{
				SimTickExecQueue.Dequeue()();
			}
			if (!(accum > 0.5f))
			{
				return;
			}
			accum = 0f;
			EntityPos pos = ((Entity)((IPlayer)capi.World.Player).Entity).Pos;
			if (pos.Dimension == 0)
			{
				ClimateCondition climateAt = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(pos.AsBlockPos, (EnumGetClimateMode)1, 0.0);
				if (!disabledInsects.Contains("grasshopper"))
				{
					spawnGrasshoppers(pos, climateAt);
				}
				if (!disabledInsects.Contains("cicada"))
				{
					spawnCicadas(pos, climateAt);
				}
				if (!disabledInsects.Contains("gnats"))
				{
					spawnMatingGnatsSwarm(pos, climateAt);
				}
				if (!disabledInsects.Contains("coqui"))
				{
					spawnCoquis(pos, climateAt);
				}
				if (!disabledInsects.Contains("waterstrider"))
				{
					spawnWaterStriders(pos, climateAt);
				}
				spawnFish(pos, climateAt);
			}
		}

		private void spawnWaterStriders(EntityPos pos, ClimateCondition climate)
		{
			if (climate.Temperature > 35f || climate.Temperature < 19f || climate.Rainfall > 0.1f || (double)climate.WorldgenRainfall < 0.5 || waterstriderNoise.Noise(pos.X, pos.Z) < 0.5 || sys.Count["waterStrider"] > 50)
			{
				return;
			}
			for (int i = 0; i < 100; i++)
			{
				double num = pos.X + (rand.NextDouble() - 0.5) * 60.0;
				double num2 = pos.Z + (rand.NextDouble() - 0.5) * 60.0;
				double num3 = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num, (int)num2);
				if (!(pos.HorDistanceTo(num, num2) < 3.0))
				{
					Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3, (int)num2, 2);
					Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3 - 1, (int)num2, 0);
					Block blockRaw3 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3 + 1, (int)num2, 0);
					if (blockRaw.LiquidCode == "water" && blockRaw.PushVector == (Vec3d)null && blockRaw2.Replaceable < 6000 && ((CollectibleObject)blockRaw3).Id == 0)
					{
						EntityParticleWaterStrider eparticle = new EntityParticleWaterStrider(capi, num, num3 + (double)((float)blockRaw.LiquidLevel / 8f), num2);
						sys.SpawnParticle(eparticle);
					}
				}
			}
		}

		private void spawnFish(EntityPos pos, ClimateCondition climate)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Expected O, but got Unknown
			//IL_0119: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ff: Expected O, but got Unknown
			//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
			if (climate.Temperature > 40f || climate.Temperature < 0f)
			{
				return;
			}
			BlockPos val = new BlockPos(0);
			if (sys.Count["fish"] > 500)
			{
				return;
			}
			FastVec3i val2 = default(FastVec3i);
			for (int i = 0; i < 100; i++)
			{
				int num = (int)(pos.X + (rand.NextDouble() - 0.5) * 60.0);
				int num2 = (int)(pos.Z + (rand.NextDouble() - 0.5) * 60.0);
				val.Set(num, 0, num2);
				int terrainMapheightAt = ((IWorldAccessor)capi.World).BlockAccessor.GetTerrainMapheightAt(val);
				val.Y = Math.Min(((IWorldAccessor)capi.World).SeaLevel - 1, terrainMapheightAt + 2);
				if (val.HorDistanceSqTo(pos.X, pos.Z) < 16f)
				{
					continue;
				}
				((FastVec3i)(ref val2))._002Ector(val.X, val.Y, val.Z);
				if (sys.SpawnedFish.Contains(val2) || GameMath.MurmurHash3Mod(val.X, val.Y, val.Z, 100) < 80)
				{
					continue;
				}
				Block block = ((IWorldAccessor)capi.World).BlockAccessor.GetBlock(val, 2);
				Block block2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlock(val.DownCopy(1));
				if (!(block.LiquidCode != "saltwater") && StringUtil.StartsWithFast(((RegistryObject)block2).Code.Path, "coral"))
				{
					sys.SpawnedFish.Add(val2);
					int num3 = 5 + rand.Next(15);
					EntityParticleFish[] array = new EntityParticleFish[num3];
					Vec3f val3 = new Vec3f(0.55f + (float)rand.NextDouble() * 0.65f, 0.3f, 0.3f);
					val3.Mul(1f + (float)rand.NextDouble() * 0.5f);
					float maxspeed = 0.15f + (float)rand.NextDouble() * 0.2f;
					int colorindex = rand.Next(EntityParticleFish.Colors.Length);
					for (int j = 0; j < num3; j++)
					{
						double num4 = rand.NextDouble() - 0.5;
						double num5 = rand.NextDouble() - 0.5;
						EntityParticleFish entityParticleFish = new EntityParticleFish(capi, (double)num + num4, val.Y, (double)num2 + num5, val3, colorindex, maxspeed);
						entityParticleFish.StartPos = val2;
						array[j] = entityParticleFish;
						sys.SpawnParticle(entityParticleFish);
					}
					for (int k = 0; k < num3; k++)
					{
						array[k].FriendFishes = new EntityParticleFish[4]
						{
							array[GameMath.Mod(k - 2, num3)],
							array[GameMath.Mod(k - 1, num3)],
							array[GameMath.Mod(k + 1, num3)],
							array[GameMath.Mod(k + 2, num3)]
						};
					}
				}
			}
		}

		private void spawnGrasshoppers(EntityPos pos, ClimateCondition climate)
		{
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Invalid comparison between Unknown and I4
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Invalid comparison between Unknown and I4
			if (climate.Temperature >= 30f || climate.Temperature < 18f || climate.Rainfall > 0.1f || (double)climate.WorldgenRainfall < 0.5 || grasshopperNoise.Noise(pos.X, pos.Z) < 0.7 || sys.Count["grassHopper"] > 40)
			{
				return;
			}
			for (int i = 0; i < 100; i++)
			{
				double num = pos.X + (rand.NextDouble() - 0.5) * 60.0;
				double num2 = pos.Z + (rand.NextDouble() - 0.5) * 60.0;
				double num3 = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num, (int)num2);
				if (!(pos.HorDistanceTo(num, num2) < 3.0))
				{
					Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3 + 1, (int)num2, 0);
					Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3, (int)num2, 0);
					if ((int)blockRaw.BlockMaterial == 13 && (int)blockRaw2.BlockMaterial == 1)
					{
						EntityParticleGrasshopper eparticle = new EntityParticleGrasshopper(capi, num, num3 + 1.01 + rand.NextDouble() * 0.25, num2);
						sys.SpawnParticle(eparticle);
					}
				}
			}
		}

		private void spawnCicadas(EntityPos pos, ClimateCondition climate)
		{
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Invalid comparison between Unknown and I4
			if (climate.Temperature > 33f || climate.Temperature < 22f || climate.WorldGenTemperature < 10f || climate.WorldGenTemperature > 22f || climate.Rainfall > 0.1f || (double)climate.WorldgenRainfall < 0.5 || cicadaNoise.Noise(pos.X, pos.Z, (double)((IGameCalendar)capi.World.Calendar).Year) < 0.7 || sys.Count["cicada"] > 40)
			{
				return;
			}
			for (int i = 0; i < 400; i++)
			{
				double num = pos.X + (rand.NextDouble() - 0.5) * 50.0;
				double num2 = pos.Z + (rand.NextDouble() - 0.5) * 50.0;
				double num3 = pos.Y + (rand.NextDouble() - 0.5) * 10.0;
				if (pos.HorDistanceTo(num, num2) < 2.0)
				{
					continue;
				}
				Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3, (int)num2, 0);
				Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3 - 1, (int)num2, 0);
				if ((int)blockRaw.BlockMaterial != 4 || !(((RegistryObject)blockRaw).Variant["type"] == "grown") || ((CollectibleObject)blockRaw2).Id != ((CollectibleObject)blockRaw).Id)
				{
					continue;
				}
				Vec3f normalf = BlockFacing.HORIZONTALS[rand.Next(4)].Normalf;
				double num4 = (float)(int)num + 0.5f + normalf.X * 0.52f;
				double num5 = num3 + 0.1 + rand.NextDouble() * 0.8;
				double num6 = (float)(int)num2 + 0.5f + normalf.Z * 0.52f;
				if (((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num4, (int)num5, (int)num6, 0).Replaceable >= 6000)
				{
					EntityParticleCicada eparticle = new EntityParticleCicada(capi, num4, num5, num6);
					sys.SpawnParticle(eparticle);
					continue;
				}
				num4 += (double)normalf.X;
				num6 += (double)normalf.Z;
				if (((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num4, (int)num5, (int)num6, 0).Replaceable >= 6000)
				{
					EntityParticleCicada eparticle2 = new EntityParticleCicada(capi, num4, num5, num6);
					sys.SpawnParticle(eparticle2);
				}
			}
		}

		private void spawnCoquis(EntityPos pos, ClimateCondition climate)
		{
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Invalid comparison between Unknown and I4
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Invalid comparison between Unknown and I4
			if (climate.WorldGenTemperature < 30f || (double)climate.WorldgenRainfall < 0.7 || coquiNoise.Noise(pos.X, pos.Z) < 0.8 || sys.Count["coqui"] > 60)
			{
				return;
			}
			for (int i = 0; i < 100; i++)
			{
				double num = pos.X + (rand.NextDouble() - 0.5) * 60.0;
				double num2 = pos.Z + (rand.NextDouble() - 0.5) * 60.0;
				double num3 = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num, (int)num2);
				if (!(pos.HorDistanceTo(num, num2) < 3.0))
				{
					Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3 + 1, (int)num2, 0);
					Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num, (int)num3, (int)num2, 0);
					if ((int)blockRaw.BlockMaterial == 13 && (int)blockRaw2.BlockMaterial == 1)
					{
						EntityParticleCoqui eparticle = new EntityParticleCoqui(capi, num, num3 + 1.01 + rand.NextDouble() * 0.25, num2);
						sys.SpawnParticle(eparticle);
					}
				}
			}
		}

		private void spawnMatingGnatsSwarm(EntityPos pos, ClimateCondition climate)
		{
			if (climate.Temperature < 17f || climate.Rainfall > 0.1f || (double)climate.WorldgenRainfall < 0.6 || GlobalConstants.CurrentWindSpeedClient.Length() > 0.35f || matingGnatsSwarmNoise.Noise(pos.X, pos.Z) < 0.5 || sys.Count["matinggnats"] > 200)
			{
				return;
			}
			int num = 0;
			for (int i = 0; i < 100; i++)
			{
				if (num >= 6)
				{
					break;
				}
				double num2 = pos.X + (rand.NextDouble() - 0.5) * 24.0;
				double num3 = pos.Z + (rand.NextDouble() - 0.5) * 24.0;
				double num4 = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num2, (int)num3);
				if (pos.HorDistanceTo(num2, num3) < 2.0)
				{
					continue;
				}
				Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num2, (int)num4 + 2, (int)num3, 0);
				Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num2, (int)num4 + 1, (int)num3, 0);
				Block blockRaw3 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num2, (int)num4, (int)num3, 2);
				Block blockRaw4 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num2, (int)num4 - 2, (int)num3, 2);
				if (blockRaw3.LiquidCode == "water" && ((CollectibleObject)blockRaw2).Id == 0 && ((CollectibleObject)blockRaw).Id == 0 && ((CollectibleObject)blockRaw4).Id == 0)
				{
					float cohesion = (float)GameMath.Max(rand.NextDouble() * 1.1, 0.25) / 2f;
					int num5 = 10 + rand.Next(21);
					for (int j = 0; j < num5; j++)
					{
						sys.SpawnParticle(new EntityParticleMatingGnats(capi, cohesion, (double)(int)num2 + 0.5, num4 + 1.5 + rand.NextDouble() * 0.5, (double)(int)num3 + 0.5));
					}
					num++;
				}
			}
		}
	}
	public class EPCounter
	{
		private Dictionary<string, int> epcount = new Dictionary<string, int>();

		public Dictionary<string, int> Dict => epcount;

		public int this[string key]
		{
			get
			{
				if (epcount.TryGetValue(key, out var value))
				{
					return value;
				}
				return 0;
			}
		}

		public void Inc(string key)
		{
			if (epcount.TryGetValue(key, out var value))
			{
				epcount[key] = value + 1;
			}
			else
			{
				epcount[key] = 1;
			}
		}

		public void Dec(string key)
		{
			if (epcount.TryGetValue(key, out var value))
			{
				epcount[key] = value - 1;
			}
			else
			{
				epcount[key] = -1;
			}
		}

		public void Clear()
		{
			epcount.Clear();
		}
	}
	public class EntityParticleSystem : ModSystem, IRenderer, IDisposable
	{
		protected MeshRef particleModelRef;

		protected MeshData[] updateBuffers;

		protected Vec3d[] cameraPos;

		protected float[] tickTimes;

		protected float[][] velocities;

		protected int writePosition = 1;

		protected int readPosition;

		protected object advanceCountLock = new object();

		protected int advanceCount;

		protected Random rand = new Random();

		protected ICoreClientAPI capi;

		protected float currentGamespeed;

		protected ParticlePhysics partPhysics;

		protected EnumParticleModel ModelType = (EnumParticleModel)1;

		private IShaderProgram vec3ScaleCubeParticleShader;

		private int poolSize = 10000;

		private int quantityAlive;

		private int offthreadid;

		private EPCounter counter = new EPCounter();

		public HashSet<FastVec3i> SpawnedFish = new HashSet<FastVec3i>();

		private bool isShuttingDown;

		public EntityParticle FirstAlive;

		public EntityParticle LastAlive;

		private float accumPhysics;

		public MeshRef Model => particleModelRef;

		public IBlockAccessor BlockAccess => partPhysics.BlockAccess;

		public double RenderOrder => 1.0;

		public int RenderRange => 50;

		public EPCounter Count => counter;

		public event Action<float> OnSimTick;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public virtual MeshData LoadModel()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MeshData cubeOnlyScaleXyz = CubeMeshUtil.GetCubeOnlyScaleXyz(1f / 32f, 1f / 32f, new Vec3f());
			cubeOnlyScaleXyz.WithNormals();
			cubeOnlyScaleXyz.Rgba = null;
			for (int i = 0; i < 24; i++)
			{
				BlockFacing val = BlockFacing.ALLFACES[i / 4];
				cubeOnlyScaleXyz.AddNormal(val);
			}
			return cubeOnlyScaleXyz;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Expected O, but got Unknown
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Expected O, but got Unknown
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Expected O, but got Unknown
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Expected O, but got Unknown
			//IL_022f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0239: Expected O, but got Unknown
			capi = api;
			capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)1, "reeps-op");
			Thread thread = TyronThreadPool.CreateDedicatedThread((ThreadStart)onThreadStart, "entityparticlesim");
			offthreadid = thread.ManagedThreadId;
			capi.Event.LeaveWorld += delegate
			{
				isShuttingDown = true;
			};
			thread.Start();
			partPhysics = new ParticlePhysics(((IWorldAccessor)api.World).GetLockFreeBlockAccessor());
			partPhysics.PhysicsTickTime = 0.125f;
			MeshData val = LoadModel();
			CustomMeshDataPartFloat val2 = new CustomMeshDataPartFloat();
			((CustomMeshDataPart<float>)(object)val2).Instanced = true;
			((CustomMeshDataPart<float>)(object)val2).StaticDraw = false;
			((CustomMeshDataPart<float>)(object)val2).Values = new float[poolSize * 10];
			((CustomMeshDataPart<float>)(object)val2).InterleaveSizes = new int[3] { 3, 3, 4 };
			((CustomMeshDataPart<float>)(object)val2).InterleaveStride = 40;
			((CustomMeshDataPart<float>)(object)val2).InterleaveOffsets = new int[3] { 0, 12, 24 };
			((CustomMeshDataPart<float>)(object)val2).Count = poolSize * 10;
			val.CustomFloats = val2;
			CustomMeshDataPartByte val3 = new CustomMeshDataPartByte();
			val3.Conversion = (DataConversion)1;
			((CustomMeshDataPart<byte>)(object)val3).Instanced = true;
			((CustomMeshDataPart<byte>)(object)val3).StaticDraw = false;
			((CustomMeshDataPart<byte>)(object)val3).Values = new byte[poolSize * 8];
			((CustomMeshDataPart<byte>)(object)val3).InterleaveSizes = new int[2] { 4, 4 };
			((CustomMeshDataPart<byte>)(object)val3).InterleaveStride = 8;
			((CustomMeshDataPart<byte>)(object)val3).InterleaveOffsets = new int[2] { 0, 4 };
			((CustomMeshDataPart<byte>)(object)val3).Count = poolSize * 8;
			val.CustomBytes = val3;
			val.Flags = new int[poolSize];
			val.FlagsInstanced = true;
			particleModelRef = api.Render.UploadMesh(val);
			updateBuffers = (MeshData[])(object)new MeshData[5];
			cameraPos = (Vec3d[])(object)new Vec3d[5];
			tickTimes = new float[5];
			velocities = new float[5][];
			for (int num = 0; num < 5; num++)
			{
				tickTimes[num] = partPhysics.PhysicsTickTime;
				velocities[num] = new float[3 * poolSize];
				cameraPos[num] = new Vec3d();
				updateBuffers[num] = genUpdateBuffer();
			}
			api.Event.ReloadShader += new ActionBoolReturn(LoadShader);
			LoadShader();
		}

		public bool LoadShader()
		{
			IShaderProgram val = (vec3ScaleCubeParticleShader = capi.Shader.NewShaderProgram());
			val.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			val.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			IShader vertexShader = val.VertexShader;
			vertexShader.PrefixCode += "#define VEC3SCALE 1\n";
			capi.Shader.RegisterFileShaderProgram("particlescube", val);
			return val.Compile();
		}

		private void onThreadStart()
		{
			while (!isShuttingDown)
			{
				Thread.Sleep(10);
				if (!capi.IsGamePaused)
				{
					IClientPlayer player = capi.World.Player;
					object obj;
					if (player == null)
					{
						obj = null;
					}
					else
					{
						EntityPlayer entity = ((IPlayer)player).Entity;
						obj = ((entity != null) ? entity.CameraPos.Clone() : null);
					}
					Vec3d val = (Vec3d)obj;
					if (val != (Vec3d)null)
					{
						OnNewFrameOffThread(0.01f, val);
					}
				}
			}
		}

		private MeshData genUpdateBuffer()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Expected O, but got Unknown
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Expected O, but got Unknown
			//IL_0034: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Expected O, but got Unknown
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Expected O, but got Unknown
			//IL_0060: Expected O, but got Unknown
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Expected O, but got Unknown
			MeshData val = new MeshData(true);
			CustomMeshDataPartFloat val2 = new CustomMeshDataPartFloat();
			((CustomMeshDataPart<float>)val2).Values = new float[poolSize * 10];
			((CustomMeshDataPart<float>)val2).Count = poolSize * 10;
			val.CustomFloats = val2;
			CustomMeshDataPartByte val3 = new CustomMeshDataPartByte();
			((CustomMeshDataPart<byte>)val3).Values = new byte[poolSize * 8];
			((CustomMeshDataPart<byte>)val3).Count = poolSize * 8;
			val.CustomBytes = val3;
			val.Flags = new int[poolSize];
			val.FlagsInstanced = true;
			return val;
		}

		public void SpawnParticle(EntityParticle eparticle)
		{
			if (Environment.CurrentManagedThreadId != offthreadid)
			{
				throw new InvalidOperationException("Only in the entityparticle thread");
			}
			((ParticleBase)eparticle).Prev = null;
			((ParticleBase)eparticle).Next = null;
			if (FirstAlive == null)
			{
				FirstAlive = eparticle;
				LastAlive = eparticle;
			}
			else
			{
				((ParticleBase)eparticle).Prev = (ParticleBase)(object)LastAlive;
				((ParticleBase)LastAlive).Next = (ParticleBase)(object)eparticle;
				LastAlive = eparticle;
			}
			eparticle.OnSpawned(partPhysics);
			counter.Inc(eparticle.Type);
			quantityAlive++;
		}

		protected void KillParticle(EntityParticle entityParticle)
		{
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			if (Environment.CurrentManagedThreadId != offthreadid)
			{
				throw new InvalidOperationException("Only in the entityparticle thread");
			}
			ParticleBase prev = ((ParticleBase)entityParticle).Prev;
			ParticleBase next = ((ParticleBase)entityParticle).Next;
			if (prev != null)
			{
				prev.Next = next;
			}
			if (next != null)
			{
				next.Prev = prev;
			}
			if (FirstAlive == entityParticle)
			{
				FirstAlive = (EntityParticle)(object)next;
			}
			if (LastAlive == entityParticle)
			{
				LastAlive = ((EntityParticle)(object)prev) ?? FirstAlive;
			}
			((ParticleBase)entityParticle).Prev = null;
			((ParticleBase)entityParticle).Next = null;
			if (entityParticle is EntityParticleFish entityParticleFish)
			{
				SpawnedFish.Remove(entityParticleFish.StartPos);
			}
			quantityAlive--;
			counter.Dec(entityParticle.Type);
		}

		public void OnRenderFrame(float dt, EnumRenderStage stage)
		{
			IShaderProgram obj = vec3ScaleCubeParticleShader;
			obj.Use();
			capi.Render.GlToggleBlend(true, (EnumBlendMode)0);
			capi.Render.GlPushMatrix();
			capi.Render.GlLoadMatrix(capi.Render.CameraMatrixOrigin);
			obj.Uniform("rgbaFogIn", capi.Ambient.BlendedFogColor);
			obj.Uniform("rgbaAmbientIn", capi.Ambient.BlendedAmbientColor);
			obj.Uniform("fogMinIn", capi.Ambient.BlendedFogMin);
			obj.Uniform("fogDensityIn", capi.Ambient.BlendedFogDensity);
			obj.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
			obj.UniformMatrix("modelViewMatrix", capi.Render.CurrentModelviewMatrix);
			OnNewFrame(dt, ((IPlayer)capi.World.Player).Entity.CameraPos);
			capi.Render.RenderMeshInstanced(Model, quantityAlive);
			obj.Stop();
			capi.Render.GlPopMatrix();
		}

		public void OnNewFrame(float dt, Vec3d cameraPos)
		{
			if (capi.IsGamePaused)
			{
				return;
			}
			accumPhysics += dt;
			float num = tickTimes[readPosition];
			if (accumPhysics >= num)
			{
				lock (advanceCountLock)
				{
					if (advanceCount > 0)
					{
						readPosition = (readPosition + 1) % updateBuffers.Length;
						advanceCount--;
						accumPhysics -= num;
						num = tickTimes[readPosition];
					}
				}
				if (accumPhysics > 1f)
				{
					accumPhysics = 0f;
				}
			}
			float num2 = dt / num;
			MeshData val = updateBuffers[readPosition];
			float[] array = velocities[readPosition];
			int num3 = (quantityAlive = val.VerticesCount);
			float num4 = (float)(this.cameraPos[readPosition].X - cameraPos.X);
			float num5 = (float)(this.cameraPos[readPosition].Y - cameraPos.Y);
			float num6 = (float)(this.cameraPos[readPosition].Z - cameraPos.Z);
			Vec3d obj = this.cameraPos[readPosition];
			obj.X -= (double)num4;
			Vec3d obj2 = this.cameraPos[readPosition];
			obj2.Y -= (double)num5;
			Vec3d obj3 = this.cameraPos[readPosition];
			obj3.Z -= (double)num6;
			float[] values = ((CustomMeshDataPart<float>)(object)val.CustomFloats).Values;
			for (int i = 0; i < num3; i++)
			{
				int num7 = i * 10;
				values[num7] += num4 + array[i * 3] * num2;
				num7++;
				values[num7] += num5 + array[i * 3 + 1] * num2;
				num7++;
				values[num7] += num6 + array[i * 3 + 2] * num2;
			}
			capi.Render.UpdateMesh(particleModelRef, val);
		}

		public void OnNewFrameOffThread(float dt, Vec3d cameraPos)
		{
			if (capi.IsGamePaused)
			{
				return;
			}
			lock (advanceCountLock)
			{
				if (advanceCount >= updateBuffers.Length - 1)
				{
					return;
				}
			}
			this.OnSimTick?.Invoke(dt);
			currentGamespeed = ((IGameCalendar)capi.World.Calendar).SpeedOfTime / 60f * 5f;
			ParticleBase val = (ParticleBase)(object)FirstAlive;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			MeshData val2 = updateBuffers[writePosition];
			float[] array = velocities[writePosition];
			Vec3d val3 = this.cameraPos[writePosition].Set(cameraPos);
			partPhysics.PhysicsTickTime = 1f / 64f;
			float num4 = Math.Max(partPhysics.PhysicsTickTime, dt);
			float num5 = num4 * currentGamespeed;
			int num6 = 0;
			while (val != null)
			{
				double x = val.Position.X;
				double y = val.Position.Y;
				double z = val.Position.Z;
				val.TickNow(num5, num5, capi, partPhysics);
				if (!val.Alive)
				{
					ParticleBase next = val.Next;
					KillParticle((EntityParticle)(object)val);
					val = next;
					continue;
				}
				array[num6 * 3] = (val.prevPosDeltaX = (float)(val.Position.X - x));
				array[num6 * 3 + 1] = (val.prevPosDeltaY = (float)(val.Position.Y - y));
				array[num6 * 3 + 2] = (val.prevPosDeltaZ = (float)(val.Position.Z - z));
				num6++;
				val.UpdateBuffers(val2, val3, ref num, ref num2, ref num3);
				val = val.Next;
			}
			((CustomMeshDataPart<float>)(object)val2.CustomFloats).Count = num6 * 10;
			((CustomMeshDataPart<byte>)(object)val2.CustomBytes).Count = num6 * 8;
			val2.VerticesCount = num6;
			tickTimes[writePosition] = Math.Min(num4, 1f);
			writePosition = (writePosition + 1) % updateBuffers.Length;
			lock (advanceCountLock)
			{
				advanceCount++;
			}
		}

		public override void Dispose()
		{
			MeshRef obj = particleModelRef;
			if (obj != null)
			{
				obj.Dispose();
			}
		}

		public void Clear()
		{
			FirstAlive = null;
			LastAlive = null;
			quantityAlive = 0;
			counter.Clear();
		}
	}
	public class EntityParticleCicada : EntityParticleGrasshopper
	{
		private float pitch;

		public override string Type => "cicada";

		protected override float soundRange => 24f;

		protected override float despawnDistanceSq => 576f;

		public EntityParticleCicada(ICoreClientAPI capi, double x, double y, double z)
			: base(capi, x, y, z)
		{
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Expected O, but got Unknown
			((ParticleBase)this).ColorRed = 42;
			((ParticleBase)this).ColorGreen = 72;
			((ParticleBase)this).ColorBlue = 96;
			jumpHeight = 0f;
			sound = new AssetLocation("sounds/creature/cicada");
			doubleJump = false;
			soundCoolDown = 12f + (float)EntityParticleInsect.rand.NextDouble() * 3f;
			pitch = (float)((IWorldAccessor)capi.World).Rand.NextDouble() * 0.2f + 0.85f;
			base.Size = 1f;
			base.GravityStrength = 0f;
		}

		protected override float RandomPitch()
		{
			return pitch;
		}
	}
	public class EntityParticleCoqui : EntityParticleGrasshopper
	{
		private static long lastCoquiSound;

		private long soundWaitMs;

		private float pitch;

		public override string Type => "coqui";

		public EntityParticleCoqui(ICoreClientAPI capi, double x, double y, double z)
			: base(capi, x, y, z)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Expected O, but got Unknown
			((ParticleBase)this).ColorRed = 86;
			((ParticleBase)this).ColorGreen = 144;
			((ParticleBase)this).ColorBlue = 193;
			jumpHeight = 0.8f;
			sound = new AssetLocation("sounds/creature/coqui");
			doubleJump = false;
			soundCoolDown = 4f + (float)EntityParticleInsect.rand.NextDouble() * 3f;
			soundWaitMs = 250 + EntityParticleInsect.rand.Next(250);
			pitch = (float)((IWorldAccessor)capi.World).Rand.NextDouble() * 0.2f + 0.89f;
		}

		protected override float RandomPitch()
		{
			return pitch;
		}

		protected override bool shouldPlaySound()
		{
			int num;
			if (EntityParticleInsect.rand.NextDouble() < 0.015 && ((IWorldAccessor)capi.World).ElapsedMilliseconds - lastCoquiSound > soundWaitMs)
			{
				num = ((((IWorldAccessor)capi.World).BlockAccessor.GetLightLevel(((ParticleBase)this).Position.AsBlockPos, (EnumLightLevelType)4) < 14) ? 1 : 0);
				if (num != 0)
				{
					lastCoquiSound = ((IWorldAccessor)capi.World).ElapsedMilliseconds;
				}
			}
			else
			{
				num = 0;
			}
			return (byte)num != 0;
		}
	}
	public class EntityParticleFish : EntityParticle
	{
		protected ICoreClientAPI capi;

		protected float dieAccum;

		protected static Random rand = new Random();

		private Vec3d StartingPosition = new Vec3d();

		private bool flee;

		private float maxspeed;

		public FastVec3i StartPos;

		private double wiggle;

		public static int[][] Colors = new int[7][]
		{
			new int[4] { 189, 187, 59, 255 },
			new int[4] { 192, 135, 53, 255 },
			new int[4] { 184, 88, 26, 255 },
			new int[4] { 180, 65, 47, 255 },
			new int[4] { 56, 125, 163, 255 },
			new int[4] { 57, 98, 193, 169 },
			new int[4] { 126, 90, 145, 255 }
		};

		public EntityParticleFish[] FriendFishes;

		public override string Type => "fish";

		public EntityParticleFish(ICoreClientAPI capi, double x, double y, double z, Vec3f size, int colorindex, float maxspeed)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			this.capi = capi;
			((ParticleBase)this).Position.Set(x, y, z);
			StartingPosition.Set(x, y, z);
			this.maxspeed = maxspeed;
			((ParticleBase)this).Alive = true;
			base.SizeX = size.X;
			base.SizeY = size.Y;
			base.SizeZ = size.Z;
			base.GravityStrength = 0f;
			((ParticleBase)this).ColorBlue = (byte)Colors[colorindex][0];
			((ParticleBase)this).ColorGreen = (byte)Colors[colorindex][1];
			((ParticleBase)this).ColorRed = (byte)Colors[colorindex][2];
			((ParticleBase)this).ColorAlpha = (byte)Colors[colorindex][3];
		}

		public override void TickNow(float dt, float physicsdt, ICoreClientAPI api, ParticlePhysics physicsSim)
		{
			base.TickNow(dt, physicsdt, api, physicsSim);
			((ParticleBase)this).Velocity.X = GameMath.Clamp(((ParticleBase)this).Velocity.X, 0f - maxspeed, maxspeed);
			((ParticleBase)this).Velocity.Y = GameMath.Clamp(((ParticleBase)this).Velocity.Y, 0f - maxspeed, maxspeed);
			((ParticleBase)this).Velocity.Z = GameMath.Clamp(((ParticleBase)this).Velocity.Z, 0f - maxspeed, maxspeed);
			wiggle = GameMath.Mod(wiggle + (double)(dt * 30f * ((ParticleBase)this).Velocity.Length()), 6.2831854820251465);
		}

		protected override void doSlowTick(ParticlePhysics physicsSim, float dt)
		{
			//IL_017b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Invalid comparison between Unknown and I4
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Invalid comparison between Unknown and I4
			base.doSlowTick(physicsSim, dt);
			Vec3d val = StartingPosition.SubCopy(((ParticleBase)this).Position);
			float num = (float)val.Length();
			if (!flee)
			{
				val.Normalize();
				float num2 = GameMath.Clamp((num - 3f) * 0.1f, 0f, 0.4f);
				((ParticleBase)this).Velocity.Add((float)val.X * num2, (float)val.Y * num2, (float)val.Z * num2);
			}
			DoSchool();
			if (rand.NextDouble() < 0.01)
			{
				float num3 = (float)rand.NextDouble() * 0.66f - 0.33f;
				float num4 = (float)rand.NextDouble() * 0.2f - 0.1f;
				float num5 = (float)rand.NextDouble() * 0.66f - 0.33f;
				propel(num3 / 3f, num4 / 3f, num5 / 3f);
				DoSchool();
				return;
			}
			EntityPlayer entity = ((IWorldAccessor)capi.World).NearestPlayer(((ParticleBase)this).Position.X, ((ParticleBase)this).Position.Y, ((ParticleBase)this).Position.Z).Entity;
			double num6 = 2500.0;
			flee = false;
			if (entity != null && (num6 = ((Entity)entity).Pos.SquareDistanceTo(((ParticleBase)this).Position)) < 25.0 && (int)entity.Player.WorldData.CurrentGameMode != 2 && (int)entity.Player.WorldData.CurrentGameMode != 3)
			{
				Vec3d val2 = ((Entity)entity).Pos.XYZ.Sub(((ParticleBase)this).Position).Normalize();
				propel((float)(0.0 - val2.X), 0f, (float)(0.0 - val2.Z));
				flee = true;
				DoSchool();
			}
			if (!((CollectibleObject)((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)((ParticleBase)this).Position.X, (int)(((ParticleBase)this).Position.Y + 0.4000000059604645), (int)((ParticleBase)this).Position.Z, 2)).IsLiquid())
			{
				Vec3f velocity = ((ParticleBase)this).Velocity;
				velocity.Y -= 0.1f;
			}
			if (entity == null || num6 > 1600.0)
			{
				dieAccum += dt;
				if (dieAccum > 15f)
				{
					((ParticleBase)this).Alive = false;
				}
			}
			else
			{
				dieAccum = 0f;
			}
		}

		private void DoSchool()
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Expected O, but got Unknown
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Expected O, but got Unknown
			if (!flee)
			{
				Vec3d val = new Vec3d();
				Vec3f val2 = new Vec3f();
				EntityParticleFish[] friendFishes = FriendFishes;
				int num = friendFishes.Length;
				for (int i = 0; i < num; i++)
				{
					Vec3d position = ((ParticleBase)friendFishes[i]).Position;
					val.Add(position.X / (double)num, position.Y / (double)num, position.Z / (double)num);
					val2.Add(((ParticleBase)friendFishes[i]).Velocity);
					Vec3d val3 = ((ParticleBase)this).Position.SubCopy(val);
					float num2 = (float)val3.Length();
					float num3 = GameMath.Clamp((0.05f - num2) / 2f, 0f, 0.03f);
					((ParticleBase)this).Velocity.Add((float)Math.Sign(val3.X) * num3, (float)Math.Sign(val3.Y) * num3, (float)Math.Sign(val3.Z) * num3);
				}
				Vec3d val4 = ((ParticleBase)this).Position.SubCopy(val);
				float num4 = GameMath.Clamp(((float)val4.Length() - 0.25f) / 1f, 0f, 0.03f);
				((ParticleBase)this).Velocity.Add((0f - (float)Math.Sign(val4.X)) * num4, (0f - (float)Math.Sign(val4.Y)) * num4, (0f - (float)Math.Sign(val4.Z)) * num4);
				((ParticleBase)this).Velocity.Add(val2.X / (float)num / 20f, val2.Y / (float)num / 20f, val2.Z / (float)num / 20f);
			}
		}

		private void propel(float dirx, float diry, float dirz)
		{
			((ParticleBase)this).Velocity.Add(dirx, diry, dirz);
		}

		public override int UpdateAngles(float[] customFloats, int posPosition)
		{
			customFloats[posPosition++] = dirNormalizedX;
			customFloats[posPosition++] = dirNormalizedY;
			customFloats[posPosition++] = dirNormalizedZ;
			customFloats[posPosition++] = GameMath.Sin((float)wiggle) / 5f;
			return posPosition;
		}
	}
	public class EntityParticleGrasshopper : EntityParticleInsect
	{
		public override string Type => "grassHopper";

		public EntityParticleGrasshopper(ICoreClientAPI capi, double x, double y, double z)
			: base(capi, x, y, z)
		{
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Invalid comparison between Unknown and I4
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Expected O, but got Unknown
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Expected O, but got Unknown
			Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)x, (int)y, (int)z, 0);
			if ((int)blockRaw.BlockMaterial == 13)
			{
				int color = blockRaw.GetColor(capi, new BlockPos((int)x, (int)y, (int)z));
				((ParticleBase)this).ColorRed = (byte)((color >> 16) & 0xFF);
				((ParticleBase)this).ColorGreen = (byte)((color >> 8) & 0xFF);
				((ParticleBase)this).ColorBlue = (byte)(color & 0xFF);
			}
			else
			{
				((ParticleBase)this).ColorRed = 31;
				((ParticleBase)this).ColorGreen = 178;
				((ParticleBase)this).ColorBlue = 144;
			}
			sound = new AssetLocation("sounds/creature/grasshopper");
		}

		protected override bool shouldPlaySound()
		{
			if (EntityParticleInsect.rand.NextDouble() < 0.01 && ((IWorldAccessor)capi.World).BlockAccessor.GetLightLevel(((ParticleBase)this).Position.AsBlockPos, (EnumLightLevelType)4) > 7)
			{
				float seasonRel = ((IGameCalendar)capi.World.Calendar).GetSeasonRel(((ParticleBase)this).Position.AsBlockPos);
				if (((double)seasonRel > 0.48 && (double)seasonRel < 0.63) || EntityParticleInsect.rand.NextDouble() < 0.33)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class EntityParticleMatingGnats : EntityParticle
	{
		protected ICoreClientAPI capi;

		protected float dieAccum;

		protected static Random rand = new Random();

		private Vec3d centerPosition;

		private float cohesion;

		public override string Type => "matinggnats";

		public EntityParticleMatingGnats(ICoreClientAPI capi, float cohesion, double x, double y, double z)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Expected O, but got Unknown
			this.capi = capi;
			centerPosition = new Vec3d(x, y, z);
			((ParticleBase)this).Position.Set(x + rand.NextDouble() - 0.5, y + rand.NextDouble() - 0.5, z + rand.NextDouble() - 0.5);
			((ParticleBase)this).ColorAlpha = 200;
			SwimOnLiquid = true;
			base.GravityStrength = 0f;
			((ParticleBase)this).Alive = true;
			base.Size = 0.25f;
			((ParticleBase)this).ColorRed = 33;
			((ParticleBase)this).ColorGreen = 33;
			((ParticleBase)this).ColorBlue = 33;
			this.cohesion = cohesion;
		}

		public override void TickNow(float dt, float physicsdt, ICoreClientAPI api, ParticlePhysics physicsSim)
		{
			base.TickNow(dt, physicsdt, api, physicsSim);
			if (rand.NextDouble() < 0.5)
			{
				Vec3d val = centerPosition.SubCopy(((ParticleBase)this).Position).Normalize();
				((ParticleBase)this).Velocity.Add((float)(val.X / 2.0 + rand.NextDouble() / 8.0 - 0.0625) / (3f / cohesion), (float)(val.Y / 2.0 + rand.NextDouble() / 8.0 - 0.0625) / 3f, (float)(val.Z / 2.0 + rand.NextDouble() / 8.0 - 0.0625) / (3f / cohesion));
			}
			((ParticleBase)this).Velocity.X = GameMath.Clamp(((ParticleBase)this).Velocity.X, -0.5f, 0.5f);
			((ParticleBase)this).Velocity.Y = GameMath.Clamp(((ParticleBase)this).Velocity.Y, -0.5f, 0.5f);
			((ParticleBase)this).Velocity.Z = GameMath.Clamp(((ParticleBase)this).Velocity.Z, -0.5f, 0.5f);
		}

		protected override void doSlowTick(ParticlePhysics physicsSim, float dt)
		{
			base.doSlowTick(physicsSim, dt);
			EntityPlayer entity = ((IWorldAccessor)capi.World).NearestPlayer(((ParticleBase)this).Position.X, ((ParticleBase)this).Position.Y, ((ParticleBase)this).Position.Z).Entity;
			double num = ((Entity)entity).Pos.SquareHorDistanceTo(((ParticleBase)this).Position);
			if (num > 100.0 && (((CollectibleObject)((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)((ParticleBase)this).Position.X, (int)((ParticleBase)this).Position.Y, (int)((ParticleBase)this).Position.Z, 2)).IsLiquid() || GlobalConstants.CurrentWindSpeedClient.Length() > 0.35f))
			{
				dieAccum += dt;
				if (dieAccum > 5f)
				{
					((ParticleBase)this).Alive = false;
				}
				return;
			}
			if (entity == null || num > 225.0)
			{
				dieAccum += dt;
				if (dieAccum > 10f)
				{
					((ParticleBase)this).Alive = false;
				}
			}
			else
			{
				dieAccum = 0f;
			}
			if (num < 4.0)
			{
				Vec3d val = ((Entity)entity).Pos.XYZ.Sub(((ParticleBase)this).Position).Normalize();
				((ParticleBase)this).Velocity.Add((0f - (float)val.X) / 2f, 0f, (0f - (float)val.Z) / 2f);
				if (((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)((ParticleBase)this).Position.X, (int)((ParticleBase)this).Position.Y - 1, (int)((ParticleBase)this).Position.Z, 1).Replaceable < 6000)
				{
					((ParticleBase)this).Velocity.Add(0f, 0.5f, 1f);
				}
			}
		}
	}
	public class EntityParticleWaterStrider : EntityParticle
	{
		private static Random rand = new Random();

		private ICoreClientAPI capi;

		private float jumpCooldown;

		private float dieAccum;

		public override string Type => "waterStrider";

		public EntityParticleWaterStrider(ICoreClientAPI capi, double x, double y, double z)
		{
			this.capi = capi;
			((ParticleBase)this).Position.Set(x, y, z);
			((ParticleBase)this).ColorAlpha = byte.MaxValue;
			((ParticleBase)this).Alive = true;
			base.Size = 0.35f + (float)((IWorldAccessor)capi.World).Rand.NextDouble() * 0.125f;
			base.GravityStrength = 0f;
			((ParticleBase)this).ColorRed = 70;
			((ParticleBase)this).ColorGreen = 109;
			((ParticleBase)this).ColorBlue = 117;
			((ParticleBase)this).VertexFlags = 402653184;
		}

		public override void TickNow(float dt, float physicsdt, ICoreClientAPI api, ParticlePhysics physicsSim)
		{
			base.TickNow(dt, physicsdt, api, physicsSim);
			Vec3f velocity = ((ParticleBase)this).Velocity;
			velocity.X *= 0.97f;
			Vec3f velocity2 = ((ParticleBase)this).Velocity;
			velocity2.Z *= 0.97f;
		}

		protected override void doSlowTick(ParticlePhysics physicsSim, float dt)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Invalid comparison between Unknown and I4
			base.doSlowTick(physicsSim, dt);
			if (jumpCooldown < 1.5f && jumpCooldown > 0f && (((ParticleBase)this).flags & 2) > 0 && ((ParticleBase)this).Velocity.Y <= 0f && rand.NextDouble() < 0.4)
			{
				propel((float)rand.NextDouble() * 0.66f - 0.33f, 0f, (float)rand.NextDouble() * 0.66f - 0.33f);
			}
			if (jumpCooldown > 0f)
			{
				jumpCooldown = GameMath.Max(0f, jumpCooldown - dt);
				return;
			}
			if (rand.NextDouble() < 0.02)
			{
				propel((float)rand.NextDouble() * 0.66f - 0.33f, 0f, (float)rand.NextDouble() * 0.66f - 0.33f);
				return;
			}
			EntityPlayer entity = ((IWorldAccessor)capi.World).NearestPlayer(((ParticleBase)this).Position.X, ((ParticleBase)this).Position.Y, ((ParticleBase)this).Position.Z).Entity;
			double num = 2500.0;
			if (entity != null && (num = ((Entity)entity).Pos.SquareHorDistanceTo(((ParticleBase)this).Position)) < 9.0)
			{
				Vec3d val = ((Entity)entity).Pos.XYZ.Sub(((ParticleBase)this).Position).Normalize();
				propel((float)(0.0 - val.X) / 3f, 0f, (float)(0.0 - val.Z) / 3f);
			}
			Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)((ParticleBase)this).Position.X, (int)((ParticleBase)this).Position.Y, (int)((ParticleBase)this).Position.Z, 2);
			if (!((CollectibleObject)blockRaw).IsLiquid())
			{
				((ParticleBase)this).Alive = false;
				return;
			}
			((ParticleBase)this).Position.Y = (float)(int)((ParticleBase)this).Position.Y + (float)blockRaw.LiquidLevel / 8f;
			if (entity == null || num > 400.0)
			{
				dieAccum += dt;
				if (dieAccum > 15f)
				{
					((ParticleBase)this).Alive = false;
				}
			}
			else
			{
				dieAccum = 0f;
			}
		}

		private void propel(float dirx, float diry, float dirz)
		{
			((ParticleBase)this).Velocity.Add(dirx, diry, dirz);
			jumpCooldown = 2f;
		}
	}
	public delegate bool PoiMatcher(IPointOfInterest poi);
	public interface IPointOfInterest
	{
		Vec3d Position { get; }

		string Type { get; }
	}
	public class WeightedFoodTag
	{
		public string Code;

		public float Weight;
	}
	public class CreatureDiet
	{
		public EnumFoodCategory[] FoodCategories;

		public string[] FoodTags;

		public WeightedFoodTag[] WeightedFoodTags;

		public string[] SkipFoodTags;

		[OnDeserialized]
		private void OnDeserialized(StreamingContext ctx)
		{
			if (FoodTags != null)
			{
				List<WeightedFoodTag> list = new List<WeightedFoodTag>(WeightedFoodTags ?? Array.Empty<WeightedFoodTag>());
				string[] foodTags = FoodTags;
				foreach (string code in foodTags)
				{
					list.Add(new WeightedFoodTag
					{
						Code = code,
						Weight = 1f
					});
				}
				WeightedFoodTags = list.ToArray();
			}
		}

		public bool Matches(EnumFoodCategory foodSourceCategory, string[] foodSourceTags, float foodTagMinWeight = 0f)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if (SkipFoodTags != null && foodSourceTags != null)
			{
				for (int i = 0; i < foodSourceTags.Length; i++)
				{
					if (ArrayExtensions.Contains<string>(SkipFoodTags, foodSourceTags[i]))
					{
						return false;
					}
				}
			}
			if (FoodCategories != null && ArrayExtensions.Contains<EnumFoodCategory>(FoodCategories, foodSourceCategory))
			{
				return true;
			}
			if (WeightedFoodTags != null && foodSourceTags != null)
			{
				for (int j = 0; j < foodSourceTags.Length; j++)
				{
					for (int k = 0; k < WeightedFoodTags.Length; k++)
					{
						WeightedFoodTag weightedFoodTag = WeightedFoodTags[k];
						if (weightedFoodTag.Weight >= foodTagMinWeight && weightedFoodTag.Code == foodSourceTags[j])
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		public bool Matches(ItemStack itemstack, bool checkCategory = true, float foodTagMinWeight = 0f)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			CollectibleObject collectible = itemstack.Collectible;
			EnumFoodCategory foodSourceCategory = (EnumFoodCategory)((!checkCategory) ? (-1) : ((int)(((_003F?)collectible?.NutritionProps?.FoodCategory) ?? (-1))));
			object obj;
			if (collectible == null)
			{
				obj = null;
			}
			else
			{
				JsonObject attributes = collectible.Attributes;
				obj = ((attributes != null) ? attributes["foodTags"].AsArray<string>((string[])null, (string)null) : null);
			}
			string[] foodSourceTags = (string[])obj;
			return Matches(foodSourceCategory, foodSourceTags, foodTagMinWeight);
		}
	}
	public interface IAnimalFoodSource : IPointOfInterest
	{
		bool IsSuitableFor(Entity entity, CreatureDiet diet);

		float ConsumeOnePortion(Entity entity);
	}
	public interface IAnimalNest : IPointOfInterest
	{
		float DistanceWeighting { get; }

		bool IsSuitableFor(Entity entity, string[] nestTypes);

		bool Occupied(Entity entity);

		void SetOccupier(Entity entity);

		bool TryAddEgg(ItemStack egg);
	}
	public class POIRegistry : ModSystem
	{
		private Dictionary<Vec2i, List<IPointOfInterest>> PoisByChunkColumn = new Dictionary<Vec2i, List<IPointOfInterest>>();

		private Vec2i tmp = new Vec2i();

		private const int chunksize = 32;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			return true;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			((ModSystem)this).StartServerSide(api);
		}

		public void WalkPois(Vec3d centerPos, float radius, PoiMatcher callback = null)
		{
			int num = (int)(centerPos.X - (double)radius) / 32;
			int num2 = (int)(centerPos.Z - (double)radius) / 32;
			int num3 = (int)(centerPos.X + (double)radius) / 32;
			int num4 = (int)(centerPos.Z + (double)radius) / 32;
			float num5 = radius * radius;
			for (int i = num; i < num3; i++)
			{
				for (int j = num2; j < num4; j++)
				{
					tmp.Set(i, j);
					PoisByChunkColumn.TryGetValue(tmp, out var value);
					if (value == null)
					{
						continue;
					}
					for (int k = 0; k < value.Count; k++)
					{
						if (!(value[k].Position.SquareDistanceTo(centerPos) > num5))
						{
							callback(value[k]);
						}
					}
				}
			}
		}

		public IPointOfInterest GetNearestPoi(Vec3d centerPos, float radius, PoiMatcher matcher = null)
		{
			int num = (int)(centerPos.X - (double)radius) / 32;
			int num2 = (int)(centerPos.Z - (double)radius) / 32;
			int num3 = (int)(centerPos.X + (double)radius) / 32;
			int num4 = (int)(centerPos.Z + (double)radius) / 32;
			float num5 = radius * radius;
			float num6 = 9999999f;
			IPointOfInterest result = null;
			for (int i = num; i <= num3; i++)
			{
				for (int j = num2; j <= num4; j++)
				{
					tmp.Set(i, j);
					PoisByChunkColumn.TryGetValue(tmp, out var value);
					if (value == null)
					{
						continue;
					}
					for (int k = 0; k < value.Count; k++)
					{
						float num7 = value[k].Position.SquareDistanceTo(centerPos);
						if (!(num7 > num5) && num7 < num6 && matcher(value[k]))
						{
							result = value[k];
							num6 = num7;
						}
					}
				}
			}
			return result;
		}

		public IPointOfInterest GetWeightedNearestPoi(Vec3d centerPos, float radius, PoiMatcher matcher = null)
		{
			int num = (int)(centerPos.X - (double)radius) / 32;
			int num2 = (int)(centerPos.Z - (double)radius) / 32;
			int num3 = (int)(centerPos.X + (double)radius) / 32;
			int num4 = (int)(centerPos.Z + (double)radius) / 32;
			float num5 = radius * radius;
			float num6 = 9999999f;
			IPointOfInterest result = null;
			for (int i = num; i <= num3; i++)
			{
				double num7 = 0.0;
				if ((double)(i * 32) > centerPos.X)
				{
					num7 = (double)(i * 32) - centerPos.X;
				}
				else if ((double)((i + 1) * 32) < centerPos.X)
				{
					num7 = centerPos.X - (double)((i + 1) * 32);
				}
				for (int j = num2; j <= num4; j++)
				{
					double num8 = 0.0;
					if ((double)(j * 32) > centerPos.Z)
					{
						num8 = (double)(j * 32) - centerPos.Z;
					}
					else if ((double)((j + 1) * 32) < centerPos.Z)
					{
						num8 = centerPos.Z - (double)((j + 1) * 32);
					}
					if (num7 * num7 + num8 * num8 > (double)num6)
					{
						continue;
					}
					tmp.Set(i, j);
					PoisByChunkColumn.TryGetValue(tmp, out var value);
					if (value == null)
					{
						continue;
					}
					for (int k = 0; k < value.Count; k++)
					{
						Vec3d position = value[k].Position;
						float num9 = ((value[k] is IAnimalNest animalNest) ? animalNest.DistanceWeighting : 1f);
						float num10 = position.SquareDistanceTo(centerPos) * num9;
						if (!(num10 > num5) && num10 < num6 && matcher(value[k]))
						{
							result = value[k];
							num6 = num10;
						}
					}
				}
			}
			return result;
		}

		public void AddPOI(IPointOfInterest poi)
		{
			tmp.Set((int)poi.Position.X / 32, (int)poi.Position.Z / 32);
			PoisByChunkColumn.TryGetValue(tmp, out var value);
			if (value == null)
			{
				value = (PoisByChunkColumn[tmp.Copy()] = new List<IPointOfInterest>());
			}
			if (!value.Contains(poi))
			{
				value.Add(poi);
			}
		}

		public void RemovePOI(IPointOfInterest poi)
		{
			tmp.Set((int)poi.Position.X / 32, (int)poi.Position.Z / 32);
			PoisByChunkColumn.TryGetValue(tmp, out var value);
			if (value != null)
			{
				value.Remove(poi);
				if (value.Count == 0)
				{
					PoisByChunkColumn.Remove(tmp);
				}
			}
		}
	}
	public class ModSystemProgressBar : ModSystem
	{
		private List<ProgressBarRenderer> pbrenderer = new List<ProgressBarRenderer>();

		private ICoreClientAPI capi;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)forSide == 2;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			capi = api;
		}

		public IProgressBar AddProgressbar()
		{
			ProgressBarRenderer progressBarRenderer = new ProgressBarRenderer(capi, pbrenderer.Count * 30);
			capi.Event.RegisterRenderer((IRenderer)(object)progressBarRenderer, (EnumRenderStage)10, (string)null);
			pbrenderer.Add(progressBarRenderer);
			return progressBarRenderer;
		}

		public void RemoveProgressbar(IProgressBar pbr)
		{
			if (pbr != null)
			{
				ProgressBarRenderer progressBarRenderer = pbr as ProgressBarRenderer;
				pbrenderer.Remove(progressBarRenderer);
				capi.Event.UnregisterRenderer((IRenderer)(object)progressBarRenderer, (EnumRenderStage)10);
				progressBarRenderer.Dispose();
			}
		}
	}
	public interface IProgressBar
	{
		float Progress { get; set; }
	}
	public class ProgressBarRenderer : IRenderer, IDisposable, IProgressBar
	{
		private MeshRef whiteRectangleRef;

		private MeshRef progressQuadRef;

		private ICoreClientAPI capi;

		private Matrixf mvMatrix = new Matrixf();

		private float offsety;

		public float Progress { get; set; }

		public double RenderOrder => 0.0;

		public int RenderRange => 10;

		public ProgressBarRenderer(ICoreClientAPI api, float offsety)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			capi = api;
			this.offsety = offsety;
			MeshData rectangle = LineMeshUtil.GetRectangle(-1);
			whiteRectangleRef = api.Render.UploadMesh(rectangle);
			progressQuadRef = api.Render.UploadMesh(QuadMeshUtil.GetQuad());
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Expected O, but got Unknown
			IShaderProgram currentActiveShader = capi.Render.CurrentActiveShader;
			Vec4f val = new Vec4f(1f, 1f, 1f, 1f);
			currentActiveShader.Uniform("rgbaIn", val);
			currentActiveShader.Uniform("extraGlow", 0);
			currentActiveShader.Uniform("applyColor", 0);
			currentActiveShader.Uniform("tex2d", 0);
			currentActiveShader.Uniform("noTexture", 1f);
			int frameWidth = capi.Render.FrameWidth;
			int frameHeight = capi.Render.FrameHeight;
			float num = RuntimeEnv.GUIScale / 2f;
			mvMatrix.Set(capi.Render.CurrentModelviewMatrix).Translate((float)(frameWidth / 2) - 50f * num, (float)(frameHeight / 2) + 20f * num + offsety * num, 50f).Scale(num * 100f, num * 20f, 0f)
				.Translate(0.5f, 0.5f, 0f)
				.Scale(0.5f, 0.5f, 0f);
			currentActiveShader.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
			currentActiveShader.UniformMatrix("modelViewMatrix", mvMatrix.Values);
			capi.Render.RenderMesh(whiteRectangleRef);
			float num2 = Progress * 100f;
			mvMatrix.Set(capi.Render.CurrentModelviewMatrix).Translate((float)(frameWidth / 2) - 50f * num, (float)(frameHeight / 2) + 20f * num + offsety * num, 50f).Scale(num * num2, num * 20f, 0f)
				.Translate(0.5f, 0.5f, 0f)
				.Scale(0.5f, 0.5f, 0f);
			currentActiveShader.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
			currentActiveShader.UniformMatrix("modelViewMatrix", mvMatrix.Values);
			capi.Render.RenderMesh(progressQuadRef);
		}

		public void Dispose()
		{
			capi.Render.DeleteMesh(whiteRectangleRef);
			capi.Render.DeleteMesh(progressQuadRef);
		}
	}
	public class Room
	{
		public int ExitCount;

		public bool IsSmallRoom;

		public int SkylightCount;

		public int NonSkylightCount;

		public int CoolingWallCount;

		public int NonCoolingWallCount;

		public Cuboidi Location;

		public byte[] PosInRoom;

		public int AnyChunkUnloaded;

		public bool IsFullyLoaded(ChunkRooms roomsList)
		{
			if (AnyChunkUnloaded == 0)
			{
				return true;
			}
			if (++AnyChunkUnloaded > 10)
			{
				roomsList.RemoveRoom(this);
			}
			return false;
		}

		public bool Contains(BlockPos pos)
		{
			if (!Location.ContainsOrTouches(pos))
			{
				return false;
			}
			int num = Location.Z2 - Location.Z1 + 1;
			int num2 = Location.X2 - Location.X1 + 1;
			int num3 = pos.X - Location.X1;
			int num4 = pos.Y - Location.Y1;
			int num5 = pos.Z - Location.Z1;
			int num6 = (num4 * num + num5) * num2 + num3;
			return (PosInRoom[num6 / 8] & (1 << num6 % 8)) > 0;
		}
	}
	public class ChunkRooms
	{
		public List<Room> Rooms = new List<Room>();

		public object roomsLock = new object();

		public void AddRoom(Room room)
		{
			lock (roomsLock)
			{
				Rooms.Add(room);
			}
		}

		public void RemoveRoom(Room room)
		{
			lock (roomsLock)
			{
				Rooms.Remove(room);
			}
		}
	}
	public class RoomRegistry : ModSystem
	{
		protected Dictionary<long, ChunkRooms> roomsByChunkIndex = new Dictionary<long, ChunkRooms>();

		protected object roomsByChunkIndexLock = new object();

		private const int chunksize = 32;

		private int chunkMapSizeX;

		private int chunkMapSizeZ;

		private ICoreAPI api;

		[ThreadStatic]
		private static ICachingBlockAccessor blockAccessor;

		private ConcurrentDictionary<int, ICachingBlockAccessor> disposableBlockAccessors = new ConcurrentDictionary<int, ICachingBlockAccessor>();

		private const int ARRAYSIZE = 29;

		private readonly int[] currentVisited = new int[24389];

		private readonly int[] skyLightXZChecked = new int[841];

		private const int MAXROOMSIZE = 14;

		private const int MAXCELLARSIZE = 7;

		private const int ALTMAXCELLARSIZE = 9;

		private const int ALTMAXCELLARVOLUME = 150;

		private int iteration;

		private ICachingBlockAccessor blockAccess
		{
			get
			{
				if (blockAccessor != null)
				{
					return blockAccessor;
				}
				blockAccessor = api.World.GetCachingBlockAccessor(false, false);
				disposableBlockAccessors[Thread.CurrentThread.ManagedThreadId] = blockAccessor;
				return blockAccessor;
			}
		}

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			return true;
		}

		public override void Start(ICoreAPI api)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Expected O, but got Unknown
			((ModSystem)this).Start(api);
			this.api = api;
			api.Event.ChunkDirty += new ChunkDirtyDelegate(Event_ChunkDirty);
		}

		public override void Dispose()
		{
			ICachingBlockAccessor obj = blockAccessor;
			if (obj != null)
			{
				obj.Dispose();
			}
			blockAccessor = null;
			foreach (ICachingBlockAccessor value in disposableBlockAccessors.Values)
			{
				if (value != null)
				{
					value.Dispose();
				}
			}
			disposableBlockAccessors.Clear();
			disposableBlockAccessors = null;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			api.Event.BlockTexturesLoaded += init;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Expected O, but got Unknown
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Expected O, but got Unknown
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Expected O, but got Unknown
			api.Event.SaveGameLoaded += init;
			((ICoreAPI)api).ChatCommands.GetOrCreate("debug").BeginSubCommand("rooms").RequiresPrivilege(Privilege.controlserver)
				.BeginSubCommand("list")
				.HandleWith(new OnCommandDelegate(onRoomRegDbgCmdList))
				.EndSubCommand()
				.BeginSubCommand("hi")
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)((ICoreAPI)api).ChatCommands.Parsers.OptionalInt("rindex", 0) })
				.RequiresPlayer()
				.HandleWith(new OnCommandDelegate(onRoomRegDbgCmdHi))
				.EndSubCommand()
				.BeginSubCommand("unhi")
				.RequiresPlayer()
				.HandleWith(new OnCommandDelegate(onRoomRegDbgCmdUnhi))
				.EndSubCommand()
				.EndSubCommand();
		}

		private TextCommandResult onRoomRegDbgCmdHi(TextCommandCallingArgs args)
		{
			//IL_0254: Unknown result type (might be due to invalid IL or missing references)
			//IL_025e: Expected O, but got Unknown
			int num = (int)args.Parsers[0].GetValue();
			IPlayer player = args.Caller.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			BlockPos asBlockPos = ((Entity)((IPlayer)val).Entity).Pos.XYZ.AsBlockPos;
			long key = MapUtil.Index3dL(asBlockPos.X / 32, asBlockPos.Y / 32, asBlockPos.Z / 32, (long)chunkMapSizeX, (long)chunkMapSizeZ);
			ChunkRooms value;
			lock (roomsByChunkIndexLock)
			{
				roomsByChunkIndex.TryGetValue(key, out value);
			}
			if (value == null || value.Rooms.Count == 0)
			{
				return TextCommandResult.Success("No rooms in this chunk", (object)null);
			}
			if (value.Rooms.Count - 1 < num || num < 0)
			{
				if (num == 0)
				{
					return TextCommandResult.Success("No room at this index", (object)null);
				}
				return TextCommandResult.Success("Wrong index, select a number between 0 and " + (value.Rooms.Count - 1), (object)null);
			}
			Room room = value.Rooms[num];
			if (args.Parsers[0].IsMissing)
			{
				room = null;
				foreach (Room room2 in value.Rooms)
				{
					if (room2.Contains(asBlockPos))
					{
						room = room2;
						break;
					}
				}
				if (room == null)
				{
					return TextCommandResult.Success("No room at your location", (object)null);
				}
			}
			List<BlockPos> list = new List<BlockPos>();
			List<int> list2 = new List<int>();
			int num2 = room.Location.X2 - room.Location.X1 + 1;
			int num3 = room.Location.Y2 - room.Location.Y1 + 1;
			int num4 = room.Location.Z2 - room.Location.Z1 + 1;
			for (int i = 0; i < num2; i++)
			{
				for (int j = 0; j < num3; j++)
				{
					for (int k = 0; k < num4; k++)
					{
						int num5 = (j * num4 + k) * num2 + i;
						if ((room.PosInRoom[num5 / 8] & (1 << num5 % 8)) > 0)
						{
							list.Add(new BlockPos(room.Location.X1 + i, room.Location.Y1 + j, room.Location.Z1 + k));
							list2.Add(ColorUtil.ColorFromRgba((room.ExitCount != 0) ? 100 : 0, (room.ExitCount == 0) ? 100 : 0, Math.Min(255, num * 30), 150));
						}
					}
				}
			}
			api.World.HighlightBlocks((IPlayer)(object)val, 50, list, list2, (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
			return TextCommandResult.Success("", (object)null);
		}

		private TextCommandResult onRoomRegDbgCmdUnhi(TextCommandCallingArgs args)
		{
			IPlayer player = args.Caller.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			api.World.HighlightBlocks((IPlayer)(object)val, 50, new List<BlockPos>(), new List<int>(), (EnumHighlightBlocksMode)0, (EnumHighlightShape)0, 1f);
			return TextCommandResult.Success("", (object)null);
		}

		private TextCommandResult onRoomRegDbgCmdList(TextCommandCallingArgs args)
		{
			IPlayer player = args.Caller.Player;
			BlockPos asBlockPos = ((Entity)((player is IServerPlayer) ? player : null).Entity).Pos.XYZ.AsBlockPos;
			long key = MapUtil.Index3dL(asBlockPos.X / 32, asBlockPos.Y / 32, asBlockPos.Z / 32, (long)chunkMapSizeX, (long)chunkMapSizeZ);
			ChunkRooms value;
			lock (roomsByChunkIndexLock)
			{
				roomsByChunkIndex.TryGetValue(key, out value);
			}
			if (value == null || value.Rooms.Count == 0)
			{
				return TextCommandResult.Success("No rooms here", (object)null);
			}
			string text = value.Rooms.Count + " Rooms here \n";
			lock (value.roomsLock)
			{
				for (int i = 0; i < value.Rooms.Count; i++)
				{
					Room room = value.Rooms[i];
					int num = room.Location.X2 - room.Location.X1 + 1;
					int num2 = room.Location.Y2 - room.Location.Y1 + 1;
					int num3 = room.Location.Z2 - room.Location.Z1 + 1;
					text += $"{i} - bbox dim: {num}/{num2}/{num3}, mid: {(float)room.Location.X1 + (float)num / 2f}/{(float)room.Location.Y1 + (float)num2 / 2f}/{(float)room.Location.Z1 + (float)num3 / 2f}\n";
				}
			}
			return TextCommandResult.Success(text, (object)null);
		}

		private void init()
		{
			chunkMapSizeX = api.World.BlockAccessor.MapSizeX / 32;
			chunkMapSizeZ = api.World.BlockAccessor.MapSizeZ / 32;
		}

		private void Event_ChunkDirty(Vec3i chunkCoord, IWorldChunk chunk, EnumChunkDirtyReason reason)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			long num = MapUtil.Index3dL(chunkCoord.X, chunkCoord.Y, chunkCoord.Z, (long)chunkMapSizeX, (long)chunkMapSizeZ);
			FastSetOfLongs val = new FastSetOfLongs();
			val.Add(num);
			lock (roomsByChunkIndexLock)
			{
				roomsByChunkIndex.TryGetValue(num, out var value);
				if (value != null)
				{
					val.Add(num);
					for (int i = 0; i < value.Rooms.Count; i++)
					{
						Cuboidi location = value.Rooms[i].Location;
						int num2 = location.Start.X / 32;
						int num3 = location.End.X / 32;
						int num4 = location.Start.Y / 32;
						int num5 = location.End.Y / 32;
						int num6 = location.Start.Z / 32;
						int num7 = location.End.Z / 32;
						val.Add(MapUtil.Index3dL(num2, num4, num6, (long)chunkMapSizeX, (long)chunkMapSizeZ));
						if (num7 != num6)
						{
							val.Add(MapUtil.Index3dL(num2, num4, num7, (long)chunkMapSizeX, (long)chunkMapSizeZ));
						}
						if (num5 != num4)
						{
							val.Add(MapUtil.Index3dL(num2, num5, num6, (long)chunkMapSizeX, (long)chunkMapSizeZ));
							if (num7 != num6)
							{
								val.Add(MapUtil.Index3dL(num2, num5, num7, (long)chunkMapSizeX, (long)chunkMapSizeZ));
							}
						}
						if (num3 == num2)
						{
							continue;
						}
						val.Add(MapUtil.Index3dL(num3, num4, num6, (long)chunkMapSizeX, (long)chunkMapSizeZ));
						if (num7 != num6)
						{
							val.Add(MapUtil.Index3dL(num3, num4, num7, (long)chunkMapSizeX, (long)chunkMapSizeZ));
						}
						if (num5 != num4)
						{
							val.Add(MapUtil.Index3dL(num3, num5, num6, (long)chunkMapSizeX, (long)chunkMapSizeZ));
							if (num7 != num6)
							{
								val.Add(MapUtil.Index3dL(num3, num5, num7, (long)chunkMapSizeX, (long)chunkMapSizeZ));
							}
						}
					}
				}
				foreach (long item in val)
				{
					roomsByChunkIndex.Remove(item);
				}
			}
		}

		public Room GetRoomForPosition(BlockPos pos)
		{
			long key = MapUtil.Index3dL(pos.X / 32, pos.Y / 32, pos.Z / 32, (long)chunkMapSizeX, (long)chunkMapSizeZ);
			ChunkRooms value;
			lock (roomsByChunkIndexLock)
			{
				roomsByChunkIndex.TryGetValue(key, out value);
			}
			Room room3;
			if (value != null)
			{
				Room room = null;
				Room room2 = null;
				for (int i = 0; i < value.Rooms.Count; i++)
				{
					room3 = value.Rooms[i];
					if (room3.Contains(pos))
					{
						if (room == null && room3.ExitCount == 0)
						{
							room = room3;
						}
						if (room2 == null && room3.ExitCount > 0)
						{
							room2 = room3;
						}
					}
				}
				if (room != null && room.IsFullyLoaded(value))
				{
					return room;
				}
				if (room2 != null && room2.IsFullyLoaded(value))
				{
					return room2;
				}
				room3 = FindRoomForPosition(pos, value);
				value.AddRoom(room3);
				return room3;
			}
			ChunkRooms chunkRooms = new ChunkRooms();
			room3 = FindRoomForPosition(pos, chunkRooms);
			chunkRooms.AddRoom(room3);
			lock (roomsByChunkIndexLock)
			{
				roomsByChunkIndex[key] = chunkRooms;
				return room3;
			}
		}

		private Room FindRoomForPosition(BlockPos pos, ChunkRooms otherRooms)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Expected O, but got Unknown
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Expected O, but got Unknown
			//IL_052e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0538: Expected O, but got Unknown
			QueueOfInt val = new QueueOfInt();
			val.Enqueue(14798);
			int num = 12194;
			int num2 = ++iteration;
			currentVisited[num] = num2;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			blockAccess.Begin();
			bool flag = true;
			int num8 = 14;
			int num9 = 14;
			int num10 = 14;
			int num11 = 14;
			int num12 = 14;
			int num13 = 14;
			int num14 = pos.X - 14;
			int num15 = pos.Y - 14;
			int num16 = pos.Z - 14;
			BlockPos val2 = new BlockPos(pos.dimension);
			BlockPos val3 = new BlockPos(pos.dimension);
			while (val.Count > 0)
			{
				int num17 = val.Dequeue();
				int num18 = num17 >> 10;
				int num19 = (num17 >> 5) & 0x1F;
				int num20 = num17 & 0x1F;
				val2.Set(num14 + num18, num15 + num19, num16 + num20);
				val3.Set(val2);
				if (num18 < num8)
				{
					num8 = num18;
				}
				else if (num18 > num11)
				{
					num11 = num18;
				}
				if (num19 < num9)
				{
					num9 = num19;
				}
				else if (num19 > num12)
				{
					num12 = num19;
				}
				if (num20 < num10)
				{
					num10 = num20;
				}
				else if (num20 > num13)
				{
					num13 = num20;
				}
				Block block = ((IBlockAccessor)blockAccess).GetBlock(val3);
				BlockFacing[] aLLFACES = BlockFacing.ALLFACES;
				foreach (BlockFacing val4 in aLLFACES)
				{
					val4.IterateThruFacingOffsets(val2);
					int retention = block.GetRetention(val3, val4, (EnumRetentionType)0);
					if (((CollectibleObject)block).Id != 0 && retention != 0)
					{
						if (retention < 0)
						{
							num3 -= retention;
						}
						else
						{
							num4 += retention;
						}
						continue;
					}
					if (!((IBlockAccessor)blockAccess).IsValidPos(val2))
					{
						num4++;
						continue;
					}
					Block block2 = ((IBlockAccessor)blockAccess).GetBlock(val2);
					flag &= blockAccess.LastChunkLoaded;
					retention = block2.GetRetention(val2, val4.Opposite, (EnumRetentionType)0);
					if (retention != 0)
					{
						if (retention < 0)
						{
							num3 -= retention;
						}
						else
						{
							num4 += retention;
						}
						continue;
					}
					num18 = val2.X - num14;
					num19 = val2.Y - num15;
					num20 = val2.Z - num16;
					bool flag2 = false;
					switch (val4.Index)
					{
					case 0:
						if (num20 < num10)
						{
							flag2 = num20 < 0 || num13 - num10 + 1 >= 14;
						}
						break;
					case 1:
						if (num18 > num11)
						{
							flag2 = num18 > 28 || num11 - num8 + 1 >= 14;
						}
						break;
					case 2:
						if (num20 > num13)
						{
							flag2 = num20 > 28 || num13 - num10 + 1 >= 14;
						}
						break;
					case 3:
						if (num18 < num8)
						{
							flag2 = num18 < 0 || num11 - num8 + 1 >= 14;
						}
						break;
					case 4:
						if (num19 > num12)
						{
							flag2 = num19 > 28 || num12 - num9 + 1 >= 14;
						}
						break;
					case 5:
						if (num19 < num9)
						{
							flag2 = num19 < 0 || num12 - num9 + 1 >= 14;
						}
						break;
					}
					if (flag2)
					{
						num7++;
						continue;
					}
					num = (num18 * 29 + num19) * 29 + num20;
					if (currentVisited[num] == num2)
					{
						continue;
					}
					currentVisited[num] = num2;
					int num21 = num18 * 29 + num20;
					if (skyLightXZChecked[num21] < num2)
					{
						skyLightXZChecked[num21] = num2;
						if (((IBlockAccessor)blockAccess).GetLightLevel(val2, (EnumLightLevelType)1) >= api.World.SunBrightness - 1)
						{
							num5++;
						}
						else
						{
							num6++;
						}
					}
					val.Enqueue((num18 << 10) | (num19 << 5) | num20);
				}
			}
			int num22 = num11 - num8 + 1;
			int num23 = num12 - num9 + 1;
			int num24 = num13 - num10 + 1;
			byte[] array = new byte[(num22 * num23 * num24 + 7) / 8];
			int num25 = 0;
			for (int num18 = 0; num18 < num22; num18++)
			{
				for (int num19 = 0; num19 < num23; num19++)
				{
					num = ((num18 + num8) * 29 + (num19 + num9)) * 29 + num10;
					for (int num20 = 0; num20 < num24; num20++)
					{
						if (currentVisited[num + num20] == num2)
						{
							int num26 = (num19 * num24 + num20) * num22 + num18;
							array[num26 / 8] = (byte)(array[num26 / 8] | (1 << num26 % 8));
							num25++;
						}
					}
				}
			}
			bool flag3 = num22 <= 7 && num23 <= 7 && num24 <= 7;
			if (!flag3 && num25 <= 150)
			{
				flag3 = (num22 <= 9 && num23 <= 7 && num24 <= 7) || (num22 <= 7 && num23 <= 9 && num24 <= 7) || (num22 <= 7 && num23 <= 7 && num24 <= 9);
			}
			return new Room
			{
				CoolingWallCount = num3,
				NonCoolingWallCount = num4,
				SkylightCount = num5,
				NonSkylightCount = num6,
				ExitCount = num7,
				AnyChunkUnloaded = ((!flag) ? 1 : 0),
				Location = new Cuboidi(num14 + num8, num15 + num9, num16 + num10, num14 + num11, num15 + num12, num16 + num13),
				PosInRoom = array,
				IsSmallRoom = (flag3 && num7 == 0)
			};
		}
	}
	public class AuroraRenderer : IRenderer, IDisposable
	{
		private bool renderAurora = true;

		private ICoreClientAPI capi;

		private IShaderProgram prog;

		private MeshRef quadTilesRef;

		private Matrixf mvMat = new Matrixf();

		private Vec4f col = new Vec4f(1f, 1f, 1f, 1f);

		private float quarterSecAccum;

		public ClimateCondition clientClimateCond;

		private BlockPos plrPos = new BlockPos();

		public double RenderOrder => 0.35;

		public int RenderRange => 9999;

		public AuroraRenderer(ICoreClientAPI capi, WeatherSystemClient wsys)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Expected O, but got Unknown
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Expected O, but got Unknown
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Expected O, but got Unknown
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Expected O, but got Unknown
			this.capi = capi;
			capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)2, "aurora");
			capi.Event.ReloadShader += new ActionBoolReturn(LoadShader);
			LoadShader();
			renderAurora = capi.Settings.Bool["renderAurora"];
			renderAurora = true;
		}

		public bool LoadShader()
		{
			InitQuads();
			prog = capi.Shader.NewShaderProgram();
			prog.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			prog.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			capi.Shader.RegisterFileShaderProgram("aurora", prog);
			return prog.Compile();
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			if (!renderAurora || prog.LoadError || capi.Render.FrameWidth == 0)
			{
				return;
			}
			Vec3d cameraPos = ((IPlayer)capi.World.Player).Entity.CameraPos;
			quarterSecAccum += deltaTime;
			if (quarterSecAccum > 0.51f)
			{
				plrPos.X = (int)cameraPos.X;
				plrPos.Y = ((IWorldAccessor)capi.World).SeaLevel;
				plrPos.Z = (int)cameraPos.Z;
				clientClimateCond = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(plrPos, (EnumGetClimateMode)0, 0.0);
				quarterSecAccum = 0f;
			}
			if (clientClimateCond != null)
			{
				float num = GameMath.Clamp((Math.Max(0f, 0f - clientClimateCond.Temperature) - 5f) / 15f, 0f, 1f);
				col.W = GameMath.Clamp(1f - 1.5f * capi.World.Calendar.DayLightStrength, 0f, 1f) * num;
				if (!(col.W <= 0f))
				{
					prog.Use();
					prog.Uniform("color", col);
					prog.Uniform("rgbaFogIn", capi.Ambient.BlendedFogColor);
					prog.Uniform("fogMinIn", capi.Ambient.BlendedFogMin);
					prog.Uniform("fogDensityIn", capi.Ambient.BlendedFogDensity);
					prog.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
					prog.Uniform("flatFogDensity", capi.Ambient.BlendedFlatFogDensity);
					prog.Uniform("flatFogStart", capi.Ambient.BlendedFlatFogYPosForShader - (float)cameraPos.Y);
					float num2 = ((IGameCalendar)capi.World.Calendar).SpeedOfTime / 60f;
					prog.Uniform("auroraCounter", (float)((double)capi.InWorldEllapsedMilliseconds / 5000.0 * (double)num2) % 579f);
					mvMat.Set(capi.Render.MvMatrix.Top).FollowPlayer().Translate(0.0, (double)(1.1f * (float)((IWorldAccessor)capi.World).BlockAccessor.MapSizeY) + 0.5 - ((IPlayer)capi.World.Player).Entity.CameraPos.Y, 0.0);
					prog.UniformMatrix("modelViewMatrix", mvMat.Values);
					capi.Render.RenderMesh(quadTilesRef);
					prog.Stop();
				}
			}
		}

		public void InitQuads()
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Expected O, but got Unknown
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Expected O, but got Unknown
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Expected O, but got Unknown
			MeshRef obj = quadTilesRef;
			if (obj != null)
			{
				obj.Dispose();
			}
			float num = 200f;
			MeshData val = new MeshData(4, 6, false, true, true, false);
			val.CustomFloats = new CustomMeshDataPartFloat(4);
			((CustomMeshDataPart<float>)(object)val.CustomFloats).InterleaveStride = 4;
			((CustomMeshDataPart<float>)(object)val.CustomFloats).InterleaveOffsets = new int[1];
			((CustomMeshDataPart<float>)(object)val.CustomFloats).InterleaveSizes = new int[1] { 1 };
			Random random = new Random();
			float num2 = 1.5f;
			float num3 = 1.5f;
			float num4 = 20f * num2;
			float num5 = 1f / num2;
			for (int i = 0; i < 15; i++)
			{
				Vec3f val2 = new Vec3f((float)random.NextDouble() * 20f - 10f, (float)random.NextDouble() * 5f - 3f, (float)random.NextDouble() * 20f - 10f);
				val2.Normalize();
				val2.Mul(num5);
				float num6 = num3 * ((float)random.NextDouble() * 800f - 400f);
				float num7 = num3 * ((float)random.NextDouble() * 80f - 40f);
				float num8 = num3 * ((float)random.NextDouble() * 800f - 400f);
				for (int j = 0; (float)j < num4 + 2f; j++)
				{
					float num9 = (float)random.NextDouble() * 5f + 20f;
					float num10 = (float)random.NextDouble() * 4f + 4f;
					float num11 = (float)random.NextDouble() * 5f + 20f;
					num6 += val2.X * num9;
					num7 += val2.Y * num10;
					num8 += val2.Z * num11;
					int verticesCount = val.VerticesCount;
					val.AddVertex(num6, num7 + num, num8, (float)(j % 2), 1f);
					val.AddVertex(num6, num7, num8, (float)(j % 2), 0f);
					float num12 = (float)j / (num4 - 1f);
					((CustomMeshDataPart<float>)(object)val.CustomFloats).Add(new float[2] { num12, num12 });
					if (j > 0 && (float)j < num4 - 1f)
					{
						val.AddIndex(verticesCount + 1);
						val.AddIndex(verticesCount + 3);
						val.AddIndex(verticesCount + 2);
						val.AddIndex(verticesCount);
						val.AddIndex(verticesCount + 1);
						val.AddIndex(verticesCount + 2);
					}
				}
			}
			quadTilesRef = capi.Render.UploadMesh(val);
		}

		public void Dispose()
		{
			capi.Render.DeleteMesh(quadTilesRef);
		}
	}
	public class CloudMeshUtil : CubeMeshUtil
	{
		public static MeshData GetCubeModelDataForClouds(float scaleH, float scaleV, Vec3f translate)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Expected O, but got Unknown
			MeshData val = new MeshData(true);
			val.xyz = new float[72];
			val.Normals = new int[24];
			for (int i = 0; i < 24; i++)
			{
				val.xyz[3 * i] = (float)CubeMeshUtil.CubeVertices[3 * i] * scaleH + translate.X;
				val.xyz[3 * i + 1] = (float)CubeMeshUtil.CubeVertices[3 * i + 1] * scaleV + translate.Y;
				val.xyz[3 * i + 2] = (float)CubeMeshUtil.CubeVertices[3 * i + 2] * scaleH + translate.Z;
			}
			val.SetVerticesCount(24);
			val.SetIndices(CubeMeshUtil.CubeVertexIndices);
			val.SetIndicesCount(36);
			return val;
		}

		public static void AddIndicesWithSides(MeshData model, int offset, byte sideFlags)
		{
			int num = 12 + 6 * (sideFlags & 1) + 6 * ((sideFlags >> 1) & 1) + 6 * ((sideFlags >> 2) & 1) + 6 * ((sideFlags >> 3) & 1);
			if (model.IndicesCount + num >= model.IndicesMax)
			{
				model.GrowIndexBuffer(model.IndicesCount + num);
			}
			int[] indices = model.Indices;
			int indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices[indicesCount] = offset + 16;
			int[] indices2 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices2[indicesCount] = offset + 17;
			int[] indices3 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices3[indicesCount] = offset + 18;
			int[] indices4 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices4[indicesCount] = offset + 16;
			int[] indices5 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices5[indicesCount] = offset + 18;
			int[] indices6 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices6[indicesCount] = offset + 19;
			int[] indices7 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices7[indicesCount] = offset + 20;
			int[] indices8 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices8[indicesCount] = offset + 21;
			int[] indices9 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices9[indicesCount] = offset + 22;
			int[] indices10 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices10[indicesCount] = offset + 20;
			int[] indices11 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices11[indicesCount] = offset + 22;
			int[] indices12 = model.Indices;
			indicesCount = model.IndicesCount;
			model.IndicesCount = indicesCount + 1;
			indices12[indicesCount] = offset + 23;
			if ((sideFlags & BlockFacing.NORTH.Flag) > 0)
			{
				int[] indices13 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices13[indicesCount] = offset;
				int[] indices14 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices14[indicesCount] = offset + 1;
				int[] indices15 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices15[indicesCount] = offset + 2;
				int[] indices16 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices16[indicesCount] = offset;
				int[] indices17 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices17[indicesCount] = offset + 2;
				int[] indices18 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices18[indicesCount] = offset + 3;
			}
			if ((sideFlags & BlockFacing.EAST.Flag) > 0)
			{
				int[] indices19 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices19[indicesCount] = offset + 4;
				int[] indices20 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices20[indicesCount] = offset + 5;
				int[] indices21 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices21[indicesCount] = offset + 6;
				int[] indices22 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices22[indicesCount] = offset + 4;
				int[] indices23 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices23[indicesCount] = offset + 6;
				int[] indices24 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices24[indicesCount] = offset + 7;
			}
			if ((sideFlags & BlockFacing.SOUTH.Flag) > 0)
			{
				int[] indices25 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices25[indicesCount] = offset + 8;
				int[] indices26 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices26[indicesCount] = offset + 9;
				int[] indices27 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices27[indicesCount] = offset + 10;
				int[] indices28 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices28[indicesCount] = offset + 8;
				int[] indices29 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices29[indicesCount] = offset + 10;
				int[] indices30 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices30[indicesCount] = offset + 11;
			}
			if ((sideFlags & BlockFacing.WEST.Flag) > 0)
			{
				int[] indices31 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices31[indicesCount] = offset + 12;
				int[] indices32 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices32[indicesCount] = offset + 13;
				int[] indices33 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices33[indicesCount] = offset + 14;
				int[] indices34 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices34[indicesCount] = offset + 12;
				int[] indices35 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices35[indicesCount] = offset + 14;
				int[] indices36 = model.Indices;
				indicesCount = model.IndicesCount;
				model.IndicesCount = indicesCount + 1;
				indices36[indicesCount] = offset + 15;
			}
		}

		public static int[] GetIndicesWithSides(int offset, byte faceFlags)
		{
			int[] array = new int[12 + 6 * (faceFlags & 1) + 6 * ((faceFlags >> 1) & 1) + 6 * ((faceFlags >> 2) & 1) + 6 * ((faceFlags >> 3) & 1)];
			int num = 0;
			array[num++] = offset + 16;
			array[num++] = offset + 17;
			array[num++] = offset + 18;
			array[num++] = offset + 16;
			array[num++] = offset + 18;
			array[num++] = offset + 19;
			array[num++] = offset + 20;
			array[num++] = offset + 21;
			array[num++] = offset + 22;
			array[num++] = offset + 20;
			array[num++] = offset + 22;
			array[num++] = offset + 23;
			if ((faceFlags & BlockFacing.NORTH.Flag) > 0)
			{
				array[num++] = offset;
				array[num++] = offset + 1;
				array[num++] = offset + 2;
				array[num++] = offset;
				array[num++] = offset + 2;
				array[num++] = offset + 3;
			}
			if ((faceFlags & BlockFacing.EAST.Flag) > 0)
			{
				array[num++] = offset + 4;
				array[num++] = offset + 5;
				array[num++] = offset + 6;
				array[num++] = offset + 4;
				array[num++] = offset + 6;
				array[num++] = offset + 7;
			}
			if ((faceFlags & BlockFacing.SOUTH.Flag) > 0)
			{
				array[num++] = offset + 8;
				array[num++] = offset + 9;
				array[num++] = offset + 10;
				array[num++] = offset + 8;
				array[num++] = offset + 10;
				array[num++] = offset + 11;
			}
			if ((faceFlags & BlockFacing.WEST.Flag) > 0)
			{
				array[num++] = offset + 12;
				array[num++] = offset + 13;
				array[num++] = offset + 14;
				array[num++] = offset + 12;
				array[num++] = offset + 14;
				array[num++] = offset + 15;
			}
			return array;
		}
	}
	public class CloudRendererBase
	{
		public int CloudTileLength = 5;

		public double windOffsetX;

		public double windOffsetZ;

		public int CloudTileSize { get; set; } = 50;

		public virtual void UpdateCloudTiles(int changeSpeed = 1)
		{
		}
	}
	public class CloudTilesState
	{
		public Vec3i CenterTilePos = new Vec3i();

		public int TileOffsetX;

		public int TileOffsetZ;

		public int WindTileOffsetX;

		public int WindTileOffsetZ;

		public void Set(CloudTilesState state)
		{
			TileOffsetX = state.TileOffsetX;
			TileOffsetZ = state.TileOffsetZ;
			WindTileOffsetX = state.WindTileOffsetX;
			WindTileOffsetZ = state.WindTileOffsetZ;
			CenterTilePos.X = state.CenterTilePos.X;
			CenterTilePos.Z = state.CenterTilePos.Z;
		}
	}
	public class CloudRenderer : CloudRendererBase, IRenderer, IDisposable
	{
		private CloudTilesState committedState = new CloudTilesState();

		private CloudTilesState mainThreadState = new CloudTilesState();

		private CloudTilesState offThreadState = new CloudTilesState();

		private CloudTile[] Tiles;

		private CloudTile[] tempTiles;

		private bool newStateRready;

		private object cloudStateLock = new object();

		internal float blendedCloudDensity;

		internal float blendedGlobalCloudBrightness;

		public int QuantityCloudTiles = 25;

		private MeshRef cloudTilesMeshRef;

		private long windChangeTimer;

		private float cloudSpeedX;

		private float cloudSpeedZ;

		private float targetCloudSpeedX;

		private float targetCloudSpeedZ;

		private Random rand;

		private bool renderClouds;

		private WeatherSystemClient weatherSys;

		private Thread cloudTileUpdThread;

		private bool isShuttingDown;

		private ICoreClientAPI capi;

		private IShaderProgram prog;

		private Matrixf mvMat = new Matrixf();

		private int cloudTileBlendSpeed = 32;

		private MeshData updateMesh = new MeshData(true)
		{
			CustomShorts = new CustomMeshDataPartShort()
		};

		private WeatherDataReaderPreLoad wreaderpreload;

		private bool isFirstTick = true;

		private bool requireTileRebuild;

		public bool instantTileBlend;

		private int accum = 20;

		public double RenderOrder => 0.35;

		public int RenderRange => 9999;

		public CloudRenderer(ICoreClientAPI capi, WeatherSystemClient weatherSys)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Expected O, but got Unknown
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Expected O, but got Unknown
			//IL_005e: Expected O, but got Unknown
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Expected O, but got Unknown
			this.capi = capi;
			this.weatherSys = weatherSys;
			wreaderpreload = weatherSys.getWeatherDataReaderPreLoad();
			rand = new Random(((IWorldAccessor)capi.World).Seed);
			capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)2, "clouds");
			capi.Event.ReloadShader += new ActionBoolReturn(LoadShader);
			LoadShader();
			double num = ((IGameCalendar)capi.World.Calendar).TotalHours * 60.0;
			windOffsetX += 2.0 * num;
			windOffsetZ += 0.10000000149011612 * num;
			mainThreadState.WindTileOffsetX += (int)(windOffsetX / (double)base.CloudTileSize);
			windOffsetX %= base.CloudTileSize;
			mainThreadState.WindTileOffsetZ += (int)(windOffsetZ / (double)base.CloudTileSize);
			windOffsetZ %= base.CloudTileSize;
			offThreadState.Set(mainThreadState);
			committedState.Set(mainThreadState);
			InitCloudTiles(8 * ((IPlayer)capi.World.Player).WorldData.DesiredViewDistance);
			LoadCloudModel();
			capi.Settings.AddWatcher<int>("viewDistance", (OnSettingsChanged<int>)OnViewDistanceChanged);
			capi.Settings.AddWatcher<int>("cloudRenderMode", (OnSettingsChanged<int>)delegate(int val)
			{
				renderClouds = val == 2;
			});
			renderClouds = capi.Settings.Int.Get("cloudRenderMode", 0) == 2;
			InitCustomDataBuffers(updateMesh);
			capi.Event.LeaveWorld += delegate
			{
				isShuttingDown = true;
			};
			cloudTileUpdThread = new Thread((ThreadStart)delegate
			{
				while (!isShuttingDown)
				{
					if (!newStateRready)
					{
						int num2 = (int)windOffsetX / base.CloudTileSize;
						int num3 = (int)windOffsetZ / base.CloudTileSize;
						int x = offThreadState.CenterTilePos.X;
						int z = offThreadState.CenterTilePos.Z;
						offThreadState.Set(mainThreadState);
						offThreadState.WindTileOffsetX += num2;
						offThreadState.WindTileOffsetZ += num3;
						int num4 = num2 + x - offThreadState.CenterTilePos.X;
						int num5 = num3 + z - offThreadState.CenterTilePos.Z;
						if (num4 != 0 || num5 != 0)
						{
							MoveCloudTilesOffThread(num4, num5);
						}
						UpdateCloudTilesOffThread(instantTileBlend ? 32767 : cloudTileBlendSpeed);
						instantTileBlend = false;
						newStateRready = true;
					}
					Thread.Sleep(40);
				}
			});
			cloudTileUpdThread.IsBackground = true;
		}

		public bool LoadShader()
		{
			prog = capi.Shader.NewShaderProgram();
			prog.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			prog.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			capi.Shader.RegisterFileShaderProgram("clouds", prog);
			return prog.Compile();
		}

		private void OnViewDistanceChanged(int newValue)
		{
			requireTileRebuild = true;
		}

		public void CloudTick(float deltaTime)
		{
			blendedCloudDensity = capi.Ambient.BlendedCloudDensity;
			blendedGlobalCloudBrightness = capi.Ambient.BlendedCloudBrightness;
			if (isFirstTick)
			{
				weatherSys.ProcessWeatherUpdates();
				UpdateCloudTilesOffThread(32767);
				cloudTileUpdThread.Start();
				isFirstTick = false;
			}
			deltaTime = Math.Min(deltaTime, 1f);
			deltaTime *= ((IGameCalendar)capi.World.Calendar).SpeedOfTime / 60f;
			if (deltaTime > 0f)
			{
				if (windChangeTimer - capi.ElapsedMilliseconds < 0)
				{
					windChangeTimer = capi.ElapsedMilliseconds + rand.Next(20000, 120000);
					targetCloudSpeedX = (float)rand.NextDouble() * 5f;
					targetCloudSpeedZ = (float)rand.NextDouble() * 0.5f;
				}
				float num = 3f * (float)weatherSys.WeatherDataAtPlayer.GetWindSpeed(((Entity)((IPlayer)capi.World.Player).Entity).Pos.Y);
				cloudSpeedX += (targetCloudSpeedX + num - cloudSpeedX) * deltaTime;
				cloudSpeedZ += (targetCloudSpeedZ - cloudSpeedZ) * deltaTime;
			}
			lock (cloudStateLock)
			{
				if (deltaTime > 0f)
				{
					windOffsetX += cloudSpeedX * deltaTime;
					windOffsetZ += cloudSpeedZ * deltaTime;
				}
				mainThreadState.CenterTilePos.X = (int)((Entity)((IPlayer)capi.World.Player).Entity).Pos.X / base.CloudTileSize;
				mainThreadState.CenterTilePos.Z = (int)((Entity)((IPlayer)capi.World.Player).Entity).Pos.Z / base.CloudTileSize;
			}
			if (newStateRready)
			{
				int num2 = offThreadState.WindTileOffsetX - committedState.WindTileOffsetX;
				int num3 = offThreadState.WindTileOffsetZ - committedState.WindTileOffsetZ;
				committedState.Set(offThreadState);
				mainThreadState.WindTileOffsetX = committedState.WindTileOffsetX;
				mainThreadState.WindTileOffsetZ = committedState.WindTileOffsetZ;
				windOffsetX -= num2 * base.CloudTileSize;
				windOffsetZ -= num3 * base.CloudTileSize;
				UpdateBufferContents(updateMesh);
				capi.Render.UpdateMesh(cloudTilesMeshRef, updateMesh);
				weatherSys.ProcessWeatherUpdates();
				if (requireTileRebuild)
				{
					InitCloudTiles(8 * ((IPlayer)capi.World.Player).WorldData.DesiredViewDistance);
					UpdateCloudTiles();
					LoadCloudModel();
					InitCustomDataBuffers(updateMesh);
					requireTileRebuild = false;
					instantTileBlend = true;
				}
				newStateRready = false;
			}
			((IWorldAccessor)capi.World).FrameProfiler.Mark("gt-clouds");
		}

		public void OnRenderFrame(float deltaTime, EnumRenderStage stage)
		{
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b4: Expected O, but got Unknown
			//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e6: Expected O, but got Unknown
			if (renderClouds)
			{
				if (!capi.IsGamePaused)
				{
					CloudTick(deltaTime);
				}
				if (capi.Render.FrameWidth != 0)
				{
					DefaultShaderUniforms shaderUniforms = capi.Render.ShaderUniforms;
					shaderUniforms.PerceptionEffectIntensity *= 20f;
					prog.Use();
					DefaultShaderUniforms shaderUniforms2 = capi.Render.ShaderUniforms;
					shaderUniforms2.PerceptionEffectIntensity /= 20f;
					prog.Uniform("sunPosition", capi.World.Calendar.SunPositionNormalized);
					double x = ((Entity)((IPlayer)capi.World.Player).Entity).Pos.X;
					double z = ((Entity)((IPlayer)capi.World.Player).Entity).Pos.Z;
					double num = (double)(committedState.CenterTilePos.X * base.CloudTileSize) - x + windOffsetX;
					double num2 = (double)(committedState.CenterTilePos.Z * base.CloudTileSize) - z + windOffsetZ;
					prog.Uniform("sunColor", capi.World.Calendar.SunColor);
					prog.Uniform("dayLight", Math.Max(0f, capi.World.Calendar.DayLightStrength - capi.World.Calendar.MoonLightStrength * 0.95f));
					prog.Uniform("windOffset", new Vec3f((float)num, 0f, (float)num2));
					prog.Uniform("alpha", GameMath.Clamp(1f - 1.5f * Math.Max(0f, capi.Render.ShaderUniforms.GlitchStrength - 0.1f), 0f, 1f));
					prog.Uniform("rgbaFogIn", capi.Ambient.BlendedFogColor);
					prog.Uniform("fogMinIn", capi.Ambient.BlendedFogMin);
					prog.Uniform("fogDensityIn", capi.Ambient.BlendedFogDensity);
					prog.Uniform("playerPos", capi.Render.ShaderUniforms.PlayerPos);
					prog.Uniform("tileOffset", new Vec2f((float)((committedState.CenterTilePos.X - committedState.TileOffsetX) * base.CloudTileSize), (float)((committedState.CenterTilePos.Z - committedState.TileOffsetZ) * base.CloudTileSize)));
					prog.Uniform("cloudTileSize", base.CloudTileSize);
					prog.Uniform("cloudsLength", (float)base.CloudTileSize * (float)CloudTileLength);
					prog.Uniform("globalCloudBrightness", blendedGlobalCloudBrightness);
					float num3 = (float)((double)(weatherSys.CloudLevelRel * (float)((IWorldAccessor)capi.World).BlockAccessor.MapSizeY) + 0.5 - ((IPlayer)capi.World.Player).Entity.CameraPos.Y);
					prog.Uniform("cloudYTranslate", num3);
					prog.Uniform("cloudCounter", (float)(((IGameCalendar)capi.World.Calendar).TotalHours * 20.0 % 578.0));
					prog.UniformMatrix("projectionMatrix", capi.Render.CurrentProjectionMatrix);
					prog.Uniform("flatFogDensity", capi.Ambient.BlendedFlatFogDensity);
					prog.Uniform("flatFogStart", capi.Ambient.BlendedFlatFogYPosForShader - (float)((IPlayer)capi.World.Player).Entity.CameraPos.Y);
					mvMat.Set(capi.Render.CameraMatrixOriginf).Translate(num, (double)num3, num2);
					prog.UniformMatrix("modelViewMatrix", mvMat.Values);
					capi.Render.RenderMeshInstanced(cloudTilesMeshRef, QuantityCloudTiles);
					prog.Stop();
				}
			}
		}

		public void InitCloudTiles(int viewDistance)
		{
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Expected O, but got Unknown
			CloudTileLength = GameMath.Clamp(viewDistance / base.CloudTileSize, 20, 200);
			QuantityCloudTiles = CloudTileLength * CloudTileLength;
			Tiles = new CloudTile[QuantityCloudTiles];
			tempTiles = new CloudTile[QuantityCloudTiles];
			int num = rand.Next();
			for (int i = 0; i < CloudTileLength; i++)
			{
				for (int j = 0; j < CloudTileLength; j++)
				{
					Tiles[i * CloudTileLength + j] = new CloudTile
					{
						GridXOffset = (short)(i - CloudTileLength / 2),
						GridZOffset = (short)(j - CloudTileLength / 2),
						brightnessRand = new LCGRandom((long)num)
					};
				}
			}
		}

		public void UpdateCloudTilesOffThread(int changeSpeed)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Expected O, but got Unknown
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Expected O, but got Unknown
			bool flag = false;
			accum++;
			if (accum > 10)
			{
				accum = 0;
				flag = true;
			}
			int num = CloudTileLength * CloudTileLength;
			int num2 = -9999;
			int num3 = -9999;
			Vec3i tilePos = new Vec3i(offThreadState.TileOffsetX - offThreadState.WindTileOffsetX, 0, offThreadState.TileOffsetZ - offThreadState.WindTileOffsetZ);
			Vec3i centerTilePos = offThreadState.CenterTilePos;
			for (int i = 0; i < num; i++)
			{
				CloudTile cloudTile = Tiles[i];
				int num4 = centerTilePos.X + cloudTile.GridXOffset;
				int num5 = centerTilePos.Z + cloudTile.GridZOffset;
				cloudTile.brightnessRand.InitPositionSeed(num4 - offThreadState.WindTileOffsetX, num5 - offThreadState.WindTileOffsetZ);
				Vec3d val = new Vec3d((double)(num4 * base.CloudTileSize), (double)((IWorldAccessor)capi.World).SeaLevel, (double)(num5 * base.CloudTileSize));
				int regionSize = ((IWorldAccessor)capi.World).BlockAccessor.RegionSize;
				int num6 = (int)Math.Round(val.X / (double)regionSize) - 1;
				int num7 = (int)Math.Round(val.Z / (double)regionSize) - 1;
				if (num6 != num2 || num7 != num3)
				{
					num2 = num6;
					num3 = num7;
					wreaderpreload.LoadAdjacentSims(val);
					wreaderpreload.EnsureCloudTileCacheIsFresh(tilePos);
				}
				if (flag || !cloudTile.rainValuesSet)
				{
					wreaderpreload.LoadLerp(val);
					cloudTile.lerpRainCloudOverlay = wreaderpreload.lerpRainCloudOverlay;
					cloudTile.lerpRainOverlay = wreaderpreload.lerpRainOverlay;
					cloudTile.rainValuesSet = true;
				}
				else
				{
					wreaderpreload.LoadLerp(val, useArgValues: true, cloudTile.lerpRainCloudOverlay, cloudTile.lerpRainOverlay);
				}
				int cloudTileX = (int)val.X / base.CloudTileSize;
				int cloudTileZ = (int)val.Z / base.CloudTileSize;
				double num8 = GameMath.Clamp(wreaderpreload.GetBlendedCloudThicknessAt(cloudTileX, cloudTileZ), 0.0, 1.0);
				double num9 = wreaderpreload.GetBlendedCloudBrightness(1f) * (double)(0.85f + cloudTile.brightnessRand.NextFloat() * 0.15f);
				cloudTile.TargetBrightnes = (short)(GameMath.Clamp(num9, 0.0, 1.0) * 32767.0);
				cloudTile.TargetThickness = (short)GameMath.Clamp(num8 * 32767.0, 0.0, 32767.0);
				cloudTile.TargetThinCloudMode = (short)GameMath.Clamp(wreaderpreload.GetBlendedThinCloudModeness() * 32767.0, 0.0, 32767.0);
				cloudTile.TargetCloudOpaquenes = (short)GameMath.Clamp(wreaderpreload.GetBlendedCloudOpaqueness() * 32767.0, 0.0, 32767.0);
				cloudTile.TargetUndulatingCloudMode = (short)GameMath.Clamp(wreaderpreload.GetBlendedUndulatingCloudModeness() * 32767.0, 0.0, 32767.0);
				cloudTile.Brightness = LerpTileValue(cloudTile.TargetBrightnes, cloudTile.Brightness, changeSpeed);
				cloudTile.SelfThickness = LerpTileValue(cloudTile.TargetThickness, cloudTile.SelfThickness, changeSpeed);
				cloudTile.ThinCloudMode = LerpTileValue(cloudTile.TargetThinCloudMode, cloudTile.ThinCloudMode, changeSpeed);
				cloudTile.CloudOpaqueness = LerpTileValue(cloudTile.TargetCloudOpaquenes, cloudTile.CloudOpaqueness, changeSpeed);
				cloudTile.UndulatingCloudMode = LerpTileValue(cloudTile.TargetUndulatingCloudMode, cloudTile.UndulatingCloudMode, changeSpeed);
				if (i > 0)
				{
					Tiles[i - 1].NorthTileThickness = cloudTile.SelfThickness;
				}
				if (i < Tiles.Length - 1)
				{
					Tiles[i + 1].SouthTileThickness = cloudTile.SelfThickness;
				}
				if (i < CloudTileLength - 1)
				{
					Tiles[i + CloudTileLength].EastTileThickness = cloudTile.SelfThickness;
				}
				if (i > CloudTileLength - 1)
				{
					Tiles[i - CloudTileLength].WestTileThickness = cloudTile.SelfThickness;
				}
			}
		}

		private short LerpTileValue(int target, int current, int changeSpeed)
		{
			float num = GameMath.Clamp(target - current, -changeSpeed, changeSpeed);
			return (short)GameMath.Clamp((float)current + num, 0f, 32767f);
		}

		public void MoveCloudTilesOffThread(int dx, int dz)
		{
			for (int i = 0; i < CloudTileLength; i++)
			{
				for (int j = 0; j < CloudTileLength; j++)
				{
					int num = GameMath.Mod(i + dx, CloudTileLength);
					int num2 = GameMath.Mod(j + dz, CloudTileLength);
					CloudTile cloudTile = Tiles[i * CloudTileLength + j];
					cloudTile.GridXOffset = (short)(num - CloudTileLength / 2);
					cloudTile.GridZOffset = (short)(num2 - CloudTileLength / 2);
					tempTiles[num * CloudTileLength + num2] = cloudTile;
				}
			}
			CloudTile[] tiles = Tiles;
			Tiles = tempTiles;
			tempTiles = tiles;
		}

		public void LoadCloudModel()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Expected O, but got Unknown
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Expected O, but got Unknown
			MeshData val = new MeshData(24, 36, false, false, true, true);
			val.Flags = new int[24];
			float[] array = new float[4] { 1f, 0.9f, 0.9f, 0.7f };
			MeshData cubeModelDataForClouds = CloudMeshUtil.GetCubeModelDataForClouds(base.CloudTileSize / 2, base.CloudTileSize / 4, new Vec3f(0f, 0f, 0f));
			byte[] shadedCubeRGBA = CubeMeshUtil.GetShadedCubeRGBA(-1, array, false);
			cubeModelDataForClouds.SetRgba(shadedCubeRGBA);
			cubeModelDataForClouds.Flags = new int[24]
			{
				0, 0, 0, 0, 1, 1, 1, 1, 2, 2,
				2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
				5, 5, 5, 5
			};
			val.AddMeshData(cubeModelDataForClouds);
			InitCustomDataBuffers(val);
			UpdateBufferContents(val);
			MeshRef obj = cloudTilesMeshRef;
			if (obj != null)
			{
				obj.Dispose();
			}
			cloudTilesMeshRef = capi.Render.UploadMesh(val);
		}

		private void InitCustomDataBuffers(MeshData modeldata)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Expected O, but got Unknown
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			CustomMeshDataPartShort val = new CustomMeshDataPartShort();
			((CustomMeshDataPart<short>)(object)val).StaticDraw = false;
			((CustomMeshDataPart<short>)(object)val).Instanced = true;
			((CustomMeshDataPart<short>)(object)val).InterleaveSizes = new int[8] { 2, 4, 1, 1, 1, 1, 1, 1 };
			((CustomMeshDataPart<short>)(object)val).InterleaveOffsets = new int[8] { 0, 4, 12, 14, 16, 18, 20, 22 };
			((CustomMeshDataPart<short>)(object)val).InterleaveStride = 24;
			val.Conversion = (DataConversion)1;
			((CustomMeshDataPart<short>)(object)val).Values = new short[QuantityCloudTiles * 12];
			((CustomMeshDataPart<short>)(object)val).Count = QuantityCloudTiles * 12;
			modeldata.CustomShorts = val;
		}

		private void UpdateBufferContents(MeshData mesh)
		{
			int num = 0;
			for (int i = 0; i < Tiles.Length; i++)
			{
				CloudTile cloudTile = Tiles[i];
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = (short)(base.CloudTileSize * cloudTile.GridXOffset);
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = (short)(base.CloudTileSize * cloudTile.GridZOffset);
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.NorthTileThickness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.EastTileThickness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.SouthTileThickness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.WestTileThickness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.SelfThickness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.Brightness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.ThinCloudMode;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.UndulatingCloudMode;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = cloudTile.CloudOpaqueness;
				((CustomMeshDataPart<short>)(object)mesh.CustomShorts).Values[num++] = 0;
			}
		}

		public void Dispose()
		{
			capi.Render.DeleteMesh(cloudTilesMeshRef);
		}
	}
	public class CloudTile
	{
		public short GridXOffset;

		public short GridZOffset;

		public short NorthTileThickness;

		public short EastTileThickness;

		public short SouthTileThickness;

		public short WestTileThickness;

		public short TargetThickness;

		public short TargetBrightnes;

		public short TargetThinCloudMode;

		public short TargetUndulatingCloudMode;

		public short TargetCloudOpaquenes;

		public short SelfThickness;

		public short Brightness;

		public short ThinCloudMode;

		public short UndulatingCloudMode;

		public short CloudOpaqueness;

		public LCGRandom brightnessRand;

		internal bool rainValuesSet;

		internal float lerpRainCloudOverlay;

		internal float lerpRainOverlay;
	}
	public class LightningFlash : IDisposable
	{
		private MeshRef quadRef;

		private Vec4f color;

		private float linewidth;

		public List<Vec3d> points;

		public LightiningPointLight[] pointLights = new LightiningPointLight[2];

		public Vec3d origin;

		public float secondsAlive;

		public bool Alive = true;

		private ICoreAPI api;

		private ICoreClientAPI capi;

		public float flashAccum;

		public float rndVal;

		public float advanceWaitSec;

		private bool soundPlayed;

		private WeatherSystemBase weatherSys;

		private Random rand;

		public LightningFlash(WeatherSystemBase weatherSys, ICoreAPI api, int? seed, Vec3d startpoint)
		{
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Expected O, but got Unknown
			this.weatherSys = weatherSys;
			capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			this.api = api;
			rand = new Random((!seed.HasValue) ? ((IWorldAccessor)capi.World).Rand.Next() : seed.Value);
			color = new Vec4f(1f, 1f, 1f, 1f);
			linewidth = 0.33f;
			origin = startpoint.Clone();
			origin.Y = api.World.BlockAccessor.GetRainMapHeightAt((int)origin.X, (int)origin.Z) + 1;
		}

		public void ClientInit()
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Expected O, but got Unknown
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Expected O, but got Unknown
			//IL_016e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Expected O, but got Unknown
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Expected O, but got Unknown
			genPoints(weatherSys);
			genMesh(points);
			float num = 200f;
			pointLights[0] = new LightiningPointLight(new Vec3f(num, num, num), points[0].AddCopy(origin));
			pointLights[1] = new LightiningPointLight(new Vec3f(0f, 0f, 0f), points[points.Count - 1].AddCopy(origin));
			capi.Render.AddPointLight((IPointLight)(object)pointLights[0]);
			capi.Render.AddPointLight((IPointLight)(object)pointLights[1]);
			Vec3d val = points[points.Count - 1];
			Vec3d val2 = origin + val;
			float num2 = (float)((Entity)((IPlayer)capi.World.Player).Entity).Pos.DistanceTo(val2);
			if (num2 < 150f)
			{
				AssetLocation val3 = new AssetLocation("sounds/weather/lightning-verynear.ogg");
				((IWorldAccessor)capi.World).PlaySoundAt(val3, 0.0, 0.0, 0.0, (IPlayer)null, (EnumSoundType)3, 1f, 32f, 1f - num2 / 180f);
			}
			else if (num2 < 200f)
			{
				AssetLocation val4 = new AssetLocation("sounds/weather/lightning-near.ogg");
				((IWorldAccessor)capi.World).PlaySoundAt(val4, 0.0, 0.0, 0.0, (IPlayer)null, (EnumSoundType)3, 1f, 32f, 1f - num2 / 250f);
			}
			else if (num2 < 320f)
			{
				AssetLocation val5 = new AssetLocation("sounds/weather/lightning-distant.ogg");
				((IWorldAccessor)capi.World).PlaySoundAt(val5, 0.0, 0.0, 0.0, (IPlayer)null, (EnumSoundType)3, 1f, 32f, 1f - num2 / 500f);
			}
		}

		protected void genPoints(WeatherSystemBase weatherSys)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Vec3d val = new Vec3d();
			points = new List<Vec3d>();
			val.Y = 0.0;
			float num = (float)((double)(weatherSys.CloudLevelRel * (float)((IWorldAccessor)capi.World).BlockAccessor.MapSizeY + 2f) - origin.Y);
			while (val.Y < (double)num)
			{
				points.Add(val.Clone());
				val.Y += rand.NextDouble();
				val.X += rand.NextDouble() * 2.0 - 1.0;
				val.Z += rand.NextDouble() * 2.0 - 1.0;
			}
			if (points.Count == 0)
			{
				points.Add(val.Clone());
			}
			points.Reverse();
		}

		protected void genMesh(List<Vec3d> points)
		{
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Expected O, but got Unknown
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Expected O, but got Unknown
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0103: Expected O, but got Unknown
			float[] array = new float[points.Count * 3];
			for (int i = 0; i < points.Count; i++)
			{
				Vec3d val = points[i];
				array[i * 3] = (float)val.X;
				array[i * 3 + 1] = (float)val.Y;
				array[i * 3 + 2] = (float)val.Z;
			}
			MeshRef obj = quadRef;
			if (obj != null)
			{
				obj.Dispose();
			}
			MeshData cube = CubeMeshUtil.GetCube(0.5f, 0.5f, 0.5f, new Vec3f(0f, 0f, 0f));
			cube.Flags = null;
			cube.Rgba = null;
			CustomMeshDataPartFloat val2 = new CustomMeshDataPartFloat();
			((CustomMeshDataPart<float>)(object)val2).Instanced = true;
			((CustomMeshDataPart<float>)(object)val2).InterleaveOffsets = new int[2] { 0, 12 };
			((CustomMeshDataPart<float>)(object)val2).InterleaveSizes = new int[2] { 3, 3 };
			((CustomMeshDataPart<float>)(object)val2).InterleaveStride = 12;
			((CustomMeshDataPart<float>)(object)val2).StaticDraw = false;
			((CustomMeshDataPart<float>)(object)val2).Values = array;
			((CustomMeshDataPart<float>)(object)val2).Count = array.Length;
			cube.CustomFloats = val2;
			MeshData val3 = new MeshData(false);
			val3.CustomFloats = cube.CustomFloats;
			quadRef = capi.Render.UploadMesh(cube);
			capi.Render.UpdateMesh(quadRef, val3);
		}

		public void GameTick(float dt)
		{
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Invalid comparison between Unknown and I4
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Expected O, but got Unknown
			//IL_014c: Expected O, but got Unknown
			dt *= 3f;
			if (rand.NextDouble() < 0.4 && (double)(secondsAlive * 10f) < 0.6 && advanceWaitSec <= 0f)
			{
				advanceWaitSec = 0.05f + (float)rand.NextDouble() / 10f;
			}
			secondsAlive += Math.Max(0f, dt - advanceWaitSec);
			advanceWaitSec = Math.Max(0f, advanceWaitSec - dt);
			if ((double)secondsAlive > 0.7)
			{
				Alive = false;
			}
			if ((int)api.Side != 1 || !(secondsAlive > 0f))
			{
				return;
			}
			weatherSys.TriggerOnLightningImpactEnd(origin, out var handling);
			if ((int)handling != 0 || !api.World.Config.GetBool("lightningDamage", true))
			{
				return;
			}
			DamageSource dmgSrc = new DamageSource
			{
				KnockbackStrength = 2f,
				Source = (EnumDamageSource)12,
				Type = (EnumDamageType)11,
				SourcePos = origin,
				HitPosition = new Vec3d()
			};
			api.ModLoader.GetModSystem<EntityPartitioning>(true).WalkEntities(origin, 8.0, delegate(Entity entity)
			{
				if (!entity.IsInteractable)
				{
					return true;
				}
				float num = 6f;
				entity.ReceiveDamage(dmgSrc, num);
				return true;
			}, EnumEntitySearchType.Creatures);
		}

		public void Render(float dt)
		{
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Expected O, but got Unknown
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Expected O, but got Unknown
			//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_02be: Unknown result type (might be due to invalid IL or missing references)
			//IL_02dd: Expected O, but got Unknown
			//IL_02dd: Expected O, but got Unknown
			//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02df: Expected O, but got Unknown
			GameTick(dt);
			capi.Render.CurrentActiveShader.Uniform("color", color);
			capi.Render.CurrentActiveShader.Uniform("lineWidth", linewidth);
			IClientPlayer player = capi.World.Player;
			Vec3d cameraPos = ((IPlayer)player).Entity.CameraPos;
			capi.Render.CurrentActiveShader.Uniform("origin", new Vec3f((float)(origin.X - cameraPos.X), (float)(origin.Y - cameraPos.Y), (float)(origin.Z - cameraPos.Z)));
			double num = GameMath.Clamp(secondsAlive * 10f, 0f, 1f);
			int num2 = (int)(num * (double)points.Count) - 1;
			if (num2 > 0)
			{
				capi.Render.RenderMeshInstanced(quadRef, num2);
			}
			if (num >= 0.9 && !soundPlayed)
			{
				soundPlayed = true;
				Vec3d val = points[points.Count - 1];
				Vec3d val2 = origin + val;
				float num3 = (float)((Entity)((IPlayer)player).Entity).Pos.DistanceTo(val2);
				if (num3 < 150f)
				{
					AssetLocation val3 = new AssetLocation("sounds/weather/lightning-nodistance.ogg");
					((IWorldAccessor)capi.World).PlaySoundAt(val3, 0.0, 0.0, 0.0, (IPlayer)null, (EnumSoundType)3, 1f, 32f, Math.Max(0.1f, 1f - num3 / 70f));
				}
				if (num3 < 100f)
				{
					(weatherSys as WeatherSystemClient).simLightning.lightningTime = 0.3f + (float)rand.NextDouble() * 0.17f;
					(weatherSys as WeatherSystemClient).simLightning.lightningIntensity = 1.5f + (float)rand.NextDouble() * 0.4f;
					int num4 = Math.Max(0, (int)num3 - 5) * 3;
					int num5 = ColorUtil.ToRgba(255, 255, 255, 255);
					SimpleParticleProperties val4 = new SimpleParticleProperties((float)(250 - num4), (float)(300 - num4), num5, val2.AddCopy(-0.5f, 0f, -0.5f), val2.AddCopy(0.5f, 1f, 0.5f), new Vec3f(-5f, 0f, -5f), new Vec3f(5f, 10f, 5f), 3f, 0.3f, 0.4f, 2f, (EnumParticleModel)1);
					val4.VertexFlags = 255;
					val4.LightEmission = int.MaxValue;
					val4.ShouldDieInLiquid = true;
					val4.SizeEvolve = EvolvingNatFloat.create((EnumTransformFunction)3, 1f);
					((IWorldAccessor)capi.World).SpawnParticles((IParticlePropertiesProvider)(object)val4, (IPlayer)null);
					val4.ParticleModel = (EnumParticleModel)0;
					val4.MinSize /= 2f;
					val4.MaxSize /= 2f;
					((IWorldAccessor)capi.World).SpawnParticles((IParticlePropertiesProvider)(object)val4, (IPlayer)null);
				}
			}
			flashAccum += dt;
			if (flashAccum > rndVal)
			{
				rndVal = (float)rand.NextDouble() / 10f;
				flashAccum = 0f;
				float num6 = (float)rand.NextDouble();
				float num7 = 50f + num6 * 150f;
				pointLights[0].Color.Set(num7, num7, num7);
				linewidth = (0.4f + 0.6f * num6) / 3f;
				if (num < 1.0)
				{
					num7 = 0f;
				}
				pointLights[1].Color.Set(num7, num7, num7);
			}
		}

		public void Dispose()
		{
			MeshRef obj = quadRef;
			if (obj != null)
			{
				obj.Dispose();
			}
			ICoreClientAPI obj2 = capi;
			if (obj2 != null)
			{
				obj2.Render.RemovePointLight((IPointLight)(object)pointLights[0]);
			}
			ICoreClientAPI obj3 = capi;
			if (obj3 != null)
			{
				obj3.Render.RemovePointLight((IPointLight)(object)pointLights[1]);
			}
		}
	}
	public class LightiningPointLight : IPointLight
	{
		public Vec3f Color { get; set; }

		public Vec3d Pos { get; set; }

		public LightiningPointLight(Vec3f color, Vec3d pos)
		{
			Color = color;
			Pos = pos;
		}
	}
	public enum EnumChanceFunction
	{
		None,
		TestRainTemp,
		AvoidHotAndDry
	}
	public abstract class ConditionalPatternConfig
	{
		public EnumChanceFunction WeightFunction;

		public float? MinRain;

		public float? MaxRain;

		public float RainRange = 1f;

		public float? MinTemp;

		public float? MaxTemp;

		public float TempRange = 1f;

		public float Weight = 1f;

		public float getWeight(float rainfall, float temperature)
		{
			float num = Weight;
			switch (WeightFunction)
			{
			case EnumChanceFunction.TestRainTemp:
				if (MinRain.HasValue)
				{
					num *= GameMath.Clamp(rainfall - MinRain.Value, 0f, RainRange) / RainRange;
				}
				if (MinTemp.HasValue)
				{
					num *= GameMath.Clamp(temperature - MinTemp.Value, 0f, TempRange) / TempRange;
				}
				if (MaxRain.HasValue)
				{
					num *= GameMath.Clamp(MaxRain.Value - rainfall, 0f, RainRange) / RainRange;
				}
				if (MaxTemp.HasValue)
				{
					num *= GameMath.Clamp(MaxTemp.Value - temperature, 0f, TempRange) / TempRange;
				}
				break;
			case EnumChanceFunction.AvoidHotAndDry:
			{
				float num2 = (TempRange + 20f) / 60f;
				float num3 = rainfall * (1f - num2);
				num *= num3;
				break;
			}
			}
			return num;
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class WeatherEventState
	{
		public int Index;

		public float BaseStrength;

		public double ActiveUntilTotalHours;

		public float LightningRate;

		public float NearThunderRate;

		public float DistantThunderRate;

		public float LightningMinTemp;

		public EnumPrecipitationType PrecType = EnumPrecipitationType.Auto;

		public float ParticleSize;
	}
	public class WeatherEvent
	{
		public WeatherEventConfig config;

		protected SimplexNoise strengthNoiseGen;

		private ICoreAPI api;

		private LCGRandom rand;

		public WeatherEventState State = new WeatherEventState();

		public float Strength;

		internal float hereChance;

		public bool AllowStop { get; set; } = true;

		public bool ShouldStop(float rainfall, float temperature)
		{
			if (config.getWeight(rainfall, temperature) <= 0f)
			{
				return AllowStop;
			}
			return false;
		}

		public WeatherEvent(ICoreAPI api, WeatherEventConfig config, int index, LCGRandom rand, int seed)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Expected O, but got Unknown
			this.rand = rand;
			this.config = config;
			this.api = api;
			State.Index = index;
			if (config.StrengthNoise != null)
			{
				strengthNoiseGen = new SimplexNoise(config.StrengthNoise.Amplitudes, config.StrengthNoise.Frequencies, (long)(seed + index));
			}
		}

		public virtual void OnBeginUse()
		{
			State.BaseStrength = (Strength = config.Strength.nextFloat(1f, (IRandom)(object)rand));
			State.ActiveUntilTotalHours = api.World.Calendar.TotalHours + (double)config.DurationHours.nextFloat(1f, (IRandom)(object)rand);
			State.PrecType = config.PrecType;
			WeatherEventState state = State;
			LightningConfig lightning = config.Lightning;
			state.NearThunderRate = ((lightning != null) ? (lightning.NearThunderRate / 100f) : 0f);
			WeatherEventState state2 = State;
			LightningConfig lightning2 = config.Lightning;
			state2.LightningRate = ((lightning2 != null) ? (lightning2.LightningRate / 100f) : 0f);
			WeatherEventState state3 = State;
			LightningConfig lightning3 = config.Lightning;
			state3.DistantThunderRate = ((lightning3 != null) ? (lightning3.DistantThunderRate / 100f) : 0f);
			State.LightningMinTemp = config.Lightning?.MinTemperature ?? 0f;
		}

		public virtual void Update(float dt)
		{
			if (strengthNoiseGen != null)
			{
				double num = api.World.Calendar.TotalDays / 10.0;
				Strength = State.BaseStrength + (float)GameMath.Clamp(strengthNoiseGen.Noise(0.0, num), 0.0, 1.0);
			}
		}

		public virtual string GetWindName()
		{
			return config.Name;
		}

		internal void updateHereChance(float rainfall, float temperature)
		{
			hereChance = config.getWeight(rainfall, temperature);
		}
	}
	public class WeatherPattern
	{
		public WeatherPatternConfig config;

		public SimplexNoise LocationalCloudThicknessGen;

		public WeatherPatternState State = new WeatherPatternState();

		protected SimplexNoise TimeBasePrecIntenstityGen;

		private WeatherSystemBase ws;

		private ICoreAPI api;

		private int lastTileX;

		private int lastTileZ;

		public double[,] CloudDensityNoiseCache;

		private LCGRandom rand;

		public float hereChance;

		private int cloudTilebasePosX;

		private int cloudTilebasePosZ;

		public static int NoisePadding = 4;

		private int tilesPerRegion;

		public void updateHereChance(float rainfall, float temperature)
		{
			hereChance = config.getWeight(rainfall, temperature);
		}

		public WeatherPattern(WeatherSystemBase ws, WeatherPatternConfig config, LCGRandom rand, int cloudTilebasePosX, int cloudTilebasePosZ)
		{
			this.ws = ws;
			this.rand = rand;
			this.config = config;
			api = ws.api;
			this.cloudTilebasePosX = cloudTilebasePosX;
			this.cloudTilebasePosZ = cloudTilebasePosZ;
		}

		public virtual void Initialize(int index, int seed)
		{
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Expected O, but got Unknown
			State.Index = index;
			if (config.Clouds?.LocationalThickness != null)
			{
				LocationalCloudThicknessGen = new SimplexNoise(config.Clouds.LocationalThickness.Amplitudes, config.Clouds.LocationalThickness.Frequencies, (long)(seed + index + 1512));
			}
		}

		public virtual void EnsureCloudTileCacheIsFresh(Vec3i tileOffset)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			if ((int)api.Side != 1 && (CloudDensityNoiseCache == null || lastTileX != cloudTilebasePosX + tileOffset.X || lastTileZ != cloudTilebasePosZ + tileOffset.Z))
			{
				RegenCloudTileCache(tileOffset);
			}
		}

		public virtual void RegenCloudTileCache(Vec3i tileOffset)
		{
			tilesPerRegion = (int)Math.Ceiling((float)api.World.BlockAccessor.RegionSize / (float)ws.CloudTileSize) + 2 * NoisePadding;
			CloudDensityNoiseCache = new double[tilesPerRegion, tilesPerRegion];
			lastTileX = cloudTilebasePosX + tileOffset.X;
			lastTileZ = cloudTilebasePosZ + tileOffset.Z;
			double num = api.World.Calendar.TotalDays / 10.0;
			if (double.IsNaN(num))
			{
				throw new ArgumentException("timeAxis value in WeatherPattern.cs:RegenCloudTileCahce is NaN. Somethings broken.");
			}
			if (LocationalCloudThicknessGen == null)
			{
				for (int i = 0; i < tilesPerRegion; i++)
				{
					for (int j = 0; j < tilesPerRegion; j++)
					{
						CloudDensityNoiseCache[i, j] = 0.0;
					}
				}
				return;
			}
			for (int k = 0; k < tilesPerRegion; k++)
			{
				for (int l = 0; l < tilesPerRegion; l++)
				{
					double num2 = (double)(lastTileX + k - tilesPerRegion / 2 - NoisePadding) / 20.0;
					double num3 = (double)(lastTileZ + l - tilesPerRegion / 2 - NoisePadding) / 20.0;
					CloudDensityNoiseCache[k, l] = GameMath.Clamp(LocationalCloudThicknessGen.Noise(num2, num3, num), 0.0, 1.0);
				}
			}
		}

		public virtual void OnBeginUse()
		{
			State.BeginUseExecuted = true;
			State.ActiveUntilTotalHours = api.World.Calendar.TotalHours + (double)config.DurationHours.nextFloat(1f, (IRandom)(object)rand);
			WeatherPatternState state = State;
			WeatherCloudConfig clouds = config.Clouds;
			float? obj;
			if (clouds == null)
			{
				obj = null;
			}
			else
			{
				NatFloat thinCloudMode = clouds.ThinCloudMode;
				obj = ((thinCloudMode != null) ? new float?(thinCloudMode.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			float? num = obj;
			state.nowThinCloudModeness = num.GetValueOrDefault();
			WeatherPatternState state2 = State;
			WeatherCloudConfig clouds2 = config.Clouds;
			float? obj2;
			if (clouds2 == null)
			{
				obj2 = null;
			}
			else
			{
				NatFloat undulatingCloudMode = clouds2.UndulatingCloudMode;
				obj2 = ((undulatingCloudMode != null) ? new float?(undulatingCloudMode.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj2;
			state2.nowUndulatingCloudModeness = num.GetValueOrDefault();
			WeatherPatternState state3 = State;
			WeatherCloudConfig clouds3 = config.Clouds;
			float? obj3;
			if (clouds3 == null)
			{
				obj3 = null;
			}
			else
			{
				NatFloat baseThickness = clouds3.BaseThickness;
				obj3 = ((baseThickness != null) ? new float?(baseThickness.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj3;
			state3.nowbaseThickness = num.GetValueOrDefault();
			WeatherPatternState state4 = State;
			WeatherCloudConfig clouds4 = config.Clouds;
			float? obj4;
			if (clouds4 == null)
			{
				obj4 = null;
			}
			else
			{
				NatFloat thicknessMul = clouds4.ThicknessMul;
				obj4 = ((thicknessMul != null) ? new float?(thicknessMul.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			state4.nowThicknessMul = obj4 ?? 1f;
			WeatherPatternState state5 = State;
			WeatherCloudConfig clouds5 = config.Clouds;
			float? obj5;
			if (clouds5 == null)
			{
				obj5 = null;
			}
			else
			{
				NatFloat opaqueness = clouds5.Opaqueness;
				obj5 = ((opaqueness != null) ? new float?(opaqueness.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj5;
			state5.nowbaseOpaqueness = num.GetValueOrDefault();
			WeatherPatternState state6 = State;
			WeatherCloudConfig clouds6 = config.Clouds;
			state6.nowCloudBrightness = ((clouds6 != null) ? clouds6.Brightness.nextFloat(1f, (IRandom)(object)rand) : 0f);
			WeatherPatternState state7 = State;
			WeatherCloudConfig clouds7 = config.Clouds;
			float? obj6;
			if (clouds7 == null)
			{
				obj6 = null;
			}
			else
			{
				NatFloat heightMul = clouds7.HeightMul;
				obj6 = ((heightMul != null) ? new float?(heightMul.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj6;
			state7.nowHeightMul = num.GetValueOrDefault();
			State.nowSceneBrightness = config.SceneBrightness.nextFloat(1f, (IRandom)(object)rand);
			WeatherPatternState state8 = State;
			WeatherFogConfig fog = config.Fog;
			float? obj7;
			if (fog == null)
			{
				obj7 = null;
			}
			else
			{
				NatFloat density = fog.Density;
				obj7 = ((density != null) ? new float?(density.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj7;
			state8.nowFogDensity = num.GetValueOrDefault();
			WeatherPatternState state9 = State;
			WeatherFogConfig fog2 = config.Fog;
			float? obj8;
			if (fog2 == null)
			{
				obj8 = null;
			}
			else
			{
				NatFloat mistDensity = fog2.MistDensity;
				obj8 = ((mistDensity != null) ? new float?(mistDensity.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj8;
			state9.nowMistDensity = num.GetValueOrDefault();
			WeatherPatternState state10 = State;
			WeatherFogConfig fog3 = config.Fog;
			float? obj9;
			if (fog3 == null)
			{
				obj9 = null;
			}
			else
			{
				NatFloat mistYPos = fog3.MistYPos;
				obj9 = ((mistYPos != null) ? new float?(mistYPos.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj9;
			state10.nowMistYPos = num.GetValueOrDefault();
			WeatherPatternState state11 = State;
			WeatherFogConfig fog4 = config.Fog;
			float? obj10;
			if (fog4 == null)
			{
				obj10 = null;
			}
			else
			{
				NatFloat fogBrightness = fog4.FogBrightness;
				obj10 = ((fogBrightness != null) ? new float?(fogBrightness.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			state11.nowFogBrightness = obj10 ?? 1f;
			WeatherPatternState state12 = State;
			WeatherPrecipitationConfig precipitation = config.Precipitation;
			float? obj11;
			if (precipitation == null)
			{
				obj11 = null;
			}
			else
			{
				NatFloat baseIntensity = precipitation.BaseIntensity;
				obj11 = ((baseIntensity != null) ? new float?(baseIntensity.nextFloat(1f, (IRandom)(object)rand)) : ((float?)null));
			}
			num = obj11;
			state12.nowBasePrecIntensity = num.GetValueOrDefault();
		}

		public virtual void Update(float dt)
		{
		}

		public virtual double GetCloudDensityAt(int dx, int dz)
		{
			try
			{
				return GameMath.Clamp((double)State.nowbaseThickness + CloudDensityNoiseCache[GameMath.Clamp(dx + NoisePadding, 0, tilesPerRegion - 1), GameMath.Clamp(dz + NoisePadding, 0, tilesPerRegion - 1)], 0.0, 1.0) * (double)State.nowThicknessMul;
			}
			catch (Exception)
			{
				throw new Exception($"{dx}/{dz} is out of range. Width/Height: {CloudDensityNoiseCache.GetLength(0)}/{CloudDensityNoiseCache.GetLength(1)}");
			}
		}

		public virtual string GetWeatherName()
		{
			return config.Name;
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class WindPatternState
	{
		public int Index;

		public float BaseStrength;

		public double ActiveUntilTotalHours;
	}
	public class WindPattern
	{
		public WindPatternConfig config;

		protected SimplexNoise strengthNoiseGen;

		private ICoreAPI api;

		private LCGRandom rand;

		public WindPatternState State = new WindPatternState();

		public float Strength;

		public WindPattern(ICoreAPI api, WindPatternConfig config, int index, LCGRandom rand, int seed)
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Expected O, but got Unknown
			this.rand = rand;
			this.config = config;
			this.api = api;
			State.Index = index;
			if (config.StrengthNoise != null)
			{
				strengthNoiseGen = new SimplexNoise(config.StrengthNoise.Amplitudes, config.StrengthNoise.Frequencies, (long)(seed + index));
			}
		}

		public virtual void OnBeginUse()
		{
			State.BaseStrength = (Strength = config.Strength.nextFloat(1f, (IRandom)(object)rand));
			State.ActiveUntilTotalHours = api.World.Calendar.TotalHours + (double)config.DurationHours.nextFloat(1f, (IRandom)(object)rand);
		}

		public virtual void Update(float dt)
		{
			if (strengthNoiseGen != null)
			{
				double num = api.World.Calendar.TotalDays * 10.0;
				Strength = State.BaseStrength + (float)GameMath.Clamp(strengthNoiseGen.Noise(0.0, num), 0.0, 1.0);
			}
		}

		public virtual string GetWindName()
		{
			return config.Name;
		}
	}
	public class WeatherEventConfig : ConditionalPatternConfig
	{
		public string Code;

		public string Name;

		public NatFloat DurationHours = NatFloat.createUniform(7.5f, 4.5f);

		public NatFloat Strength = NatFloat.Zero;

		public NoiseConfig StrengthNoise;

		public LightningConfig Lightning;

		public EnumPrecipitationType PrecType = EnumPrecipitationType.Auto;

		public NatFloat ParticleSize;
	}
	public class WeatherPatternConfig : ConditionalPatternConfig
	{
		public string Code;

		public string Name;

		public NatFloat DurationHours = NatFloat.createUniform(7.5f, 4.5f);

		public NatFloat SceneBrightness = NatFloat.createUniform(1f, 0f);

		public WeatherPrecipitationConfig Precipitation;

		public WeatherCloudConfig Clouds;

		public WeatherFogConfig Fog;
	}
	public class NoiseConfig
	{
		public double[] Amplitudes;

		public double[] Frequencies;
	}
	public class LightningConfig
	{
		public float MinTemperature;

		public float NearThunderRate;

		public float DistantThunderRate;

		public float LightningRate;

		public bool MulWithRainCloudness;
	}
	public enum EnumPrecipitationType
	{
		Rain,
		Snow,
		Hail,
		Auto
	}
	public class WeatherPrecipitationConfig
	{
		public NatFloat BaseIntensity;

		public NoiseConfig IntensityNoise;

		public float ParticleSize = 1f;
	}
	public class WeatherCloudConfig
	{
		public NatFloat Brightness = NatFloat.createUniform(1f, 0f);

		public NatFloat HeightMul = NatFloat.createUniform(1f, 0f);

		public NatFloat BaseThickness;

		public NatFloat ThinCloudMode = NatFloat.createUniform(0f, 0f);

		public NatFloat UndulatingCloudMode = NatFloat.createUniform(0f, 0f);

		public NatFloat ThicknessMul = NatFloat.createUniform(1f, 0f);

		public NoiseConfig LocationalThickness;

		public NatFloat Opaqueness;
	}
	public class WeatherFogConfig
	{
		public NatFloat FogBrightness;

		public NatFloat Density;

		public NatFloat MistDensity;

		public NatFloat MistYPos;
	}
	public class WindPatternConfig
	{
		public string Code;

		public string Name;

		public float Weight = 1f;

		public NatFloat DurationHours = NatFloat.createUniform(7.5f, 4.5f);

		public NatFloat Strength;

		public NoiseConfig StrengthNoise;
	}
	public class UpdateSnowLayerChunk : IEquatable<UpdateSnowLayerChunk>
	{
		public Vec2i Coords;

		public double LastSnowAccumUpdateTotalHours;

		public Dictionary<int, BlockIdAndSnowLevel> SetBlocks = new Dictionary<int, BlockIdAndSnowLevel>();

		public bool Equals(UpdateSnowLayerChunk other)
		{
			return other.Coords.Equals(Coords);
		}

		public override bool Equals(object obj)
		{
			if (!(obj is UpdateSnowLayerChunk { Coords: var coords }))
			{
				return false;
			}
			if (Coords.X == coords.X)
			{
				return Coords.Y == coords.Y;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (17 * 23 + Coords.X.GetHashCode()) * 23 + Coords.Y.GetHashCode();
		}
	}
	public struct BlockIdAndSnowLevel
	{
		public Block Block;

		public float SnowLevel;

		public BlockIdAndSnowLevel(Block block, float snowLevel)
		{
			Block = block;
			SnowLevel = snowLevel;
		}
	}
	public class WeatherSystemCommands : ModSystem
	{
		private ICoreClientAPI capi;

		private ICoreServerAPI sapi;

		private ICoreAPI api;

		public override bool ShouldLoad(EnumAppSide forSide)
		{
			return true;
		}

		public override void Start(ICoreAPI api)
		{
			this.api = api;
		}

		public override void StartServerSide(ICoreServerAPI sapi)
		{
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Expected O, but got Unknown
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Expected O, but got Unknown
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Expected O, but got Unknown
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Expected O, but got Unknown
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Expected O, but got Unknown
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Expected O, but got Unknown
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Expected O, but got Unknown
			//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ff: Expected O, but got Unknown
			this.sapi = sapi;
			((ICoreAPI)sapi).ChatCommands.GetOrCreate("debug").BeginSubCommand("prectest").WithDescription("recipitation test export")
				.RequiresPrivilege(Privilege.controlserver)
				.BeginSubCommand("pos")
				.RequiresPlayer()
				.HandleWith(new OnCommandDelegate(CmdPrecTestServerPos))
				.EndSubCommand()
				.BeginSubCommand("here")
				.RequiresPlayer()
				.HandleWith(new OnCommandDelegate(CmdPrecTestServerHere))
				.EndSubCommand()
				.BeginSubCommand("climate")
				.RequiresPlayer()
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.OptionalBool("climate", "on") })
				.HandleWith(new OnCommandDelegate(CmdPrecTestServerClimate))
				.EndSubCommand()
				.EndSubCommand();
			((ICoreAPI)sapi).ChatCommands.GetOrCreate("debug").BeginSubCommand("snowaccum").WithDescription("Snow accum test")
				.RequiresPrivilege(Privilege.controlserver)
				.BeginSubCommand("on")
				.HandleWith(new OnCommandDelegate(CmdSnowAccumOn))
				.EndSubCommand()
				.BeginSubCommand("off")
				.HandleWith(new OnCommandDelegate(CmdSnowAccumOff))
				.EndSubCommand()
				.BeginSubCommand("processhere")
				.RequiresPlayer()
				.HandleWith(new OnCommandDelegate(CmdSnowAccumProcesshere))
				.EndSubCommand()
				.BeginSubCommand("info")
				.RequiresPlayer()
				.HandleWith(new OnCommandDelegate(CmdSnowAccumInfo))
				.EndSubCommand()
				.BeginSubCommand("here")
				.RequiresPlayer()
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.OptionalFloat("amount", 0f) })
				.HandleWith(new OnCommandDelegate(CmdSnowAccumHere))
				.EndSubCommand()
				.EndSubCommand();
			sapi.Event.ServerRunPhase((EnumServerRunPhase)6, (Action)delegate
			{
				//IL_003a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Expected O, but got Unknown
				//IL_008c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0096: Expected O, but got Unknown
				//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f7: Expected O, but got Unknown
				//IL_0121: Unknown result type (might be due to invalid IL or missing references)
				//IL_012b: Expected O, but got Unknown
				//IL_0190: Unknown result type (might be due to invalid IL or missing references)
				//IL_019a: Expected O, but got Unknown
				//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ce: Expected O, but got Unknown
				//IL_0225: Unknown result type (might be due to invalid IL or missing references)
				//IL_022f: Expected O, but got Unknown
				//IL_0259: Unknown result type (might be due to invalid IL or missing references)
				//IL_0263: Expected O, but got Unknown
				//IL_028d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0297: Expected O, but got Unknown
				//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
				//IL_02cb: Expected O, but got Unknown
				//IL_0351: Unknown result type (might be due to invalid IL or missing references)
				//IL_035b: Expected O, but got Unknown
				//IL_037b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0385: Expected O, but got Unknown
				//IL_0445: Unknown result type (might be due to invalid IL or missing references)
				//IL_044f: Expected O, but got Unknown
				//IL_04de: Unknown result type (might be due to invalid IL or missing references)
				//IL_04e8: Expected O, but got Unknown
				//IL_0508: Unknown result type (might be due to invalid IL or missing references)
				//IL_0512: Expected O, but got Unknown
				//IL_058e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0598: Expected O, but got Unknown
				((ICoreAPI)sapi).ChatCommands.Create("whenwillitstopraining").WithDescription("When does it finally stop to rain around here?!").RequiresPrivilege(Privilege.controlserver)
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWhenWillItStopRaining));
				WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
				((ICoreAPI)sapi).ChatCommands.Create("weather").WithDescription("Show/Set current weather info").RequiresPrivilege(Privilege.controlserver)
					.HandleWith(new OnCommandDelegate(CmdWeatherinfo))
					.BeginSubCommand("setprecip")
					.WithDescription("Running with no arguments returns the current precip. override, if one is set. Including an argument overrides the precipitation intensity and in turn also the rain cloud overlay. '-1' removes all rain clouds, '0' stops any rain but keeps some rain clouds, while '1' causes the heaviest rain and full rain clouds. The server will remain indefinitely in that rain state until reset with '/weather setprecipa'.")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.OptionalFloat("level", 0f) })
					.HandleWith(new OnCommandDelegate(CmdWeatherSetprecip))
					.EndSubCommand()
					.BeginSubCommand("setprecipa")
					.WithDescription("Resets the current precip override to auto mode.")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherSetprecipa))
					.EndSubCommand()
					.BeginSubCommand("cloudypos")
					.WithAlias(new string[1] { "cyp" })
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.OptionalFloat("level", 0f) })
					.HandleWith(new OnCommandDelegate(CmdWeatherCloudypos))
					.EndSubCommand()
					.BeginSubCommand("stoprain")
					.WithDescription("Stops any current rain by forwarding to a time in the future where there is no rain.")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherStoprain))
					.EndSubCommand()
					.BeginSubCommand("acp")
					.WithDescription("Toggles auto-changing weather patterns.")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)((ICoreAPI)sapi).ChatCommands.Parsers.OptionalBool("mode", "on") })
					.HandleWith(new OnCommandDelegate(CmdWeatherAcp))
					.EndSubCommand()
					.BeginSubCommand("lp")
					.WithDescription("Lists all loaded weather patterns.")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherLp))
					.EndSubCommand()
					.BeginSubCommand("t")
					.WithDescription("Transitions to a random weather pattern.")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherT))
					.EndSubCommand()
					.BeginSubCommand("c")
					.WithDescription("Quickly transitions to a random weather pattern.")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherC))
					.EndSubCommand()
					.BeginSubCommand("setw")
					.WithDescription("Sets the current wind pattern to the given wind pattern.")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.WordRange("windpattern", modSystem.WindConfigs.Select((WindPatternConfig w) => w.Code).ToArray()) })
					.HandleWith(new OnCommandDelegate(CmdWeatherSetw))
					.EndSubCommand()
					.BeginSubCommand("randomevent")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherRandomevent))
					.EndSubCommand()
					.BeginSubCommand("setev")
					.WithAlias(new string[1] { "setevr" })
					.WithDescription("setev - Sets a weather event globally.\n  setevr - Set a weather event only in the player's region.")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[2]
					{
						(ICommandArgumentParser)api.ChatCommands.Parsers.WordRange("weather_event", modSystem.WeatherEventConfigs.Select((WeatherEventConfig w) => w.Code).ToArray()),
						(ICommandArgumentParser)api.ChatCommands.Parsers.OptionalBool("allowStop", "on")
					})
					.HandleWith(new OnCommandDelegate(CmdWeatherSetev))
					.EndSubCommand()
					.BeginSubCommand("set")
					.WithAlias(new string[1] { "seti" })
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.WordRange("weatherpattern", modSystem.WeatherConfigs.Select((WeatherPatternConfig w) => w.Code).ToArray()) })
					.HandleWith(new OnCommandDelegate(CmdWeatherSet))
					.EndSubCommand()
					.BeginSubCommand("setirandom")
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(CmdWeatherSetirandom))
					.EndSubCommand()
					.BeginSubCommand("setir")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.WordRange("weatherpattern", modSystem.WeatherConfigs.Select((WeatherPatternConfig w) => w.Code).ToArray()) })
					.HandleWith(new OnCommandDelegate(CmdWeatherSetir))
					.EndSubCommand();
			});
		}

		private TextCommandResult CmdWeatherinfo(TextCommandCallingArgs args)
		{
			return TextCommandResult.Success(GetWeatherInfo<WeatherSystemServer>(args.Caller.Player), (object)null);
		}

		private TextCommandResult CmdWeatherSetir(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			modSystem.ReloadConfigs();
			string code = args.Parsers[0].GetValue() as string;
			IPlayer player = args.Caller.Player;
			BlockPos asBlockPos = ((Entity)((player is IServerPlayer) ? player : null).Entity).SidedPos.XYZ.AsBlockPos;
			int regionX = asBlockPos.X / api.World.BlockAccessor.RegionSize;
			int regionZ = asBlockPos.Z / api.World.BlockAccessor.RegionSize;
			long key = modSystem.MapRegionIndex2D(regionX, regionZ);
			modSystem.weatherSimByMapRegion.TryGetValue(key, out var value);
			if (value == null)
			{
				return TextCommandResult.Success("Weather sim not loaded (yet) for this region", (object)null);
			}
			if (value.SetWeatherPattern(code, updateInstant: true))
			{
				value.TickEvery25ms(0.025f);
				return TextCommandResult.Success("Ok weather pattern set for current region", (object)null);
			}
			return TextCommandResult.Error("No such weather pattern found", "");
		}

		private TextCommandResult CmdWeatherSetirandom(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			modSystem.ReloadConfigs();
			bool flag = true;
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in modSystem.weatherSimByMapRegion)
			{
				flag &= item.Value.SetWeatherPattern(item.Value.RandomWeatherPattern().config.Code, updateInstant: true);
				if (flag)
				{
					item.Value.TickEvery25ms(0.025f);
				}
			}
			if (flag)
			{
				return TextCommandResult.Success("Ok random weather pattern set", (object)null);
			}
			return TextCommandResult.Error("No such weather pattern found", "");
		}

		private TextCommandResult CmdWeatherSet(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			string code = args.Parsers[0].GetValue() as string;
			modSystem.ReloadConfigs();
			bool flag = true;
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in modSystem.weatherSimByMapRegion)
			{
				item.Value.ReloadPatterns(api.World.Seed);
				flag &= item.Value.SetWeatherPattern(code, updateInstant: true);
				if (flag)
				{
					item.Value.TickEvery25ms(0.025f);
				}
			}
			if (flag)
			{
				return TextCommandResult.Success("Ok weather pattern set for all loaded regions", (object)null);
			}
			return TextCommandResult.Error("No such weather pattern found", "");
		}

		private TextCommandResult CmdWeatherSetev(TextCommandCallingArgs args)
		{
			string code = args.Parsers[0].GetValue() as string;
			bool allowStop = (bool)args.Parsers[1].GetValue();
			string subCmdCode = args.SubCmdCode;
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			modSystem.ReloadConfigs();
			IPlayer player = args.Caller.Player;
			BlockPos asBlockPos = ((Entity)((player is IServerPlayer) ? player : null).Entity).SidedPos.XYZ.AsBlockPos;
			int regionX = asBlockPos.X / api.World.BlockAccessor.RegionSize;
			int regionZ = asBlockPos.Z / api.World.BlockAccessor.RegionSize;
			if (subCmdCode == "setevr")
			{
				long key = modSystem.MapRegionIndex2D(regionX, regionZ);
				modSystem.weatherSimByMapRegion.TryGetValue(key, out var value);
				if (value == null)
				{
					return TextCommandResult.Success("Weather sim not loaded (yet) for this region", (object)null);
				}
				if (value.SetWeatherEvent(code, updateInstant: true))
				{
					value.CurWeatherEvent.AllowStop = allowStop;
					value.CurWeatherEvent.OnBeginUse();
					value.TickEvery25ms(0.025f);
					return TextCommandResult.Success("Ok weather event for this region set", (object)null);
				}
				return TextCommandResult.Error("No such weather event found", "");
			}
			bool flag = true;
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in modSystem.weatherSimByMapRegion)
			{
				flag &= item.Value.SetWeatherEvent(code, updateInstant: true);
				item.Value.CurWeatherEvent.AllowStop = allowStop;
				if (flag)
				{
					item.Value.CurWeatherEvent.OnBeginUse();
					item.Value.TickEvery25ms(0.025f);
				}
			}
			if (flag)
			{
				return TextCommandResult.Success("Ok weather event set for all loaded regions", (object)null);
			}
			return TextCommandResult.Error("No such weather event found", "");
		}

		private TextCommandResult CmdWeatherRandomevent(TextCommandCallingArgs args)
		{
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true).weatherSimByMapRegion)
			{
				item.Value.selectRandomWeatherEvent();
				item.Value.sendWeatherUpdatePacket();
			}
			return TextCommandResult.Success("Random weather event selected for all regions", (object)null);
		}

		private TextCommandResult CmdWeatherSetw(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			modSystem.ReloadConfigs();
			string code = args.Parsers[0].GetValue() as string;
			bool flag = true;
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in modSystem.weatherSimByMapRegion)
			{
				item.Value.ReloadPatterns(api.World.Seed);
				flag &= item.Value.SetWindPattern(code, updateInstant: true);
				if (flag)
				{
					item.Value.TickEvery25ms(0.025f);
				}
			}
			if (flag)
			{
				return TextCommandResult.Success("Ok wind pattern set", (object)null);
			}
			return TextCommandResult.Error("No such wind pattern found", "");
		}

		private TextCommandResult CmdWeatherC(TextCommandCallingArgs args)
		{
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true).weatherSimByMapRegion)
			{
				item.Value.TriggerTransition(1f);
			}
			return TextCommandResult.Success("Ok selected another weather pattern", (object)null);
		}

		private TextCommandResult CmdWeatherT(TextCommandCallingArgs args)
		{
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true).weatherSimByMapRegion)
			{
				item.Value.TriggerTransition();
			}
			return TextCommandResult.Success("Ok transitioning to another weather pattern", (object)null);
		}

		private TextCommandResult CmdWeatherLp(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			string text = string.Join(", ", modSystem.WeatherConfigs.Select((WeatherPatternConfig c) => c.Code));
			return TextCommandResult.Success("Patterns: " + text, (object)null);
		}

		private TextCommandResult CmdWeatherAcp(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			if (args.Parsers[0].IsMissing)
			{
				modSystem.autoChangePatterns = !modSystem.autoChangePatterns;
			}
			else
			{
				modSystem.autoChangePatterns = (bool)args[0];
			}
			return TextCommandResult.Success("Ok autochange weather patterns now " + (modSystem.autoChangePatterns ? "on" : "off"), (object)null);
		}

		private TextCommandResult CmdWeatherStoprain(TextCommandCallingArgs args)
		{
			TextCommandResult result = RainStopFunc(args.Caller.Player, skipForward: true);
			((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true).broadCastConfigUpdate();
			return result;
		}

		private TextCommandResult CmdWeatherCloudypos(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			if (args.Parsers[0].IsMissing)
			{
				return TextCommandResult.Success("Cloud level rel = " + modSystem.CloudLevelRel, (object)null);
			}
			modSystem.CloudLevelRel = (float)args.Parsers[0].GetValue();
			modSystem.serverChannel.BroadcastPacket<WeatherCloudYposPacket>(new WeatherCloudYposPacket
			{
				CloudYRel = modSystem.CloudLevelRel
			}, Array.Empty<IServerPlayer>());
			return TextCommandResult.Success($"Cloud level rel {modSystem.CloudLevelRel:0.##} set. (y={(int)(modSystem.CloudLevelRel * (float)modSystem.api.World.BlockAccessor.MapSizeY)})", (object)null);
		}

		private TextCommandResult CmdWeatherSetprecip(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			float num = (float)args.Parsers[0].GetValue();
			if (args.Parsers[0].IsMissing)
			{
				if (!modSystem.OverridePrecipitation.HasValue)
				{
					return TextCommandResult.Success("Currently no precipitation override active.", (object)null);
				}
				return TextCommandResult.Success($"Override precipitation value is currently at {modSystem.OverridePrecipitation}.", (object)null);
			}
			modSystem.OverridePrecipitation = num;
			modSystem.serverChannel.BroadcastPacket<WeatherConfigPacket>(new WeatherConfigPacket
			{
				OverridePrecipitation = modSystem.OverridePrecipitation,
				RainCloudDaysOffset = modSystem.RainCloudDaysOffset
			}, Array.Empty<IServerPlayer>());
			return TextCommandResult.Success($"Ok precipitation set to {num}", (object)null);
		}

		private TextCommandResult CmdWeatherSetprecipa(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			modSystem.OverridePrecipitation = null;
			modSystem.serverChannel.BroadcastPacket<WeatherConfigPacket>(new WeatherConfigPacket
			{
				OverridePrecipitation = modSystem.OverridePrecipitation,
				RainCloudDaysOffset = modSystem.RainCloudDaysOffset
			}, Array.Empty<IServerPlayer>());
			return TextCommandResult.Success("Ok auto precipitation on", (object)null);
		}

		private TextCommandResult CmdPrecTestServerClimate(TextCommandCallingArgs args)
		{
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Expected O, but got Unknown
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Expected O, but got Unknown
			IPlayer player = args.Caller.Player;
			bool flag = (bool)args.Parsers[0].GetValue();
			WeatherSystemServer modSystem = api.ModLoader.GetModSystem<WeatherSystemServer>(true);
			EntityPos pos = ((Entity)player.Entity).Pos;
			int num = 400;
			float num2 = 4f;
			float num3 = 1f;
			float num4 = 2f;
			double num5 = api.World.Calendar.TotalDays;
			ClimateCondition climateAt = api.World.BlockAccessor.GetClimateAt(new BlockPos((int)pos.X, (int)pos.Y, (int)pos.Z), (EnumGetClimateMode)0, num5);
			int num6 = num / 2;
			if ((int)RuntimeEnv.OS != 0)
			{
				return TextCommandResult.Success("Command only supported on windows, try sub argument \"here\"", (object)null);
			}
			Bitmap bitmap = new Bitmap(num, num);
			int[] array = new int[num * num];
			AnimatedGifCreator val = new AnimatedGifCreator("precip.gif", 100, -1);
			try
			{
				for (int i = 0; (float)i < num3 * 24f; i++)
				{
					if (flag)
					{
						for (int j = 0; j < num; j++)
						{
							for (int k = 0; k < num; k++)
							{
								climateAt.Rainfall = (float)i / (num3 * 24f);
								float rainCloudness = modSystem.GetRainCloudness(climateAt, pos.X + (double)((float)j * num4) - (double)num6, pos.Z + (double)((float)k * num4) - (double)num6, api.World.Calendar.TotalDays);
								int num7 = (int)GameMath.Clamp(255f * rainCloudness, 0f, 254f);
								array[k * num + j] = ColorUtil.ColorFromRgba(num7, num7, num7, 255);
							}
						}
					}
					else
					{
						for (int l = 0; l < num; l++)
						{
							for (int m = 0; m < num; m++)
							{
								float precipitation = modSystem.GetPrecipitation(pos.X + (double)((float)l * num4) - (double)num6, pos.Y, pos.Z + (double)((float)m * num4) - (double)num6, num5);
								int num8 = (int)GameMath.Clamp(255f * precipitation, 0f, 254f);
								array[m * num + l] = ColorUtil.ColorFromRgba(num8, num8, num8, 255);
							}
						}
					}
					num5 += (double)(num2 / 24f);
					bitmap.SetPixels(array);
					val.AddFrame((Image)bitmap, 100, (GifQuality)3);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			return TextCommandResult.Success("Ok exported", (object)null);
		}

		private TextCommandResult CmdPrecTestServerHere(TextCommandCallingArgs args)
		{
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Expected O, but got Unknown
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Expected O, but got Unknown
			WeatherSystemServer modSystem = api.ModLoader.GetModSystem<WeatherSystemServer>(true);
			EntityPos pos = ((Entity)args.Caller.Player.Entity).Pos;
			double totalDays = api.World.Calendar.TotalDays;
			api.World.BlockAccessor.GetClimateAt(new BlockPos((int)pos.X, (int)pos.Y, (int)pos.Z), (EnumGetClimateMode)0, totalDays);
			int num = 400;
			int num2 = num / 2;
			SKBitmap val = new SKBitmap(num, num, false);
			int[] array = new int[num * num];
			float num3 = 3f;
			for (int i = 0; i < num; i++)
			{
				for (int j = 0; j < num; j++)
				{
					float num4 = (float)i * num3 - (float)num2;
					float num5 = (float)j * num3 - (float)num2;
					if ((int)num4 == 0 && (int)num5 == 0)
					{
						array[j * num + i] = ColorUtil.ColorFromRgba(255, 0, 0, 255);
						continue;
					}
					float precipitation = modSystem.GetPrecipitation(pos.X + (double)num4, pos.Y, pos.Z + (double)num5, totalDays);
					int num6 = (int)GameMath.Clamp(255f * precipitation, 0f, 254f);
					array[j * num + i] = ColorUtil.ColorFromRgba(num6, num6, num6, 255);
				}
			}
			BitmapExtensions.SetPixels(val, array);
			BitmapExtensions.Save(val, "preciphere.png");
			return TextCommandResult.Success("Ok exported", (object)null);
		}

		private TextCommandResult CmdPrecTestServerPos(TextCommandCallingArgs args)
		{
			WeatherSystemServer modSystem = api.ModLoader.GetModSystem<WeatherSystemServer>(true);
			EntityPos pos = ((Entity)args.Caller.Player.Entity).Pos;
			return TextCommandResult.Success("Prec here: " + modSystem.GetPrecipitation(pos.X, pos.Y, pos.Z, api.World.Calendar.TotalDays), (object)null);
		}

		private TextCommandResult CmdSnowAccumHere(TextCommandCallingArgs args)
		{
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Expected O, but got Unknown
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Expected O, but got Unknown
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Expected O, but got Unknown
			WeatherSystemServer modSystem = api.ModLoader.GetModSystem<WeatherSystemServer>(true);
			float num = (float)args.Parsers[0].GetValue();
			BlockPos asBlockPos = ((Entity)args.Caller.Player.Entity).Pos.AsBlockPos;
			Vec2i val = new Vec2i(asBlockPos.X / 32, asBlockPos.Z / 32);
			IServerMapChunk mapChunk = sapi.WorldManager.GetMapChunk(val.X, val.Y);
			int snowAccumResolution = WeatherSimulationRegion.snowAccumResolution;
			SnowAccumSnapshot snowAccumSnapshot = new SnowAccumSnapshot
			{
				SumTemperatureByRegionCorner = new FloatDataMap3D(snowAccumResolution, snowAccumResolution, snowAccumResolution),
				SnowAccumulationByRegionCorner = new FloatDataMap3D(snowAccumResolution, snowAccumResolution, snowAccumResolution)
			};
			ArrayExtensions.Fill<float>(snowAccumSnapshot.SnowAccumulationByRegionCorner.Data, num);
			UpdateSnowLayerChunk updateChunk = modSystem.snowSimSnowAccu.UpdateSnowLayer(snowAccumSnapshot, ignoreOldAccum: true, mapChunk, val, null);
			modSystem.snowSimSnowAccu.accum = 1f;
			IBulkBlockAccessor blockAccessorBulkMinimalUpdate = ((IWorldAccessor)sapi.World).GetBlockAccessorBulkMinimalUpdate(true, false);
			((IBlockAccessor)blockAccessorBulkMinimalUpdate).UpdateSnowAccumMap = false;
			modSystem.snowSimSnowAccu.processBlockUpdates((IMapChunk)(object)mapChunk, updateChunk, blockAccessorBulkMinimalUpdate);
			((IBlockAccessor)blockAccessorBulkMinimalUpdate).Commit();
			return TextCommandResult.Success("Ok, test snow accum gen complete", (object)null);
		}

		private TextCommandResult CmdSnowAccumInfo(TextCommandCallingArgs args)
		{
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Expected O, but got Unknown
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Expected O, but got Unknown
			IPlayer player = args.Caller.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			BlockPos asBlockPos = ((Entity)((IPlayer)val).Entity).Pos.AsBlockPos;
			Vec2i val2 = new Vec2i(asBlockPos.X / 32, asBlockPos.Z / 32);
			double num = ((IMapChunk)sapi.WorldManager.GetMapChunk(val2.X, val2.Y)).GetModdata<double>("lastSnowAccumUpdateTotalHours", 0.0);
			val.SendMessage(GlobalConstants.GeneralChatGroup, "lastSnowAccumUpdate: " + (api.World.Calendar.TotalHours - num) + " hours ago", (EnumChatType)0, (string)null);
			int regionX = (int)((Entity)((IPlayer)val).Entity).Pos.X / ((IWorldAccessor)sapi.World).BlockAccessor.RegionSize;
			int regionZ = (int)((Entity)((IPlayer)val).Entity).Pos.Z / ((IWorldAccessor)sapi.World).BlockAccessor.RegionSize;
			WeatherSystemServer modSystem = ((ICoreAPI)sapi).ModLoader.GetModSystem<WeatherSystemServer>(true);
			long key = modSystem.MapRegionIndex2D(regionX, regionZ);
			modSystem.weatherSimByMapRegion.TryGetValue(key, out var value);
			int snowAccumResolution = WeatherSimulationRegion.snowAccumResolution;
			float[] data = new SnowAccumSnapshot
			{
				SnowAccumulationByRegionCorner = new FloatDataMap3D(snowAccumResolution, snowAccumResolution, snowAccumResolution)
			}.SnowAccumulationByRegionCorner.Data;
			float num2 = 3.5f;
			int length = value.SnowAccumSnapshots.Length;
			int num3 = value.SnowAccumSnapshots.EndPosition;
			while (length-- > 0)
			{
				SnowAccumSnapshot snowAccumSnapshot = value.SnowAccumSnapshots[num3];
				num3 = (num3 + 1) % value.SnowAccumSnapshots.Length;
				if (snowAccumSnapshot != null)
				{
					float[] data2 = snowAccumSnapshot.SnowAccumulationByRegionCorner.Data;
					for (int i = 0; i < data2.Length; i++)
					{
						data[i] = GameMath.Clamp(data[i] + data2[i], 0f - num2, num2);
					}
					num = Math.Max(num, snowAccumSnapshot.TotalHours);
				}
			}
			for (int j = 0; j < data.Length; j++)
			{
				val.SendMessage(GlobalConstants.GeneralChatGroup, j + ": " + data[j], (EnumChatType)0, (string)null);
			}
			return TextCommandResult.Success("", (object)null);
		}

		private TextCommandResult CmdSnowAccumProcesshere(TextCommandCallingArgs args)
		{
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Expected O, but got Unknown
			WeatherSystemServer modSystem = api.ModLoader.GetModSystem<WeatherSystemServer>(true);
			BlockPos asBlockPos = ((Entity)args.Caller.Player.Entity).Pos.AsBlockPos;
			Vec2i chunkCoord = new Vec2i(asBlockPos.X / 32, asBlockPos.Z / 32);
			modSystem.snowSimSnowAccu.AddToCheckQueue(chunkCoord);
			return TextCommandResult.Success("Ok, added to check queue", (object)null);
		}

		private TextCommandResult CmdSnowAccumOff(TextCommandCallingArgs args)
		{
			api.ModLoader.GetModSystem<WeatherSystemServer>(true).snowSimSnowAccu.ProcessChunks = false;
			return TextCommandResult.Success("Snow accum process chunks off", (object)null);
		}

		private TextCommandResult CmdSnowAccumOn(TextCommandCallingArgs args)
		{
			api.ModLoader.GetModSystem<WeatherSystemServer>(true).snowSimSnowAccu.ProcessChunks = true;
			return TextCommandResult.Success("Snow accum process chunks on", (object)null);
		}

		private TextCommandResult CmdWhenWillItStopRaining(TextCommandCallingArgs args)
		{
			return RainStopFunc(args.Caller.Player);
		}

		private TextCommandResult RainStopFunc(IPlayer player, bool skipForward = false)
		{
			WeatherSystemServer modSystem = api.ModLoader.GetModSystem<WeatherSystemServer>(true);
			if (modSystem.OverridePrecipitation.HasValue)
			{
				return TextCommandResult.Success("Override precipitation set, rain pattern will not change. Fix by typing /weather setprecipa.", (object)null);
			}
			Vec3d xYZ = ((Entity)player.Entity).Pos.XYZ;
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			bool flag = false;
			for (; num < 21f; num += 1f / ((IWorldAccessor)sapi.World).Calendar.HoursPerDay)
			{
				if (modSystem.GetPrecipitation(xYZ.X, xYZ.Y, xYZ.Z, ((IWorldAccessor)sapi.World).Calendar.TotalDays + (double)num) < 0.04f)
				{
					if (!flag)
					{
						num3 = num;
					}
					flag = true;
					num2 += 1f / ((IWorldAccessor)sapi.World).Calendar.HoursPerDay;
				}
				else if (flag)
				{
					break;
				}
			}
			if (num2 > 0f)
			{
				if (skipForward)
				{
					modSystem.RainCloudDaysOffset += num2;
					return TextCommandResult.Success($"Ok, forwarded rain simulation by {num3:0.##} days. The rain should stop for about {num2:0.##} days now", (object)(EnumChatType)0);
				}
				return TextCommandResult.Success($"In about {num3:0.##} days the rain should stop for about {num2:0.##} days", (object)null);
			}
			return TextCommandResult.Success("No rain less days found for the next 3 in-game weeks :O", (object)null);
		}

		public override void StartClientSide(ICoreClientAPI capi)
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Expected O, but got Unknown
			this.capi = capi;
			((ICoreAPI)this.capi).ChatCommands.Create("weather").WithDescription("Show current weather info").HandleWith(new OnCommandDelegate(CmdWeatherClient));
		}

		private TextCommandResult CmdWeatherClient(TextCommandCallingArgs textCommandCallingArgs)
		{
			return TextCommandResult.Success(GetWeatherInfo<WeatherSystemClient>((IPlayer)(object)capi.World.Player), (object)null);
		}

		private string GetWeatherInfo<T>(IPlayer player) where T : WeatherSystemBase
		{
			T modSystem = api.ModLoader.GetModSystem<T>(true);
			Vec3d xYZ = ((Entity)player.Entity).SidedPos.XYZ;
			BlockPos asBlockPos = xYZ.AsBlockPos;
			WeatherDataReaderPreLoad weatherDataReaderPreLoad = modSystem.getWeatherDataReaderPreLoad();
			weatherDataReaderPreLoad.LoadAdjacentSimsAndLerpValues(xYZ, 1f);
			int regionX = asBlockPos.X / api.World.BlockAccessor.RegionSize;
			int regionZ = asBlockPos.Z / api.World.BlockAccessor.RegionSize;
			long key = modSystem.MapRegionIndex2D(regionX, regionZ);
			modSystem.weatherSimByMapRegion.TryGetValue(key, out var value);
			if (value == null)
			{
				return "weatherSim is null. No idea what to do here";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Weather by region:");
			string[] array = new string[4] { "tl", "tr", "bl", "br" };
			double num = GameMath.BiLerp(1.0, 0.0, 0.0, 0.0, weatherDataReaderPreLoad.LerpLeftRight, weatherDataReaderPreLoad.LerpTopBot);
			double num2 = GameMath.BiLerp(0.0, 1.0, 0.0, 0.0, weatherDataReaderPreLoad.LerpLeftRight, weatherDataReaderPreLoad.LerpTopBot);
			double num3 = GameMath.BiLerp(0.0, 0.0, 1.0, 0.0, weatherDataReaderPreLoad.LerpLeftRight, weatherDataReaderPreLoad.LerpTopBot);
			double num4 = GameMath.BiLerp(0.0, 0.0, 0.0, 1.0, weatherDataReaderPreLoad.LerpLeftRight, weatherDataReaderPreLoad.LerpTopBot);
			int[] array2 = new int[4]
			{
				(int)(100.0 * num),
				(int)(100.0 * num2),
				(int)(100.0 * num3),
				(int)(100.0 * num4)
			};
			for (int i = 0; i < 4; i++)
			{
				WeatherSimulationRegion weatherSimulationRegion = weatherDataReaderPreLoad.AdjacentSims[i];
				if (weatherSimulationRegion == modSystem.dummySim)
				{
					stringBuilder.AppendLine($"{array[i]}: missing");
					continue;
				}
				string text = weatherSimulationRegion.OldWePattern.GetWeatherName();
				if (weatherSimulationRegion.Weight < 1f)
				{
					text = $"{weatherSimulationRegion.OldWePattern.GetWeatherName()} transitioning to {weatherSimulationRegion.NewWePattern.GetWeatherName()} ({(int)(100f * weatherSimulationRegion.Weight)}%)";
				}
				stringBuilder.AppendLine(string.Format("{0}: {1}% {2}. Wind: {3} (str={4}), Event: {5}", array[i], array2[i], text, weatherSimulationRegion.CurWindPattern.GetWindName(), weatherSimulationRegion.GetWindSpeed(asBlockPos.Y).ToString("0.###"), weatherSimulationRegion.CurWeatherEvent.config.Code));
			}
			ClimateCondition climateAt = api.World.BlockAccessor.GetClimateAt(((Entity)player.Entity).Pos.AsBlockPos, (EnumGetClimateMode)1, 0.0);
			stringBuilder.AppendLine($"Current precipitation: {(int)(climateAt.Rainfall * 100f)}%");
			stringBuilder.AppendLine($"Current wind: {GlobalConstants.CurrentWindSpeedClient}");
			return stringBuilder.ToString();
		}
	}
	public class WeatherDataReader : WeatherDataReaderBase
	{
		public WeatherDataReader(ICoreAPI api, WeatherSystemBase ws)
			: base(api, ws)
		{
		}

		public double GetBlendedCloudBrightness(Vec3d pos, float bMul = 1f)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgetBlendedCloudBrightness(bMul);
		}

		public double GetBlendedCloudOpaqueness(Vec3d pos)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgetBlendedCloudOpaqueness();
		}

		public double GetBlendedCloudThicknessAt(Vec3d pos, int cloudTileX, int cloudTileZ)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgetBlendedCloudThicknessAt(cloudTileX, cloudTileZ);
		}

		public double GetBlendedThinCloudModeness(Vec3d pos)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgetBlendedThinCloudModeness();
		}

		public double GetBlendedUndulatingCloudModeness(Vec3d pos)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgetBlendedUndulatingCloudModeness();
		}

		public double GetWindSpeed(Vec3d pos)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgetWindSpeed(pos.Y);
		}

		public EnumPrecipitationType GetPrecType(Vec3d pos)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false);
			return pgGetPrecType();
		}
	}
	public class WeatherDataReaderPreLoad : WeatherDataReaderBase
	{
		public WeatherDataReaderPreLoad(ICoreAPI api, WeatherSystemBase ws)
			: base(api, ws)
		{
		}

		public void LoadAdjacentSimsAndLerpValues(Vec3d pos, float dt)
		{
			LoadAdjacentSimsAndLerpValues(pos, useArgValues: false, 0f, 0f, dt);
		}

		public void LoadLerp(Vec3d pos)
		{
			LoadLerp(pos, useArgValues: false);
		}

		public void UpdateAdjacentAndBlendWeatherData()
		{
			updateAdjacentAndBlendWeatherData();
		}

		public void EnsureCloudTileCacheIsFresh(Vec3i tilePos)
		{
			ensureCloudTileCacheIsFresh(tilePos);
		}

		public double GetWindSpeed(double posY)
		{
			return pgetWindSpeed(posY);
		}

		public double GetBlendedCloudThicknessAt(int cloudTileX, int cloudTileZ)
		{
			return pgetBlendedCloudThicknessAt(cloudTileX, cloudTileZ);
		}

		public double GetBlendedCloudOpaqueness()
		{
			return pgetBlendedCloudOpaqueness();
		}

		public double GetBlendedCloudBrightness(float b)
		{
			return pgetBlendedCloudBrightness(b);
		}

		public double GetBlendedThinCloudModeness()
		{
			return pgetBlendedThinCloudModeness();
		}

		public double GetBlendedUndulatingCloudModeness()
		{
			return pgetBlendedUndulatingCloudModeness();
		}
	}
	public abstract class WeatherDataReaderBase
	{
		public WeatherDataSnapshot BlendedWeatherData = new WeatherDataSnapshot();

		protected WeatherDataSnapshot blendedWeatherDataNoPrec = new WeatherDataSnapshot();

		protected WeatherDataSnapshot topBlendedWeatherData = new WeatherDataSnapshot();

		protected WeatherDataSnapshot botBlendedWeatherData = new WeatherDataSnapshot();

		public WeatherSimulationRegion[] AdjacentSims = new WeatherSimulationRegion[4];

		public double LerpLeftRight;

		public double LerpTopBot;

		private ICoreAPI api;

		private WeatherSystemBase ws;

		private WeatherPattern rainOverlayData;

		private WeatherDataSnapshot rainSnapData;

		public float lerpRainCloudOverlay;

		public float lerpRainOverlay;

		private BlockPos tmpPos = new BlockPos();

		private IMapRegion hereMapRegion;

		public WeatherDataReaderBase(ICoreAPI api, WeatherSystemBase ws)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Expected O, but got Unknown
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			this.api = api;
			this.ws = ws;
			BlendedWeatherData.Ambient = new AmbientModifier().EnsurePopulated();
			blendedWeatherDataNoPrec.Ambient = new AmbientModifier().EnsurePopulated();
			AdjacentSims[0] = ws.dummySim;
			AdjacentSims[1] = ws.dummySim;
			AdjacentSims[2] = ws.dummySim;
			AdjacentSims[3] = ws.dummySim;
		}

		public void LoadAdjacentSims(Vec3d pos)
		{
			int regionSize = api.World.BlockAccessor.RegionSize;
			int num = (int)pos.X / regionSize;
			int num2 = (int)pos.Z / regionSize;
			int num3 = (int)Math.Round(pos.X / (double)regionSize) - 1;
			int num4 = (int)Math.Round(pos.Z / (double)regionSize) - 1;
			int num5 = 0;
			for (int i = 0; i <= 1; i++)
			{
				for (int j = 0; j <= 1; j++)
				{
					int num6 = num3 + i;
					int num7 = num4 + j;
					WeatherSimulationRegion weatherSimulationRegion = ws.getOrCreateWeatherSimForRegion(num6, num7);
					if (weatherSimulationRegion == null)
					{
						weatherSimulationRegion = ws.dummySim;
					}
					AdjacentSims[num5++] = weatherSimulationRegion;
					if (num6 == num && num7 == num2)
					{
						hereMapRegion = weatherSimulationRegion.MapRegion;
					}
				}
			}
		}

		public void LoadAdjacentSimsAndLerpValues(Vec3d pos, bool useArgValues, float lerpRainCloudOverlay = 0f, float lerpRainOverlay = 0f, float dt = 1f)
		{
			LoadAdjacentSims(pos);
			LoadLerp(pos, useArgValues, lerpRainCloudOverlay, lerpRainOverlay, dt);
		}

		public void LoadLerp(Vec3d pos, bool useArgValues, float lerpRainCloudOverlay = 0f, float lerpRainOverlay = 0f, float dt = 1f)
		{
			int regionSize = api.World.BlockAccessor.RegionSize;
			double num = pos.X / (double)regionSize - (double)(int)Math.Round(pos.X / (double)regionSize);
			double num2 = pos.Z / (double)regionSize - (double)(int)Math.Round(pos.Z / (double)regionSize);
			LerpTopBot = GameMath.Smootherstep(num + 0.5);
			LerpLeftRight = GameMath.Smootherstep(num2 + 0.5);
			rainOverlayData = ws.rainOverlayPattern;
			rainSnapData = ws.rainOverlaySnap;
			if (hereMapRegion == null)
			{
				this.lerpRainCloudOverlay = 0f;
				this.lerpRainOverlay = 0f;
				return;
			}
			if (useArgValues)
			{
				this.lerpRainCloudOverlay = lerpRainCloudOverlay;
				this.lerpRainOverlay = lerpRainOverlay;
				return;
			}
			tmpPos.Set((int)pos.X, (int)pos.Y, (int)pos.Z);
			int innerSize = hereMapRegion.ClimateMap.InnerSize;
			int climate = 8421504;
			if (innerSize > 0)
			{
				double num3 = Math.Max(0.0, (pos.X / (double)regionSize - (double)((int)pos.X / regionSize)) * (double)innerSize);
				double num4 = Math.Max(0.0, (pos.Z / (double)regionSize - (double)((int)pos.Z / regionSize)) * (double)innerSize);
				climate = hereMapRegion.ClimateMap.GetUnpaddedColorLerped((float)num3, (float)num4);
			}
			ClimateCondition climateFast = ws.GetClimateFast(tmpPos, climate);
			float num5 = Math.Min(1f, dt * 10f);
			this.lerpRainCloudOverlay += (climateFast.RainCloudOverlay - this.lerpRainCloudOverlay) * num5;
			this.lerpRainOverlay += (climateFast.Rainfall - this.lerpRainOverlay) * num5;
		}

		protected void updateAdjacentAndBlendWeatherData()
		{
			AdjacentSims[0].UpdateWeatherData();
			AdjacentSims[1].UpdateWeatherData();
			AdjacentSims[2].UpdateWeatherData();
			AdjacentSims[3].UpdateWeatherData();
			topBlendedWeatherData.SetLerped(AdjacentSims[0].weatherData, AdjacentSims[1].weatherData, (float)LerpLeftRight);
			botBlendedWeatherData.SetLerped(AdjacentSims[2].weatherData, AdjacentSims[3].weatherData, (float)LerpLeftRight);
			blendedWeatherDataNoPrec.SetLerped(topBlendedWeatherData, botBlendedWeatherData, (float)LerpTopBot);
			((WeightedValue<float>)(object)blendedWeatherDataNoPrec.Ambient.CloudBrightness).Weight = 0f;
			BlendedWeatherData.SetLerpedPrec(blendedWeatherDataNoPrec, rainSnapData, lerpRainOverlay);
		}

		protected void ensureCloudTileCacheIsFresh(Vec3i tilePos)
		{
			AdjacentSims[0].EnsureCloudTileCacheIsFresh(tilePos);
			AdjacentSims[1].EnsureCloudTileCacheIsFresh(tilePos);
			AdjacentSims[2].EnsureCloudTileCacheIsFresh(tilePos);
			AdjacentSims[3].EnsureCloudTileCacheIsFresh(tilePos);
		}

		protected EnumPrecipitationType pgGetPrecType()
		{
			if (LerpTopBot <= 0.5)
			{
				if (!(LerpLeftRight <= 0.5))
				{
					return AdjacentSims[1].GetPrecipitationType();
				}
				return AdjacentSims[0].GetPrecipitationType();
			}
			if (!(LerpLeftRight <= 0.5))
			{
				return AdjacentSims[3].GetPrecipitationType();
			}
			return AdjacentSims[2].GetPrecipitationType();
		}

		protected double pgetWindSpeed(double posY)
		{
			return GameMath.BiLerp(AdjacentSims[0].GetWindSpeed(posY), AdjacentSims[1].GetWindSpeed(posY), AdjacentSims[2].GetWindSpeed(posY), AdjacentSims[3].GetWindSpeed(posY), LerpLeftRight, LerpTopBot);
		}

		protected double pgetBlendedCloudThicknessAt(int cloudTileX, int cloudTileZ)
		{
			double num = GameMath.BiLerp(AdjacentSims[0].GetBlendedCloudThicknessAt(cloudTileX, cloudTileZ), AdjacentSims[1].GetBlendedCloudThicknessAt(cloudTileX, cloudTileZ), AdjacentSims[2].GetBlendedCloudThicknessAt(cloudTileX, cloudTileZ), AdjacentSims[3].GetBlendedCloudThicknessAt(cloudTileX, cloudTileZ), LerpLeftRight, LerpTopBot);
			double num2 = rainOverlayData.State.nowbaseThickness;
			return GameMath.Lerp(num, num2, (double)lerpRainCloudOverlay);
		}

		protected double pgetBlendedCloudOpaqueness()
		{
			double num = GameMath.BiLerp(AdjacentSims[0].GetBlendedCloudOpaqueness(), AdjacentSims[1].GetBlendedCloudOpaqueness(), AdjacentSims[2].GetBlendedCloudOpaqueness(), AdjacentSims[3].GetBlendedCloudOpaqueness(), LerpLeftRight, LerpTopBot);
			double num2 = rainOverlayData.State.nowbaseOpaqueness;
			return GameMath.Lerp(num, num2, (double)lerpRainCloudOverlay);
		}

		protected double pgetBlendedCloudBrightness(float b)
		{
			double num = GameMath.BiLerp(AdjacentSims[0].GetBlendedCloudBrightness(b), AdjacentSims[1].GetBlendedCloudBrightness(b), AdjacentSims[2].GetBlendedCloudBrightness(b), AdjacentSims[3].GetBlendedCloudBrightness(b), LerpLeftRight, LerpTopBot);
			double num2 = rainOverlayData.State.nowCloudBrightness;
			return GameMath.Lerp(num, num2, (double)lerpRainCloudOverlay);
		}

		protected double pgetBlendedThinCloudModeness()
		{
			return GameMath.BiLerp(AdjacentSims[0].GetBlendedThinCloudModeness(), AdjacentSims[1].GetBlendedThinCloudModeness(), AdjacentSims[2].GetBlendedThinCloudModeness(), AdjacentSims[3].GetBlendedThinCloudModeness(), LerpLeftRight, LerpTopBot);
		}

		protected double pgetBlendedUndulatingCloudModeness()
		{
			return GameMath.BiLerp(AdjacentSims[0].GetBlendedUndulatingCloudModeness(), AdjacentSims[1].GetBlendedUndulatingCloudModeness(), AdjacentSims[2].GetBlendedUndulatingCloudModeness(), AdjacentSims[3].GetBlendedUndulatingCloudModeness(), LerpLeftRight, LerpTopBot);
		}
	}
	public class WeatherDataSnapshot
	{
		public AmbientModifier Ambient = new AmbientModifier().EnsurePopulated();

		public EnumPrecipitationType BlendedPrecType;

		public float PrecIntensity;

		public float PrecParticleSize;

		public EnumPrecipitationType nowPrecType;

		public float nearLightningRate;

		public float distantLightningRate;

		public float lightningMinTemp;

		public ClimateCondition climateCond = new ClimateCondition();

		public Vec3f curWindSpeed = new Vec3f();

		public float snowThresholdTemp = 4f;

		public void SetAmbientLerped(WeatherPattern left, WeatherPattern right, float w, float addFogDensity = 0f)
		{
			float num = GameMath.Clamp(1f - (float)Math.Pow(1.1 - (double)climateCond.WorldgenRainfall, 4.0), 0f, 1f);
			((WeightedValue<float>)(object)Ambient.FlatFogDensity).Set((right.State.nowMistDensity * w + left.State.nowMistDensity * (1f - w)) / 250f, num);
			((WeightedValue<float>)(object)Ambient.FlatFogYPos).Set(right.State.nowMistYPos * w + left.State.nowMistYPos * (1f - w), 1f);
			((WeightedValue<float>)(object)Ambient.FogDensity).Set((addFogDensity + right.State.nowFogDensity * w + left.State.nowFogDensity * (1f - w)) / 1000f, num);
			((WeightedValue<float>)(object)Ambient.CloudBrightness).Set(right.State.nowCloudBrightness * w + left.State.nowCloudBrightness * (1f - w), 1f);
			((WeightedValue<float>)(object)Ambient.CloudDensity).Set(right.State.nowbaseThickness * w + left.State.nowbaseThickness * (1f - w), 1f);
			((WeightedValue<float>)(object)Ambient.SceneBrightness).Set(right.State.nowSceneBrightness * w + left.State.nowSceneBrightness * (1f - w), 1f);
			((WeightedValue<float>)(object)Ambient.FogBrightness).Set(right.State.nowFogBrightness * w + left.State.nowFogBrightness * (1f - w), 1f);
		}

		public void SetAmbient(WeatherPattern left, float addFogDensity = 0f)
		{
			float num = GameMath.Clamp(1f - (float)Math.Pow(1.1 - (double)climateCond.WorldgenRainfall, 4.0), 0f, 1f);
			((WeightedValue<float>)(object)Ambient.FlatFogDensity).Set(left.State.nowMistDensity / 250f, num);
			((WeightedValue<float>)(object)Ambient.FlatFogYPos).Set(left.State.nowMistYPos, 1f);
			((WeightedValue<float>)(object)Ambient.FogDensity).Set((addFogDensity + left.State.nowFogDensity) / 1000f, num);
			((WeightedValue<float>)(object)Ambient.CloudBrightness).Set(left.State.nowCloudBrightness, 1f);
			((WeightedValue<float>)(object)Ambient.CloudDensity).Set(left.State.nowbaseThickness, 1f);
			((WeightedValue<float>)(object)Ambient.SceneBrightness).Set(left.State.nowSceneBrightness, 1f);
			((WeightedValue<float>)(object)Ambient.FogBrightness).Set(left.State.nowFogBrightness, 1f);
		}

		public void SetLerped(WeatherDataSnapshot left, WeatherDataSnapshot right, float w)
		{
			Ambient.SetLerped(left.Ambient, right.Ambient, w);
			PrecIntensity = left.PrecIntensity * (1f - w) + right.PrecIntensity * w;
			PrecParticleSize = left.PrecParticleSize * (1f - w) + right.PrecParticleSize * w;
			nowPrecType = (((double)w < 0.5) ? left.nowPrecType : right.nowPrecType);
			BlendedPrecType = (((double)w < 0.5) ? left.BlendedPrecType : right.BlendedPrecType);
			nearLightningRate = left.nearLightningRate * (1f - w) + right.nearLightningRate * w;
			distantLightningRate = left.distantLightningRate * (1f - w) + right.distantLightningRate * w;
			lightningMinTemp = left.lightningMinTemp * (1f - w) + right.lightningMinTemp * w;
			climateCond.SetLerped(left.climateCond, right.climateCond, w);
			curWindSpeed.X = left.curWindSpeed.X * (1f - w) + right.curWindSpeed.X * w;
			snowThresholdTemp = left.snowThresholdTemp * (1f - w) + right.snowThresholdTemp * w;
		}

		public void SetLerpedPrec(WeatherDataSnapshot left, WeatherDataSnapshot right, float w)
		{
			Ambient.SetLerped(left.Ambient, right.Ambient, w);
			PrecIntensity = left.PrecIntensity * (1f - w) + right.PrecIntensity * w;
			PrecParticleSize = left.PrecParticleSize * (1f - w) + right.PrecParticleSize * w;
			nowPrecType = left.nowPrecType;
			BlendedPrecType = left.BlendedPrecType;
			nearLightningRate = left.nearLightningRate;
			distantLightningRate = left.distantLightningRate;
			lightningMinTemp = left.lightningMinTemp;
			climateCond = left.climateCond;
			curWindSpeed.X = left.curWindSpeed.X;
			snowThresholdTemp = left.snowThresholdTemp;
		}

		public void BiLerp(WeatherDataSnapshot topLeft, WeatherDataSnapshot topRight, WeatherDataSnapshot botLeft, WeatherDataSnapshot botRight, float lerpleftRight, float lerptopBot)
		{
			WeatherDataSnapshot weatherDataSnapshot = new WeatherDataSnapshot();
			weatherDataSnapshot.SetLerped(topLeft, topRight, lerpleftRight);
			WeatherDataSnapshot weatherDataSnapshot2 = new WeatherDataSnapshot();
			weatherDataSnapshot2.SetLerped(botLeft, botRight, lerptopBot);
			SetLerped(weatherDataSnapshot, weatherDataSnapshot2, lerptopBot);
		}
	}
	public class WeatherSimulationLightning : IRenderer, IDisposable
	{
		private WeatherSystemBase weatherSys;

		private WeatherSystemClient weatherSysc;

		private ICoreClientAPI capi;

		private IShaderProgram prog;

		public float lightningTime;

		public float lightningIntensity;

		public AmbientModifier LightningAmbient;

		public AmbientModifier actualSunGlowAmb = new AmbientModifier().EnsurePopulated();

		private float nearLightningCoolDown;

		public List<LightningFlash> lightningFlashes = new List<LightningFlash>();

		public double RenderOrder => 0.35;

		public int RenderRange => 9999;

		public WeatherSimulationLightning(ICoreAPI api, WeatherSystemBase weatherSys)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Invalid comparison between Unknown and I4
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Expected O, but got Unknown
			//IL_016c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Expected O, but got Unknown
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Expected O, but got Unknown
			this.weatherSys = weatherSys;
			weatherSysc = weatherSys as WeatherSystemClient;
			capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			if ((int)api.Side == 2)
			{
				LightningAmbient = new AmbientModifier().EnsurePopulated();
				capi.Ambient.CurrentModifiers["lightningambient"] = LightningAmbient;
				capi.Event.ReloadShader += new ActionBoolReturn(LoadShader);
				LoadShader();
				capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)1, "lightning");
			}
			else
			{
				api.Event.RegisterGameTickListener((Action<float>)OnServerTick, 40, 3);
				api.ChatCommands.GetOrCreate("debug").BeginSubCommand("lntest").BeginSubCommand("spawn")
					.WithDescription("Lightning test")
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)api.ChatCommands.Parsers.OptionalInt("range", 10) })
					.RequiresPlayer()
					.RequiresPrivilege(Privilege.controlserver)
					.HandleWith(new OnCommandDelegate(OnCmdLineTestServer))
					.EndSubCommand()
					.BeginSubCommand("clear")
					.WithDescription("Clear all lightning flashes")
					.RequiresPrivilege(Privilege.controlserver)
					.HandleWith(new OnCommandDelegate(OnCmdLineTestServerClear))
					.EndSubCommand()
					.EndSubCommand();
			}
		}

		private TextCommandResult OnCmdLineTestServerClear(TextCommandCallingArgs args)
		{
			foreach (LightningFlash lightningFlash in lightningFlashes)
			{
				lightningFlash.Dispose();
			}
			lightningFlashes.Clear();
			return TextCommandResult.Success("Cleared all lightning flashes", (object)null);
		}

		private TextCommandResult OnCmdLineTestServer(TextCommandCallingArgs args)
		{
			int num = (int)args.Parsers[0].GetValue();
			Vec3d xYZ = args.Caller.Entity.Pos.AheadCopy((double)num).XYZ;
			weatherSys.SpawnLightningFlash(xYZ);
			return TextCommandResult.Success($"Spawned lightning {num} block ahead", (object)null);
		}

		public void ClientTick(float dt)
		{
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Expected O, but got Unknown
			//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c2: Expected O, but got Unknown
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a9: Expected O, but got Unknown
			WeatherDataSnapshot blendedWeatherData = weatherSysc.BlendedWeatherData;
			if (!(weatherSysc.clientClimateCond.Temperature >= blendedWeatherData.lightningMinTemp))
			{
				return;
			}
			float num = GameMath.Clamp(1f - (float)Math.Pow(((Entity)((IPlayer)capi.World.Player).Entity).Pos.Y / (double)((IWorldAccessor)capi.World).SeaLevel * 1.5 - 0.5, 1.5) - WeatherSimulationSound.roomVolumePitchLoss * 0.5f, 0f, 1f);
			Random rand = ((IWorldAccessor)capi.World).Rand;
			double num2 = rand.NextDouble();
			num2 -= (double)(blendedWeatherData.distantLightningRate * weatherSysc.clientClimateCond.RainCloudOverlay);
			if (num2 <= 0.0)
			{
				lightningTime = 0.07f + (float)rand.NextDouble() * 0.17f;
				lightningIntensity = 0.25f + (float)rand.NextDouble();
				float num3 = GameMath.Clamp((float)rand.NextDouble() * 0.3f + lightningTime / 2f + lightningIntensity / 2f - num / 2f, 0.6f, 1.15f);
				float num4 = GameMath.Clamp(Math.Min(1f, 0.25f + lightningTime + lightningIntensity / 2f) - 2f * num, 0f, 1f);
				((IWorldAccessor)capi.World).PlaySoundAt(new AssetLocation("sounds/weather/lightning-distant.ogg"), 0.0, 0.0, 0.0, (IPlayer)null, (EnumSoundType)3, num3, 32f, num4);
			}
			else
			{
				if (!(nearLightningCoolDown <= 0f))
				{
					return;
				}
				num2 -= (double)(blendedWeatherData.nearLightningRate * weatherSysc.clientClimateCond.RainCloudOverlay);
				if (num2 <= 0.0)
				{
					lightningTime = 0.07f + (float)rand.NextDouble() * 0.17f;
					lightningIntensity = 1f + (float)rand.NextDouble() * 0.9f;
					float num5 = GameMath.Clamp(0.75f + (float)rand.NextDouble() * 0.3f - num / 2f, 0.5f, 1.2f);
					float num6 = GameMath.Clamp(0.5f + (float)rand.NextDouble() * 0.5f - 2f * num, 0f, 1f);
					AssetLocation val;
					if (rand.NextDouble() > 0.25)
					{
						val = new AssetLocation("sounds/weather/lightning-near.ogg");
						nearLightningCoolDown = 5f;
					}
					else
					{
						val = new AssetLocation("sounds/weather/lightning-verynear.ogg");
						nearLightningCoolDown = 10f;
					}
					((IWorldAccessor)capi.World).PlaySoundAt(val, 0.0, 0.0, 0.0, (IPlayer)null, (EnumSoundType)3, num5, 32f, num6);
				}
			}
		}

		public void OnRenderFrame(float dt, EnumRenderStage stage)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Invalid comparison between Unknown and I4
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Invalid comparison between Unknown and I4
			if (prog.LoadError)
			{
				return;
			}
			if ((int)stage == 1)
			{
				prog.Use();
				prog.UniformMatrix("projection", capi.Render.CurrentProjectionMatrix);
				prog.UniformMatrix("view", capi.Render.CameraMatrixOriginf);
				for (int i = 0; i < lightningFlashes.Count; i++)
				{
					LightningFlash lightningFlash = lightningFlashes[i];
					lightningFlash.Render(dt);
					if (!lightningFlash.Alive)
					{
						lightningFlash.Dispose();
						lightningFlashes.RemoveAt(i);
						i--;
					}
				}
				prog.Stop();
			}
			else if ((int)stage == 12)
			{
				AmbientModifier val = capi.Ambient.CurrentModifiers["sunglow"];
				((WeightedValue<float[]>)(object)actualSunGlowAmb.FogColor).Weight = ((WeightedValue<float[]>)(object)val.FogColor).Weight;
				dt = Math.Min(0.5f, dt);
				if (nearLightningCoolDown > 0f)
				{
					nearLightningCoolDown -= dt;
				}
			}
			else if (lightningTime > 0f)
			{
				float num = Math.Min(10f * lightningIntensity * lightningTime, 1.5f);
				WeatherDataSnapshot blendedWeatherData = weatherSysc.BlendedWeatherData;
				((WeightedValue<float>)(object)LightningAmbient.CloudBrightness).Value = Math.Max(((WeightedValue<float>)(object)blendedWeatherData.Ambient.SceneBrightness).Value, num);
				((WeightedValue<float>)(object)LightningAmbient.FogBrightness).Value = Math.Max(((WeightedValue<float>)(object)blendedWeatherData.Ambient.FogBrightness).Value, num);
				((WeightedValue<float>)(object)LightningAmbient.CloudBrightness).Weight = Math.Min(1f, num);
				((WeightedValue<float>)(object)LightningAmbient.FogBrightness).Weight = Math.Min(1f, num);
				float num2 = GameMath.Min(num, GameMath.Max(0f, lightningIntensity - 0.75f));
				if (num2 > 0f)
				{
					((WeightedValue<float>)(object)LightningAmbient.SceneBrightness).Weight = Math.Min(1f, num2);
					((WeightedValue<float>)(object)LightningAmbient.SceneBrightness).Value = 1f;
					AmbientModifier val2 = capi.Ambient.CurrentModifiers["sunglow"];
					float val3 = GameMath.Clamp(1f - num2, 0f, 1f);
					((WeightedValue<float[]>)(object)val2.FogColor).Weight = Math.Min(((WeightedValue<float[]>)(object)val2.FogColor).Weight, val3);
					((WeightedValue<float[]>)(object)val2.AmbientColor).Weight = Math.Min(((WeightedValue<float[]>)(object)val2.AmbientColor).Weight, val3);
				}
				lightningTime -= dt / 1.7f;
				if (lightningTime <= 0f)
				{
					AmbientModifier obj = capi.Ambient.CurrentModifiers["sunglow"];
					((WeightedValue<float[]>)(object)obj.FogColor).Weight = ((WeightedValue<float[]>)(object)actualSunGlowAmb.FogColor).Weight;
					((WeightedValue<float[]>)(object)obj.AmbientColor).Weight = ((WeightedValue<float[]>)(object)actualSunGlowAmb.AmbientColor).Weight;
					((WeightedValue<float>)(object)LightningAmbient.CloudBrightness).Weight = 0f;
					((WeightedValue<float>)(object)LightningAmbient.FogBrightness).Weight = 0f;
					((WeightedValue<float>)(object)LightningAmbient.SceneBrightness).Weight = 0f;
				}
			}
		}

		public void OnServerTick(float dt)
		{
			for (int i = 0; i < lightningFlashes.Count; i++)
			{
				LightningFlash lightningFlash = lightningFlashes[i];
				lightningFlash.GameTick(dt);
				if (!lightningFlash.Alive)
				{
					lightningFlash.Dispose();
					lightningFlashes.RemoveAt(i);
					i--;
				}
			}
		}

		public bool LoadShader()
		{
			prog = capi.Shader.NewShaderProgram();
			prog.VertexShader = capi.Shader.NewShader((EnumShaderType)35633);
			prog.FragmentShader = capi.Shader.NewShader((EnumShaderType)35632);
			capi.Shader.RegisterFileShaderProgram("lines", prog);
			return prog.Compile();
		}

		public void genLightningFlash(Vec3d pos, int? seed = null)
		{
			LightningFlash lightningFlash = new LightningFlash(weatherSys, (ICoreAPI)(object)capi, seed, pos);
			lightningFlash.ClientInit();
			lightningFlashes.Add(lightningFlash);
		}

		public void Dispose()
		{
			foreach (LightningFlash lightningFlash in lightningFlashes)
			{
				lightningFlash.Dispose();
			}
		}
	}
	public class HailParticleProps : WeatherParticleProps
	{
		public override Vec3d Pos
		{
			get
			{
				double num = ((SimpleParticleProperties)this).MinPos.X + SimpleParticleProperties.rand.NextDouble() * SimpleParticleProperties.rand.NextDouble() * 80.0 * (double)(1 - 2 * SimpleParticleProperties.rand.Next(2));
				double num2 = ((SimpleParticleProperties)this).MinPos.Z + SimpleParticleProperties.rand.NextDouble() * SimpleParticleProperties.rand.NextDouble() * 80.0 * (double)(1 - 2 * SimpleParticleProperties.rand.Next(2));
				((SimpleParticleProperties)this).tmpPos.Set(num, ((SimpleParticleProperties)this).MinPos.Y + ((SimpleParticleProperties)this).AddPos.Y * SimpleParticleProperties.rand.NextDouble(), num2);
				int num3 = (int)(((SimpleParticleProperties)this).tmpPos.X - (double)centerPos.X);
				int num4 = (int)(((SimpleParticleProperties)this).tmpPos.Z - (double)centerPos.Z);
				int num5 = GameMath.Clamp(num3 / 4 + 8, 0, 15);
				int num6 = GameMath.Clamp(num4 / 4 + 8, 0, 15);
				((SimpleParticleProperties)this).tmpPos.Y = Math.Max(((SimpleParticleProperties)this).tmpPos.Y, lowResRainHeightMap[num5, num6] + 3);
				return ((SimpleParticleProperties)this).tmpPos;
			}
		}
	}
	public class WeatherParticleProps : SimpleParticleProperties
	{
		public int[,] lowResRainHeightMap;

		public BlockPos centerPos;

		public override Vec3d Pos
		{
			get
			{
				base.tmpPos.Set(base.MinPos.X + base.AddPos.X * SimpleParticleProperties.rand.NextDouble(), base.MinPos.Y + base.AddPos.Y * SimpleParticleProperties.rand.NextDouble(), base.MinPos.Z + base.AddPos.Z * SimpleParticleProperties.rand.NextDouble());
				int num = (int)(base.tmpPos.X - (double)centerPos.X);
				int num2 = (int)(base.tmpPos.Z - (double)centerPos.Z);
				int num3 = GameMath.Clamp(num / 4 + 8, 0, 15);
				int num4 = GameMath.Clamp(num2 / 4 + 8, 0, 15);
				base.tmpPos.Y = Math.Max(base.tmpPos.Y, lowResRainHeightMap[num3, num4] + 3);
				return base.tmpPos;
			}
		}
	}
	public class WeatherSimulationParticles
	{
		private WeatherSystemClient ws;

		private ICoreClientAPI capi;

		private Random rand;

		private static int[,] lowResRainHeightMap;

		private static BlockPos centerPos;

		public static int waterColor;

		public static int lowStabColor;

		public int rainParticleColor;

		public static SimpleParticleProperties splashParticles;

		public static WeatherParticleProps stormDustParticles;

		public static SimpleParticleProperties stormWaterParticles;

		public static WeatherParticleProps rainParticle;

		public static WeatherParticleProps hailParticle;

		private static WeatherParticleProps snowParticle;

		private Block lblock;

		private Vec3f parentVeloSnow = new Vec3f();

		private BlockPos tmpPos = new BlockPos();

		private Vec3d particlePos = new Vec3d();

		private AmbientModifier desertStormAmbient;

		private int spawnCount;

		private float sandFinds;

		private int dustParticlesPerTick = 30;

		private float[] sandCountByBlock;

		private float[] targetFogColor = new float[3];

		private float targetFogDensity;

		private Dictionary<int, int> indicesBySandBlockId = new Dictionary<int, int>();

		private float accum;

		protected bool suppressDesertStorm;

		private Vec3f windSpeed;

		private float windSpeedIntensity;

		static WeatherSimulationParticles()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Expected O, but got Unknown
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Expected O, but got Unknown
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Expected O, but got Unknown
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Expected O, but got Unknown
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Expected O, but got Unknown
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Expected O, but got Unknown
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Expected O, but got Unknown
			//IL_0145: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Expected O, but got Unknown
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bf: Expected O, but got Unknown
			//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Expected O, but got Unknown
			//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0204: Expected O, but got Unknown
			//IL_0204: Unknown result type (might be due to invalid IL or missing references)
			//IL_0205: Unknown result type (might be due to invalid IL or missing references)
			//IL_020f: Expected O, but got Unknown
			//IL_020f: Unknown result type (might be due to invalid IL or missing references)
			//IL_021a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0225: Unknown result type (might be due to invalid IL or missing references)
			//IL_0244: Unknown result type (might be due to invalid IL or missing references)
			//IL_024f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0256: Unknown result type (might be due to invalid IL or missing references)
			//IL_025d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0268: Unknown result type (might be due to invalid IL or missing references)
			//IL_0278: Unknown result type (might be due to invalid IL or missing references)
			//IL_0282: Expected O, but got Unknown
			//IL_0282: Unknown result type (might be due to invalid IL or missing references)
			//IL_0292: Unknown result type (might be due to invalid IL or missing references)
			//IL_029c: Expected O, but got Unknown
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02be: Expected O, but got Unknown
			//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ce: Expected O, but got Unknown
			//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f4: Expected O, but got Unknown
			//IL_0357: Unknown result type (might be due to invalid IL or missing references)
			//IL_0361: Expected O, but got Unknown
			//IL_0371: Unknown result type (might be due to invalid IL or missing references)
			//IL_037b: Expected O, but got Unknown
			//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b1: Expected O, but got Unknown
			//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_03d7: Expected O, but got Unknown
			//IL_0455: Unknown result type (might be due to invalid IL or missing references)
			//IL_045f: Expected O, but got Unknown
			//IL_046f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0479: Expected O, but got Unknown
			//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_04c1: Expected O, but got Unknown
			//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_04e7: Expected O, but got Unknown
			//IL_055e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0568: Expected O, but got Unknown
			//IL_0578: Unknown result type (might be due to invalid IL or missing references)
			//IL_0582: Expected O, but got Unknown
			lowResRainHeightMap = new int[16, 16];
			centerPos = new BlockPos();
			waterColor = ColorUtil.ToRgba(230, 128, 178, 255);
			lowStabColor = ColorUtil.ToRgba(230, 207, 53, 10);
			splashParticles = new SimpleParticleProperties
			{
				MinPos = new Vec3d(),
				AddPos = new Vec3d(1.0, 0.25, 0.0),
				MinQuantity = 0f,
				AddQuantity = 3f,
				Color = ColorUtil.ToRgba(230, 128, 178, 200),
				GravityEffect = 1f,
				WithTerrainCollision = true,
				ParticleModel = (EnumParticleModel)0,
				LifeLength = 0.5f,
				MinVelocity = new Vec3f(-1f, 2f, -1f),
				AddVelocity = new Vec3f(2f, 0f, 2f),
				MinSize = 0.07f,
				MaxSize = 0.2f,
				VertexFlags = 32
			};
			WeatherParticleProps obj = new WeatherParticleProps
			{
				MinPos = new Vec3d(),
				AddPos = new Vec3d(),
				MinQuantity = 0f,
				AddQuantity = 3f,
				Color = ColorUtil.ToRgba(100, 200, 200, 200)
			};
			((SimpleParticleProperties)obj).GravityEffect = 1f;
			((SimpleParticleProperties)obj).WithTerrainCollision = true;
			((SimpleParticleProperties)obj).ParticleModel = (EnumParticleModel)0;
			((SimpleParticleProperties)obj).LifeLength = 0.5f;
			((SimpleParticleProperties)obj).MinVelocity = new Vec3f(-1f, 2f, -1f);
			((SimpleParticleProperties)obj).AddVelocity = new Vec3f(2f, 0f, 2f);
			((SimpleParticleProperties)obj).MinSize = 0.07f;
			((SimpleParticleProperties)obj).MaxSize = 0.1f;
			stormDustParticles = obj;
			stormWaterParticles = new SimpleParticleProperties
			{
				MinPos = new Vec3d(),
				AddPos = new Vec3d(),
				MinQuantity = 0f,
				AddQuantity = 3f,
				Color = ColorUtil.ToRgba(230, 128, 178, 200),
				GravityEffect = 1f,
				WithTerrainCollision = true,
				ParticleModel = (EnumParticleModel)0,
				LifeLength = 0.5f,
				MinVelocity = new Vec3f(-1f, 2f, -1f),
				AddVelocity = new Vec3f(2f, 0f, 2f),
				MinSize = 0.07f,
				MaxSize = 0.2f,
				VertexFlags = 0
			};
			WeatherParticleProps obj2 = new WeatherParticleProps
			{
				MinPos = new Vec3d(),
				AddPos = new Vec3d(60.0, 9.0, 60.0),
				MinQuantity = 300f,
				AddQuantity = 25f,
				Color = waterColor
			};
			((SimpleParticleProperties)obj2).GravityEffect = 1f;
			((SimpleParticleProperties)obj2).WithTerrainCollision = false;
			((SimpleParticleProperties)obj2).DieOnRainHeightmap = true;
			((SimpleParticleProperties)obj2).ShouldDieInLiquid = true;
			((SimpleParticleProperties)obj2).ParticleModel = (EnumParticleModel)0;
			((SimpleParticleProperties)obj2).LifeLength = 1.5f;
			((SimpleParticleProperties)obj2).MinVelocity = new Vec3f(-0.25f, -0.25f, -0.25f);
			((SimpleParticleProperties)obj2).AddVelocity = new Vec3f(0.5f, 0f, 0.5f);
			((SimpleParticleProperties)obj2).MinSize = 0.15f;
			((SimpleParticleProperties)obj2).MaxSize = 0.22f;
			((SimpleParticleProperties)obj2).VertexFlags = -2147483616;
			rainParticle = obj2;
			HailParticleProps obj3 = new HailParticleProps
			{
				MinPos = new Vec3d(),
				AddPos = new Vec3d(60.0, 0.0, 60.0),
				MinQuantity = 50f,
				AddQuantity = 25f,
				Color = ColorUtil.ToRgba(255, 255, 255, 255)
			};
			((SimpleParticleProperties)obj3).GravityEffect = 1f;
			((SimpleParticleProperties)obj3).WithTerrainCollision = true;
			((SimpleParticleProperties)obj3).DieOnRainHeightmap = false;
			((SimpleParticleProperties)obj3).ShouldDieInLiquid = false;
			((SimpleParticleProperties)obj3).ShouldSwimOnLiquid = true;
			((SimpleParticleProperties)obj3).ParticleModel = (EnumParticleModel)1;
			((SimpleParticleProperties)obj3).LifeLength = 3f;
			((SimpleParticleProperties)obj3).MinVelocity = new Vec3f(-1f, -2f, -1f);
			((SimpleParticleProperties)obj3).AddVelocity = new Vec3f(2f, 0f, 2f);
			((SimpleParticleProperties)obj3).MinSize = 0.1f;
			((SimpleParticleProperties)obj3).MaxSize = 0.14f;
			((SimpleParticleProperties)obj3).WindAffectednes = 0f;
			((SimpleParticleProperties)obj3).ParentVelocity = null;
			((SimpleParticleProperties)obj3).Bounciness = 0.3f;
			hailParticle = obj3;
			WeatherParticleProps obj4 = new WeatherParticleProps
			{
				MinPos = new Vec3d(),
				AddPos = new Vec3d(60.0, 0.0, 60.0),
				MinQuantity = 80f,
				AddQuantity = 15f,
				Color = ColorUtil.ToRgba(200, 255, 255, 255)
			};
			((SimpleParticleProperties)obj4).GravityEffect = 0.003f;
			((SimpleParticleProperties)obj4).WithTerrainCollision = true;
			((SimpleParticleProperties)obj4).DieOnRainHeightmap = false;
			((SimpleParticleProperties)obj4).ShouldDieInLiquid = false;
			((SimpleParticleProperties)obj4).ParticleModel = (EnumParticleModel)0;
			((SimpleParticleProperties)obj4).LifeLength = 5f;
			((SimpleParticleProperties)obj4).MinVelocity = new Vec3f(-3.5f, -1.25f, -0.5f);
			((SimpleParticleProperties)obj4).AddVelocity = new Vec3f(1f, 0.05f, 1f);
			((SimpleParticleProperties)obj4).MinSize = 0.1f;
			((SimpleParticleProperties)obj4).MaxSize = 0.2f;
			snowParticle = obj4;
			stormDustParticles.lowResRainHeightMap = lowResRainHeightMap;
			hailParticle.lowResRainHeightMap = lowResRainHeightMap;
			snowParticle.lowResRainHeightMap = lowResRainHeightMap;
			rainParticle.lowResRainHeightMap = lowResRainHeightMap;
			stormDustParticles.centerPos = centerPos;
			hailParticle.centerPos = centerPos;
			snowParticle.centerPos = centerPos;
			rainParticle.centerPos = centerPos;
		}

		public WeatherSimulationParticles(ICoreClientAPI capi, WeatherSystemClient ws)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Expected O, but got Unknown
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Expected O, but got Unknown
			//IL_00b7: Expected O, but got Unknown
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Expected O, but got Unknown
			this.capi = capi;
			this.ws = ws;
			rand = new Random(((IWorldAccessor)capi.World).Seed + 223123123);
			rainParticleColor = waterColor;
			desertStormAmbient = new AmbientModifier().EnsurePopulated();
			desertStormAmbient.FogDensity = new WeightedFloat();
			AmbientModifier obj = desertStormAmbient;
			WeightedFloatArray val = new WeightedFloatArray();
			((WeightedValue<float[]>)val).Value = new float[3];
			obj.FogColor = val;
			desertStormAmbient.FogMin = new WeightedFloat();
			capi.Ambient.CurrentModifiers["desertstorm"] = desertStormAmbient;
		}

		public void Initialize()
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Expected O, but got Unknown
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Expected O, but got Unknown
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Expected O, but got Unknown
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Invalid comparison between Unknown and I4
			lblock = ((IWorldAccessor)capi.World).GetBlock(new AssetLocation("water-still-7"));
			if (lblock != null)
			{
				capi.Event.RegisterAsyncParticleSpawner(new ContinousParticleSpawnTaskDelegate(asyncParticleSpawn));
				capi.Event.RegisterRenderer((IRenderer)new DummyRenderer
				{
					action = desertStormSim
				}, (EnumRenderStage)0, (string)null);
				int num = 0;
				foreach (Block block in ((IWorldAccessor)capi.World).Blocks)
				{
					if ((int)block.BlockMaterial == 3)
					{
						indicesBySandBlockId[((CollectibleObject)block).Id] = num++;
					}
				}
				sandCountByBlock = new float[indicesBySandBlockId.Count];
			}
			suppressDesertStorm = ((IWorldAccessor)capi.World).Config.GetAsBool("suppressDesertStorm", false);
		}

		private void desertStormSim(float dt)
		{
			if (suppressDesertStorm)
			{
				return;
			}
			accum += dt;
			if (accum > 2f)
			{
				int num = spawnCount;
				float num2 = sandFinds;
				float[] array = sandCountByBlock;
				if (windSpeedIntensity < 0.5f)
				{
					targetFogDensity = 0f;
				}
				if (num > 10 && num2 > 0f)
				{
					sandCountByBlock = new float[indicesBySandBlockId.Count];
					spawnCount = 0;
					sandFinds = 0f;
					_ = ws.BlendedWeatherData;
					BlockPos asBlockPos = ((Entity)((IPlayer)capi.World.Player).Entity).Pos.AsBlockPos;
					ClimateCondition climateAt = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(asBlockPos, (EnumGetClimateMode)1, 0.0);
					float num3 = (float)((IWorldAccessor)capi.World).BlockAccessor.GetLightLevel(asBlockPos, (EnumLightLevelType)1) / 22f;
					float num4 = 2f * Math.Max(0f, windSpeedIntensity - 0.65f) * (1f - climateAt.WorldgenRainfall) * (1f - climateAt.Rainfall);
					BlockPos asBlockPos2 = ((Entity)((IPlayer)capi.World.Player).Entity).Pos.AsBlockPos;
					targetFogColor[0] = (targetFogColor[1] = (targetFogColor[2] = 0f));
					foreach (KeyValuePair<int, int> item in indicesBySandBlockId)
					{
						float num5 = array[item.Value] / num2;
						double[] array2 = ColorUtil.ToRGBADoubles(((IWorldAccessor)capi.World).GetBlock(item.Key).GetColor(capi, asBlockPos2));
						targetFogColor[0] += (float)array2[2] * num5;
						targetFogColor[1] += (float)array2[1] * num5;
						targetFogColor[2] += (float)array2[0] * num5;
					}
					float num6 = (float)((double)num2 / 30.0 / (double)num) * num4 * num3;
					targetFogDensity = num6;
				}
				accum = 0f;
			}
			float num7 = dt / 3f;
			targetFogDensity = Math.Max(0f, targetFogDensity - 2f * WeatherSystemClient.CurrentEnvironmentWetness4h);
			((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Value[0] += (targetFogColor[0] - ((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Value[0]) * num7;
			((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Value[1] += (targetFogColor[1] - ((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Value[1]) * num7;
			((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Value[2] += (targetFogColor[2] - ((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Value[2]) * num7;
			WeightedFloat fogDensity = desertStormAmbient.FogDensity;
			((WeightedValue<float>)(object)fogDensity).Value = ((WeightedValue<float>)(object)fogDensity).Value + ((float)Math.Pow(targetFogDensity, 1.2000000476837158) - ((WeightedValue<float>)(object)desertStormAmbient.FogDensity).Value) * num7;
			WeightedFloat fogDensity2 = desertStormAmbient.FogDensity;
			((WeightedValue<float>)(object)fogDensity2).Weight = ((WeightedValue<float>)(object)fogDensity2).Weight + (targetFogDensity - ((WeightedValue<float>)(object)desertStormAmbient.FogDensity).Weight) * num7;
			WeightedFloatArray fogColor = desertStormAmbient.FogColor;
			((WeightedValue<float[]>)(object)fogColor).Weight = ((WeightedValue<float[]>)(object)fogColor).Weight + (Math.Min(1f, 2f * targetFogDensity) - ((WeightedValue<float[]>)(object)desertStormAmbient.FogColor).Weight) * num7;
		}

		private bool asyncParticleSpawn(float dt, IAsyncParticleManager manager)
		{
			WeatherDataSnapshot blendedWeatherData = ws.BlendedWeatherData;
			ClimateCondition clientClimateCond = ws.clientClimateCond;
			if (clientClimateCond == null || !ws.playerChunkLoaded)
			{
				return true;
			}
			EntityPos pos = ((Entity)((IPlayer)capi.World.Player).Entity).Pos;
			float rainfall = clientClimateCond.Rainfall;
			float plevel = rainfall * (float)capi.Settings.Int["particleLevel"] / 100f;
			float dryness = GameMath.Clamp(1f - rainfall, 0f, 1f);
			tmpPos.Set((int)pos.X, (int)pos.Y, (int)pos.Z);
			rainfall = Math.Max(0f, rainfall - (float)Math.Max(0.0, (pos.Y - (double)((IWorldAccessor)capi.World).SeaLevel - 5000.0) / 10000.0));
			EnumPrecipitationType enumPrecipitationType = blendedWeatherData.BlendedPrecType;
			if (enumPrecipitationType == EnumPrecipitationType.Auto)
			{
				enumPrecipitationType = ((clientClimateCond.Temperature < blendedWeatherData.snowThresholdTemp) ? EnumPrecipitationType.Snow : EnumPrecipitationType.Rain);
			}
			int rainMapHeightAt = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)particlePos.X, (int)particlePos.Z);
			particlePos.Set(((Entity)((IPlayer)capi.World.Player).Entity).Pos.X, (double)rainMapHeightAt, ((Entity)((IPlayer)capi.World.Player).Entity).Pos.Z);
			int num = capi.World.ApplyColorMapOnRgba(lblock.ClimateColorMapResolved, lblock.SeasonColorMapResolved, -1, (int)particlePos.X, (int)particlePos.Y, (int)particlePos.Z, false);
			byte[] array = ColorUtil.ToBGRABytes(num);
			num = ColorUtil.ToRgba(94, (int)array[0], (int)array[1], (int)array[2]);
			centerPos.Set((int)particlePos.X, 0, (int)particlePos.Z);
			for (int i = 0; i < 16; i++)
			{
				int num2 = (i - 8) * 4;
				for (int j = 0; j < 16; j++)
				{
					int num3 = (j - 8) * 4;
					lowResRainHeightMap[i, j] = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt(centerPos.X + num2, centerPos.Z + num3);
				}
			}
			windSpeed = ((IWorldAccessor)capi.World).BlockAccessor.GetWindSpeedAt(pos.XYZ).ToVec3f();
			windSpeedIntensity = windSpeed.Length();
			parentVeloSnow.X = (0f - Math.Max(0f, windSpeed.X / 2f - 0.15f)) * 2f;
			parentVeloSnow.Y = 0f;
			parentVeloSnow.Z = (0f - Math.Max(0f, windSpeed.Z / 2f - 0.15f)) * 2f;
			if (windSpeedIntensity > 0.5f)
			{
				SpawnDustParticles(manager, blendedWeatherData, pos, dryness, num);
			}
			else
			{
				spawnCount = -1;
			}
			particlePos.Y = ((Entity)((IPlayer)capi.World.Player).Entity).Pos.Y;
			if ((double)rainfall <= 0.02)
			{
				return true;
			}
			switch (enumPrecipitationType)
			{
			case EnumPrecipitationType.Hail:
				SpawnHailParticles(manager, blendedWeatherData, clientClimateCond, pos, plevel);
				return true;
			case EnumPrecipitationType.Rain:
				SpawnRainParticles(manager, blendedWeatherData, clientClimateCond, pos, plevel, num);
				break;
			}
			if (enumPrecipitationType == EnumPrecipitationType.Snow)
			{
				SpawnSnowParticles(manager, blendedWeatherData, clientClimateCond, pos, plevel);
			}
			return true;
		}

		private void SpawnDustParticles(IAsyncParticleManager manager, WeatherDataSnapshot weatherData, EntityPos plrPos, float dryness, int onwaterSplashParticleColor)
		{
			//IL_035e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0364: Invalid comparison between Unknown and I4
			//IL_0399: Unknown result type (might be due to invalid IL or missing references)
			//IL_039f: Invalid comparison between Unknown and I4
			//IL_0368: Unknown result type (might be due to invalid IL or missing references)
			//IL_036f: Invalid comparison between Unknown and I4
			//IL_038c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0392: Invalid comparison between Unknown and I4
			float num = (float)(plrPos.Motion.X * 40.0) - 50f * windSpeed.X;
			float num2 = (float)(plrPos.Motion.Y * 40.0);
			float num3 = (float)(plrPos.Motion.Z * 40.0) - 50f * windSpeed.Z;
			double num4 = 40.0;
			float num5 = 1f - targetFogDensity;
			num4 *= (double)num5;
			float num6 = windSpeed.Length();
			((SimpleParticleProperties)stormDustParticles).MinPos.Set(particlePos.X - num4 + (double)num, particlePos.Y + 20.0 + (double)(5f * num6) + (double)num2, particlePos.Z - num4 + (double)num3);
			((SimpleParticleProperties)stormDustParticles).AddPos.Set(2.0 * num4, -30.0, 2.0 * num4);
			((SimpleParticleProperties)stormDustParticles).GravityEffect = 0.1f;
			((SimpleParticleProperties)stormDustParticles).ParticleModel = (EnumParticleModel)0;
			((SimpleParticleProperties)stormDustParticles).LifeLength = 1f;
			((SimpleParticleProperties)stormDustParticles).DieOnRainHeightmap = true;
			((SimpleParticleProperties)stormDustParticles).WindAffectednes = 8f;
			((SimpleParticleProperties)stormDustParticles).MinQuantity = 0f;
			((SimpleParticleProperties)stormDustParticles).AddQuantity = 8f * (num6 - 0.5f) * dryness;
			((SimpleParticleProperties)stormDustParticles).MinSize = 0.2f;
			((SimpleParticleProperties)stormDustParticles).MaxSize = 0.7f;
			((SimpleParticleProperties)stormDustParticles).MinVelocity.Set(-0.025f + 12f * windSpeed.X, 0f, -0.025f + 12f * windSpeed.Z).Mul(3f);
			((SimpleParticleProperties)stormDustParticles).AddVelocity.Set(0.05f + 6f * windSpeed.X, -0.25f, 0.05f + 6f * windSpeed.Z).Mul(3f);
			float num7 = Math.Max(1f, num6 * 3f);
			int num8 = (int)((float)dustParticlesPerTick * num7);
			try
			{
				for (int i = 0; i < num8; i++)
				{
					double num9 = particlePos.X + (double)num + rand.NextDouble() * rand.NextDouble() * 60.0 * (double)(1 - 2 * rand.Next(2));
					double num10 = particlePos.Z + (double)num3 + rand.NextDouble() * rand.NextDouble() * 60.0 * (double)(1 - 2 * rand.Next(2));
					int rainMapHeightAt = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num9, (int)num10);
					Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num9, rainMapHeightAt, (int)num10, 0);
					if (blockRaw.BlockId != 0 && ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num9, rainMapHeightAt, (int)num10, 2).BlockId == 0 && ((int)blockRaw.BlockMaterial == 3 || (int)blockRaw.BlockMaterial == 9 || (!(rand.NextDouble() < 0.699999988079071) && (int)blockRaw.RenderPass != 5)))
					{
						if ((int)blockRaw.BlockMaterial == 3)
						{
							sandFinds += 1f / num7;
							sandCountByBlock[indicesBySandBlockId[((CollectibleObject)blockRaw).Id]] += 1f / num7;
						}
						if (!(Math.Abs((double)rainMapHeightAt - particlePos.Y) > 15.0))
						{
							tmpPos.Set((int)num9, rainMapHeightAt, (int)num10);
							((SimpleParticleProperties)stormDustParticles).Color = ColorUtil.ReverseColorBytes(blockRaw.GetColor(capi, tmpPos));
							WeatherParticleProps weatherParticleProps = stormDustParticles;
							((SimpleParticleProperties)weatherParticleProps).Color = ((SimpleParticleProperties)weatherParticleProps).Color | -16777216;
							manager.Spawn((IParticlePropertiesProvider)(object)stormDustParticles);
						}
					}
				}
			}
			catch (Exception)
			{
			}
			spawnCount++;
			if (!(num6 > 0.85f))
			{
				return;
			}
			stormWaterParticles.AddVelocity.Y = 1.5f;
			stormWaterParticles.LifeLength = 0.17f;
			stormWaterParticles.WindAffected = true;
			stormWaterParticles.WindAffectednes = 1f;
			stormWaterParticles.GravityEffect = 0.4f;
			stormWaterParticles.MinVelocity.Set(-0.025f + 4f * windSpeed.X, 1.5f, -0.025f + 4f * windSpeed.Z);
			stormWaterParticles.Color = onwaterSplashParticleColor;
			stormWaterParticles.MinQuantity = 1f;
			stormWaterParticles.AddQuantity = 5f;
			stormWaterParticles.ShouldDieInLiquid = false;
			splashParticles.WindAffected = true;
			splashParticles.WindAffectednes = 1f;
			for (int j = 0; j < 20; j++)
			{
				double num11 = particlePos.X + rand.NextDouble() * rand.NextDouble() * 40.0 * (double)(1 - 2 * rand.Next(2));
				double num12 = particlePos.Z + rand.NextDouble() * rand.NextDouble() * 40.0 * (double)(1 - 2 * rand.Next(2));
				int rainMapHeightAt2 = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num11, (int)num12);
				Block blockRaw2 = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num11, rainMapHeightAt2, (int)num12, 2);
				if (((CollectibleObject)blockRaw2).IsLiquid())
				{
					stormWaterParticles.MinPos.Set(num11, (double)((float)rainMapHeightAt2 + ((CollectibleObject)blockRaw2).TopMiddlePos.Y), num12);
					stormWaterParticles.ParticleModel = (EnumParticleModel)1;
					stormWaterParticles.MinSize = 0.4f;
					manager.Spawn((IParticlePropertiesProvider)(object)stormWaterParticles);
					splashParticles.MinPos.Set(num11, (double)((float)rainMapHeightAt2 + ((CollectibleObject)blockRaw2).TopMiddlePos.Y - 0.125f), num12);
					splashParticles.MinVelocity.X = windSpeed.X * 1.5f;
					splashParticles.AddVelocity.Y = 1.5f;
					splashParticles.MinVelocity.Z = windSpeed.Z * 1.5f;
					splashParticles.LifeLength = 0.17f;
					splashParticles.Color = onwaterSplashParticleColor;
					manager.Spawn((IParticlePropertiesProvider)(object)splashParticles);
				}
			}
		}

		private void SpawnHailParticles(IAsyncParticleManager manager, WeatherDataSnapshot weatherData, ClimateCondition conds, EntityPos plrPos, float plevel)
		{
			float num = (float)(plrPos.Motion.X * 40.0) - 4f * windSpeed.X;
			float num2 = (float)(plrPos.Motion.Y * 40.0);
			float num3 = (float)(plrPos.Motion.Z * 40.0) - 4f * windSpeed.Z;
			((SimpleParticleProperties)hailParticle).MinPos.Set(particlePos.X + (double)num, particlePos.Y + 15.0 + (double)num2, particlePos.Z + (double)num3);
			((SimpleParticleProperties)hailParticle).MinSize = 0.3f * (0.5f + conds.Rainfall);
			((SimpleParticleProperties)hailParticle).MaxSize = 1f * (0.5f + conds.Rainfall);
			((SimpleParticleProperties)hailParticle).Color = ColorUtil.ToRgba(220, 210, 230, 255);
			((SimpleParticleProperties)hailParticle).MinQuantity = 100f * plevel;
			((SimpleParticleProperties)hailParticle).AddQuantity = 25f * plevel;
			((SimpleParticleProperties)hailParticle).MinVelocity.Set(-0.025f + 7.5f * windSpeed.X, -5f, -0.025f + 7.5f * windSpeed.Z);
			((SimpleParticleProperties)hailParticle).AddVelocity.Set(0.05f + 7.5f * windSpeed.X, 0.05f, 0.05f + 7.5f * windSpeed.Z);
			manager.Spawn((IParticlePropertiesProvider)(object)hailParticle);
		}

		private void SpawnRainParticles(IAsyncParticleManager manager, WeatherDataSnapshot weatherData, ClimateCondition conds, EntityPos plrPos, float plevel, int onwaterSplashParticleColor)
		{
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Expected O, but got Unknown
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Expected O, but got Unknown
			float num = (float)(plrPos.Motion.X * 80.0);
			float num2 = (float)(plrPos.Motion.Y * 80.0);
			float num3 = (float)(plrPos.Motion.Z * 80.0);
			((SimpleParticleProperties)rainParticle).MinPos.Set(particlePos.X - 30.0 + (double)num, particlePos.Y + 15.0 + (double)num2, particlePos.Z - 30.0 + (double)num3);
			((SimpleParticleProperties)rainParticle).WithTerrainCollision = false;
			((SimpleParticleProperties)rainParticle).MinQuantity = 1000f * plevel;
			((SimpleParticleProperties)rainParticle).LifeLength = 1f;
			((SimpleParticleProperties)rainParticle).AddQuantity = 25f * plevel;
			((SimpleParticleProperties)rainParticle).MinSize = 0.15f * (0.5f + conds.Rainfall);
			((SimpleParticleProperties)rainParticle).MaxSize = 0.22f * (0.5f + conds.Rainfall);
			((SimpleParticleProperties)rainParticle).Color = rainParticleColor;
			((SimpleParticleProperties)rainParticle).MinVelocity.Set(-0.025f + 8f * windSpeed.X, -10f, -0.025f + 8f * windSpeed.Z);
			((SimpleParticleProperties)rainParticle).AddVelocity.Set(0.05f + 8f * windSpeed.X, 0.05f, 0.05f + 8f * windSpeed.Z);
			manager.Spawn((IParticlePropertiesProvider)(object)rainParticle);
			splashParticles.MinVelocity = new Vec3f(-1f, 3f, -1f);
			splashParticles.AddVelocity = new Vec3f(2f, 0f, 2f);
			splashParticles.LifeLength = 0.1f;
			splashParticles.MinSize = 0.07f * (0.5f + 0.65f * conds.Rainfall);
			splashParticles.MaxSize = 0.2f * (0.5f + 0.65f * conds.Rainfall);
			splashParticles.ShouldSwimOnLiquid = true;
			splashParticles.Color = rainParticleColor;
			float num4 = 100f * plevel;
			for (int i = 0; (float)i < num4; i++)
			{
				double num5 = particlePos.X + rand.NextDouble() * rand.NextDouble() * 60.0 * (double)(1 - 2 * rand.Next(2));
				double num6 = particlePos.Z + rand.NextDouble() * rand.NextDouble() * 60.0 * (double)(1 - 2 * rand.Next(2));
				int rainMapHeightAt = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt((int)num5, (int)num6);
				Block blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num5, rainMapHeightAt, (int)num6, 2);
				if (((CollectibleObject)blockRaw).IsLiquid())
				{
					splashParticles.MinPos.Set(num5, (double)((float)rainMapHeightAt + ((CollectibleObject)blockRaw).TopMiddlePos.Y - 0.125f), num6);
					splashParticles.AddVelocity.Y = 1.5f;
					splashParticles.LifeLength = 0.17f;
					splashParticles.Color = onwaterSplashParticleColor;
				}
				else
				{
					if (blockRaw.BlockId == 0)
					{
						blockRaw = ((IWorldAccessor)capi.World).BlockAccessor.GetBlockRaw((int)num5, rainMapHeightAt, (int)num6, 0);
					}
					double num7 = 0.75 + 0.25 * rand.NextDouble();
					int num8 = 230 - rand.Next(100);
					int num9 = (int)((double)((rainParticleColor >> 16) & 0xFF) * num7);
					int num10 = (int)((double)((rainParticleColor >> 8) & 0xFF) * num7);
					int num11 = (int)((double)(rainParticleColor & 0xFF) * num7);
					splashParticles.Color = (num8 << 24) | (num9 << 16) | (num10 << 8) | num11;
					splashParticles.AddVelocity.Y = 0f;
					splashParticles.LifeLength = 0.1f;
					splashParticles.MinPos.Set(num5, (double)((float)rainMapHeightAt + ((CollectibleObject)blockRaw).TopMiddlePos.Y) + 0.05, num6);
				}
				manager.Spawn((IParticlePropertiesProvider)(object)splashParticles);
			}
		}

		private void SpawnSnowParticles(IAsyncParticleManager manager, WeatherDataSnapshot weatherData, ClimateCondition conds, EntityPos plrPos, float plevel)
		{
			((SimpleParticleProperties)snowParticle).WindAffected = true;
			((SimpleParticleProperties)snowParticle).WindAffectednes = 1f;
			float num = 2.5f * GameMath.Clamp(ws.clientClimateCond.Temperature + 1f, 0f, 4f) / 4f;
			float num2 = (float)plrPos.Motion.X * 60f;
			float num3 = (float)plrPos.Motion.Z * 60f;
			float num4 = (float)Math.Pow(num2 * num2 + num3 * num3, 0.25);
			float num5 = num2 - Math.Max(0f, (30f - 9f * num) * windSpeed.X - 5f * num4);
			float num6 = (float)(plrPos.Motion.Y * 60.0);
			float num7 = num3 - Math.Max(0f, (30f - 9f * num) * windSpeed.Z - 5f * num4);
			((SimpleParticleProperties)snowParticle).MinVelocity.Set(-0.5f + 10f * windSpeed.X, -1f, -0.5f + 10f * windSpeed.Z);
			((SimpleParticleProperties)snowParticle).AddVelocity.Set(1f + 10f * windSpeed.X, 0.05f, 1f + 10f * windSpeed.Z);
			((SimpleParticleProperties)snowParticle).Color = ColorUtil.ToRgba(255, 255, 255, 255);
			((SimpleParticleProperties)snowParticle).MinQuantity = 100f * plevel * (1f + num / 3f);
			((SimpleParticleProperties)snowParticle).AddQuantity = 25f * plevel * (1f + num / 3f);
			((SimpleParticleProperties)snowParticle).ParentVelocity = parentVeloSnow;
			((SimpleParticleProperties)snowParticle).ShouldDieInLiquid = true;
			((SimpleParticleProperties)snowParticle).LifeLength = Math.Max(1f, 4f - num - windSpeedIntensity);
			((SimpleParticleProperties)snowParticle).Color = ColorUtil.ColorOverlay(ColorUtil.ToRgba(255, 255, 255, 255), ((SimpleParticleProperties)rainParticle).Color, num / 4f);
			((SimpleParticleProperties)snowParticle).GravityEffect = 0.005f * (1f + 20f * num);
			((SimpleParticleProperties)snowParticle).MinSize = 0.1f * conds.Rainfall;
			((SimpleParticleProperties)snowParticle).MaxSize = 0.3f * conds.Rainfall / (1f + num);
			float num8 = 20f;
			float num9 = 23f + windSpeedIntensity * 5f;
			num6 -= Math.Min(10f, num4) + windSpeedIntensity * 5f;
			((SimpleParticleProperties)snowParticle).MinVelocity.Y = -2f;
			((SimpleParticleProperties)snowParticle).MinPos.Set(particlePos.X - (double)num8 + (double)num5, particlePos.Y + (double)num9 + (double)num6, particlePos.Z - (double)num8 + (double)num7);
			((SimpleParticleProperties)snowParticle).AddPos.Set((double)(2f * num8 + num5), (double)(-0.66f * num9 + num6), (double)(2f * num8 + num7));
			manager.Spawn((IParticlePropertiesProvider)(object)snowParticle);
		}
	}
	public class WeatherSimulationRegion
	{
		public bool Transitioning;

		public float TransitionDelay;

		public WeatherPattern NewWePattern;

		public WeatherPattern OldWePattern;

		public RingArray<SnowAccumSnapshot> SnowAccumSnapshots;

		public static object snowAccumSnapshotLock = new object();

		public WindPattern CurWindPattern;

		public WeatherEvent CurWeatherEvent;

		public float Weight;

		public double LastUpdateTotalHours;

		public LCGRandom Rand;

		public int regionX;

		public int regionZ;

		public int cloudTilebasePosX;

		public int cloudTilebasePosZ;

		public WeatherDataSnapshot weatherData = new WeatherDataSnapshot();

		public bool IsInitialized;

		public bool IsDummy;

		public WeatherPattern[] WeatherPatterns;

		public WindPattern[] WindPatterns;

		public WeatherEvent[] WeatherEvents;

		protected WeatherSystemBase ws;

		protected WeatherSystemServer wsServer;

		protected ICoreClientAPI capi;

		protected float quarterSecAccum;

		protected BlockPos regionCenterPos;

		protected Vec3d tmpVecPos = new Vec3d();

		public IMapRegion MapRegion;

		public static int snowAccumResolution = 2;

		public WeatherSimulationRegion(WeatherSystemBase ws, int regionX, int regionZ)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Expected O, but got Unknown
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Expected O, but got Unknown
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Invalid comparison between Unknown and I4
			this.ws = ws;
			this.regionX = regionX;
			this.regionZ = regionZ;
			SnowAccumSnapshots = new RingArray<SnowAccumSnapshot>((int)((float)ws.api.World.Calendar.DaysPerYear * ws.api.World.Calendar.HoursPerDay) + 1);
			int regionSize = ws.api.World.BlockAccessor.RegionSize;
			LastUpdateTotalHours = ws.api.World.Calendar.TotalHours;
			cloudTilebasePosX = regionX * regionSize / ws.CloudTileSize;
			cloudTilebasePosZ = regionZ * regionSize / ws.CloudTileSize;
			regionCenterPos = new BlockPos(regionX * regionSize + regionSize / 2, 0, regionZ * regionSize + regionSize / 2);
			Rand = new LCGRandom((long)ws.api.World.Seed);
			Rand.InitPositionSeed(regionX / 3, regionZ / 3);
			weatherData.Ambient = new AmbientModifier().EnsurePopulated();
			if ((int)ws.api.Side == 2)
			{
				ref ICoreClientAPI reference = ref capi;
				ICoreAPI api = ws.api;
				reference = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
				weatherData.Ambient.FogColor = capi.Ambient.Base.FogColor.Clone();
			}
			else
			{
				wsServer = ws as WeatherSystemServer;
			}
			ReloadPatterns(ws.api.World.Seed);
		}

		internal void ReloadPatterns(int seed)
		{
			WeatherPatterns = new WeatherPattern[ws.WeatherConfigs.Length];
			for (int i = 0; i < ws.WeatherConfigs.Length; i++)
			{
				WeatherPatterns[i] = new WeatherPattern(ws, ws.WeatherConfigs[i], Rand, cloudTilebasePosX, cloudTilebasePosZ);
				WeatherPatterns[i].State.Index = i;
			}
			WindPatterns = new WindPattern[ws.WindConfigs.Length];
			for (int j = 0; j < ws.WindConfigs.Length; j++)
			{
				WindPatterns[j] = new WindPattern(ws.api, ws.WindConfigs[j], j, Rand, seed);
			}
			WeatherEvents = new WeatherEvent[ws.WeatherEventConfigs.Length];
			for (int k = 0; k < ws.WeatherEventConfigs.Length; k++)
			{
				WeatherEvents[k] = new WeatherEvent(ws.api, ws.WeatherEventConfigs[k], k, Rand, seed - 876);
			}
		}

		internal void LoadRandomPattern()
		{
			NewWePattern = RandomWeatherPattern();
			OldWePattern = RandomWeatherPattern();
			NewWePattern.OnBeginUse();
			OldWePattern.OnBeginUse();
			CurWindPattern = WindPatterns[Rand.NextInt(WindPatterns.Length)];
			CurWindPattern.OnBeginUse();
			CurWeatherEvent = RandomWeatherEvent();
			CurWeatherEvent.OnBeginUse();
			Weight = 1f;
			wsServer?.SendWeatherStateUpdate(new WeatherState
			{
				RegionX = regionX,
				RegionZ = regionZ,
				NewPattern = NewWePattern.State,
				OldPattern = OldWePattern.State,
				WindPattern = CurWindPattern.State,
				WeatherEvent = CurWeatherEvent?.State,
				TransitionDelay = 0f,
				Transitioning = false,
				Weight = Weight,
				updateInstant = false,
				LcgCurrentSeed = Rand.currentSeed,
				LcgMapGenSeed = Rand.mapGenSeed,
				LcgWorldSeed = Rand.worldSeed
			});
		}

		internal void Initialize()
		{
			for (int i = 0; i < WeatherPatterns.Length; i++)
			{
				WeatherPatterns[i].Initialize(i, ws.api.World.Seed);
			}
			NewWePattern = WeatherPatterns[0];
			OldWePattern = WeatherPatterns[0];
			CurWindPattern = WindPatterns[0];
			CurWeatherEvent = WeatherEvents[0];
			IsInitialized = true;
		}

		public void UpdateWeatherData()
		{
			weatherData.SetAmbientLerped(OldWePattern, NewWePattern, Weight, (capi == null) ? 0f : ((WeightedValue<float>)(object)capi.Ambient.Base.FogDensity).Value);
		}

		public void UpdateSnowAccumulation(int count)
		{
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Expected O, but got Unknown
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Expected O, but got Unknown
			SnowAccumSnapshot[] array = new SnowAccumSnapshot[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = new SnowAccumSnapshot
				{
					TotalHours = LastUpdateTotalHours + (double)i,
					SnowAccumulationByRegionCorner = new FloatDataMap3D(snowAccumResolution, snowAccumResolution, snowAccumResolution)
				};
			}
			BlockPos val = new BlockPos();
			int regionSize = ws.api.World.BlockAccessor.RegionSize;
			for (int j = 0; j < snowAccumResolution; j++)
			{
				for (int k = 0; k < snowAccumResolution; k++)
				{
					for (int l = 0; l < snowAccumResolution; l++)
					{
						int num = ((k == 0) ? ws.api.World.SeaLevel : (ws.api.World.BlockAccessor.MapSizeY - 1));
						val.Set(regionX * regionSize + j * (regionSize - 1), num, regionZ * regionSize + l * (regionSize - 1));
						ClimateCondition val2 = null;
						for (int m = 0; m < array.Length; m++)
						{
							double num2 = (LastUpdateTotalHours + (double)m + 0.5) / (double)ws.api.World.Calendar.HoursPerDay;
							if (val2 == null)
							{
								val2 = ws.api.World.BlockAccessor.GetClimateAt(val, (EnumGetClimateMode)4, num2);
								if (val2 == null)
								{
									return;
								}
							}
							else
							{
								ws.api.World.BlockAccessor.GetClimateAt(val, val2, (EnumGetClimateMode)4, num2);
							}
							SnowAccumSnapshot snowAccumSnapshot = array[m];
							if (val2.Temperature > 1.5f || ((double)val2.Rainfall < 0.05 && val2.Temperature > 0f))
							{
								snowAccumSnapshot.SnowAccumulationByRegionCorner.AddValue(j, k, l, (0f - val2.Temperature) / 15f);
							}
							else
							{
								snowAccumSnapshot.SnowAccumulationByRegionCorner.AddValue(j, k, l, val2.Rainfall / 3f);
							}
						}
					}
				}
			}
			lock (snowAccumSnapshotLock)
			{
				foreach (SnowAccumSnapshot snowAccumSnapshot2 in array)
				{
					SnowAccumSnapshots.Add(snowAccumSnapshot2);
					snowAccumSnapshot2.Checks++;
				}
			}
			LastUpdateTotalHours += count;
		}

		public void TickEvery25ms(float dt)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			//IL_020a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0210: Invalid comparison between Unknown and I4
			//IL_027e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Invalid comparison between Unknown and I4
			if ((int)ws.api.Side == 2)
			{
				clientUpdate(dt);
			}
			else
			{
				int num = (int)(ws.api.World.Calendar.TotalHours - LastUpdateTotalHours);
				if (num > 0)
				{
					UpdateSnowAccumulation(Math.Min(num, 480));
				}
				ws.api.World.FrameProfiler.Mark("snowaccum");
				Random rand = ws.api.World.Rand;
				float lightningMinTemp = CurWeatherEvent.State.LightningMinTemp;
				if (rand.NextDouble() < (double)CurWeatherEvent.State.LightningRate)
				{
					ClimateCondition climateAt = ws.api.World.BlockAccessor.GetClimateAt(regionCenterPos, (EnumGetClimateMode)1, 0.0);
					if (climateAt.Temperature >= lightningMinTemp && (double)climateAt.RainCloudOverlay > 0.15)
					{
						Vec3d pos = regionCenterPos.ToVec3d().Add(-200.0 + rand.NextDouble() * 400.0, (double)ws.api.World.SeaLevel, -200.0 + rand.NextDouble() * 400.0);
						ws.SpawnLightningFlash(pos);
					}
					ws.api.World.FrameProfiler.Mark("lightningcheck");
				}
			}
			if (Transitioning)
			{
				float num2 = ws.api.World.Calendar.SpeedOfTime / 60f;
				Weight += dt / TransitionDelay * num2;
				if (Weight > 1f)
				{
					Transitioning = false;
					Weight = 1f;
				}
			}
			else if (ws.autoChangePatterns && (int)ws.api.Side == 1 && ws.api.World.Calendar.TotalHours > NewWePattern.State.ActiveUntilTotalHours)
			{
				TriggerTransition();
				ws.api.World.FrameProfiler.Mark("weathertransition");
			}
			if (ws.autoChangePatterns && (int)ws.api.Side == 1)
			{
				bool flag = false;
				if (ws.api.World.Calendar.TotalHours > CurWindPattern.State.ActiveUntilTotalHours)
				{
					CurWindPattern = WindPatterns[Rand.NextInt(WindPatterns.Length)];
					CurWindPattern.OnBeginUse();
					flag = true;
				}
				if (ws.api.World.Calendar.TotalHours > CurWeatherEvent.State.ActiveUntilTotalHours || CurWeatherEvent.ShouldStop(weatherData.climateCond.Rainfall, weatherData.climateCond.Temperature))
				{
					selectRandomWeatherEvent();
					flag = true;
				}
				if (flag)
				{
					sendWeatherUpdatePacket();
				}
				ws.api.World.FrameProfiler.Mark("weatherchange");
			}
			NewWePattern.Update(dt);
			OldWePattern.Update(dt);
			CurWindPattern.Update(dt);
			CurWeatherEvent.Update(dt);
			float x = weatherData.curWindSpeed.X;
			float num3 = (float)GetWindSpeed(ws.api.World.SeaLevel);
			x += GameMath.Clamp((num3 - x) * dt, -0.001f, 0.001f);
			weatherData.curWindSpeed.X = x;
			quarterSecAccum += dt;
			if (quarterSecAccum > 0.25f)
			{
				regionCenterPos.Y = ws.api.World.BlockAccessor.GetRainMapHeightAt(regionCenterPos);
				if (regionCenterPos.Y == 0)
				{
					regionCenterPos.Y = ws.api.World.SeaLevel;
				}
				ClimateCondition climateAt2 = ws.api.World.BlockAccessor.GetClimateAt(regionCenterPos, (EnumGetClimateMode)1, 0.0);
				if (climateAt2 != null)
				{
					weatherData.climateCond = climateAt2;
				}
				quarterSecAccum = 0f;
			}
			weatherData.BlendedPrecType = CurWeatherEvent.State.PrecType;
		}

		public void selectRandomWeatherEvent()
		{
			CurWeatherEvent = RandomWeatherEvent();
			CurWeatherEvent.OnBeginUse();
		}

		public void sendWeatherUpdatePacket()
		{
			wsServer.SendWeatherStateUpdate(new WeatherState
			{
				RegionX = regionX,
				RegionZ = regionZ,
				NewPattern = NewWePattern.State,
				OldPattern = OldWePattern.State,
				WindPattern = CurWindPattern.State,
				WeatherEvent = CurWeatherEvent?.State,
				TransitionDelay = TransitionDelay,
				Transitioning = Transitioning,
				Weight = Weight,
				LcgCurrentSeed = Rand.currentSeed,
				LcgMapGenSeed = Rand.mapGenSeed,
				LcgWorldSeed = Rand.worldSeed
			});
		}

		private void clientUpdate(float dt)
		{
			ICoreAPI api = ws.api;
			EntityPlayer entity = ((IPlayer)((ICoreClientAPI)((api is ICoreClientAPI) ? api : null)).World.Player).Entity;
			regionCenterPos.Y = (int)((Entity)entity).Pos.Y;
			float nearThunderRate = CurWeatherEvent.State.NearThunderRate;
			float distantThunderRate = CurWeatherEvent.State.DistantThunderRate;
			float lightningMinTemp = CurWeatherEvent.State.LightningMinTemp;
			weatherData.nearLightningRate += GameMath.Clamp((nearThunderRate - weatherData.nearLightningRate) * dt, -0.001f, 0.001f);
			weatherData.distantLightningRate += GameMath.Clamp((distantThunderRate - weatherData.distantLightningRate) * dt, -0.001f, 0.001f);
			weatherData.lightningMinTemp += GameMath.Clamp((lightningMinTemp - weatherData.lightningMinTemp) * dt, -0.001f, 0.001f);
			weatherData.BlendedPrecType = CurWeatherEvent.State.PrecType;
		}

		public double GetWindSpeed(double posY)
		{
			if (CurWindPattern == null)
			{
				return 0.0;
			}
			double num = CurWindPattern.Strength;
			if (posY > (double)ws.api.World.SeaLevel)
			{
				num *= Math.Max(1.0, 0.9 + (posY - (double)ws.api.World.SeaLevel) / 100.0);
				return Math.Min(num, 1.5);
			}
			return num / (1.0 + ((double)ws.api.World.SeaLevel - posY) / 4.0);
		}

		public EnumPrecipitationType GetPrecipitationType()
		{
			return weatherData.BlendedPrecType;
		}

		public bool SetWindPattern(string code, bool updateInstant)
		{
			WindPattern windPattern = WindPatterns.FirstOrDefault((WindPattern p) => p.config.Code == code);
			if (windPattern == null)
			{
				return false;
			}
			CurWindPattern = windPattern;
			CurWindPattern.OnBeginUse();
			sendState(updateInstant);
			return true;
		}

		public bool SetWeatherEvent(string code, bool updateInstant)
		{
			WeatherEvent weatherEvent = WeatherEvents.FirstOrDefault((WeatherEvent p) => p.config.Code == code);
			if (weatherEvent == null)
			{
				return false;
			}
			CurWeatherEvent = weatherEvent;
			CurWeatherEvent.OnBeginUse();
			sendState(updateInstant);
			return true;
		}

		public bool SetWeatherPattern(string code, bool updateInstant)
		{
			WeatherPattern weatherPattern = WeatherPatterns.FirstOrDefault((WeatherPattern p) => p.config.Code == code);
			if (weatherPattern == null)
			{
				return false;
			}
			OldWePattern = NewWePattern;
			NewWePattern = weatherPattern;
			Weight = 1f;
			Transitioning = false;
			TransitionDelay = 0f;
			if (NewWePattern != OldWePattern || updateInstant)
			{
				NewWePattern.OnBeginUse();
			}
			UpdateWeatherData();
			sendState(updateInstant);
			return true;
		}

		private void sendState(bool updateInstant)
		{
			wsServer.SendWeatherStateUpdate(new WeatherState
			{
				RegionX = regionX,
				RegionZ = regionZ,
				NewPattern = NewWePattern.State,
				OldPattern = OldWePattern.State,
				WindPattern = CurWindPattern.State,
				WeatherEvent = CurWeatherEvent?.State,
				TransitionDelay = 0f,
				Transitioning = false,
				Weight = Weight,
				updateInstant = updateInstant,
				LcgCurrentSeed = Rand.currentSeed,
				LcgMapGenSeed = Rand.mapGenSeed,
				LcgWorldSeed = Rand.worldSeed
			});
		}

		public void TriggerTransition()
		{
			TriggerTransition(30f + Rand.NextFloat() * 60f * 60f / ws.api.World.Calendar.SpeedOfTime);
		}

		public void TriggerTransition(float delay)
		{
			Transitioning = true;
			TransitionDelay = delay;
			Weight = 0f;
			OldWePattern = NewWePattern;
			NewWePattern = RandomWeatherPattern();
			if (NewWePattern != OldWePattern)
			{
				NewWePattern.OnBeginUse();
			}
			wsServer.SendWeatherStateUpdate(new WeatherState
			{
				RegionX = regionX,
				RegionZ = regionZ,
				NewPattern = NewWePattern.State,
				OldPattern = OldWePattern.State,
				WindPattern = CurWindPattern.State,
				WeatherEvent = CurWeatherEvent?.State,
				TransitionDelay = TransitionDelay,
				Transitioning = true,
				Weight = Weight,
				LcgCurrentSeed = Rand.currentSeed,
				LcgMapGenSeed = Rand.mapGenSeed,
				LcgWorldSeed = Rand.worldSeed
			});
		}

		public WeatherEvent RandomWeatherEvent()
		{
			float num = 0f;
			for (int i = 0; i < WeatherEvents.Length; i++)
			{
				WeatherEvents[i].updateHereChance(weatherData.climateCond.WorldgenRainfall, weatherData.climateCond.Temperature);
				num += WeatherEvents[i].hereChance;
			}
			float num2 = Rand.NextFloat() * num;
			for (int j = 0; j < WeatherEvents.Length; j++)
			{
				num2 -= WeatherEvents[j].config.Weight;
				if (num2 <= 0f)
				{
					return WeatherEvents[j];
				}
			}
			return WeatherEvents[WeatherEvents.Length - 1];
		}

		public WeatherPattern RandomWeatherPattern()
		{
			float num = 0f;
			for (int i = 0; i < WeatherPatterns.Length; i++)
			{
				WeatherPatterns[i].updateHereChance(weatherData.climateCond.Rainfall, weatherData.climateCond.Temperature);
				num += WeatherPatterns[i].hereChance;
			}
			float num2 = Rand.NextFloat() * num;
			for (int j = 0; j < WeatherPatterns.Length; j++)
			{
				num2 -= WeatherPatterns[j].hereChance;
				if (num2 <= 0f)
				{
					return WeatherPatterns[j];
				}
			}
			return WeatherPatterns[WeatherPatterns.Length - 1];
		}

		public double GetBlendedCloudThicknessAt(int cloudTilePosX, int cloudTilePosZ)
		{
			if (IsDummy)
			{
				return 0.0;
			}
			int dx = cloudTilePosX - cloudTilebasePosX;
			int dz = cloudTilePosZ - cloudTilebasePosZ;
			return NewWePattern.GetCloudDensityAt(dx, dz) * (double)Weight + OldWePattern.GetCloudDensityAt(dx, dz) * (double)(1f - Weight);
		}

		public double GetBlendedCloudOpaqueness()
		{
			return NewWePattern.State.nowbaseOpaqueness * Weight + OldWePattern.State.nowbaseOpaqueness * (1f - Weight);
		}

		public double GetBlendedCloudBrightness(float b)
		{
			float num = ((WeightedValue<float>)(object)weatherData.Ambient.CloudBrightness).Weight;
			if (IsDummy)
			{
				num = 0f;
			}
			float num2 = ((WeightedValue<float>)(object)weatherData.Ambient.CloudBrightness).Value * ((WeightedValue<float>)(object)weatherData.Ambient.SceneBrightness).Value;
			return b * (1f - num) + num2 * num;
		}

		public double GetBlendedThinCloudModeness()
		{
			return NewWePattern.State.nowThinCloudModeness * Weight + OldWePattern.State.nowThinCloudModeness * (1f - Weight);
		}

		public double GetBlendedUndulatingCloudModeness()
		{
			return NewWePattern.State.nowUndulatingCloudModeness * Weight + OldWePattern.State.nowUndulatingCloudModeness * (1f - Weight);
		}

		internal void EnsureCloudTileCacheIsFresh(Vec3i tilePos)
		{
			if (!IsDummy)
			{
				NewWePattern.EnsureCloudTileCacheIsFresh(tilePos);
				OldWePattern.EnsureCloudTileCacheIsFresh(tilePos);
			}
		}

		public byte[] ToBytes()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			FastMemoryStream val = new FastMemoryStream();
			try
			{
				return ToBytes(val);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public byte[] ToBytes(FastMemoryStream ms)
		{
			return SerializerUtil.Serialize<WeatherState>(new WeatherState
			{
				NewPattern = (NewWePattern?.State ?? null),
				OldPattern = (OldWePattern?.State ?? null),
				WindPattern = (CurWindPattern?.State ?? null),
				WeatherEvent = (CurWeatherEvent?.State ?? null),
				Weight = Weight,
				TransitionDelay = TransitionDelay,
				Transitioning = Transitioning,
				LastUpdateTotalHours = LastUpdateTotalHours,
				LcgCurrentSeed = Rand.currentSeed,
				LcgMapGenSeed = Rand.mapGenSeed,
				LcgWorldSeed = Rand.worldSeed,
				SnowAccumSnapshots = SnowAccumSnapshots.Values,
				Ringarraycursor = SnowAccumSnapshots.EndPosition
			}, ms);
		}

		internal void FromBytes(byte[] data)
		{
			if (data == null)
			{
				LoadRandomPattern();
				NewWePattern.OnBeginUse();
				return;
			}
			WeatherState weatherState = SerializerUtil.Deserialize<WeatherState>(data);
			if (weatherState.NewPattern != null)
			{
				NewWePattern = WeatherPatterns[GameMath.Clamp(weatherState.NewPattern.Index, 0, WeatherPatterns.Length - 1)];
				NewWePattern.State = weatherState.NewPattern;
			}
			else
			{
				NewWePattern = WeatherPatterns[0];
			}
			if (weatherState.OldPattern != null && weatherState.OldPattern.Index < WeatherPatterns.Length)
			{
				OldWePattern = WeatherPatterns[GameMath.Clamp(weatherState.OldPattern.Index, 0, WeatherPatterns.Length - 1)];
				OldWePattern.State = weatherState.OldPattern;
			}
			else
			{
				OldWePattern = WeatherPatterns[0];
			}
			if (weatherState.WindPattern != null)
			{
				CurWindPattern = WindPatterns[GameMath.Clamp(weatherState.WindPattern.Index, 0, WindPatterns.Length - 1)];
				CurWindPattern.State = weatherState.WindPattern;
			}
			Weight = weatherState.Weight;
			TransitionDelay = weatherState.TransitionDelay;
			Transitioning = weatherState.Transitioning;
			LastUpdateTotalHours = weatherState.LastUpdateTotalHours;
			Rand.worldSeed = weatherState.LcgWorldSeed;
			Rand.currentSeed = weatherState.LcgCurrentSeed;
			Rand.mapGenSeed = weatherState.LcgMapGenSeed;
			double totalHours = ws.api.World.Calendar.TotalHours;
			LastUpdateTotalHours = Math.Max(LastUpdateTotalHours, totalHours - (double)(ws.api.World.Calendar.DaysPerYear * 24) + ws.api.World.Rand.NextDouble());
			int num = (int)((float)ws.api.World.Calendar.DaysPerYear * ws.api.World.Calendar.HoursPerDay) + 1;
			SnowAccumSnapshots = new RingArray<SnowAccumSnapshot>(num, weatherState.SnowAccumSnapshots);
			SnowAccumSnapshots.EndPosition = GameMath.Clamp(weatherState.Ringarraycursor, 0, num - 1);
			if (weatherState.WeatherEvent != null)
			{
				CurWeatherEvent = WeatherEvents[weatherState.WeatherEvent.Index];
				CurWeatherEvent.State = weatherState.WeatherEvent;
			}
			if (CurWeatherEvent == null)
			{
				CurWeatherEvent = RandomWeatherEvent();
				CurWeatherEvent.OnBeginUse();
			}
		}
	}
	public class WeatherSimulationSnowAccum
	{
		private int[][] randomShuffles;

		private ICoreServerAPI sapi;

		private WeatherSystemBase ws;

		private Thread snowLayerScannerThread;

		private bool isShuttingDown;

		private UniqueQueue<Vec2i> chunkColsstoCheckQueue = new UniqueQueue<Vec2i>();

		private UniqueQueue<UpdateSnowLayerChunk> updateSnowLayerQueue = new UniqueQueue<UpdateSnowLayerChunk>();

		[ThreadStatic]
		private static BlockPos tmpPos;

		private const int chunksize = 32;

		private int regionsize;

		internal float accum;

		public bool ProcessChunks = true;

		public bool enabled;

		private IBulkBlockAccessor ba;

		private IBulkBlockAccessor cuba;

		private bool shouldPauseThread;

		private bool isThreadPaused;

		public WeatherSimulationSnowAccum(ICoreServerAPI sapi, WeatherSystemBase ws)
		{
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Expected O, but got Unknown
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Expected O, but got Unknown
			//IL_0119: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Expected O, but got Unknown
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Expected O, but got Unknown
			this.sapi = sapi;
			this.ws = ws;
			ba = ((IWorldAccessor)sapi.World).GetBlockAccessorBulkMinimalUpdate(true, false);
			((IBlockAccessor)ba).UpdateSnowAccumMap = false;
			cuba = ((IWorldAccessor)sapi.World).GetBlockAccessorMapChunkLoading(false, false);
			((IBlockAccessor)cuba).UpdateSnowAccumMap = false;
			initRandomShuffles();
			sapi.Event.BeginChunkColumnLoadChunkThread += new ChunkColumnBeginLoadChunkThread(Event_BeginChunkColLoadChunkThread);
			sapi.Event.ChunkColumnLoaded += new ChunkColumnLoadedDelegate(Event_ChunkColumnLoaded);
			sapi.Event.SaveGameLoaded += Event_SaveGameLoaded;
			sapi.Event.ServerRunPhase((EnumServerRunPhase)9, (Action)delegate
			{
				isShuttingDown = true;
			});
			((IEventAPI)sapi.Event).RegisterGameTickListener((Action<float>)OnServerTick3s, 3000, 0);
			((IEventAPI)sapi.Event).RegisterGameTickListener((Action<float>)OnServerTick100ms, 100, 0);
			sapi.Event.ServerSuspend += new SuspendServerDelegate(Event_ServerSuspend);
			sapi.Event.ServerResume += new ResumeServerDelegate(Event_ServerResume);
			snowLayerScannerThread = TyronThreadPool.CreateDedicatedThread((ThreadStart)onThreadStart, "snowlayerScanner");
		}

		private void Event_ServerResume()
		{
			shouldPauseThread = false;
		}

		private EnumSuspendState Event_ServerSuspend()
		{
			shouldPauseThread = true;
			if (!isThreadPaused && enabled)
			{
				return (EnumSuspendState)0;
			}
			return (EnumSuspendState)1;
		}

		private void Event_SaveGameLoaded()
		{
			regionsize = sapi.WorldManager.RegionSize;
			if (regionsize == 0)
			{
				((ICoreAPI)sapi).Logger.Notification("Warning: region size was 0 for Snow Accum system");
				regionsize = 16;
			}
			enabled = ((IWorldAccessor)sapi.World).Config.GetBool("snowAccum", true);
			GlobalConstants.MeltingFreezingEnabled = enabled;
			if (enabled)
			{
				snowLayerScannerThread.Start();
			}
		}

		private void OnServerTick3s(float dt)
		{
			if (!ProcessChunks || !enabled)
			{
				return;
			}
			foreach (KeyValuePair<long, IMapChunk> allLoadedMapchunk in sapi.WorldManager.AllLoadedMapchunks)
			{
				Vec2i val = sapi.WorldManager.MapChunkPosFromChunkIndex2D(allLoadedMapchunk.Key);
				lock (chunkColsstoCheckQueue)
				{
					chunkColsstoCheckQueue.Enqueue(val);
				}
			}
		}

		public void AddToCheckQueue(Vec2i chunkCoord)
		{
			lock (chunkColsstoCheckQueue)
			{
				chunkColsstoCheckQueue.Enqueue(chunkCoord);
			}
		}

		private void OnServerTick100ms(float dt)
		{
			accum += dt;
			if (updateSnowLayerQueue.Count <= 5 && (!(accum > 1f) || updateSnowLayerQueue.Count <= 0))
			{
				return;
			}
			accum = 0f;
			int num = 0;
			int num2 = 10;
			UpdateSnowLayerChunk[] array = new UpdateSnowLayerChunk[num2];
			lock (updateSnowLayerQueue)
			{
				while (updateSnowLayerQueue.Count > 0)
				{
					array[num] = updateSnowLayerQueue.Dequeue();
					num++;
					if (num >= num2)
					{
						break;
					}
				}
			}
			for (int i = 0; i < num; i++)
			{
				IMapChunk mapChunk = (IMapChunk)(object)sapi.WorldManager.GetMapChunk(array[i].Coords.X, array[i].Coords.Y);
				if (mapChunk != null)
				{
					processBlockUpdates(mapChunk, array[i], ba);
				}
			}
			((IBlockAccessor)ba).Commit();
		}

		internal void processBlockUpdates(IMapChunk mc, UpdateSnowLayerChunk updateChunk, IBulkBlockAccessor ba)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Expected O, but got Unknown
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Expected O, but got Unknown
			Dictionary<int, BlockIdAndSnowLevel> setBlocks = updateChunk.SetBlocks;
			double lastSnowAccumUpdateTotalHours = updateChunk.LastSnowAccumUpdateTotalHours;
			Vec2i val = new Vec2i();
			int x = updateChunk.Coords.X;
			int y = updateChunk.Coords.Y;
			if (tmpPos == null)
			{
				tmpPos = new BlockPos(0);
			}
			foreach (KeyValuePair<int, BlockIdAndSnowLevel> item in setBlocks)
			{
				Block block = item.Value.Block;
				float snowLevel = item.Value.SnowLevel;
				tmpPos.SetFromColumnIndex3d(item.Key, x, y);
				Block block2 = ((IBlockAccessor)ba).GetBlock(tmpPos);
				val.Set(tmpPos.X, tmpPos.Z);
				if (!(snowLevel > 0f) || mc.SnowAccum.ContainsKey(val))
				{
					block2.PerformSnowLevelUpdate(ba, tmpPos, block, snowLevel);
				}
			}
			mc.SetModdata("lastSnowAccumUpdateTotalHours", SerializerUtil.Serialize<double>(lastSnowAccumUpdateTotalHours));
			mc.MarkDirty();
		}

		private void Event_ChunkColumnLoaded(Vec2i chunkCoord, IWorldChunk[] chunks)
		{
			if (!ProcessChunks)
			{
				return;
			}
			int regionX = chunkCoord.X * 32 / regionsize;
			int regionZ = chunkCoord.Y * 32 / regionsize;
			WeatherSimulationRegion orCreateWeatherSimForRegion = ws.getOrCreateWeatherSimForRegion(regionX, regionZ);
			if (sapi.WorldManager.GetMapChunk(chunkCoord.X, chunkCoord.Y) == null || orCreateWeatherSimForRegion == null)
			{
				return;
			}
			lock (chunkColsstoCheckQueue)
			{
				chunkColsstoCheckQueue.Enqueue(chunkCoord);
			}
		}

		private void Event_BeginChunkColLoadChunkThread(IServerMapChunk mc, int chunkX, int chunkZ, IWorldChunk[] chunks)
		{
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Expected O, but got Unknown
			if (ProcessChunks)
			{
				int regionX = chunkX * 32 / regionsize;
				int regionZ = chunkZ * 32 / regionsize;
				WeatherSimulationRegion orCreateWeatherSimForRegion = ws.getOrCreateWeatherSimForRegion(regionX, regionZ);
				if (orCreateWeatherSimForRegion != null)
				{
					TryImmediateSnowUpdate(orCreateWeatherSimForRegion, mc, new Vec2i(chunkX, chunkZ), chunks);
				}
			}
		}

		private bool TryImmediateSnowUpdate(WeatherSimulationRegion simregion, IServerMapChunk mc, Vec2i chunkCoord, IWorldChunk[] chunksCol)
		{
			UpdateSnowLayerChunk updateSnowLayerChunk = new UpdateSnowLayerChunk
			{
				Coords = chunkCoord
			};
			lock (updateSnowLayerQueue)
			{
				if (updateSnowLayerQueue.Contains(updateSnowLayerChunk))
				{
					return false;
				}
			}
			if (ws.api.World.Calendar.TotalHours - simregion.LastUpdateTotalHours > 1.0)
			{
				return false;
			}
			UpdateSnowLayerChunk snowUpdate = GetSnowUpdate(simregion, mc, chunkCoord, chunksCol);
			if (snowUpdate == null)
			{
				return true;
			}
			if (snowUpdate.SetBlocks.Count == 0)
			{
				return true;
			}
			cuba.SetChunks(chunkCoord, chunksCol);
			processBlockUpdates((IMapChunk)(object)mc, snowUpdate, cuba);
			((IBlockAccessor)cuba).Commit();
			lock (updateSnowLayerQueue)
			{
				updateSnowLayerQueue.Enqueue(updateSnowLayerChunk);
			}
			return true;
		}

		private void onThreadStart()
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			FrameProfilerUtil val = new FrameProfilerUtil("[Thread snowaccum] ");
			while (!isShuttingDown)
			{
				Thread.Sleep(5);
				if (shouldPauseThread)
				{
					isThreadPaused = true;
					continue;
				}
				isThreadPaused = false;
				val.Begin((string)null, Array.Empty<object>());
				int num = 0;
				while (chunkColsstoCheckQueue.Count > 0 && num++ < 10)
				{
					Vec2i val2;
					lock (chunkColsstoCheckQueue)
					{
						val2 = chunkColsstoCheckQueue.Dequeue();
					}
					int regionX = val2.X * 32 / regionsize;
					int regionZ = val2.Y * 32 / regionsize;
					WeatherSimulationRegion orCreateWeatherSimForRegion = ws.getOrCreateWeatherSimForRegion(regionX, regionZ);
					IServerMapChunk mapChunk = sapi.WorldManager.GetMapChunk(val2.X, val2.Y);
					if (mapChunk != null && orCreateWeatherSimForRegion != null)
					{
						UpdateSnowLayerOffThread(orCreateWeatherSimForRegion, mapChunk, val2);
						val.Mark("update ", (object)val2);
					}
				}
				val.OffThreadEnd();
			}
		}

		private void initRandomShuffles()
		{
			randomShuffles = new int[50][];
			for (int i = 0; i < randomShuffles.Length; i++)
			{
				int[] array = (randomShuffles[i] = new int[1024]);
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = j;
				}
				GameMath.Shuffle<int>(((IWorldAccessor)sapi.World).Rand, array);
			}
		}

		public void UpdateSnowLayerOffThread(WeatherSimulationRegion simregion, IServerMapChunk mc, Vec2i chunkPos)
		{
			UpdateSnowLayerChunk updateSnowLayerChunk = new UpdateSnowLayerChunk
			{
				Coords = chunkPos
			};
			lock (updateSnowLayerQueue)
			{
				if (updateSnowLayerQueue.Contains(updateSnowLayerChunk))
				{
					return;
				}
			}
			if (simregion == null || ws.api.World.Calendar.TotalHours - simregion.LastUpdateTotalHours > 1.0)
			{
				return;
			}
			updateSnowLayerChunk = GetSnowUpdate(simregion, mc, chunkPos, null);
			if (updateSnowLayerChunk == null)
			{
				return;
			}
			lock (updateSnowLayerQueue)
			{
				updateSnowLayerQueue.Enqueue(updateSnowLayerChunk);
			}
		}

		private UpdateSnowLayerChunk GetSnowUpdate(WeatherSimulationRegion simregion, IServerMapChunk mc, Vec2i chunkPos, IWorldChunk[] chunksCol)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			double num = ((IMapChunk)mc).GetModdata<double>("lastSnowAccumUpdateTotalHours", 0.0);
			double num2 = num;
			int snowAccumResolution = WeatherSimulationRegion.snowAccumResolution;
			SnowAccumSnapshot snowAccumSnapshot = new SnowAccumSnapshot
			{
				SnowAccumulationByRegionCorner = new FloatDataMap3D(snowAccumResolution, snowAccumResolution, snowAccumResolution)
			};
			float[] data = snowAccumSnapshot.SnowAccumulationByRegionCorner.Data;
			float num3 = (float)ws.GeneralConfig.SnowLayerBlocks.Count + 0.6f;
			int length = simregion.SnowAccumSnapshots.Length;
			int num4 = simregion.SnowAccumSnapshots.EndPosition;
			int num5 = 0;
			lock (WeatherSimulationRegion.snowAccumSnapshotLock)
			{
				while (length-- > 0)
				{
					SnowAccumSnapshot snowAccumSnapshot2 = simregion.SnowAccumSnapshots[num4];
					num4 = (num4 + 1) % simregion.SnowAccumSnapshots.Length;
					if (snowAccumSnapshot2 != null && !(num >= snowAccumSnapshot2.TotalHours))
					{
						float[] data2 = snowAccumSnapshot2.SnowAccumulationByRegionCorner.Data;
						for (int i = 0; i < data2.Length; i++)
						{
							data[i] = GameMath.Clamp(data[i] + data2[i], 0f - num3, num3);
						}
						num = Math.Max(num, snowAccumSnapshot2.TotalHours);
						num5++;
					}
				}
			}
			if (num5 == 0)
			{
				return null;
			}
			bool ignoreOldAccum = false;
			if (num - num2 >= (double)((float)((IWorldAccessor)sapi.World).Calendar.DaysPerYear * ((IWorldAccessor)sapi.World).Calendar.HoursPerDay))
			{
				ignoreOldAccum = true;
			}
			UpdateSnowLayerChunk updateSnowLayerChunk = UpdateSnowLayer(snowAccumSnapshot, ignoreOldAccum, mc, chunkPos, chunksCol);
			if (updateSnowLayerChunk != null)
			{
				updateSnowLayerChunk.LastSnowAccumUpdateTotalHours = num;
				updateSnowLayerChunk.Coords = chunkPos.Copy();
			}
			return updateSnowLayerChunk;
		}

		public UpdateSnowLayerChunk UpdateSnowLayer(SnowAccumSnapshot sumsnapshot, bool ignoreOldAccum, IServerMapChunk mc, Vec2i chunkPos, IWorldChunk[] chunksCol)
		{
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Expected O, but got Unknown
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Expected O, but got Unknown
			//IL_0236: Unknown result type (might be due to invalid IL or missing references)
			//IL_023d: Expected O, but got Unknown
			UpdateSnowLayerChunk updateSnowLayerChunk = new UpdateSnowLayerChunk();
			OrderedDictionary<Block, int> snowLayerBlocks = ws.GeneralConfig.SnowLayerBlocks;
			int x = chunkPos.X;
			int y = chunkPos.Y;
			int num = x * 32 / regionsize;
			int num2 = y * 32 / regionsize;
			int num3 = num * regionsize;
			int num4 = num2 * regionsize;
			int seaLevel = ((IWorldAccessor)sapi.World).SeaLevel;
			int count = ws.GeneralConfig.SnowLayerBlocks.Count;
			BlockPos val = new BlockPos(0);
			BlockPos val2 = new BlockPos(0);
			float num5 = ((IWorldAccessor)sapi.World).BlockAccessor.MapSizeY - seaLevel;
			int[] array = randomShuffles[((IWorldAccessor)sapi.World).Rand.Next(randomShuffles.Length)];
			int num6 = -99999;
			IWorldChunk val3 = null;
			int num7 = ((IWorldAccessor)sapi.World).BlockAccessor.MapSizeY - 1;
			foreach (int num8 in array)
			{
				int num9 = GameMath.Clamp((int)((IMapChunk)mc).RainHeightMap[num8], 0, num7);
				int num10 = num9 / 32;
				val.Set(x * 32 + num8 % 32, num9, y * 32 + num8 / 32);
				if (num6 != num10)
				{
					val3 = (IWorldChunk)(((object)((chunksCol != null) ? chunksCol[num10] : null)) ?? ((object)sapi.WorldManager.GetChunk(x, num10, y)));
					num6 = num10;
				}
				if (val3 == null)
				{
					return null;
				}
				float x2 = (float)(val.X - num3) / (float)regionsize;
				float y2 = GameMath.Clamp((float)(val.Y - seaLevel) / num5, 0f, 1f);
				float z = (float)(val.Z - num4) / (float)regionsize;
				Block val4 = val3.GetLocalBlockAtBlockPos((IWorldAccessor)(object)sapi.World, val);
				Block localBlockAtBlockPos = val3.GetLocalBlockAtBlockPos((IWorldAccessor)(object)sapi.World, val.X, val.Y, val.Z, 2);
				if (((CollectibleObject)localBlockAtBlockPos).Id != 0)
				{
					if (!((CollectibleObject)localBlockAtBlockPos).IsLiquid())
					{
						val4 = localBlockAtBlockPos;
					}
					else if (val4.GetSnowLevel(val) == 0f)
					{
						continue;
					}
				}
				float value = 0f;
				Vec2i key = new Vec2i(val.X, val.Z);
				if (!ignoreOldAccum && !((IMapChunk)mc).SnowAccum.TryGetValue(key, out value))
				{
					value = val4.GetSnowLevel(val);
				}
				float num11 = value + sumsnapshot.GetAvgSnowAccumByRegionCorner(x2, y2, z);
				((IMapChunk)mc).SnowAccum[key] = GameMath.Clamp(num11, -1f, (float)count + 0.6f);
				float num12 = num11 - (float)GameMath.MurmurHash3Mod(val.X, 0, val.Z, 150) / 300f;
				float num13 = GameMath.Clamp(num12 - 1.1f, -1f, (float)(count - 1));
				int num14 = ((num13 < 0f) ? (-1) : ((int)num13));
				val2.Set(val.X, Math.Min(val.Y + 1, ((IWorldAccessor)sapi.World).BlockAccessor.MapSizeY - 1), val.Z);
				num10 = val2.Y / 32;
				if (num6 != num10)
				{
					val3 = (IWorldChunk)(((object)((chunksCol != null) ? chunksCol[num10] : null)) ?? ((object)sapi.WorldManager.GetChunk(x, num10, y)));
					num6 = num10;
				}
				if (val3 == null)
				{
					return null;
				}
				Block val5 = val3.GetLocalBlockAtBlockPos((IWorldAccessor)(object)sapi.World, val2);
				Block localBlockAtBlockPos2 = val3.GetLocalBlockAtBlockPos((IWorldAccessor)(object)sapi.World, val2.X, val2.Y, val2.Z, 2);
				if (((CollectibleObject)localBlockAtBlockPos2).Id != 0)
				{
					if (!((CollectibleObject)localBlockAtBlockPos2).IsLiquid())
					{
						val5 = localBlockAtBlockPos2;
					}
					else if (val5.GetSnowLevel(val) == 0f)
					{
						continue;
					}
				}
				val2.Set(val);
				Block snowCoveredVariant = val4.GetSnowCoveredVariant(val2, num12);
				if (snowCoveredVariant != null)
				{
					if (((CollectibleObject)val4).Id != ((CollectibleObject)snowCoveredVariant).Id && val5.Replaceable > 6000)
					{
						updateSnowLayerChunk.SetBlocks[val2.ToColumnIndex3d()] = new BlockIdAndSnowLevel(snowCoveredVariant, num12);
					}
				}
				else
				{
					if (!val4.AllowSnowCoverage((IWorldAccessor)(object)sapi.World, val2))
					{
						continue;
					}
					val2.Set(val.X, val.Y + 1, val.Z);
					if (((CollectibleObject)val5).Id != 0)
					{
						snowCoveredVariant = val5.GetSnowCoveredVariant(val2, num12);
						if (snowCoveredVariant != null && ((CollectibleObject)val5).Id != ((CollectibleObject)snowCoveredVariant).Id)
						{
							updateSnowLayerChunk.SetBlocks[val2.ToColumnIndex3d()] = new BlockIdAndSnowLevel(snowCoveredVariant, num12);
						}
					}
					else if (num14 >= 0)
					{
						Block keyAtIndex = snowLayerBlocks.GetKeyAtIndex(num14);
						updateSnowLayerChunk.SetBlocks[val2.ToColumnIndex3d()] = new BlockIdAndSnowLevel(keyAtIndex, num12);
					}
				}
			}
			return updateSnowLayerChunk;
		}
	}
	public class WeatherSimulationSound
	{
		private WeatherSystemClient weatherSys;

		private ILoadedSound[] rainSoundsLeafless;

		private ILoadedSound[] rainSoundsLeafy;

		private ILoadedSound lowTrembleSound;

		private ILoadedSound hailSound;

		private ILoadedSound windSoundLeafy;

		private ILoadedSound windSoundLeafless;

		private ICoreClientAPI capi;

		private bool windSoundsOn;

		private bool rainSoundsOn;

		private bool hailSoundsOn;

		private float curWindVolumeLeafy;

		private float curWindVolumeLeafless;

		private float curRainVolumeLeafy;

		private float curRainVolumeLeafless;

		private float curRainPitch = 1f;

		private float curHailVolume;

		private float curHailPitch = 1f;

		private float curTrembleVolume;

		private float curTremblePitch;

		private float quarterSecAccum;

		private bool searchComplete = true;

		public static float roomVolumePitchLoss;

		private bool soundsReady;

		private BlockPos plrPos = new BlockPos();

		public WeatherSimulationSound(ICoreClientAPI capi, WeatherSystemClient weatherSys)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Expected O, but got Unknown
			this.weatherSys = weatherSys;
			this.capi = capi;
		}

		internal void Initialize()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Expected O, but got Unknown
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Expected O, but got Unknown
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Expected O, but got Unknown
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Expected O, but got Unknown
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Expected O, but got Unknown
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Expected O, but got Unknown
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Expected O, but got Unknown
			//IL_0191: Unknown result type (might be due to invalid IL or missing references)
			//IL_0196: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a6: Expected O, but got Unknown
			//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Expected O, but got Unknown
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f7: Expected O, but got Unknown
			//IL_0204: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_020f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0219: Expected O, but got Unknown
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_0220: Unknown result type (might be due to invalid IL or missing references)
			//IL_0227: Unknown result type (might be due to invalid IL or missing references)
			//IL_0237: Unknown result type (might be due to invalid IL or missing references)
			//IL_0241: Expected O, but got Unknown
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			//IL_0253: Unknown result type (might be due to invalid IL or missing references)
			//IL_0255: Unknown result type (might be due to invalid IL or missing references)
			//IL_025a: Unknown result type (might be due to invalid IL or missing references)
			//IL_026a: Expected O, but got Unknown
			//IL_027b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0280: Unknown result type (might be due to invalid IL or missing references)
			//IL_0286: Unknown result type (might be due to invalid IL or missing references)
			//IL_0290: Expected O, but got Unknown
			//IL_0290: Unknown result type (might be due to invalid IL or missing references)
			//IL_0297: Unknown result type (might be due to invalid IL or missing references)
			//IL_029e: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b8: Expected O, but got Unknown
			//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e1: Expected O, but got Unknown
			lowTrembleSound = capi.World.LoadSound(new SoundParams
			{
				Location = new AssetLocation("sounds/weather/tracks/verylowtremble.ogg"),
				ShouldLoop = true,
				DisposeOnFinish = false,
				Position = new Vec3f(0f, 0f, 0f),
				RelativePosition = true,
				Range = 16f,
				SoundType = (EnumSoundType)3,
				Volume = 1f
			});
			hailSound = capi.World.LoadSound(new SoundParams
			{
				Location = new AssetLocation("sounds/weather/tracks/hail.ogg"),
				ShouldLoop = true,
				DisposeOnFinish = false,
				Position = new Vec3f(0f, 0f, 0f),
				RelativePosition = true,
				Range = 16f,
				SoundType = (EnumSoundType)3,
				Volume = 1f
			});
			rainSoundsLeafless = (ILoadedSound[])(object)new ILoadedSound[1];
			rainSoundsLeafless[0] = capi.World.LoadSound(new SoundParams
			{
				Location = new AssetLocation("sounds/weather/tracks/rain-leafless.ogg"),
				ShouldLoop = true,
				DisposeOnFinish = false,
				Position = new Vec3f(0f, 0f, 0f),
				RelativePosition = true,
				Range = 16f,
				SoundType = (EnumSoundType)3,
				Volume = 1f
			});
			rainSoundsLeafy = (ILoadedSound[])(object)new ILoadedSound[1];
			rainSoundsLeafy[0] = capi.World.LoadSound(new SoundParams
			{
				Location = new AssetLocation("sounds/weather/tracks/rain-leafy.ogg"),
				ShouldLoop = true,
				DisposeOnFinish = false,
				Position = new Vec3f(0f, 0f, 0f),
				RelativePosition = true,
				Range = 16f,
				SoundType = (EnumSoundType)3,
				Volume = 1f
			});
			windSoundLeafy = capi.World.LoadSound(new SoundParams
			{
				Location = new AssetLocation("sounds/weather/wind-leafy.ogg"),
				ShouldLoop = true,
				DisposeOnFinish = false,
				Position = new Vec3f(0f, 0f, 0f),
				RelativePosition = true,
				Range = 16f,
				SoundType = (EnumSoundType)3,
				Volume = 1f
			});
			windSoundLeafless = capi.World.LoadSound(new SoundParams
			{
				Location = new AssetLocation("sounds/weather/wind-leafless.ogg"),
				ShouldLoop = true,
				DisposeOnFinish = false,
				Position = new Vec3f(0f, 0f, 0f),
				RelativePosition = true,
				Range = 16f,
				SoundType = (EnumSoundType)3,
				Volume = 1f
			});
		}

		public void Update(float dt)
		{
			if (lowTrembleSound != null)
			{
				dt = Math.Min(0.5f, dt);
				quarterSecAccum += dt;
				if (quarterSecAccum > 0.25f)
				{
					updateSounds(dt);
				}
			}
		}

		private void updateSounds(float dt)
		{
			if (!soundsReady)
			{
				if (!lowTrembleSound.IsReady || !hailSound.IsReady || !rainSoundsLeafless.All((ILoadedSound s) => s.IsReady) || !rainSoundsLeafy.All((ILoadedSound s) => s.IsReady) || !windSoundLeafy.IsReady || !windSoundLeafless.IsReady)
				{
					return;
				}
				soundsReady = true;
			}
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			float num6 = 1f;
			float num7 = 1f;
			WeatherDataSnapshot blendedWeatherData = weatherSys.BlendedWeatherData;
			if (searchComplete)
			{
				EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
				plrPos.Set((int)((Entity)entity).Pos.X, (int)((Entity)entity).Pos.Y, (int)((Entity)entity).Pos.Z);
				searchComplete = false;
				TyronThreadPool.QueueTask((Action)delegate
				{
					int distanceToRainFall = ((IWorldAccessor)capi.World).BlockAccessor.GetDistanceToRainFall(plrPos, 12, 4);
					roomVolumePitchLoss = GameMath.Clamp((float)Math.Pow(Math.Max(0f, (float)(distanceToRainFall - 2) / 10f), 2.0), 0f, 1f);
					searchComplete = true;
				}, "weathersimulationsound");
			}
			EnumPrecipitationType enumPrecipitationType = blendedWeatherData.BlendedPrecType;
			if (enumPrecipitationType == EnumPrecipitationType.Auto)
			{
				enumPrecipitationType = ((weatherSys.clientClimateCond?.Temperature < blendedWeatherData.snowThresholdTemp) ? EnumPrecipitationType.Snow : EnumPrecipitationType.Rain);
			}
			float num8 = GameMath.Clamp(GlobalConstants.CurrentNearbyRelLeavesCountClient * 60f, 0f, 1f);
			ClimateCondition clientClimateCond = weatherSys.clientClimateCond;
			if (clientClimateCond.Rainfall > 0f)
			{
				if (enumPrecipitationType == EnumPrecipitationType.Rain || weatherSys.clientClimateCond.Temperature < blendedWeatherData.snowThresholdTemp)
				{
					num = num8 * GameMath.Clamp(clientClimateCond.Rainfall * 2f - Math.Max(0f, 2f * (blendedWeatherData.snowThresholdTemp - weatherSys.clientClimateCond.Temperature)), 0f, 1f);
					num = GameMath.Max(0f, num - roomVolumePitchLoss);
					num2 = Math.Max(0.3f, 1f - num8) * GameMath.Clamp(clientClimateCond.Rainfall * 2f - Math.Max(0f, 2f * (blendedWeatherData.snowThresholdTemp - weatherSys.clientClimateCond.Temperature)), 0f, 1f);
					num2 = GameMath.Max(0f, num2 - roomVolumePitchLoss);
					num6 = Math.Max(0.7f, 1.25f - clientClimateCond.Rainfall * 0.7f);
					num6 = Math.Max(0f, num6 - roomVolumePitchLoss / 4f);
					num4 = GameMath.Clamp(clientClimateCond.Rainfall * 1.6f - 0.8f - roomVolumePitchLoss * 0.25f, 0f, 1f);
					num5 = GameMath.Clamp(1f - roomVolumePitchLoss * 0.65f, 0f, 1f);
					if (!rainSoundsOn && ((double)num > 0.01 || (double)num2 > 0.01))
					{
						for (int num9 = 0; num9 < rainSoundsLeafless.Length; num9++)
						{
							ILoadedSound obj = rainSoundsLeafless[num9];
							if (obj != null)
							{
								obj.Start();
							}
						}
						for (int num10 = 0; num10 < rainSoundsLeafy.Length; num10++)
						{
							ILoadedSound obj2 = rainSoundsLeafy[num10];
							if (obj2 != null)
							{
								obj2.Start();
							}
						}
						ILoadedSound obj3 = lowTrembleSound;
						if (obj3 != null)
						{
							obj3.Start();
						}
						rainSoundsOn = true;
						curRainPitch = num6;
					}
					if (((EntityAgent)((IPlayer)capi.World.Player).Entity).IsEyesSubmerged())
					{
						curRainPitch = num6 / 2f;
						num *= 0.75f;
						num2 *= 0.75f;
					}
				}
				if (enumPrecipitationType == EnumPrecipitationType.Hail)
				{
					num3 = GameMath.Clamp(clientClimateCond.Rainfall * 2f - roomVolumePitchLoss, 0f, 1f);
					num3 = GameMath.Max(0f, num3 - roomVolumePitchLoss);
					num7 = Math.Max(0.7f, 1.25f - clientClimateCond.Rainfall * 0.7f);
					num7 = Math.Max(0f, num7 - roomVolumePitchLoss / 4f);
					if (!hailSoundsOn && (double)num3 > 0.01)
					{
						ILoadedSound obj4 = hailSound;
						if (obj4 != null)
						{
							obj4.Start();
						}
						hailSoundsOn = true;
						curHailPitch = num7;
					}
				}
			}
			curRainVolumeLeafy += (num - curRainVolumeLeafy) * dt / 2f;
			curRainVolumeLeafless += (num2 - curRainVolumeLeafless) * dt / 2f;
			curTrembleVolume += (num4 - curTrembleVolume) * dt;
			curHailVolume += (num3 - curHailVolume) * dt;
			curHailPitch += (num7 - curHailPitch) * dt;
			curRainPitch += (num6 - curRainPitch) * dt;
			curTremblePitch += (num5 - curTremblePitch) * dt;
			if (rainSoundsOn)
			{
				for (int num11 = 0; num11 < rainSoundsLeafless.Length; num11++)
				{
					ILoadedSound obj5 = rainSoundsLeafless[num11];
					if (obj5 != null)
					{
						obj5.SetVolume(curRainVolumeLeafless);
					}
					ILoadedSound obj6 = rainSoundsLeafless[num11];
					if (obj6 != null)
					{
						obj6.SetPitch(curRainPitch);
					}
				}
				for (int num12 = 0; num12 < rainSoundsLeafy.Length; num12++)
				{
					ILoadedSound obj7 = rainSoundsLeafy[num12];
					if (obj7 != null)
					{
						obj7.SetVolume(curRainVolumeLeafy);
					}
					ILoadedSound obj8 = rainSoundsLeafy[num12];
					if (obj8 != null)
					{
						obj8.SetPitch(curRainPitch);
					}
				}
			}
			ILoadedSound obj9 = lowTrembleSound;
			if (obj9 != null)
			{
				obj9.SetVolume(curTrembleVolume);
			}
			ILoadedSound obj10 = lowTrembleSound;
			if (obj10 != null)
			{
				obj10.SetPitch(curTremblePitch);
			}
			if (hailSoundsOn)
			{
				ILoadedSound obj11 = hailSound;
				if (obj11 != null)
				{
					obj11.SetVolume(curHailVolume);
				}
				ILoadedSound obj12 = hailSound;
				if (obj12 != null)
				{
					obj12.SetPitch(curHailPitch);
				}
			}
			if ((double)curRainVolumeLeafless < 0.01 && (double)curRainVolumeLeafy < 0.01)
			{
				for (int num13 = 0; num13 < rainSoundsLeafless.Length; num13++)
				{
					ILoadedSound obj13 = rainSoundsLeafless[num13];
					if (obj13 != null)
					{
						obj13.Stop();
					}
				}
				for (int num14 = 0; num14 < rainSoundsLeafy.Length; num14++)
				{
					ILoadedSound obj14 = rainSoundsLeafy[num14];
					if (obj14 != null)
					{
						obj14.Stop();
					}
				}
				rainSoundsOn = false;
			}
			if ((double)curHailVolume < 0.01)
			{
				ILoadedSound obj15 = hailSound;
				if (obj15 != null)
				{
					obj15.Stop();
				}
				hailSoundsOn = false;
			}
			float num15 = (1f - roomVolumePitchLoss) * blendedWeatherData.curWindSpeed.X - 0.3f;
			if (num15 > 0.03f || curWindVolumeLeafy > 0.01f || curWindVolumeLeafless > 0.01f)
			{
				if (!windSoundsOn)
				{
					ILoadedSound obj16 = windSoundLeafy;
					if (obj16 != null)
					{
						obj16.Start();
					}
					ILoadedSound obj17 = windSoundLeafless;
					if (obj17 != null)
					{
						obj17.Start();
					}
					windSoundsOn = true;
				}
				float num16 = num8 * 1.2f * num15;
				float num17 = (1f - num8) * 1.2f * num15;
				curWindVolumeLeafy += (num16 - curWindVolumeLeafy) * dt;
				curWindVolumeLeafless += (num17 - curWindVolumeLeafless) * dt;
				ILoadedSound obj18 = windSoundLeafy;
				if (obj18 != null)
				{
					obj18.SetVolume(Math.Max(0f, curWindVolumeLeafy));
				}
				ILoadedSound obj19 = windSoundLeafless;
				if (obj19 != null)
				{
					obj19.SetVolume(Math.Max(0f, curWindVolumeLeafless));
				}
			}
			else if (windSoundsOn)
			{
				ILoadedSound obj20 = windSoundLeafy;
				if (obj20 != null)
				{
					obj20.Stop();
				}
				ILoadedSound obj21 = windSoundLeafless;
				if (obj21 != null)
				{
					obj21.Stop();
				}
				windSoundsOn = false;
			}
		}

		public void Dispose()
		{
			if (rainSoundsLeafless != null)
			{
				ILoadedSound[] array = rainSoundsLeafless;
				for (int i = 0; i < array.Length; i++)
				{
					((IDisposable)array[i])?.Dispose();
				}
			}
			if (rainSoundsLeafy != null)
			{
				ILoadedSound[] array = rainSoundsLeafy;
				for (int i = 0; i < array.Length; i++)
				{
					((IDisposable)array[i])?.Dispose();
				}
			}
			((IDisposable)hailSound)?.Dispose();
			((IDisposable)lowTrembleSound)?.Dispose();
			((IDisposable)windSoundLeafy)?.Dispose();
			((IDisposable)windSoundLeafless)?.Dispose();
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class LightningFlashPacket
	{
		public Vec3d Pos;

		public int Seed;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class WeatherPatternAssetsPacket
	{
		public string Data;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class WeatherCloudYposPacket
	{
		public float CloudYRel;
	}
	public class WeatherPatternAssets
	{
		public WeatherSystemConfig GeneralConfig;

		public WeatherPatternConfig[] WeatherConfigs;

		public WindPatternConfig[] WindConfigs;

		public WeatherEventConfig[] WeatherEventConfigs;
	}
	[ProtoContract]
	public class WeatherState
	{
		[ProtoMember(1)]
		public int RegionX;

		[ProtoMember(2)]
		public int RegionZ;

		[ProtoMember(3)]
		public WeatherPatternState NewPattern;

		[ProtoMember(4)]
		public WeatherPatternState OldPattern;

		[ProtoMember(5)]
		public WindPatternState WindPattern;

		[ProtoMember(6)]
		public WeatherEventState WeatherEvent;

		[ProtoMember(7)]
		public float TransitionDelay;

		[ProtoMember(8)]
		public float Weight;

		[ProtoMember(9)]
		public bool Transitioning;

		[ProtoMember(10)]
		public bool updateInstant;

		[ProtoMember(11)]
		public double LastUpdateTotalHours;

		[ProtoMember(12)]
		public long LcgWorldSeed;

		[ProtoMember(13)]
		public long LcgMapGenSeed;

		[ProtoMember(14)]
		public long LcgCurrentSeed;

		[ProtoMember(15)]
		public SnowAccumSnapshot[] SnowAccumSnapshots;

		[ProtoMember(16)]
		public int Ringarraycursor;
	}
	[ProtoContract]
	public class WeatherConfigPacket
	{
		[ProtoMember(1)]
		public float? OverridePrecipitation;

		[ProtoMember(2)]
		public double RainCloudDaysOffset;
	}
	[ProtoContract]
	public class SnowAccumSnapshot
	{
		[ProtoMember(1)]
		public double TotalHours;

		[ProtoMember(2)]
		public FloatDataMap3D SumTemperatureByRegionCorner;

		[ProtoMember(3)]
		public int Checks;

		[ProtoMember(4)]
		public FloatDataMap3D SnowAccumulationByRegionCorner;

		public float GetAvgTemperatureByRegionCorner(float x, float y, float z)
		{
			return SumTemperatureByRegionCorner.GetLerped(x, y, z) / (float)Checks;
		}

		public float GetAvgSnowAccumByRegionCorner(float x, float y, float z)
		{
			return SnowAccumulationByRegionCorner.GetLerped(x, y, z);
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class WeatherPatternState
	{
		public bool BeginUseExecuted;

		public int Index;

		public float nowSceneBrightness = 1f;

		public float nowThicknessMul;

		public float nowbaseThickness;

		public float nowbaseOpaqueness;

		public float nowThinCloudModeness;

		public float nowUndulatingCloudModeness;

		public float nowCloudBrightness;

		public float nowHeightMul;

		public double ActiveUntilTotalHours;

		public float nowFogBrightness = 1f;

		public float nowFogDensity;

		public float nowMistDensity;

		public float nowMistYPos;

		public float nowNearLightningRate;

		public float nowDistantLightningRate;

		public float nowLightningMinTempature;

		public float nowPrecIntensity;

		public EnumPrecipitationType nowPrecType = EnumPrecipitationType.Auto;

		public float nowBasePrecIntensity;
	}
	public delegate void LightningImpactDelegate(ref Vec3d impactPos, ref EnumHandling handling);
	public abstract class WeatherSystemBase : ModSystem
	{
		public ICoreAPI api;

		public WeatherSystemConfig GeneralConfig;

		public WeatherPatternConfig[] WeatherConfigs;

		public WindPatternConfig[] WindConfigs;

		public WeatherEventConfig[] WeatherEventConfigs;

		public bool autoChangePatterns = true;

		public Dictionary<long, WeatherSimulationRegion> weatherSimByMapRegion = new Dictionary<long, WeatherSimulationRegion>();

		protected SimplexNoise precipitationNoise;

		protected SimplexNoise precipitationNoiseSub;

		public WeatherSimulationRegion dummySim;

		public WeatherDataReader WeatherDataSlowAccess;

		public WeatherPattern rainOverlayPattern;

		public WeatherDataSnapshot rainOverlaySnap;

		public WeatherSimulationLightning simLightning;

		private object weatherSimByMapRegionLock = new object();

		public virtual float? OverridePrecipitation { get; set; }

		public virtual double RainCloudDaysOffset { get; set; }

		public virtual int CloudTileSize { get; set; } = 50;

		public virtual float CloudLevelRel { get; set; } = 1f;

		public event LightningImpactDelegate OnLightningImpactBegin;

		public event LightningImpactDelegate OnLightningImpactEnd;

		public override void Start(ICoreAPI api)
		{
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Expected O, but got Unknown
			this.api = api;
			api.Network.RegisterChannel("weather").RegisterMessageType(typeof(WeatherState)).RegisterMessageType(typeof(WeatherConfigPacket))
				.RegisterMessageType(typeof(WeatherPatternAssetsPacket))
				.RegisterMessageType(typeof(LightningFlashPacket))
				.RegisterMessageType(typeof(WeatherCloudYposPacket));
			api.Event.OnGetWindSpeed += new OnGetWindSpeedDelegate(Event_OnGetWindSpeed);
		}

		private void Event_OnGetWindSpeed(Vec3d pos, ref Vec3d windSpeed)
		{
			windSpeed.X = WeatherDataSlowAccess.GetWindSpeed(pos);
		}

		public void Initialize()
		{
			precipitationNoise = SimplexNoise.FromDefaultOctaves(4, 1.0 / 150.0, 0.95, (long)(api.World.Seed - 18971121));
			precipitationNoiseSub = SimplexNoise.FromDefaultOctaves(3, 1.0 / 750.0, 0.95, (long)(api.World.Seed - 1717121));
			simLightning = new WeatherSimulationLightning(api, this);
		}

		public void InitDummySim()
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Expected O, but got Unknown
			dummySim = new WeatherSimulationRegion(this, 0, 0);
			dummySim.IsDummy = true;
			dummySim.Initialize();
			LCGRandom val = new LCGRandom((long)api.World.Seed);
			val.InitPositionSeed(3, 3);
			rainOverlayPattern = new WeatherPattern(this, GeneralConfig.RainOverlayPattern, val, 0, 0);
			rainOverlayPattern.Initialize(0, api.World.Seed);
			rainOverlayPattern.OnBeginUse();
			rainOverlaySnap = new WeatherDataSnapshot();
		}

		public double GetEnvironmentWetness(BlockPos pos, double days, double hourResolution = 2.0)
		{
			double num = api.World.Calendar.TotalDays - days;
			double totalDays = api.World.Calendar.TotalDays;
			double num2 = 0.0;
			double num3 = num;
			double num4 = api.World.Calendar.HoursPerDay;
			double num5 = 1.0 / 84.0;
			for (; num3 < totalDays; num3 += hourResolution / num4)
			{
				num2 += num5 * (double)api.World.BlockAccessor.GetClimateAt(pos, (EnumGetClimateMode)2, num3).Rainfall;
			}
			return GameMath.Clamp(num2, 0.0, 1.0);
		}

		public PrecipitationState GetPrecipitationState(Vec3d pos)
		{
			return GetPrecipitationState(pos, api.World.Calendar.TotalDays);
		}

		public PrecipitationState GetPrecipitationState(Vec3d pos, double totalDays)
		{
			float precipitation = GetPrecipitation(pos.X, pos.Y, pos.Z, totalDays);
			return new PrecipitationState
			{
				Level = Math.Max(0f, precipitation - 0.5f),
				ParticleSize = Math.Max(0f, precipitation - 0.5f),
				Type = ((precipitation > 0f) ? WeatherDataSlowAccess.GetPrecType(pos) : EnumPrecipitationType.Auto)
			};
		}

		public float GetPrecipitation(Vec3d pos)
		{
			return GetPrecipitation(pos.X, pos.Y, pos.Z, api.World.Calendar.TotalDays);
		}

		public float GetPrecipitation(double posX, double posY, double posZ)
		{
			return GetPrecipitation(posX, posY, posZ, api.World.Calendar.TotalDays);
		}

		public float GetPrecipitation(double posX, double posY, double posZ, double totalDays)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Expected O, but got Unknown
			ClimateCondition climateAt = api.World.BlockAccessor.GetClimateAt(new BlockPos((int)posX, (int)posY, (int)posZ), (EnumGetClimateMode)0, totalDays);
			return Math.Max(0f, GetRainCloudness(climateAt, posX, posZ, totalDays) - 0.5f);
		}

		public float GetPrecipitation(BlockPos pos, double totalDays, ClimateCondition conds)
		{
			return Math.Max(0f, GetRainCloudness(conds, (double)pos.X + 0.5, (double)pos.Z + 0.5, totalDays) - 0.5f);
		}

		protected void Event_OnGetClimate(ref ClimateCondition climate, BlockPos pos, EnumGetClimateMode mode = (EnumGetClimateMode)0, double totalDays = 0.0)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0003: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Invalid comparison between Unknown and I4
			if ((int)mode != 0 && (int)mode != 3)
			{
				float rainCloudness = GetRainCloudness(climate, (double)pos.X + 0.5, (double)pos.Z + 0.5, totalDays);
				climate.Rainfall = GameMath.Clamp(rainCloudness - 0.5f, 0f, 1f);
				climate.RainCloudOverlay = GameMath.Clamp(rainCloudness, 0f, 1f);
			}
		}

		public float GetRainCloudness(ClimateCondition conds, double posX, double posZ, double totalDays)
		{
			if (OverridePrecipitation.HasValue)
			{
				return OverridePrecipitation.Value + 0.5f;
			}
			float wgenRain = 0f;
			if (conds != null)
			{
				wgenRain = GameMath.Clamp((conds.Rainfall - 0.6f) * 2f, -1f, 1f);
			}
			return getPrecipNoise(posX, posZ, totalDays + RainCloudDaysOffset, wgenRain);
		}

		public ClimateCondition GetClimateFast(BlockPos pos, int climate)
		{
			return api.World.BlockAccessor.GetClimateAt(pos, climate);
		}

		private float getPrecipNoise(double posX, double posZ, double totalDays, float wgenRain)
		{
			return (float)GameMath.Max(precipitationNoise.Noise(posX / 9.0 / 2.0 + totalDays * 18.0, posZ / 9.0 / 2.0, totalDays * 4.0) * 1.600000023841858 - GameMath.Clamp(precipitationNoiseSub.Noise(posX / 4.0 / 2.0 + totalDays * 24.0, posZ / 4.0 / 2.0, totalDays * 6.0) * 5.0 - 1.0 - (double)wgenRain, 0.0, 1.0) + (double)wgenRain, 0.0);
		}

		public WeatherDataReader getWeatherDataReader()
		{
			return new WeatherDataReader(api, this);
		}

		public WeatherDataReaderPreLoad getWeatherDataReaderPreLoad()
		{
			return new WeatherDataReaderPreLoad(api, this);
		}

		public WeatherSimulationRegion getOrCreateWeatherSimForRegion(int regionX, int regionZ)
		{
			long index2d = MapRegionIndex2D(regionX, regionZ);
			IMapRegion mapRegion = api.World.BlockAccessor.GetMapRegion(regionX, regionZ);
			if (mapRegion == null)
			{
				return null;
			}
			return getOrCreateWeatherSimForRegion(index2d, mapRegion);
		}

		public WeatherSimulationRegion getOrCreateWeatherSimForRegion(long index2d, IMapRegion mapregion)
		{
			Vec3i val = MapRegionPosFromIndex2D(index2d);
			WeatherSimulationRegion value;
			lock (weatherSimByMapRegionLock)
			{
				if (weatherSimByMapRegion.TryGetValue(index2d, out value))
				{
					return value;
				}
			}
			value = new WeatherSimulationRegion(this, val.X, val.Z);
			value.Initialize();
			mapregion.RemoveModdata("weather");
			byte[] moddata = mapregion.GetModdata("weatherState");
			if (moddata != null)
			{
				try
				{
					value.FromBytes(moddata);
				}
				catch (Exception)
				{
					value.LoadRandomPattern();
					value.NewWePattern.OnBeginUse();
				}
			}
			else
			{
				value.LoadRandomPattern();
				value.NewWePattern.OnBeginUse();
				mapregion.SetModdata("weatherState", value.ToBytes());
			}
			value.MapRegion = mapregion;
			lock (weatherSimByMapRegionLock)
			{
				weatherSimByMapRegion[index2d] = value;
				return value;
			}
		}

		public long MapRegionIndex2D(int regionX, int regionZ)
		{
			return ((long)regionZ << 32) + regionX;
		}

		public Vec3i MapRegionPosFromIndex2D(long index)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Expected O, but got Unknown
			return new Vec3i((int)index, 0, (int)(index >> 32));
		}

		public virtual void SpawnLightningFlash(Vec3d pos)
		{
		}

		internal void TriggerOnLightningImpactStart(ref Vec3d impactPos, out EnumHandling handling)
		{
			handling = (EnumHandling)0;
			if (this.OnLightningImpactBegin != null)
			{
				TriggerOnLightningImpactAny(ref impactPos, out handling, this.OnLightningImpactBegin.GetInvocationList());
			}
		}

		internal void TriggerOnLightningImpactEnd(Vec3d impactPos, out EnumHandling handling)
		{
			handling = (EnumHandling)0;
			if (this.OnLightningImpactEnd != null)
			{
				TriggerOnLightningImpactAny(ref impactPos, out handling, this.OnLightningImpactEnd.GetInvocationList());
			}
		}

		internal void TriggerOnLightningImpactAny(ref Vec3d pos, out EnumHandling handling, Delegate[] delegates)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Invalid comparison between Unknown and I4
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Invalid comparison between Unknown and I4
			handling = (EnumHandling)0;
			for (int i = 0; i < delegates.Length; i++)
			{
				LightningImpactDelegate obj = (LightningImpactDelegate)delegates[i];
				EnumHandling handling2 = (EnumHandling)0;
				obj(ref pos, ref handling2);
				if ((int)handling2 == 3)
				{
					handling = (EnumHandling)3;
					break;
				}
				if ((int)handling2 == 2)
				{
					handling = (EnumHandling)2;
				}
			}
		}
	}
	public class WeatherSystemClient : WeatherSystemBase, IRenderer, IDisposable
	{
		public static float CurrentEnvironmentWetness4h;

		public ICoreClientAPI capi;

		public IClientNetworkChannel clientChannel;

		public CloudRenderer cloudRenderer;

		public ClimateCondition clientClimateCond;

		public bool playerChunkLoaded;

		private float quarterSecAccum;

		private BlockPos plrPos = new BlockPos();

		private Vec3d plrPosd = new Vec3d();

		public bool haveLevelFinalize;

		public WeatherSimulationSound simSounds;

		public WeatherSimulationParticles simParticles;

		public AuroraRenderer auroraRenderer;

		private long blendedLastCheckedMSDiv60 = -1L;

		private WeatherDataSnapshot blendedWeatherDataCached;

		public WeatherDataReaderPreLoad WeatherDataAtPlayer;

		private Vec3f windSpeedSmoothed = new Vec3f();

		private double windRandCounter;

		private Vec3f surfaceWindSpeedSmoothed = new Vec3f();

		private double surfaceWindRandCounter;

		private float wetnessScanAccum2s;

		private float flatFogd;

		private float targetFlatFogd;

		private Queue<WeatherState> weatherUpdateQueue = new Queue<WeatherState>();

		public WeatherDataSnapshot BlendedWeatherData
		{
			get
			{
				long num = capi.ElapsedMilliseconds / 60;
				if (num != blendedLastCheckedMSDiv60)
				{
					blendedLastCheckedMSDiv60 = num;
					blendedWeatherDataCached = WeatherDataAtPlayer.BlendedWeatherData;
					this.OnGetBlendedWeatherData(blendedWeatherDataCached);
				}
				return blendedWeatherDataCached;
			}
		}

		public double RenderOrder => -0.1;

		public int RenderRange => 999;

		public event Action<WeatherDataSnapshot> OnGetBlendedWeatherData;

		public override bool ShouldLoad(EnumAppSide side)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)side == 2;
		}

		public override void StartClientSide(ICoreClientAPI capi)
		{
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Expected O, but got Unknown
			this.capi = capi;
			Initialize();
			clientChannel = capi.Network.GetChannel("weather").SetMessageHandler<WeatherState>((NetworkServerMessageHandler<WeatherState>)OnWeatherUpdatePacket).SetMessageHandler<WeatherConfigPacket>((NetworkServerMessageHandler<WeatherConfigPacket>)OnWeatherConfigUpdatePacket)
				.SetMessageHandler<WeatherPatternAssetsPacket>((NetworkServerMessageHandler<WeatherPatternAssetsPacket>)OnAssetsPacket)
				.SetMessageHandler<LightningFlashPacket>((NetworkServerMessageHandler<LightningFlashPacket>)OnLightningFlashPacket)
				.SetMessageHandler<WeatherCloudYposPacket>((NetworkServerMessageHandler<WeatherCloudYposPacket>)OnCloudLevelRelPacket);
			((IEventAPI)capi.Event).RegisterGameTickListener((Action<float>)OnClientGameTick, 50, 0);
			capi.Event.LevelFinalize += LevelFinalizeInit;
			capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)0, "weatherSystem");
			capi.Event.RegisterRenderer((IRenderer)(object)this, (EnumRenderStage)12, "weatherSystem");
			capi.Event.LeaveWorld += delegate
			{
				cloudRenderer?.Dispose();
			};
			((IEventAPI)capi.Event).OnGetClimate += new OnGetClimateDelegate(base.Event_OnGetClimate);
			simSounds = new WeatherSimulationSound(capi, this);
			simParticles = new WeatherSimulationParticles(capi, this);
			auroraRenderer = new AuroraRenderer(capi, this);
			((ICoreAPI)capi).Logger.Notification("Initialised WeatherSystemClient. simLightning is " + ((simLightning == null) ? "null." : "loaded."));
		}

		private void OnCloudLevelRelPacket(WeatherCloudYposPacket msg)
		{
			CloudLevelRel = msg.CloudYRel;
		}

		private void OnAssetsPacket(WeatherPatternAssetsPacket msg)
		{
			WeatherPatternAssets weatherPatternAssets = JsonUtil.FromString<WeatherPatternAssets>(msg.Data);
			GeneralConfig = weatherPatternAssets.GeneralConfig;
			GeneralConfig.Init(api.World);
			WeatherConfigs = weatherPatternAssets.WeatherConfigs;
			WindConfigs = weatherPatternAssets.WindConfigs;
			WeatherEventConfigs = weatherPatternAssets.WeatherEventConfigs;
			foreach (KeyValuePair<long, WeatherSimulationRegion> item in weatherSimByMapRegion)
			{
				item.Value.ReloadPatterns(api.World.Seed);
			}
		}

		public void OnRenderFrame(float dt, EnumRenderStage stage)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			try
			{
				simLightning.OnRenderFrame(dt, stage);
			}
			catch (Exception ex)
			{
				if (simLightning == null)
				{
					api.Logger.Error("simLightning was null! Please report this as a bug");
				}
				api.Logger.Error(ex);
			}
			if ((int)stage != 0)
			{
				return;
			}
			EntityPlayer entity = ((IPlayer)capi.World.Player).Entity;
			plrPos.Set((int)((Entity)entity).Pos.X, (int)((Entity)entity).Pos.Y, (int)((Entity)entity).Pos.Z);
			plrPosd.Set(((Entity)entity).Pos.X, ((Entity)entity).Pos.Y, ((Entity)entity).Pos.Z);
			WeatherDataAtPlayer.LoadAdjacentSimsAndLerpValues(plrPosd, dt);
			WeatherDataAtPlayer.UpdateAdjacentAndBlendWeatherData();
			dt = Math.Min(0.5f, dt);
			Vec3d windSpeedAt = ((IWorldAccessor)capi.World).BlockAccessor.GetWindSpeedAt(plrPosd);
			Vec3f obj = windSpeedSmoothed;
			obj.X += ((float)windSpeedAt.X - windSpeedSmoothed.X) * dt;
			Vec3f obj2 = windSpeedSmoothed;
			obj2.Y += ((float)windSpeedAt.Y - windSpeedSmoothed.Y) * dt;
			Vec3f obj3 = windSpeedSmoothed;
			obj3.Z += ((float)windSpeedAt.Z - windSpeedSmoothed.Z) * dt;
			windRandCounter = (windRandCounter + (double)dt) % (Math.PI * 2000.0);
			double num = (2.0 * Math.Sin(windRandCounter / 8.0) + Math.Sin(windRandCounter / 2.0) + Math.Sin(0.5 + 2.0 * windRandCounter)) / 10.0;
			GlobalConstants.CurrentWindSpeedClient.Set(windSpeedSmoothed.X, windSpeedSmoothed.Y, windSpeedSmoothed.Z + (float)num * windSpeedSmoothed.X);
			int rainMapHeightAt = ((IWorldAccessor)capi.World).BlockAccessor.GetRainMapHeightAt(plrPos.X, plrPos.Z);
			plrPosd.Y = rainMapHeightAt;
			Vec3d windSpeedAt2 = ((IWorldAccessor)capi.World).BlockAccessor.GetWindSpeedAt(plrPosd);
			Vec3f obj4 = surfaceWindSpeedSmoothed;
			obj4.X += ((float)windSpeedAt2.X - surfaceWindSpeedSmoothed.X) * dt;
			Vec3f obj5 = surfaceWindSpeedSmoothed;
			obj5.Y += ((float)windSpeedAt2.Y - surfaceWindSpeedSmoothed.Y) * dt;
			Vec3f obj6 = surfaceWindSpeedSmoothed;
			obj6.Z += ((float)windSpeedAt2.Z - surfaceWindSpeedSmoothed.Z) * dt;
			surfaceWindRandCounter = (surfaceWindRandCounter + (double)dt) % (Math.PI * 2000.0);
			num = (2.0 * Math.Sin(surfaceWindRandCounter / 8.0) + Math.Sin(surfaceWindRandCounter / 2.0) + Math.Sin(0.5 + 2.0 * surfaceWindRandCounter)) / 10.0;
			GlobalConstants.CurrentSurfaceWindSpeedClient.Set(surfaceWindSpeedSmoothed.X, surfaceWindSpeedSmoothed.Y, surfaceWindSpeedSmoothed.Z + (float)num * surfaceWindSpeedSmoothed.X);
			capi.Ambient.CurrentModifiers["weather"] = WeatherDataAtPlayer.BlendedWeatherData.Ambient;
			wetnessScanAccum2s += dt;
			if (wetnessScanAccum2s > 2f)
			{
				wetnessScanAccum2s = 0f;
				double totalDays = ((IGameCalendar)capi.World.Calendar).TotalDays;
				float num2 = 0f;
				for (int i = 0; i < 12; i++)
				{
					float num3 = 1f - (float)i / 20f;
					num2 += num3 * ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(plrPos, (EnumGetClimateMode)2, totalDays - (double)i / 24.0 / 4.0).Rainfall;
				}
				CurrentEnvironmentWetness4h = GameMath.Clamp(num2, 0f, 1f);
			}
			int lightLevel = ((IWorldAccessor)capi.World).BlockAccessor.GetLightLevel(((Entity)((IPlayer)capi.World.Player).Entity).Pos.AsBlockPos, (EnumLightLevelType)1);
			float weight = ((WeightedValue<float>)(object)WeatherDataAtPlayer.BlendedWeatherData.Ambient.FlatFogDensity).Weight;
			targetFlatFogd = Math.Min(weight, GameMath.Clamp((float)lightLevel / 5f, 0f, 1f));
			flatFogd += (targetFlatFogd - flatFogd) * dt;
			((WeightedValue<float>)(object)capi.Ambient.CurrentModifiers["weather"].FlatFogDensity).Weight = flatFogd;
		}

		private void OnClientGameTick(float dt)
		{
			quarterSecAccum += dt;
			if (quarterSecAccum > 0.25f || clientClimateCond == null)
			{
				clientClimateCond = ((IWorldAccessor)capi.World).BlockAccessor.GetClimateAt(plrPos, (EnumGetClimateMode)1, 0.0);
				quarterSecAccum = 0f;
				playerChunkLoaded |= ((IWorldAccessor)capi.World).BlockAccessor.GetChunkAtBlockPos(plrPos) != null;
			}
			simLightning.ClientTick(dt);
			for (int i = 0; i < 4; i++)
			{
				WeatherSimulationRegion weatherSimulationRegion = WeatherDataAtPlayer.AdjacentSims[i];
				if (weatherSimulationRegion != dummySim)
				{
					weatherSimulationRegion.TickEvery25ms(dt);
				}
			}
			simSounds.Update(dt);
			rainOverlaySnap.climateCond = clientClimateCond;
			rainOverlaySnap.SetAmbient(rainOverlayPattern, (capi == null) ? 0f : ((WeightedValue<float>)(object)capi.Ambient.Base.FogDensity).Value);
		}

		private void OnWeatherConfigUpdatePacket(WeatherConfigPacket packet)
		{
			OverridePrecipitation = packet.OverridePrecipitation;
			RainCloudDaysOffset = packet.RainCloudDaysOffset;
		}

		private void OnWeatherUpdatePacket(WeatherState msg)
		{
			weatherUpdateQueue.Enqueue(msg);
		}

		public void ProcessWeatherUpdates()
		{
			foreach (WeatherState item in weatherUpdateQueue)
			{
				ProcessWeatherUpdate(item);
			}
			weatherUpdateQueue.Clear();
		}

		private void ProcessWeatherUpdate(WeatherState msg)
		{
			WeatherSimulationRegion orCreateWeatherSimForRegion = getOrCreateWeatherSimForRegion(msg.RegionX, msg.RegionZ);
			if (orCreateWeatherSimForRegion == null)
			{
				api.Logger.Warning("weatherSim for region {0}/{1} is null. No idea what to do here", new object[2] { msg.RegionX, msg.RegionZ });
				return;
			}
			if (msg.updateInstant)
			{
				orCreateWeatherSimForRegion.ReloadPatterns(api.World.Seed);
				for (int i = 0; i < orCreateWeatherSimForRegion.WeatherPatterns.Length; i++)
				{
					orCreateWeatherSimForRegion.WeatherPatterns[i].Initialize(i, api.World.Seed);
				}
			}
			orCreateWeatherSimForRegion.NewWePattern = orCreateWeatherSimForRegion.WeatherPatterns[Math.Min(orCreateWeatherSimForRegion.WeatherPatterns.Length - 1, msg.NewPattern.Index)];
			orCreateWeatherSimForRegion.NewWePattern.State = msg.NewPattern;
			orCreateWeatherSimForRegion.OldWePattern = orCreateWeatherSimForRegion.WeatherPatterns[Math.Min(orCreateWeatherSimForRegion.WeatherPatterns.Length - 1, msg.OldPattern.Index)];
			orCreateWeatherSimForRegion.OldWePattern.State = msg.OldPattern;
			orCreateWeatherSimForRegion.TransitionDelay = msg.TransitionDelay;
			orCreateWeatherSimForRegion.Transitioning = msg.Transitioning;
			orCreateWeatherSimForRegion.Weight = msg.Weight;
			orCreateWeatherSimForRegion.CurWindPattern = orCreateWeatherSimForRegion.WindPatterns[Math.Min(orCreateWeatherSimForRegion.WindPatterns.Length - 1, msg.WindPattern.Index)];
			orCreateWeatherSimForRegion.CurWindPattern.State = msg.WindPattern;
			orCreateWeatherSimForRegion.CurWeatherEvent = orCreateWeatherSimForRegion.WeatherEvents[Math.Min(orCreateWeatherSimForRegion.WeatherEvents.Length - 1, msg.WeatherEvent.Index)];
			orCreateWeatherSimForRegion.CurWeatherEvent.State = msg.WeatherEvent;
			if (msg.updateInstant)
			{
				orCreateWeatherSimForRegion.NewWePattern.OnBeginUse();
				cloudRenderer.instantTileBlend = true;
			}
			if (msg.Transitioning)
			{
				orCreateWeatherSimForRegion.Weight = 0f;
			}
			if (msg.updateInstant)
			{
				orCreateWeatherSimForRegion.TickEvery25ms(0.025f);
				cloudRenderer.UpdateCloudTiles(32767);
			}
		}

		private void LevelFinalizeInit()
		{
			InitDummySim();
			WeatherDataAtPlayer = getWeatherDataReaderPreLoad();
			WeatherDataSlowAccess = getWeatherDataReader();
			simSounds.Initialize();
			simParticles.Initialize();
			cloudRenderer = new CloudRenderer(capi, this);
			capi.Ambient.CurrentModifiers.InsertBefore("serverambient", "weather", WeatherDataAtPlayer.BlendedWeatherData.Ambient);
			haveLevelFinalize = true;
			capi.Ambient.UpdateAmbient(0.1f);
			cloudRenderer.CloudTick(0.1f);
			((ICoreAPI)capi).Logger.VerboseDebug("Done init WeatherSystemClient");
		}

		public override void Dispose()
		{
			((ModSystem)this).Dispose();
			simSounds?.Dispose();
		}

		private void OnLightningFlashPacket(LightningFlashPacket msg)
		{
			if (capi.World.Player != null)
			{
				simLightning.genLightningFlash(msg.Pos, msg.Seed);
			}
		}

		public override void SpawnLightningFlash(Vec3d pos)
		{
			simLightning.genLightningFlash(pos);
		}
	}
	public class PrecipitationState
	{
		public double Level;

		public double ParticleSize;

		public EnumPrecipitationType Type;
	}
	[JsonObject(/*Could not decode attribute arguments.*/)]
	public class WeatherSystemConfig
	{
		[JsonProperty]
		public AssetLocation[] SnowLayerBlockCodes;

		[JsonProperty]
		public WeatherPatternConfig RainOverlayPattern;

		public OrderedDictionary<Block, int> SnowLayerBlocks;

		internal void Init(IWorldAccessor world)
		{
			SnowLayerBlocks = new OrderedDictionary<Block, int>();
			int num = 0;
			AssetLocation[] snowLayerBlockCodes = SnowLayerBlockCodes;
			foreach (AssetLocation val in snowLayerBlockCodes)
			{
				Block block = world.GetBlock(val);
				if (block == null)
				{
					world.Logger.Error("config/weather.json: No such block found: '{0}', will ignore.", new object[1] { val });
				}
				else
				{
					SnowLayerBlocks[block] = num++;
				}
			}
		}
	}
	public class WeatherSystemServer : WeatherSystemBase
	{
		public ICoreServerAPI sapi;

		public IServerNetworkChannel serverChannel;

		internal WeatherSimulationSnowAccum snowSimSnowAccu;

		protected WeatherPatternAssetsPacket packetForClient;

		private float? overrideprecip;

		private double daysoffset;

		public override float? OverridePrecipitation
		{
			get
			{
				return overrideprecip;
			}
			set
			{
				overrideprecip = value;
				sapi.WorldManager.SaveGame.StoreData("overrideprecipitation", (!overrideprecip.HasValue) ? null : SerializerUtil.Serialize<float>(overrideprecip.Value));
			}
		}

		public override double RainCloudDaysOffset
		{
			get
			{
				return daysoffset;
			}
			set
			{
				daysoffset = value;
				sapi.WorldManager.SaveGame.StoreData("precipitationdaysoffset", SerializerUtil.Serialize<double>(daysoffset));
			}
		}

		public override bool ShouldLoad(EnumAppSide side)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			return (int)side == 1;
		}

		public override void StartServerSide(ICoreServerAPI api)
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Expected O, but got Unknown
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			sapi = api;
			LoadConfigs();
			serverChannel = api.Network.GetChannel("weather");
			((IEventAPI)sapi.Event).RegisterGameTickListener((Action<float>)OnServerGameTick, 200, 0);
			sapi.Event.GameWorldSave += OnSaveGameSaving;
			sapi.Event.SaveGameLoaded += Event_SaveGameLoaded;
			((IEventAPI)sapi.Event).OnGetClimate += new OnGetClimateDelegate(base.Event_OnGetClimate);
			sapi.Event.PlayerJoin += new PlayerDelegate(Event_PlayerJoin);
			snowSimSnowAccu = new WeatherSimulationSnowAccum(sapi, this);
		}

		public void ReloadConfigs()
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Expected O, but got Unknown
			api.Assets.Reload(new AssetLocation("config/"));
			LoadConfigs(isReload: true);
			IPlayer[] allOnlinePlayers = ((IWorldAccessor)sapi.World).AllOnlinePlayers;
			foreach (IPlayer val in allOnlinePlayers)
			{
				serverChannel.SendPacket<WeatherPatternAssetsPacket>(packetForClient, (IServerPlayer[])(object)new IServerPlayer[1] { (IServerPlayer)((val is IServerPlayer) ? val : null) });
			}
		}

		public void LoadConfigs(bool isReload = false)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Expected O, but got Unknown
			WeatherSystemConfig weatherSystemConfig = api.Assets.Get<WeatherSystemConfig>(new AssetLocation("config/weather.json"));
			if (isReload)
			{
				weatherSystemConfig.Init(api.World);
			}
			GeneralConfig = weatherSystemConfig;
			WeatherPatternConfig[][] array = (from val in api.Assets.GetMany<WeatherPatternConfig[]>(api.World.Logger, "config/weatherpatterns/", (string)null)
				orderby ((object)val.Key).ToString()
				select val.Value).ToArray();
			WeatherConfigs = Array.Empty<WeatherPatternConfig>();
			WeatherPatternConfig[][] array2 = array;
			foreach (WeatherPatternConfig[] array3 in array2)
			{
				WeatherConfigs = ArrayExtensions.Append<WeatherPatternConfig>(WeatherConfigs, array3);
			}
			WindPatternConfig[][] array4 = (from val in api.Assets.GetMany<WindPatternConfig[]>(api.World.Logger, "config/windpatterns/", (string)null)
				orderby ((object)val.Key).ToString()
				select val.Value).ToArray();
			WindConfigs = Array.Empty<WindPatternConfig>();
			WindPatternConfig[][] array5 = array4;
			foreach (WindPatternConfig[] array6 in array5)
			{
				WindConfigs = ArrayExtensions.Append<WindPatternConfig>(WindConfigs, array6);
			}
			WeatherEventConfig[][] array7 = (from val in api.Assets.GetMany<WeatherEventConfig[]>(api.World.Logger, "config/weatherevents/", (string)null)
				orderby ((object)val.Key).ToString()
				select val.Value).ToArray();
			WeatherEventConfigs = Array.Empty<WeatherEventConfig>();
			WeatherEventConfig[][] array8 = array7;
			foreach (WeatherEventConfig[] array9 in array8)
			{
				WeatherEventConfigs = ArrayExtensions.Append<WeatherEventConfig>(WeatherEventConfigs, array9);
			}
			api.World.Logger.Notification("Reloaded {0} weather patterns, {1} wind patterns and {2} weather events", new object[3] { WeatherConfigs.Length, WindConfigs.Length, WeatherEventConfigs.Length });
			WeatherPatternAssets weatherPatternAssets = new WeatherPatternAssets
			{
				GeneralConfig = GeneralConfig,
				WeatherConfigs = WeatherConfigs,
				WindConfigs = WindConfigs,
				WeatherEventConfigs = WeatherEventConfigs
			};
			packetForClient = new WeatherPatternAssetsPacket
			{
				Data = JsonUtil.ToString<WeatherPatternAssets>(weatherPatternAssets)
			};
		}

		private void Event_PlayerJoin(IServerPlayer byPlayer)
		{
			serverChannel.SendPacket<WeatherPatternAssetsPacket>(packetForClient, (IServerPlayer[])(object)new IServerPlayer[1] { byPlayer });
			serverChannel.SendPacket<WeatherCloudYposPacket>(new WeatherCloudYposPacket
			{
				CloudYRel = CloudLevelRel
			}, (IServerPlayer[])(object)new IServerPlayer[1] { byPlayer });
			sendConfigUpdate(byPlayer);
		}

		public void sendConfigUpdate(IServerPlayer byPlayer)
		{
			serverChannel.SendPacket<WeatherConfigPacket>(new WeatherConfigPacket
			{
				OverridePrecipitation = OverridePrecipitation,
				RainCloudDaysOffset = RainCloudDaysOffset
			}, (IServerPlayer[])(object)new IServerPlayer[1] { byPlayer });
		}

		public void broadCastConfigUpdate()
		{
			serverChannel.BroadcastPacket<WeatherConfigPacket>(new WeatherConfigPacket
			{
				OverridePrecipitation = OverridePrecipitation,
				RainCloudDaysOffset = RainCloudDaysOffset
			}, Array.Empty<IServerPlayer>());
		}

		private void Event_SaveGameLoaded()
		{
			byte[] data = sapi.WorldManager.SaveGame.GetData("overrideprecipitation");
			if (data != null)
			{
				overrideprecip = SerializerUtil.Deserialize<float>(data);
			}
			data = sapi.WorldManager.SaveGame.GetData("precipitationdaysoffset");
			if (data != null)
			{
				daysoffset = SerializerUtil.Deserialize<double>(data);
			}
			Initialize();
			InitDummySim();
			WeatherDataSlowAccess = getWeatherDataReader();
			GeneralConfig.Init(api.World);
			if (sapi.WorldManager.SaveGame.WorldConfiguration != null)
			{
				CloudLevelRel = StringUtil.ToFloat(sapi.WorldManager.SaveGame.WorldConfiguration.GetString("cloudypos", "1"), 1f);
			}
		}

		public void SendWeatherStateUpdate(WeatherState state)
		{
			int regionSize = sapi.WorldManager.RegionSize;
			byte[] array = SerializerUtil.Serialize<WeatherState>(state);
			IPlayer[] allOnlinePlayers = ((IWorldAccessor)sapi.World).AllOnlinePlayers;
			List<IServerPlayer> list = new List<IServerPlayer>(allOnlinePlayers.Length);
			IPlayer[] array2 = allOnlinePlayers;
			foreach (IPlayer val in array2)
			{
				int num = (int)((Entity)val.Entity).ServerPos.X / regionSize;
				int num2 = (int)((Entity)val.Entity).ServerPos.Z / regionSize;
				if (Math.Abs(state.RegionX - num) <= 1 && Math.Abs(state.RegionZ - num2) <= 1)
				{
					list.Add((IServerPlayer)(object)((val is IServerPlayer) ? val : null));
				}
			}
			if (list.Count > 0)
			{
				serverChannel.SendPacket<WeatherState>(state, array, list.ToArray());
			}
			IMapRegion mapRegion = sapi.WorldManager.GetMapRegion(state.RegionX, state.RegionZ);
			if (mapRegion != null)
			{
				mapRegion.SetModdata("weatherState", array);
			}
		}

		private void OnServerGameTick(float dt)
		{
			((IWorldAccessor)sapi.World).FrameProfiler.Enter("weathersimulation");
			foreach (KeyValuePair<long, IMapRegion> allLoadedMapRegion in sapi.WorldManager.AllLoadedMapRegions)
			{
				WeatherSimulationRegion orCreateWeatherSimForRegion = getOrCreateWeatherSimForRegion(allLoadedMapRegion.Key, allLoadedMapRegion.Value);
				orCreateWeatherSimForRegion.TickEvery25ms(dt);
				((IWorldAccessor)sapi.World).FrameProfiler.Mark("finishedtick");
				orCreateWeatherSimForRegion.UpdateWeatherData();
				((IWorldAccessor)sapi.World).FrameProfiler.Mark("updatedata");
			}
			rainOverlaySnap.SetAmbient(rainOverlayPattern);
			((IWorldAccessor)sapi.World).FrameProfiler.Leave();
		}

		private void OnSaveGameSaving()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Expected O, but got Unknown
			HashSet<long> hashSet = new HashSet<long>();
			FastMemoryStream val = new FastMemoryStream();
			try
			{
				foreach (KeyValuePair<long, WeatherSimulationRegion> item in weatherSimByMapRegion)
				{
					IMapRegion mapRegion = sapi.WorldManager.GetMapRegion(item.Key);
					if (mapRegion != null)
					{
						mapRegion.SetModdata("weatherState", item.Value.ToBytes(val));
					}
					else
					{
						hashSet.Add(item.Key);
					}
				}
				foreach (long item2 in hashSet)
				{
					weatherSimByMapRegion.Remove(item2);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public override void SpawnLightningFlash(Vec3d pos)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			TriggerOnLightningImpactStart(ref pos, out var handling);
			if ((int)handling == 0)
			{
				LightningFlashPacket lightningFlashPacket = new LightningFlashPacket
				{
					Pos = pos,
					Seed = api.World.Rand.Next()
				};
				serverChannel.BroadcastPacket<LightningFlashPacket>(lightningFlashPacket, Array.Empty<IServerPlayer>());
				LightningFlash item = new LightningFlash(this, api, lightningFlashPacket.Seed, lightningFlashPacket.Pos);
				simLightning.lightningFlashes.Add(item);
			}
		}
	}
	public class BlurTool
	{
		public static void Blur(byte[] data, int sizeX, int sizeZ, int range)
		{
			BoxBlurHorizontal(data, range, 0, 0, sizeX, sizeZ);
			BoxBlurVertical(data, range, 0, 0, sizeX, sizeZ);
		}

		public unsafe static void BoxBlurHorizontal(byte[] map, int range, int xStart, int yStart, int xEnd, int yEnd)
		{
			fixed (byte* ptr = map)
			{
				int num = xEnd - xStart;
				int num2 = range / 2;
				int num3 = yStart * num;
				byte[] array = new byte[num];
				for (int i = yStart; i < yEnd; i++)
				{
					int num4 = 0;
					int num5 = 0;
					for (int j = xStart - num2; j < xEnd; j++)
					{
						int num6 = j - num2 - 1;
						if (num6 >= xStart)
						{
							byte b = ptr[num3 + num6];
							if (b != 0)
							{
								num5 -= b;
							}
							num4--;
						}
						int num7 = j + num2;
						if (num7 < xEnd)
						{
							byte b2 = ptr[num3 + num7];
							if (b2 != 0)
							{
								num5 += b2;
							}
							num4++;
						}
						if (j >= xStart)
						{
							byte b3 = (byte)(num5 / num4);
							array[j] = b3;
						}
					}
					for (int k = xStart; k < xEnd; k++)
					{
						ptr[num3 + k] = array[k];
					}
					num3 += num;
				}
			}
		}

		public unsafe static void BoxBlurVertical(byte[] map, int range, int xStart, int yStart, int xEnd, int yEnd)
		{
			fixed (byte* ptr = map)
			{
				int num = xEnd - xStart;
				int num2 = yEnd - yStart;
				int num3 = range / 2;
				byte[] array = new byte[num2];
				int num4 = -(num3 + 1) * num;
				int num5 = num3 * num;
				for (int i = xStart; i < xEnd; i++)
				{
					int num6 = 0;
					int num7 = 0;
					int num8 = yStart * num - num3 * num + i;
					for (int j = yStart - num3; j < yEnd; j++)
					{
						if (j - num3 - 1 >= yStart)
						{
							byte b = ptr[num8 + num4];
							if (b != 0)
							{
								num7 -= b;
							}
							num6--;
						}
						if (j + num3 < yEnd)
						{
							byte b2 = ptr[num8 + num5];
							if (b2 != 0)
							{
								num7 += b2;
							}
							num6++;
						}
						if (j >= yStart)
						{
							byte b3 = (byte)(num7 / num6);
							array[j] = b3;
						}
						num8 += num;
					}
					for (int k = yStart; k < yEnd; k++)
					{
						ptr[k * num + i] = array[k];
					}
				}
			}
		}
	}
	public class ReadyMapPiece
	{
		public int[] Pixels;

		public FastVec2i Cord;
	}
	public class ChunkMapLayer : RGBMapLayer
	{
		public static Dictionary<EnumBlockMaterial, string> defaultMapColorCodes = new Dictionary<EnumBlockMaterial, string>
		{
			{
				(EnumBlockMaterial)1,
				"land"
			},
			{
				(EnumBlockMaterial)3,
				"desert"
			},
			{
				(EnumBlockMaterial)7,
				"land"
			},
			{
				(EnumBlockMaterial)2,
				"desert"
			},
			{
				(EnumBlockMaterial)6,
				"land"
			},
			{
				(EnumBlockMaterial)5,
				"forest"
			},
			{
				(EnumBlockMaterial)13,
				"plant"
			},
			{
				(EnumBlockMaterial)4,
				"forest"
			},
			{
				(EnumBlockMaterial)9,
				"glacier"
			},
			{
				(EnumBlockMaterial)8,
				"lake"
			},
			{
				(EnumBlockMaterial)10,
				"glacier"
			},
			{
				(EnumBlockMaterial)17,
				"lava"
			}
		};

		public static OrderedDictionary<string, string> hexColorsByCode;

		public OrderedDictionary<string, int> colorsByCode = new OrderedDictionary<string, int>();

		private int[] colors;

		public byte[] block2Color;

		private const int chunksize = 32;

		private IWorldChunk[] chunksTmp;

		private object chunksToGenLock = new object();

		private UniqueQueue<FastVec2i> chunksToGen = new UniqueQueue<FastVec2i>();

		private ConcurrentDictionary<FastVec2i, MultiChunkMapComponent> loadedMapData = new ConcurrentDictionary<FastVec2i, MultiChunkMapComponent>();

		private HashSet<FastVec2i> curVisibleChunks = new HashSet<FastVec2i>();

		private ConcurrentQueue<ReadyMapPiece> readyMapPieces = new ConcurrentQueue<ReadyMapPiece>();

		private MapDB mapdb;

		private ICoreClientAPI capi;

		private bool colorAccurate;

		private float mtThread1secAccum;

		private float genAccum;

		private float diskSaveAccum;

		private Dictionary<FastVec2i, MapPieceDB> toSaveList = new Dictionary<FastVec2i, MapPieceDB>();

		[ThreadStatic]
		private static byte[] shadowMapReusable;

		[ThreadStatic]
		private static byte[] shadowMapBlurReusable;

		public override MapLegendItem[] LegendItems
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		public override EnumMinMagFilter MinFilter => EnumMinMagFilter.Linear;

		public override EnumMinMagFilter MagFilter => EnumMinMagFilter.Nearest;

		public override string Title => "Terrain";

		public override EnumMapAppSide DataSide => EnumMapAppSide.Client;

		public override string LayerGroupCode => "terrain";

		public string getMapDbFilePath()
		{
			string text = Path.Combine(GamePaths.DataPath, "Maps");
			GamePaths.EnsurePathExists(text);
			return Path.Combine(text, api.World.SavegameIdentifier + ".db");
		}

		public ChunkMapLayer(ICoreAPI api, IWorldMapManager mapSink)
			: base(api, mapSink)
		{
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Invalid comparison between Unknown and I4
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Invalid comparison between Unknown and I4
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Expected O, but got Unknown
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_0183: Expected O, but got Unknown
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Expected O, but got Unknown
			foreach (KeyValuePair<string, string> item in hexColorsByCode)
			{
				colorsByCode[item.Key] = ColorUtil.ReverseColorBytes(ColorUtil.Hex2Int(item.Value));
			}
			api.Event.ChunkDirty += new ChunkDirtyDelegate(Event_OnChunkDirty);
			capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			if ((int)api.Side == 1)
			{
				((ICoreServerAPI)((api is ICoreServerAPI) ? api : null)).Event.DidPlaceBlock += new BlockPlacedDelegate(Event_DidPlaceBlock);
			}
			if ((int)api.Side == 2)
			{
				api.World.Logger.Notification("Loading world map cache db...");
				mapdb = new MapDB(api.World.Logger);
				string text = null;
				string mapDbFilePath = getMapDbFilePath();
				((SQLiteDBConnection)mapdb).OpenOrCreate(mapDbFilePath, ref text, true, true, false);
				if (text != null)
				{
					throw new Exception($"Cannot open {mapDbFilePath}, possibly corrupted. Please fix manually or delete this file to continue playing");
				}
				api.ChatCommands.GetOrCreate("map").BeginSubCommand("purgedb").WithDescription("purge the map db")
					.HandleWith((OnCommandDelegate)delegate
					{
						mapdb.Purge();
						return TextCommandResult.Success("Ok, db purged", (object)null);
					})
					.EndSubCommand()
					.BeginSubCommand("redraw")
					.WithDescription("Redraw the map")
					.HandleWith(new OnCommandDelegate(OnMapCmdRedraw))
					.EndSubCommand();
			}
		}

		private TextCommandResult OnMapCmdRedraw(TextCommandCallingArgs args)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			foreach (MultiChunkMapComponent value in loadedMapData.Values)
			{
				value.ActuallyDispose();
			}
			loadedMapData.Clear();
			lock (chunksToGenLock)
			{
				foreach (FastVec2i curVisibleChunk in curVisibleChunks)
				{
					FastVec2i current = curVisibleChunk;
					chunksToGen.Enqueue(((FastVec2i)(ref current)).Copy());
				}
			}
			return TextCommandResult.Success("Redrawing map...", (object)null);
		}

		private void Event_DidPlaceBlock(IServerPlayer byPlayer, int oldblockId, BlockSelection blockSel, ItemStack withItemStack)
		{
			IMapChunk mapChunkAtBlockPos = api.World.BlockAccessor.GetMapChunkAtBlockPos(blockSel.Position);
			if (mapChunkAtBlockPos != null)
			{
				int num = blockSel.Position.X % 32;
				int num2 = blockSel.Position.Z % 32;
				int num3 = mapChunkAtBlockPos.RainHeightMap[num2 * 32 + num];
				int num4 = num3 % 32;
				IWorldChunk chunkAtBlockPos = api.World.BlockAccessor.GetChunkAtBlockPos(blockSel.Position.X, num3, blockSel.Position.Z);
				if (chunkAtBlockPos != null && chunkAtBlockPos.UnpackAndReadBlock((num4 * 32 + num2) * 32 + num, 3) == 0)
				{
					int num5 = blockSel.Position.X / 32;
					int num6 = blockSel.Position.Z / 32;
					api.World.Logger.Notification("Huh. Found air block in rain map at chunk pos {0}/{1}. That seems invalid, will regenerate rain map", new object[2] { num5, num6 });
					rebuildRainmap(num5, num6);
				}
			}
		}

		private void Event_OnChunkDirty(Vec3i chunkCoord, IWorldChunk chunk, EnumChunkDirtyReason reason)
		{
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			lock (chunksToGenLock)
			{
				if (mapSink.IsOpened)
				{
					FastVec2i key = default(FastVec2i);
					((FastVec2i)(ref key))._002Ector(chunkCoord.X / 3, chunkCoord.Z / 3);
					FastVec2i item = default(FastVec2i);
					((FastVec2i)(ref item))._002Ector(chunkCoord.X, chunkCoord.Z);
					if (loadedMapData.ContainsKey(key) || curVisibleChunks.Contains(item))
					{
						chunksToGen.Enqueue(new FastVec2i(chunkCoord.X, chunkCoord.Z));
						chunksToGen.Enqueue(new FastVec2i(chunkCoord.X, chunkCoord.Z - 1));
						chunksToGen.Enqueue(new FastVec2i(chunkCoord.X - 1, chunkCoord.Z));
						chunksToGen.Enqueue(new FastVec2i(chunkCoord.X, chunkCoord.Z + 1));
						chunksToGen.Enqueue(new FastVec2i(chunkCoord.X + 1, chunkCoord.Z + 1));
					}
				}
			}
		}

		public override void OnLoaded()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Invalid comparison between Unknown and I4
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			if ((int)api.Side == 1)
			{
				return;
			}
			chunksTmp = (IWorldChunk[])(object)new IWorldChunk[api.World.BlockAccessor.MapSizeY / 32];
			colors = new int[colorsByCode.Count];
			for (int i = 0; i < colors.Length; i++)
			{
				colors[i] = colorsByCode.GetValueAtIndex(i);
			}
			IList<Block> blocks = api.World.Blocks;
			block2Color = new byte[blocks.Count];
			for (int j = 0; j < block2Color.Length; j++)
			{
				Block val = blocks[j];
				string value = "land";
				if (((CollectibleObject)(val?)).Attributes != null)
				{
					value = ((CollectibleObject)val).Attributes["mapColorCode"].AsString((string)null);
					if (value == null && !defaultMapColorCodes.TryGetValue(val.BlockMaterial, out value))
					{
						value = "land";
					}
				}
				block2Color[j] = (byte)colorsByCode.IndexOfKey(value);
				if (colorsByCode.IndexOfKey(value) < 0)
				{
					throw new Exception("No color exists for color code " + value);
				}
			}
		}

		public override void OnMapOpenedClient()
		{
			colorAccurate = api.World.Config.GetAsBool("colorAccurateWorldmap", false) || ArrayExtensions.IndexOf<string>(((IPlayer)capi.World.Player).Privileges, "colorAccurateWorldmap") != -1;
		}

		public override void OnMapClosedClient()
		{
			lock (chunksToGenLock)
			{
				chunksToGen.Clear();
			}
			curVisibleChunks.Clear();
		}

		public override void Dispose()
		{
			if (loadedMapData != null)
			{
				foreach (MultiChunkMapComponent value in loadedMapData.Values)
				{
					value?.ActuallyDispose();
				}
			}
			MultiChunkMapComponent.DisposeStatic();
			base.Dispose();
		}

		public override void OnShutDown()
		{
			LoadedTexture tmpTexture = MultiChunkMapComponent.tmpTexture;
			if (tmpTexture != null)
			{
				tmpTexture.Dispose();
			}
			MapDB mapDB = mapdb;
			if (mapDB != null)
			{
				((SQLiteDBConnection)mapDB).Dispose();
			}
		}

		public override void OnOffThreadTick(float dt)
		{
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01de: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			genAccum += dt;
			if ((double)genAccum < 0.1)
			{
				return;
			}
			genAccum = 0f;
			int num = chunksToGen.Count;
			while (num > 0 && !mapSink.IsShuttingDown)
			{
				num--;
				FastVec2i val;
				lock (chunksToGenLock)
				{
					if (chunksToGen.Count == 0)
					{
						break;
					}
					val = chunksToGen.Dequeue();
					goto IL_0091;
				}
				IL_0091:
				if (!api.World.BlockAccessor.IsValidPos(((FastVec2i)(ref val)).X * 32, 1, ((FastVec2i)(ref val)).Y * 32))
				{
					continue;
				}
				IMapChunk mapChunk = api.World.BlockAccessor.GetMapChunk(((FastVec2i)(ref val)).X, ((FastVec2i)(ref val)).Y);
				if (mapChunk == null)
				{
					try
					{
						MapPieceDB mapPiece = mapdb.GetMapPiece(val);
						if (mapPiece?.Pixels != null)
						{
							loadFromChunkPixels(val, mapPiece.Pixels);
						}
					}
					catch (ProtoException)
					{
						api.Logger.Warning("Failed loading map db section {0}/{1}, a protobuf exception was thrown. Will ignore.", new object[2]
						{
							((FastVec2i)(ref val)).X,
							((FastVec2i)(ref val)).Y
						});
					}
					catch (OverflowException)
					{
						api.Logger.Warning("Failed loading map db section {0}/{1}, a overflow exception was thrown. Will ignore.", new object[2]
						{
							((FastVec2i)(ref val)).X,
							((FastVec2i)(ref val)).Y
						});
					}
					continue;
				}
				int[] array = GenerateChunkImage(val, mapChunk, colorAccurate);
				if (array == null)
				{
					lock (chunksToGenLock)
					{
						chunksToGen.Enqueue(val);
					}
				}
				else
				{
					toSaveList[((FastVec2i)(ref val)).Copy()] = new MapPieceDB
					{
						Pixels = array
					};
					loadFromChunkPixels(val, array);
				}
			}
			if (toSaveList.Count > 100 || diskSaveAccum > 4f)
			{
				diskSaveAccum = 0f;
				mapdb.SetMapPieces(toSaveList);
				toSaveList.Clear();
			}
		}

		public override void OnTick(float dt)
		{
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			if (!readyMapPieces.IsEmpty)
			{
				int num = Math.Min(readyMapPieces.Count, 200);
				List<MultiChunkMapComponent> list = new List<MultiChunkMapComponent>();
				FastVec2i key = default(FastVec2i);
				FastVec2i baseChunkCord = default(FastVec2i);
				while (num-- > 0)
				{
					if (readyMapPieces.TryDequeue(out var result))
					{
						((FastVec2i)(ref key))._002Ector(((FastVec2i)(ref result.Cord)).X / 3, ((FastVec2i)(ref result.Cord)).Y / 3);
						((FastVec2i)(ref baseChunkCord))._002Ector(((FastVec2i)(ref key)).X * 3, ((FastVec2i)(ref key)).Y * 3);
						if (!loadedMapData.TryGetValue(key, out var value))
						{
							value = (loadedMapData[key] = new MultiChunkMapComponent((ICoreClientAPI)/*isinst with value type is only supported in some contexts*/, baseChunkCord));
						}
						value.setChunk(((FastVec2i)(ref result.Cord)).X - ((FastVec2i)(ref baseChunkCord)).X, ((FastVec2i)(ref result.Cord)).Y - ((FastVec2i)(ref baseChunkCord)).Y, result.Pixels);
						list.Add(value);
					}
				}
				foreach (MultiChunkMapComponent item in list)
				{
					item.FinishSetChunks();
				}
			}
			mtThread1secAccum += dt;
			if (!(mtThread1secAccum > 1f))
			{
				return;
			}
			List<FastVec2i> list2 = new List<FastVec2i>();
			foreach (KeyValuePair<FastVec2i, MultiChunkMapComponent> loadedMapDatum in loadedMapData)
			{
				MultiChunkMapComponent value2 = loadedMapDatum.Value;
				if (!value2.AnyChunkSet || !value2.IsVisible(curVisibleChunks))
				{
					value2.TTL -= 1f;
					if (value2.TTL <= 0f)
					{
						FastVec2i key2 = loadedMapDatum.Key;
						list2.Add(key2);
						value2.ActuallyDispose();
					}
				}
				else
				{
					value2.TTL = MultiChunkMapComponent.MaxTTL;
				}
			}
			foreach (FastVec2i item2 in list2)
			{
				loadedMapData.TryRemove(item2, out var _);
			}
			mtThread1secAccum = 0f;
		}

		public override void Render(GuiElementMap mapElem, float dt)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<FastVec2i, MultiChunkMapComponent> loadedMapDatum in loadedMapData)
			{
				loadedMapDatum.Value.Render(mapElem, dt);
			}
		}

		public override void OnMouseMoveClient(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<FastVec2i, MultiChunkMapComponent> loadedMapDatum in loadedMapData)
			{
				loadedMapDatum.Value.OnMouseMove(args, mapElem, hoverText);
			}
		}

		public override void OnMouseUpClient(MouseEvent args, GuiElementMap mapElem)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<FastVec2i, MultiChunkMapComponent> loadedMapDatum in loadedMapData)
			{
				loadedMapDatum.Value.OnMouseUpOnElement(args, mapElem);
			}
		}

		private void loadFromChunkPixels(FastVec2i cord, int[] pixels)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			readyMapPieces.Enqueue(new ReadyMapPiece
			{
				Pixels = pixels,
				Cord = cord
			});
		}

		public override void OnViewChangedClient(List<FastVec2i> nowVisible, List<FastVec2i> nowHidden)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			foreach (FastVec2i item in nowVisible)
			{
				curVisibleChunks.Add(item);
			}
			foreach (FastVec2i item2 in nowHidden)
			{
				curVisibleChunks.Remove(item2);
			}
			lock (chunksToGenLock)
			{
				FastVec2i key = default(FastVec2i);
				foreach (FastVec2i item3 in nowVisible)
				{
					FastVec2i current3 = item3;
					((FastVec2i)(ref key))._002Ector(((FastVec2i)(ref current3)).X / 3, ((FastVec2i)(ref current3)).Y / 3);
					int num = ((FastVec2i)(ref current3)).X % 3;
					int num2 = ((FastVec2i)(ref current3)).Y % 3;
					if (num >= 0 && num2 >= 0 && (!loadedMapData.TryGetValue(key, out var value) || !value.IsChunkSet(num, num2)))
					{
						chunksToGen.Enqueue(((FastVec2i)(ref current3)).Copy());
					}
				}
			}
			FastVec2i key2 = default(FastVec2i);
			foreach (FastVec2i item4 in nowHidden)
			{
				FastVec2i current4 = item4;
				if (((FastVec2i)(ref current4)).X >= 0 && ((FastVec2i)(ref current4)).Y >= 0)
				{
					((FastVec2i)(ref key2))._002Ector(((FastVec2i)(ref current4)).X / 3, ((FastVec2i)(ref current4)).Y / 3);
					if (loadedMapData.TryGetValue(key2, out var value2))
					{
						value2.unsetChunk(((FastVec2i)(ref current4)).X % 3, ((FastVec2i)(ref current4)).Y % 3);
					}
				}
			}
		}

		private static bool isLake(Block block)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Invalid comparison between Unknown and I4
			if ((int)block.BlockMaterial != 8)
			{
				if ((int)block.BlockMaterial == 10)
				{
					return ((RegistryObject)block).Code.Path != "glacierice";
				}
				return false;
			}
			return true;
		}

		public int[] GenerateChunkImage(FastVec2i chunkPos, IMapChunk mc, bool colorAccurate = false)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Expected O, but got Unknown
			//IL_031b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0322: Invalid comparison between Unknown and I4
			BlockPos val = new BlockPos();
			Vec2i val2 = new Vec2i();
			for (int i = 0; i < chunksTmp.Length; i++)
			{
				chunksTmp[i] = ((IWorldAccessor)capi.World).BlockAccessor.GetChunk(((FastVec2i)(ref chunkPos)).X, i, ((FastVec2i)(ref chunkPos)).Y);
				if (chunksTmp[i] == null || !((IClientChunk)/*isinst with value type is only supported in some contexts*/).LoadedFromServer)
				{
					return null;
				}
			}
			int[] array = new int[1024];
			IMapChunk mapChunk = ((IWorldAccessor)capi.World).BlockAccessor.GetMapChunk(((FastVec2i)(ref chunkPos)).X - 1, ((FastVec2i)(ref chunkPos)).Y - 1);
			IMapChunk mapChunk2 = ((IWorldAccessor)capi.World).BlockAccessor.GetMapChunk(((FastVec2i)(ref chunkPos)).X - 1, ((FastVec2i)(ref chunkPos)).Y);
			IMapChunk mapChunk3 = ((IWorldAccessor)capi.World).BlockAccessor.GetMapChunk(((FastVec2i)(ref chunkPos)).X, ((FastVec2i)(ref chunkPos)).Y - 1);
			if (shadowMapReusable == null)
			{
				shadowMapReusable = new byte[array.Length];
			}
			byte[] array2 = shadowMapReusable;
			for (int j = 0; j < array2.Length; j += 4)
			{
				array2[j] = 128;
				array2[j + 1] = 128;
				array2[j + 2] = 128;
				array2[j + 3] = 128;
			}
			for (int k = 0; k < array.Length; k++)
			{
				int num = mc.RainHeightMap[k];
				int num2 = num / 32;
				if (num2 >= chunksTmp.Length)
				{
					continue;
				}
				MapUtil.PosInt2d((long)k, 32L, val2);
				int x = val2.X;
				int y = val2.Y;
				float num3 = 1f;
				IMapChunk val3 = mc;
				IMapChunk val4 = mc;
				IMapChunk val5 = mc;
				int num4 = x - 1;
				int num5 = x;
				int num6 = y - 1;
				int num7 = y;
				if (num4 < 0 && num6 < 0)
				{
					val3 = mapChunk;
					val4 = mapChunk2;
					val5 = mapChunk3;
				}
				else
				{
					if (num4 < 0)
					{
						val3 = mapChunk2;
						val4 = mapChunk2;
					}
					if (num6 < 0)
					{
						val3 = mapChunk3;
						val5 = mapChunk3;
					}
				}
				num4 = GameMath.Mod(num4, 32);
				num6 = GameMath.Mod(num6, 32);
				int value = ((val3 != null) ? (num - val3.RainHeightMap[num6 * 32 + num4]) : 0);
				int value2 = ((val4 != null) ? (num - val4.RainHeightMap[num7 * 32 + num4]) : 0);
				int value3 = ((val5 != null) ? (num - val5.RainHeightMap[num6 * 32 + num5]) : 0);
				float num8 = Math.Sign(value) + Math.Sign(value2) + Math.Sign(value3);
				float num9 = Math.Max(Math.Max(Math.Abs(value), Math.Abs(value2)), Math.Abs(value3));
				int index = chunksTmp[num2].UnpackAndReadBlock(MapUtil.Index3d(x, num % 32, y, 32, 32), 3);
				Block val6 = api.World.Blocks[index];
				if (num8 > 0f)
				{
					num3 = 1.08f + Math.Min(0.5f, num9 / 10f) / 1.25f;
				}
				if (num8 < 0f)
				{
					num3 = 0.92f - Math.Min(0.5f, num9 / 10f) / 1.25f;
				}
				if ((int)val6.BlockMaterial == 9 && !colorAccurate)
				{
					num--;
					num2 = num / 32;
					index = chunksTmp[num2].UnpackAndReadBlock(MapUtil.Index3d(val2.X, num % 32, val2.Y, 32, 32), 3);
					val6 = api.World.Blocks[index];
				}
				val.Set(32 * ((FastVec2i)(ref chunkPos)).X + val2.X, num, 32 * ((FastVec2i)(ref chunkPos)).Y + val2.Y);
				if (colorAccurate)
				{
					int color = val6.GetColor(capi, val);
					int randomColor = val6.GetRandomColor(capi, val, BlockFacing.UP, GameMath.MurmurHash3Mod(val.X, val.Y, val.Z, 30));
					randomColor = ((randomColor & 0xFF) << 16) | (((randomColor >> 8) & 0xFF) << 8) | ((randomColor >> 16) & 0xFF);
					int num10 = ColorUtil.ColorOverlay(color, randomColor, 0.6f);
					array[k] = num10;
					array2[k] = (byte)((float)(int)array2[k] * num3);
				}
				else if (isLake(val6))
				{
					IWorldChunk val7 = chunksTmp[num2];
					IWorldChunk val8 = val7;
					IWorldChunk val9 = val7;
					IWorldChunk val10 = val7;
					int num11 = val2.X - 1;
					int num12 = val2.X + 1;
					int num13 = val2.Y - 1;
					int num14 = val2.Y + 1;
					if (num11 < 0)
					{
						val7 = ((IWorldAccessor)capi.World).BlockAccessor.GetChunk(((FastVec2i)(ref chunkPos)).X - 1, num2, ((FastVec2i)(ref chunkPos)).Y);
					}
					if (num12 >= 32)
					{
						val8 = ((IWorldAccessor)capi.World).BlockAccessor.GetChunk(((FastVec2i)(ref chunkPos)).X + 1, num2, ((FastVec2i)(ref chunkPos)).Y);
					}
					if (num13 < 0)
					{
						val9 = ((IWorldAccessor)capi.World).BlockAccessor.GetChunk(((FastVec2i)(ref chunkPos)).X, num2, ((FastVec2i)(ref chunkPos)).Y - 1);
					}
					if (num14 >= 32)
					{
						val10 = ((IWorldAccessor)capi.World).BlockAccessor.GetChunk(((FastVec2i)(ref chunkPos)).X, num2, ((FastVec2i)(ref chunkPos)).Y + 1);
					}
					if (val7 != null && val8 != null && val9 != null && val10 != null)
					{
						num11 = GameMath.Mod(num11, 32);
						num12 = GameMath.Mod(num12, 32);
						num13 = GameMath.Mod(num13, 32);
						num14 = GameMath.Mod(num14, 32);
						Block block = api.World.Blocks[val7.UnpackAndReadBlock(MapUtil.Index3d(num11, num % 32, val2.Y, 32, 32), 3)];
						Block block2 = api.World.Blocks[val8.UnpackAndReadBlock(MapUtil.Index3d(num12, num % 32, val2.Y, 32, 32), 3)];
						Block block3 = api.World.Blocks[val9.UnpackAndReadBlock(MapUtil.Index3d(val2.X, num % 32, num13, 32, 32), 3)];
						Block block4 = api.World.Blocks[val10.UnpackAndReadBlock(MapUtil.Index3d(val2.X, num % 32, num14, 32, 32), 3)];
						if (isLake(block) && isLake(block2) && isLake(block3) && isLake(block4))
						{
							array[k] = getColor(val6, val2.X, num, val2.Y);
						}
						else
						{
							array[k] = colorsByCode["wateredge"];
						}
					}
					else
					{
						array[k] = getColor(val6, val2.X, num, val2.Y);
					}
				}
				else
				{
					array2[k] = (byte)((float)(int)array2[k] * num3);
					array[k] = getColor(val6, val2.X, num, val2.Y);
				}
			}
			if (shadowMapBlurReusable == null)
			{
				shadowMapBlurReusable = new byte[array2.Length];
			}
			byte[] array3 = shadowMapBlurReusable;
			for (int l = 0; l < array3.Length; l += 4)
			{
				array3[l] = array2[l];
				array3[l + 1] = array2[l + 1];
				array3[l + 2] = array2[l + 2];
				array3[l + 3] = array2[l + 3];
			}
			BlurTool.Blur(array2, 32, 32, 2);
			float num15 = 1f;
			for (int m = 0; m < array2.Length; m++)
			{
				float num16 = (float)(int)(((float)(int)array2[m] / 128f - 1f) * 5f) / 5f;
				num16 += ((float)(int)array3[m] / 128f - 1f) * 5f % 1f / 5f;
				array[m] = ColorUtil.ColorMultiply3Clamped(array[m], num16 * num15 + 1f) | -16777216;
			}
			for (int n = 0; n < chunksTmp.Length; n++)
			{
				chunksTmp[n] = null;
			}
			return array;
		}

		private int getColor(Block block, int x, int y1, int y2)
		{
			byte b = block2Color[((CollectibleObject)block).Id];
			return colors[b];
		}

		private void rebuildRainmap(int cx, int cz)
		{
			ICoreAPI obj = api;
			ICoreServerAPI val = (ICoreServerAPI)(object)((obj is ICoreServerAPI) ? obj : null);
			int num = val.WorldManager.MapSizeY / val.WorldManager.ChunkSize;
			IServerChunk[] array = (IServerChunk[])(object)new IServerChunk[num];
			int chunkSize = val.WorldManager.ChunkSize;
			IMapChunk val2 = null;
			for (int i = 0; i < num; i++)
			{
				array[i] = val.WorldManager.GetChunk(cx, i, cz);
				IServerChunk obj2 = array[i];
				if (obj2 != null)
				{
					((IWorldChunk)obj2).Unpack_ReadOnly();
				}
				IServerChunk obj3 = array[i];
				val2 = ((obj3 != null) ? ((IWorldChunk)obj3).MapChunk : null);
			}
			if (val2 == null)
			{
				return;
			}
			for (int j = 0; j < chunkSize; j++)
			{
				for (int k = 0; k < chunkSize; k++)
				{
					for (int num2 = val.WorldManager.MapSizeY - 1; num2 >= 0; num2--)
					{
						IServerChunk val3 = array[num2 / chunkSize];
						if (val3 != null)
						{
							int num3 = (num2 % chunkSize * chunkSize + k) * chunkSize + j;
							if (!((IWorldAccessor)val.World).Blocks[((IWorldChunk)val3).Data.GetBlockId(num3, 3)].RainPermeable || num2 == 0)
							{
								val2.RainHeightMap[k * chunkSize + j] = (ushort)num2;
								break;
							}
						}
					}
				}
			}
			val.WorldManager.ResendMapChunk(cx, cz, true);
			val2.MarkDirty();
		}

		static ChunkMapLayer()
		{
			OrderedDictionary<string, string> obj = new OrderedDictionary<string, string>();
			obj.Add("ink", "#483018");
			obj.Add("settlement", "#856844");
			obj.Add("wateredge", "#483018");
			obj.Add("land", "#AC8858");
			obj.Add("desert", "#C4A468");
			obj.Add("forest", "#98844C");
			obj.Add("road", "#805030");
			obj.Add("plant", "#808650");
			obj.Add("lake", "#CCC890");
			obj.Add("ocean", "#CCC890");
			obj.Add("glacier", "#E0E0C0");
			obj.Add("devastation", "#755c3c");
			hexColorsByCode = obj;
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class MapBlockIdMappingDB
	{
		public Dictionary<AssetLocation, int> BlockIndicesByBlockCode;
	}
	[ProtoContract]
	public class MapPieceDB
	{
		[ProtoMember(1)]
		public int[] Pixels;
	}
	public class MapDB : SQLiteDBConnection
	{
		private SqliteCommand setMapPieceCmd;

		private SqliteCommand getMapPieceCmd;

		public override string DBTypeCode => "worldmap database";

		public MapDB(ILogger logger)
			: base(logger)
		{
		}

		public override void OnOpened()
		{
			((SQLiteDBConnection)this).OnOpened();
			setMapPieceCmd = base.sqliteConn.CreateCommand();
			((DbCommand)(object)setMapPieceCmd).CommandText = "INSERT OR REPLACE INTO mappiece (position, data) VALUES (@pos, @data)";
			setMapPieceCmd.Parameters.Add("@pos", (SqliteType)1, 1);
			setMapPieceCmd.Parameters.Add("@data", (SqliteType)4);
			((DbCommand)(object)setMapPieceCmd).Prepare();
			getMapPieceCmd = base.sqliteConn.CreateCommand();
			((DbCommand)(object)getMapPieceCmd).CommandText = "SELECT data FROM mappiece WHERE position=@pos";
			getMapPieceCmd.Parameters.Add("@pos", (SqliteType)1, 1);
			((DbCommand)(object)getMapPieceCmd).Prepare();
		}

		protected override void CreateTablesIfNotExists(SqliteConnection sqliteConn)
		{
			SqliteCommand val = sqliteConn.CreateCommand();
			try
			{
				((DbCommand)(object)val).CommandText = "CREATE TABLE IF NOT EXISTS mappiece (position integer PRIMARY KEY, data BLOB);";
				((DbCommand)(object)val).ExecuteNonQuery();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			SqliteCommand val2 = sqliteConn.CreateCommand();
			try
			{
				((DbCommand)(object)val2).CommandText = "CREATE TABLE IF NOT EXISTS blockidmapping (id integer PRIMARY KEY, data BLOB);";
				((DbCommand)(object)val2).ExecuteNonQuery();
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}

		public void Purge()
		{
			SqliteCommand val = base.sqliteConn.CreateCommand();
			try
			{
				((DbCommand)(object)val).CommandText = "delete FROM mappiece";
				((DbCommand)(object)val).ExecuteNonQuery();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public MapPieceDB[] GetMapPieces(List<FastVec2i> chunkCoords)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			MapPieceDB[] array = new MapPieceDB[chunkCoords.Count];
			for (int i = 0; i < chunkCoords.Count; i++)
			{
				SqliteParameter obj = getMapPieceCmd.Parameters["@pos"];
				FastVec2i val = chunkCoords[i];
				((DbParameter)(object)obj).Value = ((FastVec2i)(ref val)).ToChunkIndex();
				SqliteDataReader val2 = getMapPieceCmd.ExecuteReader();
				try
				{
					while (((DbDataReader)(object)val2).Read())
					{
						object obj2 = ((DbDataReader)(object)val2)["data"];
						if (obj2 == null)
						{
							return null;
						}
						array[i] = SerializerUtil.Deserialize<MapPieceDB>(obj2 as byte[]);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			return array;
		}

		public MapPieceDB GetMapPiece(FastVec2i chunkCoord)
		{
			((DbParameter)(object)getMapPieceCmd.Parameters["@pos"]).Value = ((FastVec2i)(ref chunkCoord)).ToChunkIndex();
			SqliteDataReader val = getMapPieceCmd.ExecuteReader();
			try
			{
				if (((DbDataReader)(object)val).Read())
				{
					object obj = ((DbDataReader)(object)val)["data"];
					if (obj == null)
					{
						return null;
					}
					return SerializerUtil.Deserialize<MapPieceDB>(obj as byte[]);
				}
				return null;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public void SetMapPieces(Dictionary<FastVec2i, MapPieceDB> pieces)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			SqliteTransaction val = base.sqliteConn.BeginTransaction();
			try
			{
				setMapPieceCmd.Transaction = val;
				foreach (KeyValuePair<FastVec2i, MapPieceDB> piece in pieces)
				{
					SqliteParameter obj = setMapPieceCmd.Parameters["@pos"];
					FastVec2i key = piece.Key;
					((DbParameter)(object)obj).Value = ((FastVec2i)(ref key)).ToChunkIndex();
					((DbParameter)(object)setMapPieceCmd.Parameters["@data"]).Value = SerializerUtil.Serialize<MapPieceDB>(piece.Value);
					((DbCommand)(object)setMapPieceCmd).ExecuteNonQuery();
				}
				((DbTransaction)(object)val).Commit();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public MapBlockIdMappingDB GetMapBlockIdMappingDB()
		{
			SqliteCommand val = base.sqliteConn.CreateCommand();
			try
			{
				((DbCommand)(object)val).CommandText = "SELECT data FROM blockidmapping WHERE id=1";
				SqliteDataReader val2 = val.ExecuteReader();
				try
				{
					if (((DbDataReader)(object)val2).Read())
					{
						object obj = ((DbDataReader)(object)val2)["data"];
						return (obj == null) ? null : SerializerUtil.Deserialize<MapBlockIdMappingDB>(obj as byte[]);
					}
					return null;
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public void SetMapBlockIdMappingDB(MapBlockIdMappingDB mapping)
		{
			SqliteTransaction val = base.sqliteConn.BeginTransaction();
			try
			{
				using (DbCommand dbCommand = base.sqliteConn.CreateCommand())
				{
					dbCommand.Transaction = (DbTransaction?)(object)val;
					byte[] array = SerializerUtil.Serialize<MapBlockIdMappingDB>(mapping);
					dbCommand.CommandText = "INSERT OR REPLACE INTO mappiece (position, data) VALUES (@position,@data)";
					dbCommand.Parameters.Add(((SQLiteDBConnection)this).CreateParameter("position", DbType.UInt64, (object)1, dbCommand));
					dbCommand.Parameters.Add(((SQLiteDBConnection)this).CreateParameter("data", DbType.Object, (object)array, dbCommand));
					dbCommand.ExecuteNonQuery();
				}
				((DbTransaction)(object)val).Commit();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public override void Close()
		{
			((Component)(object)setMapPieceCmd)?.Dispose();
			((Component)(object)getMapPieceCmd)?.Dispose();
			((SQLiteDBConnection)this).Close();
		}

		public override void Dispose()
		{
			((Component)(object)setMapPieceCmd)?.Dispose();
			((Component)(object)getMapPieceCmd)?.Dispose();
			((SQLiteDBConnection)this).Dispose();
		}
	}
	public class MultiChunkMapComponent : MapComponent
	{
		public const int ChunkLen = 3;

		public static LoadedTexture tmpTexture;

		public float renderZ = 50f;

		public FastVec2i chunkCoord;

		public LoadedTexture Texture;

		private static int[] emptyPixels;

		private Vec3d worldPos;

		private Vec2f viewPos = new Vec2f();

		private bool[,] chunkSet = new bool[3, 3];

		private const int chunksize = 32;

		public float TTL = MaxTTL;

		public static float MaxTTL = 30f;

		private int[][] pixelsToSet;

		public bool AnyChunkSet
		{
			get
			{
				for (int i = 0; i < 3; i++)
				{
					for (int j = 0; j < 3; j++)
					{
						if (chunkSet[i, j])
						{
							return true;
						}
					}
				}
				return false;
			}
		}

		public bool IsChunkSet(int dx, int dz)
		{
			if (dx < 0 || dz < 0)
			{
				return false;
			}
			return chunkSet[dx, dz];
		}

		public MultiChunkMapComponent(ICoreClientAPI capi, FastVec2i baseChunkCord)
			: base(capi)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Expected O, but got Unknown
			chunkCoord = baseChunkCord;
			worldPos = new Vec3d((double)(((FastVec2i)(ref baseChunkCord)).X * 32), 0.0, (double)(((FastVec2i)(ref baseChunkCord)).Y * 32));
			if (emptyPixels == null)
			{
				emptyPixels = new int[96 * 96];
			}
		}

		public void setChunk(int dx, int dz, int[] pixels)
		{
			if (dx < 0 || dx >= 3 || dz < 0 || dz >= 3)
			{
				throw new ArgumentOutOfRangeException("dx/dz must be within [0," + 2 + "]");
			}
			if (pixelsToSet == null)
			{
				pixelsToSet = new int[9][];
			}
			pixelsToSet[dz * 3 + dx] = pixels;
			chunkSet[dx, dz] = true;
		}

		public void FinishSetChunks()
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Expected O, but got Unknown
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Expected O, but got Unknown
			if (pixelsToSet == null)
			{
				return;
			}
			if (tmpTexture == null || tmpTexture.Disposed)
			{
				tmpTexture = new LoadedTexture(capi, 0, 32, 32);
			}
			if (Texture == null || Texture.Disposed)
			{
				int num = 96;
				Texture = new LoadedTexture(capi, 0, num, num);
				capi.Render.LoadOrUpdateTextureFromRgba(emptyPixels, false, 0, ref Texture);
			}
			FrameBufferRef val = capi.Render.CreateFrameBuffer(Texture);
			for (int i = 0; i < pixelsToSet.Length; i++)
			{
				if (pixelsToSet[i] != null)
				{
					capi.Render.LoadOrUpdateTextureFromRgba(pixelsToSet[i], false, 0, ref tmpTexture);
					capi.Render.GlToggleBlend(false, (EnumBlendMode)0);
					capi.Render.GLDisableDepthTest();
					capi.Render.RenderTextureIntoFrameBuffer(0, tmpTexture, 0f, 0f, 32f, 32f, val, (float)(32 * (i % 3)), (float)(32 * (i / 3)), 0.005f);
				}
			}
			capi.Render.DestroyFrameBuffer(val);
			capi.Render.BindTexture2d(Texture.TextureId);
			capi.Render.GlGenerateTex2DMipmaps();
			pixelsToSet = null;
		}

		public void unsetChunk(int dx, int dz)
		{
			if (dx < 0 || dx >= 3 || dz < 0 || dz >= 3)
			{
				throw new ArgumentOutOfRangeException("dx/dz must be within [0," + 2 + "]");
			}
			chunkSet[dx, dz] = false;
		}

		public override void Render(GuiElementMap map, float dt)
		{
			map.TranslateWorldPosToViewPos(worldPos, ref viewPos);
			capi.Render.Render2DTexture(Texture.TextureId, (float)(int)(((GuiElement)map).Bounds.renderX + (double)viewPos.X), (float)(int)(((GuiElement)map).Bounds.renderY + (double)viewPos.Y), (float)(int)((float)Texture.Width * map.ZoomLevel), (float)(int)((float)Texture.Height * map.ZoomLevel), renderZ, (Vec4f)null);
		}

		public override void Dispose()
		{
			base.Dispose();
		}

		public void ActuallyDispose()
		{
			Texture.Dispose();
		}

		public bool IsVisible(HashSet<FastVec2i> curVisibleChunks)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			FastVec2i item = default(FastVec2i);
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					((FastVec2i)(ref item))._002Ector(((FastVec2i)(ref chunkCoord)).X + i, ((FastVec2i)(ref chunkCoord)).Y + j);
					if (curVisibleChunks.Contains(item))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void DisposeStatic()
		{
			LoadedTexture obj = tmpTexture;
			if (obj != null)
			{
				obj.Dispose();
			}
			emptyPixels = null;
			tmpTexture = null;
		}
	}
	public class EntityMapComponent : MapComponent
	{
		public Entity entity;

		internal MeshRef quadModel;

		public LoadedTexture Texture;

		private Vec2f viewPos = new Vec2f();

		private Matrixf mvMat = new Matrixf();

		private int color;

		public EntityMapComponent(ICoreClientAPI capi, LoadedTexture texture, Entity entity, string color = null)
			: base(capi)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			quadModel = capi.Render.UploadMesh(QuadMeshUtil.GetQuad());
			Texture = texture;
			this.entity = entity;
			this.color = ((color != null) ? (ColorUtil.Hex2Int(color) | -16777216) : 0);
		}

		public override void Render(GuiElementMap map, float dt)
		{
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Invalid comparison between Unknown and I4
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0157: Expected O, but got Unknown
			Entity obj = entity;
			Entity obj2 = ((obj is EntityPlayer) ? obj : null);
			IPlayer val = ((obj2 != null) ? ((EntityPlayer)obj2).Player : null);
			if (val != null)
			{
				IWorldPlayerData worldData = val.WorldData;
				if ((int)((worldData != null) ? new EnumGameMode?(worldData.CurrentGameMode) : ((EnumGameMode?)null)).GetValueOrDefault() == 3 && (object)capi.World.Player != val)
				{
					return;
				}
			}
			Entity obj3 = entity;
			Entity obj4 = ((obj3 is EntityPlayer) ? obj3 : null);
			if (obj4 == null || !((EntityAgent)obj4).Controls.Sneak || (object)val == capi.World.Player)
			{
				map.TranslateWorldPosToViewPos(entity.Pos.XYZ, ref viewPos);
				float num = (float)(((GuiElement)map).Bounds.renderX + (double)viewPos.X);
				float num2 = (float)(((GuiElement)map).Bounds.renderY + (double)viewPos.Y);
				ICoreClientAPI api = map.Api;
				if (Texture.Disposed)
				{
					throw new Exception("Fatal. Trying to render a disposed texture");
				}
				if (quadModel.Disposed)
				{
					throw new Exception("Fatal. Trying to render a disposed texture");
				}
				capi.Render.GlToggleBlend(true, (EnumBlendMode)0);
				IShaderProgram engineShader = api.Render.GetEngineShader((EnumShaderProgram)17);
				if (color == 0)
				{
					engineShader.Uniform("rgbaIn", ColorUtil.WhiteArgbVec);
				}
				else
				{
					Vec4f val2 = new Vec4f();
					ColorUtil.ToRGBAVec4f(color, ref val2);
					engineShader.Uniform("rgbaIn", val2);
				}
				engineShader.Uniform("applyColor", 0);
				engineShader.Uniform("extraGlow", 0);
				engineShader.Uniform("noTexture", 0f);
				engineShader.BindTexture2D("tex2d", Texture.TextureId, 0);
				mvMat.Set(api.Render.CurrentModelviewMatrix).Translate(num, num2, 60f).Scale((float)Texture.Width, (float)Texture.Height, 0f)
					.Scale(0.5f, 0.5f, 0f)
					.RotateZ(0f - entity.Pos.Yaw + (float)Math.PI);
				engineShader.UniformMatrix("projectionMatrix", api.Render.CurrentProjectionMatrix);
				engineShader.UniformMatrix("modelViewMatrix", mvMat.Values);
				api.Render.RenderMesh(quadModel);
			}
		}

		public override void Dispose()
		{
			base.Dispose();
			quadModel.Dispose();
		}

		public override void OnMouseMove(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Vec2f val = new Vec2f();
			mapElem.TranslateWorldPosToViewPos(entity.Pos.XYZ, ref val);
			double num = (double)args.X - ((GuiElement)mapElem).Bounds.renderX;
			double num2 = (double)args.Y - ((GuiElement)mapElem).Bounds.renderY;
			double num3 = GuiElement.scaled(5.0);
			if (Math.Abs((double)val.X - num) < num3 && Math.Abs((double)val.Y - num2) < num3)
			{
				Entity obj = entity;
				EntityPlayer val2 = (EntityPlayer)(object)((obj is EntityPlayer) ? obj : null);
				if (val2 != null)
				{
					IPlayer obj2 = ((IWorldAccessor)capi.World).PlayerByUid(val2.PlayerUID);
					hoverText.AppendLine("Player " + ((obj2 != null) ? obj2.PlayerName : null));
				}
				else
				{
					hoverText.AppendLine(entity.GetName());
				}
			}
		}
	}
	public class EntityMapLayer : MarkerMapLayer
	{
		private Dictionary<long, EntityMapComponent> MapComps = new Dictionary<long, EntityMapComponent>();

		private ICoreClientAPI capi;

		private LoadedTexture otherTexture;

		public override string Title => "Creatures";

		public override EnumMapAppSide DataSide => EnumMapAppSide.Client;

		public override string LayerGroupCode => "creatures";

		public EntityMapLayer(ICoreAPI api, IWorldMapManager mapsink)
			: base(api, mapsink)
		{
			capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
		}

		public override void OnLoaded()
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Expected O, but got Unknown
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Expected O, but got Unknown
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Expected O, but got Unknown
			if (capi != null)
			{
				((IEventAPI)capi.Event).OnEntitySpawn += new EntityDelegate(Event_OnEntitySpawn);
				((IEventAPI)capi.Event).OnEntityLoaded += new EntityDelegate(Event_OnEntitySpawn);
				((IEventAPI)capi.Event).OnEntityDespawn += new EntityDespawnDelegate(Event_OnEntityDespawn);
			}
		}

		private void Event_OnEntityDespawn(Entity entity, EntityDespawnData reasonData)
		{
			if (MapComps.TryGetValue(entity.EntityId, out var value))
			{
				value.Dispose();
				MapComps.Remove(entity.EntityId);
			}
		}

		private void Event_OnEntitySpawn(Entity entity)
		{
			if (!(entity is EntityPlayer) && !((RegistryObject)entity).Code.Path.Contains("drifter") && mapSink.IsOpened && !MapComps.ContainsKey(entity.EntityId))
			{
				EntityMapComponent value = new EntityMapComponent(capi, otherTexture, entity, entity.Properties.Color);
				MapComps[entity.EntityId] = value;
			}
		}

		public override void OnMapOpenedClient()
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Expected O, but got Unknown
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Expected O, but got Unknown
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Expected O, but got Unknown
			int num = (int)GuiElement.scaled(32.0);
			if (otherTexture == null)
			{
				ImageSurface val = new ImageSurface((Format)0, num, num);
				Context val2 = new Context((Surface)(object)val);
				val2.SetSourceRGBA(0.0, 0.0, 0.0, 0.0);
				val2.Paint();
				capi.Gui.Icons.DrawMapPlayer(val2, 0, 0, (float)num, (float)num, new double[4] { 0.3, 0.3, 0.3, 1.0 }, new double[4] { 0.95, 0.95, 0.95, 1.0 });
				otherTexture = new LoadedTexture(capi, capi.Gui.LoadCairoTexture(val, false), num / 2, num / 2);
				val2.Dispose();
				((Surface)val).Dispose();
			}
			foreach (KeyValuePair<long, Entity> loadedEntity in capi.World.LoadedEntities)
			{
				if (!(loadedEntity.Value is EntityPlayer))
				{
					if (MapComps.TryGetValue(loadedEntity.Value.EntityId, out var value))
					{
						value?.Dispose();
						MapComps.Remove(loadedEntity.Value.EntityId);
					}
					value = new EntityMapComponent(capi, otherTexture, loadedEntity.Value, loadedEntity.Value.Properties.Color);
					MapComps[loadedEntity.Value.EntityId] = value;
				}
			}
		}

		public override void Render(GuiElementMap mapElem, float dt)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<long, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value.Render(mapElem, dt);
			}
		}

		public override void OnMouseMoveClient(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<long, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value.OnMouseMove(args, mapElem, hoverText);
			}
		}

		public override void OnMouseUpClient(MouseEvent args, GuiElementMap mapElem)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<long, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value.OnMouseUpOnElement(args, mapElem);
			}
		}

		public override void Dispose()
		{
			foreach (KeyValuePair<long, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value?.Dispose();
			}
			LoadedTexture obj = otherTexture;
			if (obj != null)
			{
				obj.Dispose();
			}
			otherTexture = null;
		}
	}
	public class PlayerMapLayer : MarkerMapLayer
	{
		private Dictionary<IPlayer, EntityMapComponent> MapComps = new Dictionary<IPlayer, EntityMapComponent>();

		private ICoreClientAPI capi;

		private LoadedTexture ownTexture;

		private LoadedTexture otherTexture;

		public override string Title => "Players";

		public override EnumMapAppSide DataSide => EnumMapAppSide.Client;

		public override string LayerGroupCode => "terrain";

		public PlayerMapLayer(ICoreAPI api, IWorldMapManager mapsink)
			: base(api, mapsink)
		{
			capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
		}

		private void Event_PlayerDespawn(IClientPlayer byPlayer)
		{
			if (MapComps.TryGetValue((IPlayer)(object)byPlayer, out var value))
			{
				value.Dispose();
				MapComps.Remove((IPlayer)(object)byPlayer);
			}
		}

		private void Event_PlayerSpawn(IClientPlayer byPlayer)
		{
			if ((!((IWorldAccessor)capi.World).Config.GetBool("mapHideOtherPlayers", false) || !(((IPlayer)byPlayer).PlayerUID != ((IPlayer)capi.World.Player).PlayerUID)) && mapSink.IsOpened && !MapComps.ContainsKey((IPlayer)(object)byPlayer))
			{
				EntityMapComponent value = new EntityMapComponent(capi, otherTexture, (Entity)(object)((IPlayer)byPlayer).Entity);
				MapComps[(IPlayer)(object)byPlayer] = value;
			}
		}

		public override void OnLoaded()
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Expected O, but got Unknown
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Expected O, but got Unknown
			if (capi != null)
			{
				capi.Event.PlayerEntitySpawn += new PlayerEventDelegate(Event_PlayerSpawn);
				capi.Event.PlayerEntityDespawn += new PlayerEventDelegate(Event_PlayerDespawn);
			}
		}

		public override void OnMapOpenedClient()
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Expected O, but got Unknown
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Expected O, but got Unknown
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Expected O, but got Unknown
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Expected O, but got Unknown
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Expected O, but got Unknown
			//IL_017b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Expected O, but got Unknown
			int num = (int)GuiElement.scaled(32.0);
			if (ownTexture == null)
			{
				ImageSurface val = new ImageSurface((Format)0, num, num);
				Context val2 = new Context((Surface)(object)val);
				val2.SetSourceRGBA(0.0, 0.0, 0.0, 0.0);
				val2.Paint();
				capi.Gui.Icons.DrawMapPlayer(val2, 0, 0, (float)num, (float)num, new double[4] { 0.0, 0.0, 0.0, 1.0 }, new double[4] { 1.0, 1.0, 1.0, 1.0 });
				ownTexture = new LoadedTexture(capi, capi.Gui.LoadCairoTexture(val, false), num / 2, num / 2);
				val2.Dispose();
				((Surface)val).Dispose();
			}
			if (otherTexture == null)
			{
				ImageSurface val3 = new ImageSurface((Format)0, num, num);
				Context val4 = new Context((Surface)(object)val3);
				val4.SetSourceRGBA(0.0, 0.0, 0.0, 0.0);
				val4.Paint();
				capi.Gui.Icons.DrawMapPlayer(val4, 0, 0, (float)num, (float)num, new double[4] { 0.3, 0.3, 0.3, 1.0 }, new double[4] { 0.7, 0.7, 0.7, 1.0 });
				otherTexture = new LoadedTexture(capi, capi.Gui.LoadCairoTexture(val3, false), num / 2, num / 2);
				val4.Dispose();
				((Surface)val3).Dispose();
			}
			IPlayer[] allOnlinePlayers = ((IWorldAccessor)capi.World).AllOnlinePlayers;
			foreach (IPlayer val5 in allOnlinePlayers)
			{
				if (MapComps.TryGetValue(val5, out var value))
				{
					value?.Dispose();
					MapComps.Remove(val5);
				}
				if (val5.Entity == null)
				{
					((IWorldAccessor)capi.World).Logger.Warning("Can't add player {0} to world map, missing entity :<", new object[1] { val5.PlayerUID });
				}
				else if (!((IWorldAccessor)capi.World).Config.GetBool("mapHideOtherPlayers", false) || !(val5.PlayerUID != ((IPlayer)capi.World.Player).PlayerUID))
				{
					value = new EntityMapComponent(capi, ((object)val5 == capi.World.Player) ? ownTexture : otherTexture, (Entity)(object)val5.Entity);
					MapComps[val5] = value;
				}
			}
		}

		public override void Render(GuiElementMap mapElem, float dt)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<IPlayer, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value.Render(mapElem, dt);
			}
		}

		public override void OnMouseMoveClient(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<IPlayer, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value.OnMouseMove(args, mapElem, hoverText);
			}
		}

		public override void OnMouseUpClient(MouseEvent args, GuiElementMap mapElem)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (KeyValuePair<IPlayer, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value.OnMouseUpOnElement(args, mapElem);
			}
		}

		public override void OnMapClosedClient()
		{
		}

		public override void Dispose()
		{
			foreach (KeyValuePair<IPlayer, EntityMapComponent> mapComp in MapComps)
			{
				mapComp.Value?.Dispose();
			}
			LoadedTexture obj = ownTexture;
			if (obj != null)
			{
				obj.Dispose();
			}
			ownTexture = null;
			LoadedTexture obj2 = otherTexture;
			if (obj2 != null)
			{
				obj2.Dispose();
			}
			otherTexture = null;
		}
	}
	public delegate void OnViewChangedDelegate(List<FastVec2i> nowVisibleChunks, List<FastVec2i> nowHiddenChunks);
	public delegate void OnViewChangedSyncDelegate(int x1, int z1, int x2, int z2);
	public class GuiDialogWorldMap : GuiDialogGeneric
	{
		protected EnumDialogType dialogType = (EnumDialogType)1;

		protected OnViewChangedDelegate viewChanged;

		protected OnViewChangedSyncDelegate viewChangedSync;

		protected long listenerId;

		protected bool requireRecompose;

		protected int mapWidth = 1200;

		protected int mapHeight = 800;

		protected GuiComposer fullDialog;

		protected GuiComposer hudDialog;

		protected List<GuiTab> tabs;

		private List<string> tabnames;

		private Vec3d hoveredWorldPos = new Vec3d();

		private GuiDialogAddWayPoint addWpDlg;

		public override bool PrefersUngrabbedMouse => true;

		public override EnumDialogType DialogType => dialogType;

		public override double DrawOrder
		{
			get
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Invalid comparison between Unknown and I4
				if ((int)dialogType != 1)
				{
					return 0.11;
				}
				return 0.07;
			}
		}

		public List<MapLayer> MapLayers
		{
			get
			{
				GuiComposer singleComposer = ((GuiDialog)this).SingleComposer;
				return (((singleComposer != null) ? singleComposer.GetElement("mapElem") : null) as GuiElementMap)?.mapLayers;
			}
		}

		public GuiDialogWorldMap(OnViewChangedDelegate viewChanged, OnViewChangedSyncDelegate viewChangedSync, ICoreClientAPI capi, List<string> tabnames)
			: base("", capi)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Expected O, but got Unknown
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Expected O, but got Unknown
			this.viewChanged = viewChanged;
			this.viewChangedSync = viewChangedSync;
			this.tabnames = tabnames;
			fullDialog = ComposeDialog((EnumDialogType)0);
			hudDialog = ComposeDialog((EnumDialogType)1);
			CommandArgumentParsers parsers = ((ICoreAPI)capi).ChatCommands.Parsers;
			((ICoreAPI)capi).ChatCommands.GetOrCreate("map").BeginSubCommand("worldmapsize").WithDescription("Show/set worldmap size")
				.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[2]
				{
					(ICommandArgumentParser)parsers.OptionalInt("mapWidth", 1200),
					(ICommandArgumentParser)parsers.OptionalInt("mapHeight", 800)
				})
				.HandleWith(new OnCommandDelegate(OnCmdMapSize));
		}

		private TextCommandResult OnCmdMapSize(TextCommandCallingArgs args)
		{
			if (args.Parsers[0].IsMissing)
			{
				return TextCommandResult.Success($"Current map size: {mapWidth}x{mapHeight}", (object)null);
			}
			mapWidth = (int)args.Parsers[0].GetValue();
			mapHeight = (int)args.Parsers[1].GetValue();
			fullDialog = ComposeDialog((EnumDialogType)0);
			return TextCommandResult.Success($"Map size {mapWidth}x{mapHeight} set", (object)null);
		}

		private unsafe GuiComposer ComposeDialog(EnumDialogType dlgType)
		{
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Invalid comparison between Unknown and I4
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02dc: Invalid comparison between Unknown and I4
			//IL_033c: Unknown result type (might be due to invalid IL or missing references)
			//IL_033e: Invalid comparison between Unknown and I4
			//IL_0377: Unknown result type (might be due to invalid IL or missing references)
			//IL_0379: Invalid comparison between Unknown and I4
			//IL_022e: Expected O, but got Unknown
			//IL_049d: Unknown result type (might be due to invalid IL or missing references)
			ElementBounds val = ElementBounds.Fixed(0.0, 28.0, (double)mapWidth, (double)mapHeight);
			ElementBounds val2 = val.RightCopy(0.0, 0.0, 0.0, 0.0).WithFixedSize(1.0, 350.0);
			ElementBounds val3 = ElementBounds.Fill.WithFixedPadding(3.0);
			val3.BothSizing = (ElementSizing)2;
			val3.WithChildren((ElementBounds[])(object)new ElementBounds[2] { val, val2 });
			ElementBounds val4 = ElementStdBounds.AutosizedMainDialog.WithAlignment((EnumDialogArea)6).WithFixedAlignmentOffset(0.0 - GuiStyle.DialogToScreenPadding, 0.0);
			GuiComposer val5;
			if ((int)dlgType == 1)
			{
				val = ElementBounds.Fixed(0.0, 0.0, 250.0, 250.0);
				val3 = ElementBounds.Fill.WithFixedPadding(2.0);
				val3.BothSizing = (ElementSizing)2;
				val3.WithChildren((ElementBounds[])(object)new ElementBounds[1] { val });
				val4 = ElementStdBounds.AutosizedMainDialog.WithAlignment(GetMinimapPosition(out var offsetX, out var offsetY)).WithFixedAlignmentOffset(offsetX, offsetY);
				val5 = hudDialog;
			}
			else
			{
				val5 = fullDialog;
			}
			Cuboidd val6 = null;
			if (val5 != null)
			{
				val6 = (val5.GetElement("mapElem") as GuiElementMap)?.CurrentBlockViewBounds;
				val5.Dispose();
			}
			tabs = new List<GuiTab>();
			int i;
			for (i = 0; i < tabnames.Count; i++)
			{
				tabs.Add(new GuiTab
				{
					Name = Lang.Get("maplayer-" + tabnames[i], Array.Empty<object>()),
					DataInt = i,
					Active = (MapLayers?.FirstOrDefault((MapLayer layer) => layer.LayerGroupCode == tabnames[i])?.Active ?? true)
				});
			}
			ElementBounds val7 = ElementBounds.Fixed(-200.0, 45.0, 200.0, 545.0);
			List<MapLayer> mapLayers = ((ICoreAPI)((GuiDialog)this).capi).ModLoader.GetModSystem<WorldMapManager>(true).MapLayers;
			val5 = GuiComposerHelpers.AddVerticalToggleTabs(GuiComposerHelpers.AddHoverText(GuiElementInsetHelper.AddInset(GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(((GuiDialog)this).capi.Gui.CreateCompo("worldmap" + ((object)(*(EnumDialogType*)(&dlgType))/*cast due to .constrained prefix*/).ToString(), val4), val3, false, 5.0, 0.75f).AddIf((int)dlgType == 0), Lang.Get("World Map", Array.Empty<object>()), (Action)OnTitleBarClose, (CairoFont)null, (ElementBounds)null, (string)null), val, 2, 0.85f).EndIf().BeginChildElements(val3), "", CairoFont.WhiteDetailText(), 350, val.FlatCopy(), "hoverText").AddIf((int)dlgType == 0), tabs.ToArray(), val7, (Action<int, GuiTab>)OnTabClicked, "verticalTabs").EndIf().AddInteractiveElement((GuiElement)(object)new GuiElementMap(mapLayers, ((GuiDialog)this).capi, this, val, (int)dlgType == 1), "mapElem")
				.EndChildElements()
				.Compose(true);
			tabs[0].Active = MapLayers?.FirstOrDefault((MapLayer layer) => layer.LayerGroupCode == tabnames[0])?.Active ?? true;
			val5.OnComposed += OnRecomposed;
			GuiElementMap guiElementMap = val5.GetElement("mapElem") as GuiElementMap;
			if (val6 != null)
			{
				guiElementMap.chunkViewBoundsBefore = val6.ToCuboidi().Div(32);
			}
			guiElementMap.viewChanged = viewChanged;
			guiElementMap.viewChangedSync = viewChangedSync;
			guiElementMap.ZoomAdd(1f, 0.5f, 0.5f);
			GuiComposerHelpers.GetHoverText(val5, "hoverText").SetAutoWidth(true);
			if (listenerId == 0L)
			{
				listenerId = ((IEventAPI)((GuiDialog)this).capi.Event).RegisterGameTickListener((Action<float>)delegate
				{
					//IL_0032: Unknown result type (might be due to invalid IL or missing references)
					//IL_0037: Unknown result type (might be due to invalid IL or missing references)
					//IL_0049: Unknown result type (might be due to invalid IL or missing references)
					//IL_0060: Unknown result type (might be due to invalid IL or missing references)
					if (((GuiDialog)this).IsOpened())
					{
						(((GuiDialog)this).SingleComposer.GetElement("mapElem") as GuiElementMap)?.EnsureMapFullyLoaded();
						if (requireRecompose)
						{
							EnumDialogType asType = dialogType;
							((ICoreAPI)((GuiDialog)this).capi).ModLoader.GetModSystem<WorldMapManager>(true).ToggleMap(asType);
							((ICoreAPI)((GuiDialog)this).capi).ModLoader.GetModSystem<WorldMapManager>(true).ToggleMap(asType);
							requireRecompose = false;
						}
					}
				}, 100, 0);
			}
			if ((int)dlgType == 0)
			{
				foreach (MapLayer item in mapLayers)
				{
					item.ComposeDialogExtras(this, val5);
				}
			}
			((IWorldAccessor)((GuiDialog)this).capi.World).FrameProfiler.Mark("composeworldmap");
			updateMaplayerExtrasState();
			return val5;
		}

		private void OnTabClicked(int arg1, GuiTab tab)
		{
			string text = tabnames[arg1];
			foreach (MapLayer mapLayer in MapLayers)
			{
				if (mapLayer.LayerGroupCode == text)
				{
					mapLayer.Active = tab.Active;
				}
			}
			updateMaplayerExtrasState();
		}

		private void updateMaplayerExtrasState()
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Invalid comparison between Unknown and I4
			if (tabs == null)
			{
				return;
			}
			for (int i = 0; i < tabs.Count; i++)
			{
				string text = tabnames[i];
				GuiTab val = tabs[i];
				if (((GuiDialog)this).Composers["worldmap-layer-" + text] != null)
				{
					((GuiDialog)this).Composers["worldmap-layer-" + text].Enabled = val.Active && (int)dialogType == 0;
				}
			}
		}

		private void OnRecomposed()
		{
			requireRecompose = true;
		}

		public override void OnGuiOpened()
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Invalid comparison between Unknown and I4
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Expected O, but got Unknown
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Expected O, but got Unknown
			((GuiDialog)this).OnGuiOpened();
			updateMaplayerExtrasState();
			if ((int)dialogType == 1)
			{
				((GuiDialog)this).SingleComposer = hudDialog;
				((GuiDialog)this).SingleComposer.Bounds.Alignment = GetMinimapPosition(out var offsetX, out var offsetY);
				((GuiDialog)this).SingleComposer.Bounds.fixedOffsetX = offsetX;
				((GuiDialog)this).SingleComposer.Bounds.fixedOffsetY = offsetY;
				((GuiDialog)this).SingleComposer.ReCompose();
			}
			else
			{
				((GuiDialog)this).SingleComposer = ComposeDialog((EnumDialogType)0);
			}
			if (((GuiDialog)this).SingleComposer.GetElement("mapElem") is GuiElementMap guiElementMap)
			{
				guiElementMap.chunkViewBoundsBefore = new Cuboidi();
			}
			((GuiDialog)this).OnMouseMove(new MouseEvent(((GuiDialog)this).capi.Input.MouseX, ((GuiDialog)this).capi.Input.MouseY));
		}

		private void OnTitleBarClose()
		{
			((GuiDialog)this).TryClose();
		}

		public override bool TryClose()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			if ((int)((GuiDialog)this).DialogType == 0 && ((GuiDialog)this).capi.Settings.Bool["showMinimapHud"])
			{
				Open((EnumDialogType)1);
				return false;
			}
			return ((GuiDialog)this).TryClose();
		}

		public void Open(EnumDialogType type)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			dialogType = type;
			((GuiDialog)this).opened = false;
			((GuiDialog)this).TryOpen();
		}

		public override void OnGuiClosed()
		{
			updateMaplayerExtrasState();
			((GuiDialog)this).OnGuiClosed();
		}

		public override void Dispose()
		{
			((GuiDialog)this).Dispose();
			((IEventAPI)((GuiDialog)this).capi.Event).UnregisterGameTickListener(listenerId);
			listenerId = 0L;
			fullDialog.Dispose();
			hudDialog.Dispose();
		}

		public override void OnMouseMove(MouseEvent args)
		{
			((GuiDialog)this).OnMouseMove(args);
			if (((GuiDialog)this).SingleComposer == null || !((GuiDialog)this).SingleComposer.Bounds.PointInside(args.X, args.Y))
			{
				return;
			}
			loadWorldPos(args.X, args.Y, ref hoveredWorldPos);
			double y = hoveredWorldPos.Y;
			hoveredWorldPos.Sub(((IWorldAccessor)((GuiDialog)this).capi.World).DefaultSpawnPosition.AsBlockPos);
			hoveredWorldPos.Y = y;
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"{(int)hoveredWorldPos.X}, {(int)hoveredWorldPos.Y}, {(int)hoveredWorldPos.Z}");
			GuiElementMap guiElementMap = ((GuiDialog)this).SingleComposer.GetElement("mapElem") as GuiElementMap;
			GuiElementHoverText hoverText = GuiComposerHelpers.GetHoverText(((GuiDialog)this).SingleComposer, "hoverText");
			foreach (MapLayer mapLayer in guiElementMap.mapLayers)
			{
				mapLayer.OnMouseMoveClient(args, guiElementMap, stringBuilder);
			}
			string newText = stringBuilder.ToString().TrimEnd();
			hoverText.SetNewText(newText);
		}

		private void loadWorldPos(double mouseX, double mouseY, ref Vec3d worldPos)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Expected O, but got Unknown
			double num = mouseX - ((GuiDialog)this).SingleComposer.Bounds.absX;
			double num2 = mouseY - ((GuiDialog)this).SingleComposer.Bounds.absY - (((int)dialogType == 0) ? GuiElement.scaled(30.0) : 0.0);
			(((GuiDialog)this).SingleComposer.GetElement("mapElem") as GuiElementMap).TranslateViewPosToWorldPos(new Vec2f((float)num, (float)num2), ref worldPos);
			Vec3d obj = worldPos;
			obj.Y += 1.0;
		}

		public override void OnMouseDown(MouseEvent args)
		{
			((GuiDialog)this).OnMouseDown(args);
		}

		public override void OnRenderGUI(float deltaTime)
		{
			((GuiDialog)this).OnRenderGUI(deltaTime);
			((GuiDialog)this).capi.Render.CheckGlError("map-rend2d");
		}

		public override void OnFinalizeFrame(float dt)
		{
			((GuiDialog)this).OnFinalizeFrame(dt);
			((GuiDialog)this).capi.Render.CheckGlError("map-fina");
			bool flag = ((GuiDialog)this).SingleComposer.Bounds.PointInside(((GuiDialog)this).capi.Input.MouseX, ((GuiDialog)this).capi.Input.MouseY) && ((GuiDialog)this).Focused;
			GuiElementHoverText hoverText = GuiComposerHelpers.GetHoverText(((GuiDialog)this).SingleComposer, "hoverText");
			hoverText.SetVisible(flag);
			hoverText.SetAutoDisplay(flag);
		}

		public void TranslateWorldPosToViewPos(Vec3d worldPos, ref Vec2f viewPos)
		{
			(((GuiDialog)this).SingleComposer.GetElement("mapElem") as GuiElementMap).TranslateWorldPosToViewPos(worldPos, ref viewPos);
		}

		public override void OnMouseUp(MouseEvent args)
		{
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Invalid comparison between Unknown and I4
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Expected O, but got Unknown
			if (!((GuiDialog)this).SingleComposer.Bounds.PointInside(args.X, args.Y))
			{
				((GuiDialog)this).OnMouseUp(args);
				return;
			}
			GuiElementMap guiElementMap = ((GuiDialog)this).SingleComposer.GetElement("mapElem") as GuiElementMap;
			foreach (MapLayer mapLayer in guiElementMap.mapLayers)
			{
				mapLayer.OnMouseUpClient(args, guiElementMap);
				if (args.Handled)
				{
					return;
				}
			}
			if ((int)args.Button == 2)
			{
				Vec3d worldPos = new Vec3d();
				loadWorldPos(args.X, args.Y, ref worldPos);
				if (addWpDlg != null)
				{
					((GuiDialog)addWpDlg).TryClose();
					((GuiDialog)addWpDlg).Dispose();
				}
				WaypointMapLayer wml = MapLayers.FirstOrDefault((MapLayer l) => l is WaypointMapLayer) as WaypointMapLayer;
				addWpDlg = new GuiDialogAddWayPoint(((GuiDialog)this).capi, wml);
				addWpDlg.WorldPos = worldPos;
				((GuiDialog)addWpDlg).TryOpen();
				((GuiDialog)addWpDlg).OnClosed += delegate
				{
					((GuiDialog)this).capi.Gui.RequestFocus((GuiDialog)(object)this);
				};
			}
			((GuiDialog)this).OnMouseUp(args);
		}

		public override bool ShouldReceiveKeyboardEvents()
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Invalid comparison between Unknown and I4
			if (((GuiDialog)this).ShouldReceiveKeyboardEvents())
			{
				return (int)dialogType == 0;
			}
			return false;
		}

		private EnumDialogArea GetMinimapPosition(out double offsetX, out double offsetY)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			offsetX = GuiStyle.DialogToScreenPadding;
			offsetY = GuiStyle.DialogToScreenPadding;
			EnumDialogArea result;
			switch (((GuiDialog)this).capi.Settings.Int["minimapHudPosition"])
			{
			case 1:
				result = (EnumDialogArea)1;
				break;
			case 2:
				result = (EnumDialogArea)3;
				offsetY = 0.0 - offsetY;
				break;
			case 3:
				result = (EnumDialogArea)11;
				offsetX = 0.0 - offsetX;
				offsetY = 0.0 - offsetY;
				break;
			default:
				result = (EnumDialogArea)9;
				offsetX = 0.0 - offsetX;
				break;
			}
			return result;
		}
	}
	public class GuiElementMap : GuiElement
	{
		public List<MapLayer> mapLayers;

		public bool IsDragingMap;

		public float ZoomLevel = 1f;

		internal Vec3d prevPlayerPos = new Vec3d();

		public Cuboidi chunkViewBoundsBefore = new Cuboidi();

		public OnViewChangedDelegate viewChanged;

		public OnViewChangedSyncDelegate viewChangedSync;

		private bool snapToPlayer;

		public Cuboidd CurrentBlockViewBounds = new Cuboidd();

		private GuiDialogWorldMap worldmapdlg;

		private float tkeyDeltaX;

		private float tkeyDeltaY;

		private float skeyDeltaX;

		private float skeyDeltaY;

		private int prevMouseX;

		private int prevMouseY;

		private List<FastVec2i> nowVisible = new List<FastVec2i>();

		private List<FastVec2i> nowHidden = new List<FastVec2i>();

		public ICoreClientAPI Api => base.api;

		private bool dialogHasFocus
		{
			get
			{
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Invalid comparison between Unknown and I4
				if (((GuiDialog)worldmapdlg).Focused)
				{
					return (int)((GuiDialog)worldmapdlg).DialogType == 0;
				}
				return false;
			}
		}

		public GuiElementMap(List<MapLayer> mapLayers, ICoreClientAPI capi, GuiDialogWorldMap worldmapdlg, ElementBounds bounds, bool snapToPlayer)
			: base(capi, bounds)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Expected O, but got Unknown
			this.mapLayers = mapLayers;
			this.snapToPlayer = snapToPlayer;
			this.worldmapdlg = worldmapdlg;
			prevPlayerPos.X = ((Entity)((IPlayer)base.api.World.Player).Entity).Pos.X;
			prevPlayerPos.Z = ((Entity)((IPlayer)base.api.World.Player).Entity).Pos.Z;
		}

		public override void ComposeElements(Context ctxStatic, ImageSurface surface)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Expected O, but got Unknown
			base.Bounds.CalcWorldBounds();
			chunkViewBoundsBefore = new Cuboidi();
			BlockPos asBlockPos = ((Entity)((IPlayer)base.api.World.Player).Entity).Pos.AsBlockPos;
			CurrentBlockViewBounds = new Cuboidd((double)asBlockPos.X - base.Bounds.InnerWidth / 2.0 / (double)ZoomLevel, 0.0, (double)asBlockPos.Z - base.Bounds.InnerHeight / 2.0 / (double)ZoomLevel, (double)asBlockPos.X + base.Bounds.InnerWidth / 2.0 / (double)ZoomLevel, 0.0, (double)asBlockPos.Z + base.Bounds.InnerHeight / 2.0 / (double)ZoomLevel);
		}

		public override void RenderInteractiveElements(float deltaTime)
		{
			base.api.Render.PushScissor(base.Bounds, false);
			for (int i = 0; i < mapLayers.Count; i++)
			{
				mapLayers[i].Render(this, deltaTime);
			}
			base.api.Render.PopScissor();
			base.api.Render.CheckGlError("");
		}

		public override void PostRenderInteractiveElements(float deltaTime)
		{
			((GuiElement)this).PostRenderInteractiveElements(deltaTime);
			EntityPlayer entity = ((IPlayer)base.api.World.Player).Entity;
			double num = ((Entity)entity).Pos.X - prevPlayerPos.X;
			double num2 = ((Entity)entity).Pos.Z - prevPlayerPos.Z;
			if (Math.Abs(num) > 0.0002 || Math.Abs(num2) > 0.0002)
			{
				if (snapToPlayer)
				{
					EntityPos pos = ((Entity)((IPlayer)base.api.World.Player).Entity).Pos;
					CurrentBlockViewBounds.X1 = pos.X - base.Bounds.InnerWidth / 2.0 / (double)ZoomLevel;
					CurrentBlockViewBounds.Z1 = pos.Z - base.Bounds.InnerHeight / 2.0 / (double)ZoomLevel;
					CurrentBlockViewBounds.X2 = pos.X + base.Bounds.InnerWidth / 2.0 / (double)ZoomLevel;
					CurrentBlockViewBounds.Z2 = pos.Z + base.Bounds.InnerHeight / 2.0 / (double)ZoomLevel;
				}
				else
				{
					CurrentBlockViewBounds.Translate(num, 0.0, num2);
				}
			}
			prevPlayerPos.Set(((Entity)entity).Pos.X, ((Entity)entity).Pos.Y, ((Entity)entity).Pos.Z);
			if (dialogHasFocus)
			{
				if (base.api.Input.KeyboardKeyStateRaw[45])
				{
					tkeyDeltaY = 15f;
				}
				else if (base.api.Input.KeyboardKeyStateRaw[46])
				{
					tkeyDeltaY = -15f;
				}
				else
				{
					tkeyDeltaY = 0f;
				}
				if (base.api.Input.KeyboardKeyStateRaw[47])
				{
					tkeyDeltaX = 15f;
				}
				else if (base.api.Input.KeyboardKeyStateRaw[48])
				{
					tkeyDeltaX = -15f;
				}
				else
				{
					tkeyDeltaX = 0f;
				}
				skeyDeltaX += (tkeyDeltaX - skeyDeltaX) * deltaTime * 15f;
				skeyDeltaY += (tkeyDeltaY - skeyDeltaY) * deltaTime * 15f;
				if (Math.Abs(skeyDeltaX) > 0.5f || Math.Abs(skeyDeltaY) > 0.5f)
				{
					CurrentBlockViewBounds.Translate((double)((0f - skeyDeltaX) / ZoomLevel), 0.0, (double)((0f - skeyDeltaY) / ZoomLevel));
				}
			}
		}

		public override void OnMouseDownOnElement(ICoreClientAPI api, MouseEvent args)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			((GuiElement)this).OnMouseDownOnElement(api, args);
			if ((int)args.Button == 0)
			{
				IsDragingMap = true;
				prevMouseX = args.X;
				prevMouseY = args.Y;
			}
		}

		public override void OnMouseUp(ICoreClientAPI api, MouseEvent args)
		{
			((GuiElement)this).OnMouseUp(api, args);
			IsDragingMap = false;
		}

		public override void OnMouseMove(ICoreClientAPI api, MouseEvent args)
		{
			if (IsDragingMap)
			{
				CurrentBlockViewBounds.Translate((double)((float)(-(args.X - prevMouseX)) / ZoomLevel), 0.0, (double)((float)(-(args.Y - prevMouseY)) / ZoomLevel));
				prevMouseX = args.X;
				prevMouseY = args.Y;
			}
		}

		public override void OnMouseWheel(ICoreClientAPI api, MouseWheelEventArgs args)
		{
			if (base.Bounds.ParentBounds.PointInside(api.Input.MouseX, api.Input.MouseY))
			{
				float px = (float)(((double)api.Input.MouseX - base.Bounds.absX) / base.Bounds.InnerWidth);
				float pz = (float)(((double)api.Input.MouseY - base.Bounds.absY) / base.Bounds.InnerHeight);
				ZoomAdd((args.delta > 0) ? 0.25f : (-0.25f), px, pz);
				args.SetHandled(true);
			}
		}

		public void ZoomAdd(float zoomDiff, float px, float pz)
		{
			if ((!(zoomDiff < 0f) || !(ZoomLevel + zoomDiff < 0.25f)) && (!(zoomDiff > 0f) || !(ZoomLevel + zoomDiff > 6f)))
			{
				ZoomLevel += zoomDiff;
				double num = 1f / ZoomLevel;
				double num2 = base.Bounds.InnerWidth * num - CurrentBlockViewBounds.Width;
				double num3 = base.Bounds.InnerHeight * num - CurrentBlockViewBounds.Length;
				Cuboidd currentBlockViewBounds = CurrentBlockViewBounds;
				currentBlockViewBounds.X2 += num2;
				Cuboidd currentBlockViewBounds2 = CurrentBlockViewBounds;
				currentBlockViewBounds2.Z2 += num3;
				CurrentBlockViewBounds.Translate((0.0 - num2) * (double)px, 0.0, (0.0 - num3) * (double)pz);
				EnsureMapFullyLoaded();
			}
		}

		public void TranslateWorldPosToViewPos(Vec3d worldPos, ref Vec2f viewPos)
		{
			if (worldPos == (Vec3d)null)
			{
				throw new ArgumentNullException("worldPos is null");
			}
			double num = CurrentBlockViewBounds.X2 - CurrentBlockViewBounds.X1;
			double num2 = CurrentBlockViewBounds.Z2 - CurrentBlockViewBounds.Z1;
			viewPos.X = (float)((worldPos.X - CurrentBlockViewBounds.X1) / num * base.Bounds.InnerWidth);
			viewPos.Y = (float)((worldPos.Z - CurrentBlockViewBounds.Z1) / num2 * base.Bounds.InnerHeight);
		}

		public void ClampButPreserveAngle(ref Vec2f viewPos, int border)
		{
			if (!(viewPos.X >= (float)border) || !((double)viewPos.X <= base.Bounds.InnerWidth - 2.0) || !(viewPos.Y >= (float)border) || !((double)viewPos.Y <= base.Bounds.InnerHeight - 2.0))
			{
				double num = base.Bounds.InnerWidth / 2.0 - (double)border;
				double num2 = base.Bounds.InnerHeight / 2.0 - (double)border;
				double value = ((double)viewPos.X - num) / num;
				double num3 = Math.Max(val2: Math.Abs(((double)viewPos.Y - num2) / num2), val1: Math.Abs(value));
				viewPos.X = (float)(((double)viewPos.X - num) / num3 + num);
				viewPos.Y = (float)(((double)viewPos.Y - num2) / num3 + num2);
			}
		}

		public void TranslateViewPosToWorldPos(Vec2f viewPos, ref Vec3d worldPos)
		{
			if (worldPos == (Vec3d)null)
			{
				throw new ArgumentNullException("viewPos is null");
			}
			double num = CurrentBlockViewBounds.X2 - CurrentBlockViewBounds.X1;
			double num2 = CurrentBlockViewBounds.Z2 - CurrentBlockViewBounds.Z1;
			worldPos.X = (double)viewPos.X * num / base.Bounds.InnerWidth + CurrentBlockViewBounds.X1;
			worldPos.Z = (double)viewPos.Y * num2 / base.Bounds.InnerHeight + CurrentBlockViewBounds.Z1;
			worldPos.Y = ((IWorldAccessor)base.api.World).BlockAccessor.GetRainMapHeightAt(worldPos.AsBlockPos);
		}

		public void EnsureMapFullyLoaded()
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Expected O, but got Unknown
			//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			nowVisible.Clear();
			nowHidden.Clear();
			Cuboidi val = CurrentBlockViewBounds.ToCuboidi();
			val.Div(32);
			if (chunkViewBoundsBefore.Equals(val))
			{
				return;
			}
			viewChangedSync(val.X1, val.Z1, val.X2, val.Z2);
			BlockPos val2 = new BlockPos();
			bool flag = chunkViewBoundsBefore.SizeX == 0 && chunkViewBoundsBefore.SizeZ == 0;
			int num = ((val.X2 > chunkViewBoundsBefore.X2) ? 1 : (-1));
			int num2 = ((val.Z2 > chunkViewBoundsBefore.Z2) ? 1 : (-1));
			val2.Set((num > 0) ? val.X1 : val.X2, 0, val.Z1);
			while ((num > 0 && val2.X <= val.X2) || (num < 0 && val2.X >= val.X1))
			{
				val2.Z = ((num2 > 0) ? val.Z1 : val.Z2);
				while ((num2 > 0 && val2.Z <= val.Z2) || (num2 < 0 && val2.Z >= val.Z1))
				{
					if (flag || !chunkViewBoundsBefore.ContainsOrTouches(val2))
					{
						nowVisible.Add(new FastVec2i(val2.X, val2.Z));
					}
					val2.Z += num2;
				}
				val2.X += num;
			}
			if (!flag)
			{
				val2.Set(chunkViewBoundsBefore.X1, 0, chunkViewBoundsBefore.Z1);
				while (val2.X <= chunkViewBoundsBefore.X2)
				{
					val2.Z = chunkViewBoundsBefore.Z1;
					while (val2.Z <= chunkViewBoundsBefore.Z2)
					{
						if (!val.ContainsOrTouches(val2))
						{
							nowHidden.Add(new FastVec2i(val2.X, val2.Z));
						}
						val2.Z++;
					}
					val2.X++;
				}
			}
			chunkViewBoundsBefore = val.Clone();
			if (nowHidden.Count > 0 || nowVisible.Count > 0)
			{
				viewChanged(nowVisible, nowHidden);
			}
		}

		public override void OnKeyDown(ICoreClientAPI api, KeyEvent args)
		{
			((GuiElement)this).OnKeyDown(api, args);
			if (args.KeyCode == 51)
			{
				CenterMapTo(((Entity)((IPlayer)api.World.Player).Entity).Pos.AsBlockPos);
			}
			if (api.Input.KeyboardKeyStateRaw[45] || api.Input.KeyboardKeyStateRaw[46] || api.Input.KeyboardKeyStateRaw[47] || api.Input.KeyboardKeyStateRaw[48])
			{
				args.Handled = true;
			}
			if (api.Input.KeyboardKeyStateRaw[121] || api.Input.KeyboardKeyStateRaw[80])
			{
				ZoomAdd(0.25f, 0.5f, 0.5f);
			}
			if (api.Input.KeyboardKeyStateRaw[120] || api.Input.KeyboardKeyStateRaw[79])
			{
				ZoomAdd(-0.25f, 0.5f, 0.5f);
			}
		}

		public override void OnKeyUp(ICoreClientAPI api, KeyEvent args)
		{
			((GuiElement)this).OnKeyUp(api, args);
		}

		public void CenterMapTo(BlockPos pos)
		{
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Expected O, but got Unknown
			CurrentBlockViewBounds = new Cuboidd((double)pos.X - base.Bounds.InnerWidth / 2.0 / (double)ZoomLevel, 0.0, (double)pos.Z - base.Bounds.InnerHeight / 2.0 / (double)ZoomLevel, (double)pos.X + base.Bounds.InnerWidth / 2.0 / (double)ZoomLevel, 0.0, (double)pos.Z + base.Bounds.InnerHeight / 2.0 / (double)ZoomLevel);
		}

		public override void Dispose()
		{
		}
	}
	public interface IWorldMapManager
	{
		bool IsShuttingDown { get; }

		bool IsOpened { get; }

		void TranslateWorldPosToViewPos(Vec3d worldPos, ref Vec2f viewPos);

		void SendMapDataToClient(MapLayer forMapLayer, IServerPlayer forPlayer, byte[] data);

		void SendMapDataToServer(MapLayer forMapLayer, byte[] data);
	}
	public abstract class MapComponent : IDisposable
	{
		public ICoreClientAPI capi;

		public MapComponent(ICoreClientAPI capi)
		{
			this.capi = capi;
		}

		public virtual void Render(GuiElementMap map, float dt)
		{
		}

		public virtual void Dispose()
		{
		}

		public virtual void OnMouseMove(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
		}

		public virtual void OnMouseUpOnElement(MouseEvent args, GuiElementMap mapElem)
		{
		}
	}
	public enum EnumMinMagFilter
	{
		Linear,
		Nearest
	}
	public enum EnumMapAppSide
	{
		Client,
		Server
	}
	public class MapLegendItem
	{
		public int Color;

		public string Name;
	}
	public abstract class MapLayer
	{
		public string RequirePrivilege;

		public string RequireCode;

		public EnumGameMode? RequiredGameMode;

		public int ZIndex = 1;

		protected ICoreAPI api;

		protected IWorldMapManager mapSink;

		public HashSet<Vec2i> LoadedChunks = new HashSet<Vec2i>();

		public abstract string Title { get; }

		public abstract string LayerGroupCode { get; }

		public bool Active { get; set; }

		public abstract EnumMapAppSide DataSide { get; }

		public virtual bool RequireChunkLoaded => true;

		public MapLayer(ICoreAPI api, IWorldMapManager mapSink)
		{
			this.api = api;
			this.mapSink = mapSink;
			Active = true;
		}

		public virtual void OnOffThreadTick(float dt)
		{
		}

		public virtual void OnTick(float dt)
		{
		}

		public virtual void OnViewChangedClient(List<FastVec2i> nowVisible, List<FastVec2i> nowHidden)
		{
		}

		[Obsolete("Receiving the OnViewChangedPacket now calls: OnViewChangedServer(fromPlayer, int x1, int z1, int x2, int z2) but retained in 1.20.10 for backwards compatibility")]
		public virtual void OnViewChangedServer(IServerPlayer fromPlayer, List<FastVec2i> nowVisible, List<FastVec2i> nowHidden)
		{
		}

		public virtual void OnViewChangedServer(IServerPlayer fromPlayer, int x1, int z1, int x2, int z2)
		{
		}

		public virtual void OnMapOpenedClient()
		{
		}

		public virtual void OnMapClosedClient()
		{
		}

		public virtual void OnMapOpenedServer(IServerPlayer fromPlayer)
		{
		}

		public virtual void OnMapClosedServer(IServerPlayer fromPlayer)
		{
		}

		public virtual void OnDataFromServer(byte[] data)
		{
		}

		public virtual void OnDataFromClient(byte[] data)
		{
		}

		public virtual void OnLoaded()
		{
		}

		public virtual void Dispose()
		{
		}

		public virtual void OnShutDown()
		{
		}

		public virtual void Render(GuiElementMap mapElem, float dt)
		{
		}

		public virtual void OnMouseMoveClient(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
		}

		public virtual void OnMouseUpClient(MouseEvent args, GuiElementMap mapElem)
		{
		}

		public virtual void ComposeDialogExtras(GuiDialogWorldMap guiDialogWorldMap, GuiComposer compo)
		{
		}
	}
	public abstract class RGBMapLayer : MapLayer
	{
		public Dictionary<FastVec2i, int> ChunkTextures = new Dictionary<FastVec2i, int>();

		public bool Visible;

		public abstract MapLegendItem[] LegendItems { get; }

		public abstract EnumMinMagFilter MinFilter { get; }

		public abstract EnumMinMagFilter MagFilter { get; }

		public RGBMapLayer(ICoreAPI api, IWorldMapManager mapSink)
			: base(api, mapSink)
		{
		}
	}
	public abstract class MarkerMapLayer : MapLayer
	{
		public Dictionary<string, int> IconTextures = new Dictionary<string, int>();

		public MarkerMapLayer(ICoreAPI api, IWorldMapManager mapSink)
			: base(api, mapSink)
		{
		}
	}
	public class WorldMapsPacket
	{
		public MapLayer[] Maps;
	}
	public class GuiDialogAddWayPoint : GuiDialogGeneric
	{
		private EnumDialogType dialogType;

		internal Vec3d WorldPos;

		private int[] colors;

		private string[] icons;

		private string curIcon;

		private string curColor;

		private bool autoSuggest = true;

		private bool ignoreNextAutosuggestDisable;

		public override bool PrefersUngrabbedMouse => true;

		public override EnumDialogType DialogType => dialogType;

		public override double DrawOrder => 0.2;

		public override bool DisableMouseGrab => true;

		public GuiDialogAddWayPoint(ICoreClientAPI capi, WaypointMapLayer wml)
			: base("", capi)
		{
			icons = wml.WaypointIcons.Keys.ToArray();
			colors = wml.WaypointColors.ToArray();
			ComposeDialog();
		}

		public override bool TryOpen()
		{
			ComposeDialog();
			return ((GuiDialog)this).TryOpen();
		}

		private void ComposeDialog()
		{
			//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0403: Expected O, but got Unknown
			//IL_0419: Unknown result type (might be due to invalid IL or missing references)
			//IL_0453: Expected O, but got Unknown
			ElementBounds val = ElementBounds.Fixed(0.0, 28.0, 90.0, 25.0);
			ElementBounds val2 = val.RightCopy(0.0, 0.0, 0.0, 0.0);
			ElementBounds val3 = ElementBounds.Fixed(0.0, 28.0, 360.0, 25.0);
			ElementBounds val4 = ElementBounds.Fill.WithFixedPadding(GuiStyle.ElementToDialogPadding);
			val4.BothSizing = (ElementSizing)2;
			val4.WithChildren((ElementBounds[])(object)new ElementBounds[2] { val, val2 });
			ElementBounds val5 = ElementStdBounds.AutosizedMainDialog.WithAlignment((EnumDialogArea)6).WithFixedAlignmentOffset(0.0 - GuiStyle.DialogToScreenPadding, 0.0);
			if (((GuiDialog)this).SingleComposer != null)
			{
				((GuiDialog)this).SingleComposer.Dispose();
			}
			int num = 22;
			curIcon = icons[0];
			curColor = ColorUtil.Int2Hex(colors[0]);
			((GuiDialog)this).SingleComposer = GuiComposerHelpers.AddSmallButton(GuiComposerHelpers.AddSmallButton(GuiComposerHelpers.AddIconListPicker(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddColorListPicker(GuiComposerHelpers.AddRichtext(GuiComposerHelpers.AddSwitch(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddTextInput(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(((GuiDialog)this).capi.Gui.CreateCompo("worldmap-addwp", val5), val4, false, 5.0, 0.75f), Lang.Get("Add waypoint", Array.Empty<object>()), (Action)delegate
			{
				((GuiDialog)this).TryClose();
			}, (CairoFont)null, (ElementBounds)null, (string)null).BeginChildElements(val4), Lang.Get("Name", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.FlatCopy(), (string)null), val2 = val2.FlatCopy().WithFixedWidth(200.0), (Action<string>)onNameChanged, CairoFont.TextInput(), "nameInput"), Lang.Get("Pinned", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.BelowCopy(0.0, 9.0, 0.0, 0.0), (string)null), (Action<bool>)onPinnedToggled, val2 = val2.BelowCopy(0.0, 5.0, 0.0, 0.0).WithFixedWidth(200.0), "pinnedSwitch", 30.0, 4.0), Lang.Get("waypoint-color", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.BelowCopy(0.0, 5.0, 0.0, 0.0), (string)null), colors, (Action<int>)onColorSelected, val = val.BelowCopy(0.0, 5.0, 0.0, 0.0).WithFixedSize((double)num, (double)num), 270, "colorpicker"), Lang.Get("Icon", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.WithFixedPosition(0.0, val.fixedY + val.fixedHeight).WithFixedWidth(200.0).BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), icons, (Action<int>)onIconSelected, val = val.BelowCopy(0.0, 5.0, 0.0, 0.0).WithFixedSize((double)(num + 5), (double)(num + 5)), 270, "iconpicker"), Lang.Get("Cancel", Array.Empty<object>()), new ActionConsumable(onCancel), val3.FlatCopy().FixedUnder(val, 0.0).WithFixedWidth(100.0), (EnumButtonStyle)2, (string)null), Lang.Get("Save", Array.Empty<object>()), new ActionConsumable(onSave), val3.FlatCopy().FixedUnder(val, 0.0).WithFixedWidth(100.0)
				.WithAlignment((EnumDialogArea)12), (EnumButtonStyle)2, "saveButton").EndChildElements().Compose(true);
			((GuiElementControl)GuiComposerHelpers.GetButton(((GuiDialog)this).SingleComposer, "saveButton")).Enabled = false;
			GuiComposerHelpers.ColorListPickerSetValue(((GuiDialog)this).SingleComposer, "colorpicker", 0);
			GuiComposerHelpers.IconListPickerSetValue(((GuiDialog)this).SingleComposer, "iconpicker", 0);
		}

		private void onIconSelected(int index)
		{
			curIcon = icons[index];
			autoSuggestName();
		}

		private void onColorSelected(int index)
		{
			curColor = ColorUtil.Int2Hex(colors[index]);
			autoSuggestName();
		}

		private void onPinnedToggled(bool on)
		{
		}

		private void autoSuggestName()
		{
			if (autoSuggest)
			{
				GuiElementTextInput textInput = GuiComposerHelpers.GetTextInput(((GuiDialog)this).SingleComposer, "nameInput");
				ignoreNextAutosuggestDisable = true;
				if (Lang.HasTranslation("wpSuggestion-" + curIcon + "-" + curColor, true, true))
				{
					((GuiElementEditableTextBase)textInput).SetValue(Lang.Get("wpSuggestion-" + curIcon + "-" + curColor, Array.Empty<object>()), true);
				}
				else if (Lang.HasTranslation("wpSuggestion-" + curIcon, true, true))
				{
					((GuiElementEditableTextBase)textInput).SetValue(Lang.Get("wpSuggestion-" + curIcon, Array.Empty<object>()), true);
				}
				else
				{
					((GuiElementEditableTextBase)textInput).SetValue("", true);
				}
			}
		}

		private bool onSave()
		{
			string text = ((GuiElementTextBase)GuiComposerHelpers.GetTextInput(((GuiDialog)this).SingleComposer, "nameInput")).GetText();
			bool flag = GuiComposerHelpers.GetSwitch(((GuiDialog)this).SingleComposer, "pinnedSwitch").On;
			((GuiDialog)this).capi.SendChatMessage($"/waypoint addati {curIcon} ={WorldPos.X.ToString(GlobalConstants.DefaultCultureInfo)} ={WorldPos.Y.ToString(GlobalConstants.DefaultCultureInfo)} ={WorldPos.Z.ToString(GlobalConstants.DefaultCultureInfo)} {flag} {curColor} {text}", (string)null);
			((GuiDialog)this).TryClose();
			return true;
		}

		private bool onCancel()
		{
			((GuiDialog)this).TryClose();
			return true;
		}

		private void onNameChanged(string t1)
		{
			((GuiElementControl)GuiComposerHelpers.GetButton(((GuiDialog)this).SingleComposer, "saveButton")).Enabled = t1.Trim() != "";
			if (!ignoreNextAutosuggestDisable)
			{
				autoSuggest = t1.Length == 0;
			}
			ignoreNextAutosuggestDisable = false;
		}

		public override bool CaptureAllInputs()
		{
			return ((GuiDialog)this).IsOpened();
		}

		public override void OnMouseDown(MouseEvent args)
		{
			((GuiDialog)this).OnMouseDown(args);
			args.Handled = true;
		}

		public override void OnMouseUp(MouseEvent args)
		{
			((GuiDialog)this).OnMouseUp(args);
			args.Handled = true;
		}

		public override void OnMouseMove(MouseEvent args)
		{
			((GuiDialog)this).OnMouseMove(args);
			args.Handled = true;
		}

		public override void OnMouseWheel(MouseWheelEventArgs args)
		{
			((GuiDialog)this).OnMouseWheel(args);
			args.SetHandled(true);
		}
	}
	public class GuiDialogEditWayPoint : GuiDialogGeneric
	{
		private EnumDialogType dialogType;

		private int[] colors;

		private string[] icons;

		private Waypoint waypoint;

		private int wpIndex;

		internal Vec3d WorldPos;

		public override bool PrefersUngrabbedMouse => true;

		public override EnumDialogType DialogType => dialogType;

		public Waypoint Waypoint => waypoint;

		public int WpIndex => wpIndex;

		public override double DrawOrder => 0.2;

		public override bool DisableMouseGrab => true;

		public GuiDialogEditWayPoint(ICoreClientAPI capi, WaypointMapLayer wml, Waypoint waypoint, int index)
			: base("", capi)
		{
			icons = wml.WaypointIcons.Keys.ToArray();
			colors = wml.WaypointColors.ToArray();
			wpIndex = index;
			this.waypoint = waypoint;
			ComposeDialog();
		}

		public override bool TryOpen()
		{
			ComposeDialog();
			return ((GuiDialog)this).TryOpen();
		}

		private void ComposeDialog()
		{
			//IL_0418: Unknown result type (might be due to invalid IL or missing references)
			//IL_0447: Expected O, but got Unknown
			//IL_045d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0492: Expected O, but got Unknown
			//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_04e2: Expected O, but got Unknown
			ElementBounds val = ElementBounds.Fixed(0.0, 28.0, 120.0, 25.0);
			ElementBounds val2 = val.RightCopy(0.0, 0.0, 0.0, 0.0);
			ElementBounds val3 = ElementBounds.Fixed(0.0, 28.0, 360.0, 25.0);
			ElementBounds val4 = ElementBounds.Fill.WithFixedPadding(GuiStyle.ElementToDialogPadding);
			val4.BothSizing = (ElementSizing)2;
			val4.WithChildren((ElementBounds[])(object)new ElementBounds[2] { val, val2 });
			ElementBounds val5 = ElementStdBounds.AutosizedMainDialog.WithAlignment((EnumDialogArea)6).WithFixedAlignmentOffset(0.0 - GuiStyle.DialogToScreenPadding, 0.0);
			if (((GuiDialog)this).SingleComposer != null)
			{
				((GuiDialog)this).SingleComposer.Dispose();
			}
			int num = 22;
			int num2 = ArrayExtensions.IndexOf<string>(icons, waypoint.Icon);
			if (num2 < 0)
			{
				num2 = 0;
			}
			int num3 = ArrayExtensions.IndexOf<int>(colors, waypoint.Color);
			if (num3 < 0)
			{
				colors = ArrayExtensions.Append<int>(colors, waypoint.Color);
				num3 = colors.Length - 1;
			}
			((GuiDialog)this).SingleComposer = GuiComposerHelpers.AddSmallButton(GuiComposerHelpers.AddSmallButton(GuiComposerHelpers.AddSmallButton(GuiComposerHelpers.AddIconListPicker(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddColorListPicker(GuiComposerHelpers.AddRichtext(GuiComposerHelpers.AddSwitch(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddTextInput(GuiComposerHelpers.AddStaticText(GuiComposerHelpers.AddDialogTitleBar(GuiComposerHelpers.AddShadedDialogBG(((GuiDialog)this).capi.Gui.CreateCompo("worldmap-modwp", val5), val4, false, 5.0, 0.75f), Lang.Get("Modify waypoint", Array.Empty<object>()), (Action)delegate
			{
				((GuiDialog)this).TryClose();
			}, (CairoFont)null, (ElementBounds)null, (string)null).BeginChildElements(val4), Lang.Get("Name", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.FlatCopy(), (string)null), val2 = val2.FlatCopy().WithFixedWidth(200.0), (Action<string>)onNameChanged, CairoFont.TextInput(), "nameInput"), Lang.Get("Pinned", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.BelowCopy(0.0, 9.0, 0.0, 0.0), (string)null), (Action<bool>)onPinnedToggled, val2 = val2.BelowCopy(0.0, 5.0, 0.0, 0.0).WithFixedWidth(200.0), "pinnedSwitch", 30.0, 4.0), Lang.Get("waypoint-color", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.BelowCopy(0.0, 5.0, 0.0, 0.0), (string)null), colors, (Action<int>)onColorSelected, val = val.BelowCopy(0.0, 5.0, 0.0, 0.0).WithFixedSize((double)num, (double)num), 270, "colorpicker"), Lang.Get("Icon", Array.Empty<object>()), CairoFont.WhiteSmallText(), val = val.WithFixedPosition(0.0, val.fixedY + val.fixedHeight).WithFixedWidth(100.0).BelowCopy(0.0, 0.0, 0.0, 0.0), (string)null), icons, (Action<int>)onIconSelected, val = val.BelowCopy(0.0, 5.0, 0.0, 0.0).WithFixedSize((double)(num + 5), (double)(num + 5)), 270, "iconpicker"), Lang.Get("Cancel", Array.Empty<object>()), new ActionConsumable(onCancel), val3.FlatCopy().FixedUnder(val, 0.0).WithFixedWidth(100.0), (EnumButtonStyle)2, (string)null), Lang.Get("Delete", Array.Empty<object>()), new ActionConsumable(onDelete), val3.FlatCopy().FixedUnder(val, 0.0).WithFixedWidth(100.0)
				.WithAlignment((EnumDialogArea)8), (EnumButtonStyle)2, (string)null), Lang.Get("Save", Array.Empty<object>()), new ActionConsumable(onSave), val3.FlatCopy().FixedUnder(val, 0.0).WithFixedWidth(100.0)
				.WithAlignment((EnumDialogArea)12), (EnumButtonStyle)2, "saveButton").EndChildElements().Compose(true);
			Color.FromArgb(255, ColorUtil.ColorR(waypoint.Color), ColorUtil.ColorG(waypoint.Color), ColorUtil.ColorB(waypoint.Color));
			GuiComposerHelpers.ColorListPickerSetValue(((GuiDialog)this).SingleComposer, "colorpicker", num3);
			GuiComposerHelpers.IconListPickerSetValue(((GuiDialog)this).SingleComposer, "iconpicker", num2);
			((GuiElementEditableTextBase)GuiComposerHelpers.GetTextInput(((GuiDialog)this).SingleComposer, "nameInput")).SetValue(waypoint.Title, true);
			GuiComposerHelpers.GetSwitch(((GuiDialog)this).SingleComposer, "pinnedSwitch").SetValue(waypoint.Pinned);
		}

		private void onIconSelected(int index)
		{
			waypoint.Icon = icons[index];
		}

		private void onColorSelected(int index)
		{
			waypoint.Color = colors[index];
		}

		private void onPinnedToggled(bool t1)
		{
		}

		private void onIconSelectionChanged(string code, bool selected)
		{
		}

		private bool onDelete()
		{
			((GuiDialog)this).capi.SendChatMessage($"/waypoint remove {wpIndex}", (string)null);
			((GuiDialog)this).TryClose();
			return true;
		}

		private bool onSave()
		{
			string text = ((GuiElementTextBase)GuiComposerHelpers.GetTextInput(((GuiDialog)this).SingleComposer, "nameInput")).GetText();
			bool flag = GuiComposerHelpers.GetSwitch(((GuiDialog)this).SingleComposer, "pinnedSwitch").On;
			((GuiDialog)this).capi.SendChatMessage($"/waypoint modify {wpIndex} {ColorUtil.Int2Hex(waypoint.Color)} {waypoint.Icon} {flag} {text}", (string)null);
			((GuiDialog)this).TryClose();
			return true;
		}

		private bool onCancel()
		{
			((GuiDialog)this).TryClose();
			return true;
		}

		private void onNameChanged(string t1)
		{
			((GuiElementControl)GuiComposerHelpers.GetButton(((GuiDialog)this).SingleComposer, "saveButton")).Enabled = t1.Trim() != "";
		}

		public override bool CaptureAllInputs()
		{
			return ((GuiDialog)this).IsOpened();
		}

		public override void OnMouseDown(MouseEvent args)
		{
			((GuiDialog)this).OnMouseDown(args);
			args.Handled = true;
		}

		public override void OnMouseUp(MouseEvent args)
		{
			((GuiDialog)this).OnMouseUp(args);
			args.Handled = true;
		}

		public override void OnMouseMove(MouseEvent args)
		{
			((GuiDialog)this).OnMouseMove(args);
			args.Handled = true;
		}

		public override void OnMouseWheel(MouseWheelEventArgs args)
		{
			((GuiDialog)this).OnMouseWheel(args);
			args.SetHandled(true);
		}
	}
	public class WaypointMapComponent : MapComponent
	{
		private Vec2f viewPos = new Vec2f();

		private Vec4f color = new Vec4f();

		private Waypoint waypoint;

		private int waypointIndex;

		private Matrixf mvMat = new Matrixf();

		private WaypointMapLayer wpLayer;

		private bool mouseOver;

		public static float IconScale = 0.85f;

		private GuiDialogEditWayPoint editWpDlg;

		public WaypointMapComponent(int waypointIndex, Waypoint waypoint, WaypointMapLayer wpLayer, ICoreClientAPI capi)
			: base(capi)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Expected O, but got Unknown
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Expected O, but got Unknown
			this.waypointIndex = waypointIndex;
			this.waypoint = waypoint;
			this.wpLayer = wpLayer;
			ColorUtil.ToRGBAVec4f(waypoint.Color, ref color);
		}

		public override void Render(GuiElementMap map, float dt)
		{
			//IL_0263: Unknown result type (might be due to invalid IL or missing references)
			//IL_026d: Expected O, but got Unknown
			map.TranslateWorldPosToViewPos(waypoint.Position, ref viewPos);
			if (waypoint.Pinned)
			{
				map.Api.Render.PushScissor((ElementBounds)null, false);
				map.ClampButPreserveAngle(ref viewPos, 2);
			}
			else if (viewPos.X < -10f || viewPos.Y < -10f || (double)viewPos.X > ((GuiElement)map).Bounds.OuterWidth + 10.0 || (double)viewPos.Y > ((GuiElement)map).Bounds.OuterHeight + 10.0)
			{
				return;
			}
			float num = (float)(((GuiElement)map).Bounds.renderX + (double)viewPos.X);
			float num2 = (float)(((GuiElement)map).Bounds.renderY + (double)viewPos.Y);
			ICoreClientAPI api = map.Api;
			IShaderProgram engineShader = api.Render.GetEngineShader((EnumShaderProgram)17);
			engineShader.Uniform("rgbaIn", color);
			engineShader.Uniform("extraGlow", 0);
			engineShader.Uniform("applyColor", 0);
			engineShader.Uniform("noTexture", 0f);
			float num3 = (float)(mouseOver ? 6 : 0) - 1.5f * Math.Max(1f, 1f / map.ZoomLevel);
			if (!wpLayer.texturesByIcon.TryGetValue(waypoint.Icon, out var value))
			{
				wpLayer.texturesByIcon.TryGetValue("circle", out value);
			}
			if (value != null)
			{
				engineShader.BindTexture2D("tex2d", value.TextureId, 0);
				engineShader.UniformMatrix("projectionMatrix", api.Render.CurrentProjectionMatrix);
				mvMat.Set(api.Render.CurrentModelviewMatrix).Translate(num, num2, 60f).Scale((float)value.Width + num3, (float)value.Height + num3, 0f)
					.Scale(0.5f * IconScale, 0.5f * IconScale, 0f);
				Matrixf val = mvMat.Clone().Scale(1.25f, 1.25f, 1.25f);
				engineShader.Uniform("rgbaIn", new Vec4f(0f, 0f, 0f, 0.6f));
				engineShader.UniformMatrix("modelViewMatrix", val.Values);
				api.Render.RenderMesh(wpLayer.quadModel);
				engineShader.Uniform("rgbaIn", color);
				engineShader.UniformMatrix("modelViewMatrix", mvMat.Values);
				api.Render.RenderMesh(wpLayer.quadModel);
			}
			if (waypoint.Pinned)
			{
				map.Api.Render.PopScissor();
			}
		}

		public override void Dispose()
		{
			base.Dispose();
		}

		public override void OnMouseMove(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Vec2f val = new Vec2f();
			mapElem.TranslateWorldPosToViewPos(waypoint.Position, ref val);
			double num = (double)val.X + ((GuiElement)mapElem).Bounds.renderX;
			double num2 = (double)val.Y + ((GuiElement)mapElem).Bounds.renderY;
			if (waypoint.Pinned)
			{
				mapElem.ClampButPreserveAngle(ref val, 2);
				num = (double)val.X + ((GuiElement)mapElem).Bounds.renderX;
				num2 = (double)val.Y + ((GuiElement)mapElem).Bounds.renderY;
				num = (float)GameMath.Clamp(num, ((GuiElement)mapElem).Bounds.renderX + 2.0, ((GuiElement)mapElem).Bounds.renderX + ((GuiElement)mapElem).Bounds.InnerWidth - 2.0);
				num2 = (float)GameMath.Clamp(num2, ((GuiElement)mapElem).Bounds.renderY + 2.0, ((GuiElement)mapElem).Bounds.renderY + ((GuiElement)mapElem).Bounds.InnerHeight - 2.0);
			}
			double value = (double)args.X - num;
			double value2 = (double)args.Y - num2;
			float num3 = RuntimeEnv.GUIScale * 8f;
			if (mouseOver = Math.Abs(value) < (double)num3 && Math.Abs(value2) < (double)num3)
			{
				string value3 = Lang.Get("Waypoint {0}", new object[1] { waypointIndex }) + "\n" + waypoint.Title;
				hoverText.AppendLine(value3);
			}
		}

		public override void OnMouseUpOnElement(MouseEvent args, GuiElementMap mapElem)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Invalid comparison between Unknown and I4
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Invalid comparison between Unknown and I4
			if ((int)args.Button != 2)
			{
				return;
			}
			Vec2f val = new Vec2f();
			mapElem.TranslateWorldPosToViewPos(waypoint.Position, ref val);
			double num = (double)val.X + ((GuiElement)mapElem).Bounds.renderX;
			double num2 = (double)val.Y + ((GuiElement)mapElem).Bounds.renderY;
			if (waypoint.Pinned)
			{
				mapElem.ClampButPreserveAngle(ref val, 2);
				num = (double)val.X + ((GuiElement)mapElem).Bounds.renderX;
				num2 = (double)val.Y + ((GuiElement)mapElem).Bounds.renderY;
				num = (float)GameMath.Clamp(num, ((GuiElement)mapElem).Bounds.renderX + 2.0, ((GuiElement)mapElem).Bounds.renderX + ((GuiElement)mapElem).Bounds.InnerWidth - 2.0);
				num2 = (float)GameMath.Clamp(num2, ((GuiElement)mapElem).Bounds.renderY + 2.0, ((GuiElement)mapElem).Bounds.renderY + ((GuiElement)mapElem).Bounds.InnerHeight - 2.0);
			}
			double value = (double)args.X - num;
			double value2 = (double)args.Y - num2;
			float num3 = RuntimeEnv.GUIScale * 8f;
			if (!(Math.Abs(value) < (double)num3) || !(Math.Abs(value2) < (double)num3))
			{
				return;
			}
			if (editWpDlg != null)
			{
				((GuiDialog)editWpDlg).TryClose();
				((GuiDialog)editWpDlg).Dispose();
			}
			if ((int)((IPlayer)capi.World.Player).WorldData.CurrentGameMode == 2 && ((EntityAgent)((IPlayer)capi.World.Player).Entity).Controls.ShiftKey)
			{
				BlockPos asBlockPos = waypoint.Position.AsBlockPos;
				capi.SendChatMessage($"/tp ={asBlockPos.X} {asBlockPos.Y} ={asBlockPos.Z}", (string)null);
				mapElem.prevPlayerPos.Set(asBlockPos);
				mapElem.CenterMapTo(asBlockPos);
			}
			else
			{
				GuiDialogWorldMap mapdlg = ((ICoreAPI)capi).ModLoader.GetModSystem<WorldMapManager>(true).worldMapDlg;
				editWpDlg = new GuiDialogEditWayPoint(capi, mapdlg.MapLayers.FirstOrDefault((MapLayer l) => l is WaypointMapLayer) as WaypointMapLayer, waypoint, waypointIndex);
				((GuiDialog)editWpDlg).TryOpen();
				((GuiDialog)editWpDlg).OnClosed += delegate
				{
					capi.Gui.RequestFocus((GuiDialog)(object)mapdlg);
				};
			}
			args.Handled = true;
		}
	}
	[ProtoContract]
	public class Waypoint
	{
		[ProtoMember(6)]
		public Vec3d Position = new Vec3d();

		[ProtoMember(10)]
		public string Title;

		[ProtoMember(9)]
		public string Text;

		[ProtoMember(1)]
		public int Color;

		[ProtoMember(2)]
		public string Icon = "circle";

		[ProtoMember(7)]
		public bool ShowInWorld;

		[ProtoMember(5)]
		public bool Pinned;

		[ProtoMember(4)]
		public string OwningPlayerUid;

		[ProtoMember(3)]
		public int OwningPlayerGroupId = -1;

		[ProtoMember(8)]
		public bool Temporary;

		[ProtoMember(11)]
		public string Guid { get; set; }
	}
	public delegate LoadedTexture CreateIconTextureDelegate();
	public class WaypointMapLayer : MarkerMapLayer
	{
		public List<Waypoint> Waypoints = new List<Waypoint>();

		private ICoreServerAPI sapi;

		public List<Waypoint> ownWaypoints = new List<Waypoint>();

		private List<MapComponent> wayPointComponents = new List<MapComponent>();

		public MeshRef quadModel;

		private List<MapComponent> tmpWayPointComponents = new List<MapComponent>();

		public Dictionary<string, LoadedTexture> texturesByIcon;

		private static string[] hexcolors = new string[36]
		{
			"#F9D0DC", "#F179AF", "#F15A4A", "#ED272A", "#A30A35", "#FFDE98", "#EFFD5F", "#F6EA5E", "#FDBB3A", "#C8772E",
			"#F47832", "C3D941", "#9FAB3A", "#94C948", "#47B749", "#366E4F", "#516D66", "93D7E3", "#7698CF", "#20909E",
			"#14A4DD", "#204EA2", "#28417A", "#C395C4", "#92479B", "#8E007E", "#5E3896", "D9D4CE", "#AFAAA8", "#706D64",
			"#4F4C2B", "#BF9C86", "#9885530", "#5D3D21", "#FFFFFF", "#080504"
		};

		public override bool RequireChunkLoaded => false;

		public OrderedDictionary<string, CreateIconTextureDelegate> WaypointIcons { get; set; } = new OrderedDictionary<string, CreateIconTextureDelegate>();

		public List<int> WaypointColors { get; set; } = new List<int>();

		public override string Title => "Player Set Markers";

		public override EnumMapAppSide DataSide => EnumMapAppSide.Server;

		public override string LayerGroupCode => "waypoints";

		public WaypointMapLayer(ICoreAPI api, IWorldMapManager mapSink)
			: base(api, mapSink)
		{
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Invalid comparison between Unknown and I4
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Expected O, but got Unknown
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Invalid comparison between Unknown and I4
			//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Expected O, but got Unknown
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_026f: Expected O, but got Unknown
			//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c7: Expected O, but got Unknown
			//IL_0315: Unknown result type (might be due to invalid IL or missing references)
			//IL_031f: Expected O, but got Unknown
			//IL_0390: Unknown result type (might be due to invalid IL or missing references)
			//IL_039a: Expected O, but got Unknown
			//IL_041a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0424: Expected O, but got Unknown
			//IL_04a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ae: Expected O, but got Unknown
			//IL_04ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_04f7: Expected O, but got Unknown
			//IL_054c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0556: Expected O, but got Unknown
			//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_05ac: Expected O, but got Unknown
			WaypointColors = new List<int>();
			for (int i = 0; i < hexcolors.Length; i++)
			{
				WaypointColors.Add(ColorUtil.Hex2Int(hexcolors[i]));
			}
			List<IAsset> many = api.Assets.GetMany("textures/icons/worldmap/", (string)null, false);
			ICoreClientAPI capi = (ICoreClientAPI)(object)((api is ICoreClientAPI) ? api : null);
			foreach (IAsset icon in many)
			{
				string input = icon.Name.Substring(0, icon.Name.IndexOf('.'));
				input = Regex.Replace(input, "\\d+\\-", "");
				if ((int)api.Side == 1)
				{
					WaypointIcons[input] = () => (LoadedTexture)null;
					continue;
				}
				WaypointIcons[input] = delegate
				{
					int num = (int)Math.Ceiling(20f * RuntimeEnv.GUIScale);
					return capi.Gui.LoadSvg(icon.Location, num, num, num, num, (int?)(-1));
				};
				capi.Gui.Icons.CustomIcons["wp" + StringUtil.UcFirst(input)] = (IconRendererDelegate)delegate(Context ctx, int x, int y, float w, float h, double[] rgba)
				{
					int value = ColorUtil.ColorFromRgba(rgba);
					_003F val2 = capi.Gui;
					IAsset obj = icon;
					Surface target = ctx.GetTarget();
					((IGuiAPI)val2).DrawSvg(obj, (ImageSurface)(object)((target is ImageSurface) ? target : null), ctx.Matrix, x, y, (int)w, (int)h, (int?)value);
				};
			}
			if ((int)api.Side == 1)
			{
				ICoreServerAPI val = (sapi = (ICoreServerAPI)(object)((api is ICoreServerAPI) ? api : null));
				val.Event.GameWorldSave += OnSaveGameGettingSaved;
				val.Event.PlayerDeath += new PlayerDeathDelegate(Event_PlayerDeath);
				CommandArgumentParsers parsers = ((ICoreAPI)val).ChatCommands.Parsers;
				((ICoreAPI)val).ChatCommands.Create("waypoint").WithDescription("Put a waypoint at this location which will be visible for you on the map").RequiresPrivilege(Privilege.chat)
					.BeginSubCommand("deathwp")
					.WithDescription("Enable/Disable automatic adding of a death waypoint")
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)parsers.OptionalBool("enabled", "on") })
					.RequiresPlayer()
					.HandleWith(new OnCommandDelegate(OnCmdWayPointDeathWp))
					.EndSubCommand()
					.BeginSubCommand("add")
					.WithDescription("Add a waypoint to the map")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[2]
					{
						(ICommandArgumentParser)parsers.Color("color"),
						(ICommandArgumentParser)parsers.All("title")
					})
					.HandleWith(new OnCommandDelegate(OnCmdWayPointAdd))
					.EndSubCommand()
					.BeginSubCommand("addp")
					.RequiresPlayer()
					.WithDescription("Add a waypoint to the map")
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[2]
					{
						(ICommandArgumentParser)parsers.Color("color"),
						(ICommandArgumentParser)parsers.All("title")
					})
					.HandleWith(new OnCommandDelegate(OnCmdWayPointAddp))
					.EndSubCommand()
					.BeginSubCommand("addat")
					.WithDescription("Add a waypoint to the map")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[4]
					{
						(ICommandArgumentParser)parsers.WorldPosition("position"),
						(ICommandArgumentParser)parsers.Bool("pinned", "on"),
						(ICommandArgumentParser)parsers.Color("color"),
						(ICommandArgumentParser)parsers.All("title")
					})
					.HandleWith(new OnCommandDelegate(OnCmdWayPointAddat))
					.EndSubCommand()
					.BeginSubCommand("addati")
					.WithDescription("Add a waypoint to the map")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[5]
					{
						(ICommandArgumentParser)parsers.Word("icon"),
						(ICommandArgumentParser)parsers.WorldPosition("position"),
						(ICommandArgumentParser)parsers.Bool("pinned", "on"),
						(ICommandArgumentParser)parsers.Color("color"),
						(ICommandArgumentParser)parsers.All("title")
					})
					.HandleWith(new OnCommandDelegate(OnCmdWayPointAddati))
					.EndSubCommand()
					.BeginSubCommand("modify")
					.WithDescription("")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[5]
					{
						(ICommandArgumentParser)parsers.Int("waypoint_id"),
						(ICommandArgumentParser)parsers.Color("color"),
						(ICommandArgumentParser)parsers.Word("icon"),
						(ICommandArgumentParser)parsers.Bool("pinned", "on"),
						(ICommandArgumentParser)parsers.All("title")
					})
					.HandleWith(new OnCommandDelegate(OnCmdWayPointModify))
					.EndSubCommand()
					.BeginSubCommand("remove")
					.WithDescription("Remove a waypoint by its id. Get a lost of ids using /waypoint list")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)parsers.Int("waypoint_id") })
					.HandleWith(new OnCommandDelegate(OnCmdWayPointRemove))
					.EndSubCommand()
					.BeginSubCommand("list")
					.WithDescription("List your own waypoints")
					.RequiresPlayer()
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)parsers.OptionalWordRange("details", new string[2] { "details", "d" }) })
					.HandleWith(new OnCommandDelegate(OnCmdWayPointList))
					.EndSubCommand();
				((ICoreAPI)val).ChatCommands.Create("tpwp").WithDescription("Teleport yourself to a waypoint starting with the supplied name").RequiresPrivilege(Privilege.tp)
					.WithArgs((ICommandArgumentParser[])(object)new ICommandArgumentParser[1] { (ICommandArgumentParser)parsers.All("name") })
					.HandleWith(new OnCommandDelegate(OnCmdTpTo));
			}
			else
			{
				quadModel = ((ICoreClientAPI)((api is ICoreClientAPI) ? api : null)).Render.UploadMesh(QuadMeshUtil.GetQuad());
			}
		}

		private TextCommandResult OnCmdWayPointList(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			bool flag = args[0] as string == "details" || args[0] as string == "d";
			StringBuilder stringBuilder = new StringBuilder();
			int num = 0;
			Waypoint[] array = Waypoints.Where((Waypoint p) => p.OwningPlayerUid == args.Caller.Player.PlayerUID).ToArray();
			foreach (Waypoint waypoint in array)
			{
				Vec3d val = waypoint.Position.Clone();
				val.X -= api.World.DefaultSpawnPosition.X;
				val.Z -= api.World.DefaultSpawnPosition.Z;
				if (flag)
				{
					stringBuilder.AppendLine($"{num}: {waypoint.Title} at {val.AsBlockPos} {ColorUtil.Int2Hex(waypoint.Color)} {waypoint.Icon}");
				}
				else
				{
					stringBuilder.AppendLine($"{num}: {waypoint.Title} at {val.AsBlockPos}");
				}
				num++;
			}
			if (stringBuilder.Length == 0)
			{
				return TextCommandResult.Success(Lang.Get("You have no waypoints", Array.Empty<object>()), (object)null);
			}
			return TextCommandResult.Success(Lang.Get("Your waypoints:", Array.Empty<object>()) + "\n" + stringBuilder.ToString(), (object)null);
		}

		private bool IsMapDisallowed(out TextCommandResult response)
		{
			if (!api.World.Config.GetBool("allowMap", true))
			{
				response = TextCommandResult.Success(Lang.Get("Maps are disabled on this server", Array.Empty<object>()), (object)null);
				return true;
			}
			response = null;
			return false;
		}

		private TextCommandResult OnCmdWayPointRemove(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			IServerPlayer player = default(IServerPlayer);
			ref IServerPlayer reference = ref player;
			IPlayer player2 = args.Caller.Player;
			reference = (IServerPlayer)(object)((player2 is IServerPlayer) ? player2 : null);
			int num = (int)args.Parsers[0].GetValue();
			Waypoint[] array = Waypoints.Where((Waypoint p) => p.OwningPlayerUid == ((IPlayer)player).PlayerUID).ToArray();
			if (array.Length == 0)
			{
				return TextCommandResult.Success(Lang.Get("You have no waypoints to delete", Array.Empty<object>()), (object)null);
			}
			if (args.Parsers[0].IsMissing || num < 0 || num >= array.Length)
			{
				return TextCommandResult.Success(Lang.Get("Invalid waypoint number, valid ones are 0..{0}", new object[1] { array.Length - 1 }), (object)null);
			}
			Waypoints.Remove(array[num]);
			RebuildMapComponents();
			ResendWaypoints(player);
			return TextCommandResult.Success(Lang.Get("Ok, deleted waypoint.", Array.Empty<object>()), (object)null);
		}

		private TextCommandResult OnCmdWayPointDeathWp(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			if (!api.World.Config.GetBool("allowDeathwaypointing", true))
			{
				return TextCommandResult.Success(Lang.Get("Death waypointing is disabled on this server", Array.Empty<object>()), (object)null);
			}
			IPlayer player = args.Caller.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			if (args.Parsers[0].IsMissing)
			{
				bool modData = val.GetModData<bool>("deathWaypointing", false);
				return TextCommandResult.Success(Lang.Get("Death waypoint is {0}", new object[1] { modData ? Lang.Get("on", Array.Empty<object>()) : Lang.Get("off", Array.Empty<object>()) }), (object)null);
			}
			bool flag = (bool)args.Parsers[0].GetValue();
			val.SetModData<bool>("deathWaypointing", flag);
			return TextCommandResult.Success(Lang.Get("Death waypoint now {0}", new object[1] { flag ? Lang.Get("on", Array.Empty<object>()) : Lang.Get("off", Array.Empty<object>()) }), (object)null);
		}

		private void Event_PlayerDeath(IServerPlayer byPlayer, DamageSource damageSource)
		{
			if (!api.World.Config.GetBool("allowMap", true) || !api.World.Config.GetBool("allowDeathwaypointing", true) || !byPlayer.GetModData<bool>("deathWaypointing", true))
			{
				return;
			}
			string text = Lang.Get("You died here", Array.Empty<object>());
			for (int i = 0; i < Waypoints.Count; i++)
			{
				Waypoint waypoint = Waypoints[i];
				if (waypoint.OwningPlayerUid == ((IPlayer)byPlayer).PlayerUID && waypoint.Title == text)
				{
					Waypoints.RemoveAt(i);
					i--;
				}
			}
			Waypoint waypoint2 = new Waypoint
			{
				Color = ColorUtil.ColorFromRgba(200, 200, 200, 255),
				OwningPlayerUid = ((IPlayer)byPlayer).PlayerUID,
				Position = ((Entity)((IPlayer)byPlayer).Entity).Pos.XYZ,
				Title = text,
				Icon = "gravestone",
				Pinned = true
			};
			AddWaypoint(waypoint2, byPlayer);
		}

		private TextCommandResult OnCmdTpTo(TextCommandCallingArgs args)
		{
			IPlayer player = args.Caller.Player;
			string value = (args.Parsers[0].GetValue() as string).ToLowerInvariant();
			Waypoint[] array = Waypoints.Where((Waypoint p) => p.OwningPlayerUid == player.PlayerUID).ToArray();
			foreach (Waypoint waypoint in array)
			{
				if (waypoint.Title != null && waypoint.Title.StartsWith(value, StringComparison.InvariantCultureIgnoreCase))
				{
					((Entity)player.Entity).TeleportTo(waypoint.Position);
					return TextCommandResult.Success(Lang.Get("Ok teleported you to waypoint {0}.", new object[1] { waypoint.Title }), (object)null);
				}
			}
			return TextCommandResult.Success(Lang.Get("No such waypoint found", Array.Empty<object>()), (object)null);
		}

		private TextCommandResult OnCmdWayPointAdd(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			Color parsedColor = (Color)args.Parsers[0].GetValue();
			string title = args.Parsers[1].GetValue() as string;
			IPlayer player = args.Caller.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			return AddWp(val, ((Entity)((IPlayer)val).Entity).Pos.XYZ, title, parsedColor, "circle", pinned: false);
		}

		private TextCommandResult OnCmdWayPointAddp(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			Color parsedColor = (Color)args.Parsers[0].GetValue();
			string title = args.Parsers[1].GetValue() as string;
			IPlayer player = args.Caller.Player;
			IServerPlayer val = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			return AddWp(val, ((Entity)((IPlayer)val).Entity).Pos.XYZ, title, parsedColor, "circle", pinned: true);
		}

		private TextCommandResult OnCmdWayPointAddat(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			object value = args.Parsers[0].GetValue();
			Vec3d pos = (Vec3d)((value is Vec3d) ? value : null);
			bool pinned = (bool)args.Parsers[1].GetValue();
			Color parsedColor = (Color)args.Parsers[2].GetValue();
			string title = args.Parsers[3].GetValue() as string;
			IPlayer player = args.Caller.Player;
			IServerPlayer player2 = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			return AddWp(player2, pos, title, parsedColor, "circle", pinned);
		}

		private TextCommandResult OnCmdWayPointAddati(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			string icon = args.Parsers[0].GetValue() as string;
			object value = args.Parsers[1].GetValue();
			Vec3d pos = (Vec3d)((value is Vec3d) ? value : null);
			bool pinned = (bool)args.Parsers[2].GetValue();
			Color parsedColor = (Color)args.Parsers[3].GetValue();
			string title = args.Parsers[4].GetValue() as string;
			IPlayer player = args.Caller.Player;
			IServerPlayer player2 = (IServerPlayer)(object)((player is IServerPlayer) ? player : null);
			return AddWp(player2, pos, title, parsedColor, icon, pinned);
		}

		private TextCommandResult OnCmdWayPointModify(TextCommandCallingArgs args)
		{
			if (IsMapDisallowed(out var response))
			{
				return response;
			}
			int num = (int)args.Parsers[0].GetValue();
			Color color = (Color)args.Parsers[1].GetValue();
			string text = args.Parsers[2].GetValue() as string;
			bool pinned = (bool)args.Parsers[3].GetValue();
			string text2 = args.Parsers[4].GetValue() as string;
			IServerPlayer player = default(IServerPlayer);
			ref IServerPlayer reference = ref player;
			IPlayer player2 = args.Caller.Player;
			reference = (IServerPlayer)(object)((player2 is IServerPlayer) ? player2 : null);
			Waypoint[] array = Waypoints.Where((Waypoint p) => p.OwningPlayerUid == ((IPlayer)player).PlayerUID).ToArray();
			if (args.Parsers[0].IsMissing || num < 0 || num >= array.Length)
			{
				return TextCommandResult.Success(Lang.Get("command-modwaypoint-invalidindex", new object[1] { array.Length - 1 }), (object)null);
			}
			if (string.IsNullOrEmpty(text2))
			{
				return TextCommandResult.Success(Lang.Get("command-waypoint-notext", Array.Empty<object>()), (object)null);
			}
			array[num].Color = color.ToArgb() | -16777216;
			array[num].Title = text2;
			array[num].Pinned = pinned;
			if (text != null)
			{
				array[num].Icon = text;
			}
			ResendWaypoints(player);
			return TextCommandResult.Success(Lang.Get("Ok, waypoint nr. {0} modified", new object[1] { num }), (object)null);
		}

		private TextCommandResult AddWp(IServerPlayer player, Vec3d pos, string title, Color parsedColor, string icon, bool pinned)
		{
			if (string.IsNullOrEmpty(title))
			{
				return TextCommandResult.Success(Lang.Get("command-waypoint-notext", Array.Empty<object>()), (object)null);
			}
			Waypoint waypoint = new Waypoint
			{
				Color = (parsedColor.ToArgb() | -16777216),
				OwningPlayerUid = ((IPlayer)player).PlayerUID,
				Position = pos,
				Title = title,
				Icon = icon,
				Pinned = pinned,
				Guid = Guid.NewGuid().ToString()
			};
			int num = AddWaypoint(waypoint, player);
			return TextCommandResult.Success(Lang.Get("Ok, waypoint nr. {0} added", new object[1] { num }), (object)null);
		}

		public int AddWaypoint(Waypoint waypoint, IServerPlayer player)
		{
			Waypoints.Add(waypoint);
			Waypoint[] array = Waypoints.Where((Waypoint p) => p.OwningPlayerUid == ((IPlayer)player).PlayerUID).ToArray();
			ResendWaypoints(player);
			return array.Length - 1;
		}

		private void OnSaveGameGettingSaved()
		{
			sapi.WorldManager.SaveGame.StoreData("playerMapMarkers_v2", SerializerUtil.Serialize<List<Waypoint>>(Waypoints));
		}

		[Obsolete("Receiving the OnViewChangedPacket now calls: OnViewChangedServer(fromPlayer, int x1, int z1, int x2, int z2) but retained in 1.20.10 for backwards compatibility")]
		public override void OnViewChangedServer(IServerPlayer fromPlayer, List<FastVec2i> nowVisible, List<FastVec2i> nowHidden)
		{
			ResendWaypoints(fromPlayer);
		}

		public override void OnViewChangedServer(IServerPlayer fromPlayer, int x1, int z1, int x2, int z2)
		{
			OnViewChangedServer(fromPlayer, null, null);
		}

		public override void OnMapOpenedClient()
		{
			reloadIconTextures();
			ensureIconTexturesLoaded();
			RebuildMapComponents();
		}

		public void reloadIconTextures()
		{
			if (texturesByIcon != null)
			{
				foreach (KeyValuePair<string, LoadedTexture> item in texturesByIcon)
				{
					item.Value.Dispose();
				}
			}
			texturesByIcon = null;
			ensureIconTexturesLoaded();
		}

		protected void ensureIconTexturesLoaded()
		{
			if (texturesByIcon != null)
			{
				return;
			}
			texturesByIcon = new Dictionary<string, LoadedTexture>();
			foreach (KeyValuePair<string, CreateIconTextureDelegate> waypointIcon in WaypointIcons)
			{
				texturesByIcon[waypointIcon.Key] = waypointIcon.Value();
			}
		}

		public override void OnMapClosedClient()
		{
			foreach (MapComponent tmpWayPointComponent in tmpWayPointComponents)
			{
				wayPointComponents.Remove(tmpWayPointComponent);
			}
			tmpWayPointComponents.Clear();
		}

		public override void Dispose()
		{
			if (texturesByIcon != null)
			{
				foreach (KeyValuePair<string, LoadedTexture> item in texturesByIcon)
				{
					item.Value.Dispose();
				}
			}
			texturesByIcon = null;
			MeshRef obj = quadModel;
			if (obj != null)
			{
				obj.Dispose();
			}
			base.Dispose();
		}

		public override void OnLoaded()
		{
			if (sapi == null)
			{
				return;
			}
			try
			{
				byte[] data = sapi.WorldManager.SaveGame.GetData("playerMapMarkers_v2");
				if (data != null)
				{
					Waypoints = SerializerUtil.Deserialize<List<Waypoint>>(data);
					((IWorldAccessor)sapi.World).Logger.Notification("Successfully loaded " + Waypoints.Count + " waypoints");
				}
				else
				{
					data = sapi.WorldManager.SaveGame.GetData("playerMapMarkers");
					if (data != null)
					{
						Waypoints = JsonUtil.FromBytes<List<Waypoint>>(data);
					}
				}
				for (int i = 0; i < Waypoints.Count; i++)
				{
					Waypoint waypoint = Waypoints[i];
					if (waypoint == null)
					{
						((IWorldAccessor)sapi.World).Logger.Error("Waypoint with no information loaded, will remove");
						Waypoints.RemoveAt(i);
						i--;
					}
					if (waypoint.Title == null)
					{
						waypoint.Title = waypoint.Text;
					}
				}
			}
			catch (Exception ex)
			{
				((IWorldAccessor)sapi.World).Logger.Error("Failed deserializing player map markers. Won't load them, sorry! Exception thrown:");
				((IWorldAccessor)sapi.World).Logger.Error(ex);
			}
			foreach (Waypoint waypoint2 in Waypoints)
			{
				if (waypoint2.Guid == null)
				{
					waypoint2.Guid = Guid.NewGuid().ToString();
				}
			}
		}

		public override void OnDataFromServer(byte[] data)
		{
			ownWaypoints.Clear();
			ownWaypoints.AddRange(SerializerUtil.Deserialize<List<Waypoint>>(data));
			RebuildMapComponents();
		}

		public void AddTemporaryWaypoint(Waypoint waypoint)
		{
			int count = ownWaypoints.Count;
			ICoreAPI obj = api;
			WaypointMapComponent item = new WaypointMapComponent(count, waypoint, this, (ICoreClientAPI)(object)((obj is ICoreClientAPI) ? obj : null));
			wayPointComponents.Add(item);
			tmpWayPointComponents.Add(item);
		}

		private void RebuildMapComponents()
		{
			if (!mapSink.IsOpened)
			{
				return;
			}
			foreach (MapComponent tmpWayPointComponent in tmpWayPointComponents)
			{
				wayPointComponents.Remove(tmpWayPointComponent);
			}
			foreach (WaypointMapComponent wayPointComponent in wayPointComponents)
			{
				wayPointComponent.Dispose();
			}
			wayPointComponents.Clear();
			for (int i = 0; i < ownWaypoints.Count; i++)
			{
				int waypointIndex = i;
				Waypoint waypoint = ownWaypoints[i];
				ICoreAPI obj = api;
				WaypointMapComponent item = new WaypointMapComponent(waypointIndex, waypoint, this, (ICoreClientAPI)(object)((obj is ICoreClientAPI) ? obj : null));
				wayPointComponents.Add(item);
			}
			wayPointComponents.AddRange(tmpWayPointComponents);
		}

		public override void Render(GuiElementMap mapElem, float dt)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (MapComponent wayPointComponent in wayPointComponents)
			{
				wayPointComponent.Render(mapElem, dt);
			}
		}

		public override void OnMouseMoveClient(MouseEvent args, GuiElementMap mapElem, StringBuilder hoverText)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (MapComponent wayPointComponent in wayPointComponents)
			{
				wayPointComponent.OnMouseMove(args, mapElem, hoverText);
			}
		}

		public override void OnMouseUpClient(MouseEvent args, GuiElementMap mapElem)
		{
			if (!base.Active)
			{
				return;
			}
			foreach (MapComponent wayPointComponent in wayPointComponents)
			{
				wayPointComponent.OnMouseUpOnElement(args, mapElem);
				if (args.Handled)
				{
					break;
				}
			}
		}

		private void ResendWaypoints(IServerPlayer toPlayer)
		{
			Dictionary<int, PlayerGroupMembership> playerGroupMemberships = toPlayer.ServerData.PlayerGroupMemberships;
			List<Waypoint> list = new List<Waypoint>();
			foreach (Waypoint waypoint in Waypoints)
			{
				if (!(((IPlayer)toPlayer).PlayerUID != waypoint.OwningPlayerUid) || playerGroupMemberships.ContainsKey(waypoint.OwningPlayerGroupId))
				{
					list.Add(waypoint);
				}
			}
			mapSink.SendMapDataToClient(this, toPlayer, SerializerUtil.Serialize<List<Waypoint>>(list));
		}
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class MapLayerUpdate
	{
		public MapLayerData[] Maplayers;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class MapLayerData
	{
		public string ForMapLayer;

		public byte[] Data;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class OnMapToggle
	{
		public bool OpenOrClose;
	}
	[ProtoContract(/*Could not decode attribute arguments.*/)]
	public class OnViewChangedPacket
	{
		public int X1;

		public int Z1;

		public int X2;

		public int Z2;
	}
	public class WorldMapManager : ModSystem, IWorldMapManager
	{
		public Dictionary<string, Type> MapLayerRegistry = new Dictionary<string, Type>();

		public Dictionary<string, double> LayerGroupPositions = new Dictionary<string, double>();

		private ICoreAPI api;

		private ICoreClientAPI capi;

		private IClientNetworkChannel clientChannel;

		public GuiDialogWorldMap worldMapDlg;

		public List<MapLayer> MapLayers = new List<MapLayer>();

		private Thread mapLayerGenThread;

		private IServerNetworkChannel serverChannel;

		public bool IsOpened
		{
			get
			{
				GuiDialogWorldMap guiDialogWorldMap = worldMapDlg;
				if (guiDialogWorldMap == null)
				{
					return false;
				}
				return ((GuiDialog)guiDialogWorldMap).IsOpened();
			}
		}

		public bool IsShuttingDown { get; set; }

		public override bool ShouldLoad(EnumAppSide side)
		{
			return true;
		}

		public override void Start(ICoreAPI api)
		{
			((ModSystem)this).Start(api);
			RegisterDefaultMapLayers();
			this.api = api;
		}

		public void RegisterDefaultMapLayers()
		{
			RegisterMapLayer<ChunkMapLayer>("chunks", 0.0);
			RegisterMapLayer<PlayerMapLayer>("players", 0.5);
			RegisterMapLayer<EntityMapLayer>("entities", 0.5);
			RegisterMapLayer<WaypointMapLayer>("waypoints", 1.0);
		}

		public void RegisterMapLayer<T>(string code, double position) where T : MapLayer
		{
			MapLayerRegistry[code] = typeof(T);
			LayerGroupPositions[code] = position;
		}

		public override void StartClientSide(ICoreClientAPI api)
		{
			((ModSystem)this).StartClientSide(api);
			capi = api;
			capi.Event.LevelFinalize += OnLvlFinalize;
			((IEventAPI)capi.Event).RegisterGameTickListener((Action<float>)OnClientTick, 20, 0);
			capi.Settings.AddWatcher<bool>("showMinimapHud", (OnSettingsChanged<bool>)delegate
			{
				ToggleMap((EnumDialogType)1);
			});
			capi.Event.LeaveWorld += delegate
			{
				IsShuttingDown = true;
				int num = 0;
				while (mapLayerGenThread != null && mapLayerGenThread.IsAlive && num < 20)
				{
					Thread.Sleep(50);
					num++;
				}
				GuiDialogWorldMap guiDialogWorldMap = worldMapDlg;
				if (guiDialogWorldMap != null)
				{
					((GuiDialog)guiDialogWorldMap).Dispose();
				}
				foreach (MapLayer mapLayer in MapLayers)
				{
					mapLayer?.OnShutDown();
					mapLayer?.Dispose();
				}
			};
			clientChannel = api.Network.RegisterChannel("worldmap").RegisterMessageType(typeof(MapLayerUpdate)).RegisterMessageType(typeof(OnViewChangedPacket))
				.RegisterMessageType(typeof(OnMapToggle))
				.SetMessageHandler<MapLayerUpdate>((NetworkServerMessageHandler<MapLayerUpdate>)OnMapLayerDataReceivedClient);
		}

		private void onWorldMapLinkClicked(LinkTextComponent linkcomp)
		{
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Invalid comparison between Unknown and I4
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Expected O, but got Unknown
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a6: Expected O, but got Unknown
			string[] array = linkcomp.Href.Substring("worldmap://".Length).Split('=');
			int num = StringUtil.ToInt(array[1], 0);
			int num2 = StringUtil.ToInt(array[2], 0);
			int num3 = StringUtil.ToInt(array[3], 0);
			string text = ((array.Length >= 5) ? array[4] : "");
			if (worldMapDlg == null || !((GuiDialog)worldMapDlg).IsOpened() || (((GuiDialog)worldMapDlg).IsOpened() && (int)((GuiDialog)worldMapDlg).DialogType == 1))
			{
				ToggleMap((EnumDialogType)0);
			}
			bool flag = false;
			GuiElementMap guiElementMap = ((GuiDialog)worldMapDlg).SingleComposer.GetElement("mapElem") as GuiElementMap;
			WaypointMapLayer waypointMapLayer = guiElementMap?.mapLayers.FirstOrDefault((MapLayer ml) => ml is WaypointMapLayer) as WaypointMapLayer;
			Vec3d val = new Vec3d((double)num, (double)num2, (double)num3);
			if (waypointMapLayer != null)
			{
				foreach (Waypoint ownWaypoint in waypointMapLayer.ownWaypoints)
				{
					if (ownWaypoint.Position.Equals(val, 0.01))
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				capi.SendChatMessage(string.Format("/waypoint addati {0} ={1} ={2} ={3} {4} {5} {6}", "circle", num, num2, num3, false, "steelblue", text), (string)null);
			}
			guiElementMap?.CenterMapTo(new BlockPos(num, num2, num3));
		}

		private void OnClientTick(float dt)
		{
			foreach (MapLayer mapLayer in MapLayers)
			{
				mapLayer.OnTick(dt);
			}
		}

		private void OnLvlFinalize()
		{
			if (capi != null && mapAllowedClient())
			{
				capi.Input.RegisterHotKey("worldmaphud", Lang.Get("Show/Hide Minimap", Array.Empty<object>()), (GlKeys)15, (HotkeyType)0, false, false, false);
				capi.Input.RegisterHotKey("minimapposition", Lang.Get("keycontrol-minimap-position", Array.Empty<object>()), (GlKeys)15, (HotkeyType)0, false, true, false);
				capi.Input.RegisterHotKey("worldmapdialog", Lang.Get("Show World Map", Array.Empty<object>()), (GlKeys)95, (HotkeyType)0, false, false, false);
				capi.Input.SetHotKeyHandler("worldmaphud", (ActionConsumable<KeyCombination>)OnHotKeyWorldMapHud);
				capi.Input.SetHotKeyHandler("minimapposition", (ActionConsumable<KeyCombination>)OnHotKeyMinimapPosition);
				capi.Input.SetHotKeyHandler("worldmapdialog", (ActionConsumable<KeyCombination>)OnHotKeyWorldMapDlg);
				capi.RegisterLinkProtocol("worldmap", (Action<LinkTextComponent>)onWorldMapLinkClicked);
			}
			foreach (KeyValuePair<string, Type> item in MapLayerRegistry)
			{
				if (!(item.Key == "entities") || api.World.Config.GetAsBool("entityMapLayer", false))
				{
					MapLayers.Add((MapLayer)Activator.CreateInstance(item.Value, api, this));
				}
			}
			foreach (MapLayer mapLayer in MapLayers)
			{
				mapLayer.OnLoaded();
			}
			mapLayerGenThread = new Thread((ThreadStart)delegate
			{
				while (!IsShuttingDown)
				{
					foreach (MapLayer mapLayer2 in MapLayers)
					{
						mapLayer2.OnOffThreadTick(0.02f);
					}
					Thread.Sleep(20);
				}
			});
			mapLayerGenThread.IsBackground = true;
			mapLayerGenThread.Start();
			if (capi != null && (capi.Settings.Bool["showMinimapHud"] || !capi.Settings.Bool.Exists("showMinimapHud")) && (worldMapDlg == null || !((GuiDialog)worldMapDlg).IsOpened()))
			{
				ToggleMap((EnumDialogType)1);
			}
		}

		private void OnMapLayerDataReceivedClient(MapLayerUpdate msg)
		{
			for (int i = 0; i < msg.Maplayers.Length; i++)
			{
				Type type = MapLayerRegistry[msg.Maplayers[i].ForMapLayer];
				MapLayers.FirstOrDefault((MapLayer x) => x.GetType() == type)?.OnDataFromServer(msg.Maplayers[i].Data);
			}
		}

		public bool mapAllowedClient()
		{
			if (!((IWorldAccessor)capi.World).Config.GetBool("allowMap", true))
			{
				return ArrayExtensions.IndexOf<string>(((IPlayer)capi.World.Player).Privileges, "allowMap") != -1;
			}
			return true;
		}

		private bool OnHotKeyWorldMapHud(KeyCombination comb)
		{
			ToggleMap((EnumDialogType)1);
			return true;
		}

		private bool OnHotKeyMinimapPosition(KeyCombination comb)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Invalid comparison between Unknown and I4
			int num = capi.Settings.Int["minimapHudPosition"];
			capi.Settings.Int["minimapHudPosition"] = (num + 1) % 4;
			if (worldMapDlg == null || !((GuiDialog)worldMapDlg).IsOpened())
			{
				ToggleMap((EnumDialogType)1);
			}
			else if ((int)((GuiDialog)worldMapDlg).DialogType == 1)
			{
				((GuiDialogGeneric)worldMapDlg).Recompose();
			}
			return true;
		}

		private bool OnHotKeyWorldMapDlg(KeyCombination comb)
		{
			ToggleMap((EnumDialogType)0);
			return true;
		}

		public void ToggleMap(EnumDialogType asType)
		{
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Invalid comparison between Unknown and I4
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Invalid comparison between Unknown and I4
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c5: Invalid comparison between Unknown and I4
			bool flag = worldMapDlg != null && ((GuiDialog)worldMapDlg).IsOpened();
			if (!mapAllowedClient())
			{
				if (flag)
				{
					((GuiDialog)worldMapDlg).TryClose();
				}
				return;
			}
			if (worldMapDlg != null)
			{
				if (!flag)
				{
					if ((int)asType == 1)
					{
						capi.Settings.Bool.Set("showMinimapHud", true, false);
					}
					worldMapDlg.Open(asType);
					foreach (MapLayer mapLayer in MapLayers)
					{
						mapLayer.OnMapOpenedClient();
					}
					clientChannel.SendPacket<OnMapToggle>(new OnMapToggle
					{
						OpenOrClose = true
					});
				}
				else if (((GuiDialog)worldMapDlg).DialogType != asType)
				{
					worldMapDlg.Open(asType);
				}
				else
				{
					if ((int)asType == 1)
					{
						capi.Settings.Bool.Set("showMinimapHud", false, false);
					}
					else if (capi.Settings.Bool["showMinimapHud"])
					{
						worldMapDlg.Open((EnumDialogType)1);
						return;
					}
					((GuiDialog)worldMapDlg).TryClose();
				}
				return;
			}
			worldMapDlg = new GuiDialogWorldMap(onViewChangedClient, syncViewChange, capi, getTabsOrdered());
			((GuiDialog)worldMapDlg).OnClosed += delegate
			{
				foreach (MapLayer mapLayer2 in MapLayers)
				{
					mapLayer2.OnMapClosedClient();
				}
				clientChannel.SendPacket<OnMapToggle>(new OnMapToggle
				{
					OpenOrClose = false
				});
			};
			worldMapDlg.Open(asType);
			foreach (MapLayer mapLayer3 in MapLayers)
			{
				mapLayer3.OnMapOpenedClient();
			}
			clientChannel.SendPacket<OnMapToggle>(new OnMapToggle
			{
				OpenOrClose = true
			});
			if ((int)asType == 1)
			{
				capi.Settings.Bool.Set("showMinimapHud", true, false);
			}
		}

		private List<string> getTabsOrdered()
		{
			Dictionary<string, double> dictionary = new Dictionary<string, double>();
			foreach (MapLayer mapLayer in MapLayers)
			{
				if (!dictionary.ContainsKey(mapLayer.LayerGroupCode))
				{
					if (!LayerGroupPositions.TryGetValue(mapLayer.LayerGroupCode, out var value))
					{
						value = 1.0;
					}
					dictionary[mapLayer.LayerGroupCode] = value;
				}
			}
			return (from val in dictionary
				orderby val.Value
				select val.Key).ToList();
		}

		private void onViewChangedClient(List<FastVec2i> nowVisible, List<FastVec2i> nowHidden)
		{
			foreach (MapLayer mapLayer in MapLayers)
			{
				mapLayer.OnViewChangedClient(nowVisible, nowHidden);
			}
		}

		private void syncViewChange(int x1, int z1, int x2, int z2)
		{
			clientChannel.SendPacket<OnViewChangedPacket>(new OnViewChangedPacket
			{
				X1 = x1,
				Z1 = z1,
				X2 = x2,
				Z2 = z2
			});
		}

		public void TranslateWorldPosToViewPos(Vec3d worldPos, ref Vec2f viewPos)
		{
			worldMapDlg.TranslateWorldPosToViewPos(worldPos, ref viewPos);
		}

		public void SendMapDataToServer(MapLayer forMapLayer, byte[] data)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Invalid comparison between Unknown and I4
			if ((int)api.Side != 1)
			{
				List<MapLayerData> list = new List<MapLayerData>();
				list.Add(new MapLayerData
				{
					Data = data,
					ForMapLayer = MapLayerRegistry.FirstOrDefault((KeyValuePair<string, Type> x) => x.Value == forMapLayer.GetType()).Key
				});
				clientChannel.SendPacket<MapLayerUpdate>(new MapLayerUpdate
				{
					Maplayers = list.ToArray()
				});
			}
		}

		public override void StartServerSide(ICoreServerAPI sapi)
		{
			sapi.Event.ServerRunPhase((EnumServerRunPhase)8, (Action)OnLvlFinalize);
			sapi.Event.ServerRunPhase((EnumServerRunPhase)9, (Action)delegate
			{
				IsShuttingDown = true;
			});
			serverChannel = sapi.Network.RegisterChannel("worldmap").RegisterMessageType(typeof(MapLayerUpdate)).RegisterMessageType(typeof(OnViewChangedPacket))
				.RegisterMessageType(typeof(OnMapToggle))
				.SetMessageHandler<OnMapToggle>((NetworkClientMessageHandler<OnMapToggle>)OnMapToggledServer)
				.SetMessageHandler<OnViewChangedPacket>((NetworkClientMessageHandler<OnViewChangedPacket>)OnViewChangedServer)
				.SetMessageHandler<MapLayerUpdate>((NetworkClientMessageHandler<MapLayerUpdate>)OnMapLayerDataReceivedServer);
		}

		private void OnMapLayerDataReceivedServer(IServerPlayer fromPlayer, MapLayerUpdate msg)
		{
			for (int i = 0; i < msg.Maplayers.Length; i++)
			{
				Type type = MapLayerRegistry[msg.Maplayers[i].ForMapLayer];
				MapLayers.FirstOrDefault((MapLayer x) => x.GetType() == type)?.OnDataFromClient(msg.Maplayers[i].Data);
			}
		}

		private void OnMapToggledServer(IServerPlayer fromPlayer, OnMapToggle msg)
		{
			foreach (MapLayer mapLayer in MapLayers)
			{
				if (mapLayer.DataSide != EnumMapAppSide.Client)
				{
					if (msg.OpenOrClose)
					{
						mapLayer.OnMapOpenedServer(fromPlayer);
					}
					else
					{
						mapLayer.OnMapClosedServer(fromPlayer);
					}
				}
			}
		}

		private void OnViewChangedServer(IServerPlayer fromPlayer, OnViewChangedPacket networkMessage)
		{
			foreach (MapLayer mapLayer in MapLayers)
			{
				if (mapLayer.DataSide != EnumMapAppSide.Client)
				{
					mapLayer.OnViewChangedServer(fromPlayer, networkMessage.X1, networkMessage.Z1, networkMessage.X2, networkMessage.Z2);
				}
			}
		}

		public void SendMapDataToClient(MapLayer forMapLayer, IServerPlayer forPlayer, byte[] data)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Invalid comparison between Unknown and I4
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Invalid comparison between Unknown and I4
			if ((int)api.Side != 2 && (int)forPlayer.ConnectionState == 3)
			{
				MapLayerData[] maplayers = new MapLayerData[1]
				{
					new MapLayerData
					{
						Data = data,
						ForMapLayer = MapLayerRegistry.FirstOrDefault((KeyValuePair<string, Type> x) => x.Value == forMapLayer.GetType()).Key
					}
				};
				serverChannel.SendPacket<MapLayerUpdate>(new MapLayerUpdate
				{
					Maplayers = maplayers
				}, (IServerPlayer[])(object)new IServerPlayer[1] { forPlayer });
			}
		}
	}
}
